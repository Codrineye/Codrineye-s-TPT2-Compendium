# Editor_actions lib

This is a library for use within the [External AI Editor by d0sboots](https://d0sboots.github.io/perfect-tower/) that holds multiple functions that output the editors syntax. By doing this, you can build complex conditions and ternary expressions fully within lua to better modify/documment what you're building.

This is source import
```
{"workspaces":{"Editor Actions lib":[["Editor_actions lib","; Script that defines multiple helper lua functions\n; that let you easily build and return large expressions\n; by using a lua macro instead of multiple line breaks\n; \n; Building expressions in lua can greately improve script\n; readability and maintinability if used correctly\n; \n\n; \n; For this library, I will take a page out of d0s's book and\n; just write the functions out in a string\n; \n; I'm pretty sure this should make everything easier\n; \n; The library is made to read from the Editor_actions string and\n; create a function that the user can call, that returns\n; the formatted value requested by the syntax\n; \n; Function name is defined first, its name ends at the first instance of\n; an open parenthesis (\n; \n; Function parameters are the contents within the set of\n; (enclosed parenthesies), the match() pattern matches the\n; first instance of the (enclosed parenthesies) set\n; \n; Function return output is found at the first instance of a\n; closed parenthesis ) and a space. It stops reading when it reaches ;\n; \n; A function sequence ends with a semicolon ;\n{lua(\\\n  Editor = {};\\\n  Editor.format_error_message = false;\\\n  Editor.error_msg_params = {};\\\n  \\\n  --[[Internal variable for debugging, logs the function]]\\\n  local logging = false;\\\n  \\\n  --[[Internal variable that stores an error message]]\\\n  local err_msg = {};\\\n  \\\n  function Editor.assemble_error(input_string)\\\n    if not Editor.format_error_message then\\\n      err_msg = table.pack(\\\n        \"Cod-proofing violation!\\n\\n\",\\\n        \"Editor.assemble_error was called when Editor.format_error_message is false.\\n\",\\\n        \"Why are you trying to assemble an error when the output is un-formatted?\"\\\n      );\\\n    elseif input_string:match(\",\") == nil then\\\n      err_msg = table.pack(\\\n        \"Cod-proofing violation!\\n\\n\",\\\n        \"Editor.assemble_error called for an input without multiple parameters.\\n\",\\\n        \"Any formatting applied would only make the output harder to read.\"\\\n      );\\\n    end\\\n    \\\n    if err_msg[1] ~= nil then\\\n      err_msg[#err_msg + 1] = \"\\n\\n\";\\\n      err_msg[#err_msg + 1] = \"Unformatted input message:\\n\";\\\n      err_msg[#err_msg + 1] = input_string;\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local spaces = 0;\\\n    \\\n    local idx = 1;\\\n    local args = {};\\\n    \\\n    local pos = 0;\\\n    \\\n    local action = input_string;\\\n    while pos < #action do\\\n      local pos_copy = pos;\\\n      \\\n      --[[/*\\\n        * Extract the text up to and including the first parenthesee.\\\n        * Add pos as our offset, so acc doesn't have repeat contents.\\\n      */]]\\\n      args[idx] = action:match(\"([^%(%)]+.)\", pos);\\\n      if args[idx] == nil then\\\n        --[[extract just 1 parenthesee]]\\\n        args[idx] = action:sub(pos + 1, pos + 1);\\\n      \\\n      elseif input_string:sub(pos + 1, pos + 1) == string.sub(\"()\", 0, 1) then\\\n        --[[/*\\\n          * If the first character was a paranthesee,\\\n          * the match wouldn't have hit it, so we have to add it\\\n        */]]\\\n        args[idx] = string.sub(\"()\", 0, 1) .. args[idx];\\\n      end\\\n      \\\n      if args[idx]:sub(#args[idx], #args[idx]) == string.sub(\"()\", 0, 1) then\\\n        args[idx] = args[idx]:gsub(\"%%0s\", \"%%\" .. spaces .. \"s\")\\\n        spaces = spaces + 2;\\\n      else\\\n        spaces = spaces - 2;\\\n        args[idx] = args[idx]:gsub(\"%%0s\", \"%%\" .. spaces .. \"s\");\\\n      end\\\n      \\\n      pos = pos + #args[idx];\\\n      idx = idx + 1;\\\n      if pos == pos_copy then\\\n        error(\"Prevent infinite loop\");\\\n      end\\\n    end\\\n    \\\n    action = \"\\n\" .. string.gsub(table.concat(args), \"\\\\n\", \"\\n\");\\\n    action = string.format(action, table.unpack(Editor.error_msg_params));\\\n    error(action, 0);\\\n  end\\\n  \\\n  local function create_Editor_functions(actions_string)\\\n    --[[/*\\\n      * Every action must end with a ;\\\n      * If the actions_string doesn't contain a `;`, throw an error\\\n    */]]\\\n    if actions_string:match(\";\") == nil then\\\n      error(\"\\n\\nMalformed action string.\\nInput contains no `;`.\", 0);\\\n    end\\\n    \\\n    local action_count = 0;\\\n    --[[/*\\\n      * Keep count of our actions for additional helpful information\\\n      * \\\n      * Create a pattern that defines an action.\\\n    */]]\\\n    local actions_pattern = \"([%w_]+)(%b())%s*(.*)\";\\\n    for line in actions_string:gmatch(\"[^;]+\") do\\\n      --[[line is the action without the EOL character]]\\\n      \\\n      action_count = action_count + 1;\\\n      local action = table.pack(line:match(actions_pattern))\\\n      --[[Extracts our action name, parameters and output]]\\\n      \\\n      if #action ~= 3 then\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Cannot compute actions string:\\n\",\\\n          \"|'\", line, \"'\\n\",\\\n          \"|Was only able to extract \" .. #action .. \" values of the expected 3:\\n\",\\\n          \"|name = '\", action[1] or \"nil\", \"'\\n\",\\\n          \"|params = '\", action[2] or \"nil\", \"'\\n\",\\\n          \"|output = '\", action[3] or \"nil\", \"'\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      --[[/*\\\n        * now that all 3 parameters have been obtained,\\\n        * we can assign them to their respective variables\\\n        * so it's easier to know what we're doing\\\n      */]]\\\n      local name, params, output = table.unpack(action);\\\n      \\\n      params = params:sub(2, -2);\\\n      \\\n      --[[Create the name of our function and check if it has already been defined]]\\\n      local func_name = \"Editor_\" .. name;\\\n      if _G[func_name] ~= nil then\\\n        --[[/*\\\n          * If the function already exists, throw an error telling us that we messed up.\\\n          * Access the functions \"root\" to be able to compare the input and output of the 2\\\n        */]]\\\n        local root = \"root_\" .. func_name;\\\n        local origin = Editor[root];\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Action duplicate detected on action string:\\n\",\\\n          \"|'\", line, \"'\\n|\\n\",\\\n          \"|line number = \", action_count, \"\\n\",\\\n          \"|root line number = \", origin.action_count, \"\\n|\\n\",\\\n          \"|name = '\", name, \"'\\n\",\\\n          \"|root name = '\", origin.name, \"'\\n|\\n\",\\\n          \"|params = '\", params, \"'\\n\",\\\n          \"|original params = '\", origin.params, \"'\\n|\\n\",\\\n          \"|output = '\", output, \"'\\n\",\\\n          \"|original output = '\", origin.output, \"'\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      local params_count = 0;\\\n      for _ in params:gmatch(\",\") do\\\n        params_count = params_count + 1;\\\n      end\\\n      params_count = params_count + 1;\\\n      \\\n      --[[Now we handle logging the action, so we can check if our error handling is faulty]]\\\n      if logging then\\\n        local print_msg = table.pack(\\\n          \"|Logging action number \", action_count, \"\\n\",\\\n          \"|Line = \", line, \"\\n\",\\\n          \"|name = '\", name, \"'\\n\",\\\n          \"|params = '\", params, \"'\\n\",\\\n          \"|params_count = \", params_count, \"\\n\",\\\n          \"|output = '\", output, \"'\\n\"\\\n        );\\\n        print(table.concat(print_msg));\\\n      end\\\n      \\\n      --[[/*\\\n        * Time to create the function body.\\\n        * Since this is activated using load(), we need to return the function definition,\\\n        * Additionally, every escape character must be doubled, meaning that,\\\n        * to create %s, you'd need to do %%s\\\n      */]]\\\n      local func_body = string.format(\\\n        [==[\\\n          return function(%s)\\\n            local output = %s;\\\n            local params = table.pack(%s);\\\n            local param_count = %d;\\\n            Editor.error_msg_params[#Editor.error_msg_params + 1] = \"\";\\\n            if #params < param_count then\\\n              local err_msg = table.pack(\\\n                \"\\n\\n\",\\\n                \"Missing \", (#params == 0) and \"all\" or (param_count - #params), \" parameters!\",\\\n                \"\\nExpected \", param_count, \" but obtained \", #params, \" parameters\"\\\n              );\\\n              if #params == 0 then\\\n              end\\\n              error(table.concat(err_msg));\\\n            elseif not Editor.format_error_message or not output:match(\",\") then\\\n              return string.format(output, table.unpack(params));\\\n            end\\\n            \\\n            local action = {};\\\n            action[1] = output:match(\"([^%%(%%)]+.)\");\\\n            \\\n            for i = 1, param_count do\\\n              Editor.error_msg_params[#Editor.error_msg_params + 1] = \"\";\\\n              action[#action + 1] = \"\\\\n%%0s\" .. params[i];\\\n              if i ~= #params then\\\n                action[#action + 1] = \",\";\\\n              end\\\n            end\\\n            action[#action + 1] = \"\\\\n%%0s\";\\\n            if output:match(\"%%b()\") ~= nil then\\\n              action[#action + 1] = string.sub(\"()\", -1);\\\n            end\\\n            return table.concat(action)\\\n          end\\\n        ]==],\\\n        params, output, params, params_count\\\n      );\\\n      --[[/*\\\n        * With our function defined, we must load the function in a chunk\\\n        * We assign 2 values here:\\\n        * - chunk is the actual function we're loading\\\n        * - err is an error message returned if the function failed to load\\\n        * \\\n        * The parameters in load are as follows:\\\n        * - The function to load\\\n        * - The \"chunk\" we're loading it into. This provides the function name.\\\n        * - The mode of our function.\\\n        *   The mode \"t\" reprezents text, as our function body is defined as a string\\\n        *   and its parameters are treated as strings\\\n        * - The environment is global, as we need to have access to our Editor body\\\n      ]]\\\n      local chunk, err = load(func_body, func_name, \"t\", _G);\\\n      if not chunk then\\\n        --[[If the chunk failed to load, throw an error and include the error message]]\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Error while loading function '\", name, \"'\\n\",\\\n          \"|Error message =\\n\",\\\n          \"|`\", err, \"`\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      _G[func_name] = chunk();\\\n      --[[/*\\\n        * We've successfully created the function called func_name,\\\n        * Add it to the global scope instead of our Editor table\\\n        * so that the call Editor.Editor_name() can just be Editor_name()\\\n        * \\\n        * Also define the root properties of our function.\\\n        * Since these aren't useful to anyone other than ourselves, we can add them to our\\\n        * Editor table instead, purely for organization purposes.\\\n      */]]\\\n      local root = \"root_\" .. func_name;\\\n      Editor[root] = {};\\\n      local root_data = Editor[root];\\\n      \\\n      root_data.name = name;\\\n      root_data.params = params;\\\n      root_data.output = output;\\\n      root_data.action_count = action_count;\\\n    end\\\n  end\\\n  \\\n  local Editor_actions = [==[\\\nstringify_value(value_to_stringify) [[\"%s\"]];\\\nencase_value(value_to_encase) \"(%s)\";\\\n\\\nsetVar(var_type, dataType, name, set_value) \"%s.%s.set(%s, %s)\";\\\nset_globalVar(dataType, name, set_value) \"global.%s.set(%s, %s)\";\\\nset_localVar(dataType, name, set_value) \"local.%s.set(%s, %s)\";\\\n\\\ngetVar(var_type, dataType, name) \"%s.%s.get(%s)\";\\\nget_globalVar(dataType, name) \"global.%s.get(%s)\";\\\nget_localVar(dataType, name) \"local.%s.get(%s)\";\\\n\\\nunsetVar(var_type, name) \"%s.unset(%s)\";\\\nunset_globalVar(name) \"global.unset(%s)\";\\\nunset_localVar(name) \"local.unset(%s)\";\\\n\\\nmath(leftVal, op_name, rightVal) \"%s %s %s\";\\\n\\\nprimitive_math(primitive_op, dataType, leftVal, op_name, rightVal) \"%s.%s(%s, %s, %s)\";\\\nprimitive_comparison(dataType, leftVal, op_name, rightVal) \"comparison.%s(%s, %s, %s)\";\\\nprimitive_arithmetic(dataType, leftVal, op_name, rightVal) \"arithmetic.%s(%s, %s, %s)\";\\\n\\\nnot(value_to_negate) \"not(%s)\";\\\n\\\nif(condition, valueTrue, valueFalse) \"if(%s, %s, %s)\";\\\nternary.int(condition, valueTrue, valueFalse) \"if(%s, %s, %s)\";\\\nternary.double(condition, valueTrue, valueFalse) \"if(%s, %s, %s)\";\\\nternary.string(condition, valueTrue, valueFalse) \"if(%s, %s, %s)\";\\\nternary.vec2(condition, valueTrue, valueFalse) \"if(%s, %s, %s)\";\\\n\\\ncontains(parent_string, checker_string) \"string.contains(%s, %s)\";\\\n\\\nlen(string_value) \"string.length(%s)\";\\\nindex(parent_string, checker_string, string_offset) \"string.indexOf(%s, %s, %s)\";\\\n\\\nconcat(left_string, right_string) \"concat(%s, %s)\";\\\nsub(parent_string, string_offset, substring_lenght) \"substring(%s, %s, %s)\";\\\n\\\nimpulse() \"script.impulse()\";\\\n\\\nlower(string_to_manipulate) \"string.lower(%s)\";\\\nupper(string_to_manipulate) \"string.upper(%s)\";\\\n\\\nbudget() \"generic.budget()\";\\\ntime_frame() \"time.frame()\";\\\nscreenWidth() \"screen.width()\";\\\nscreenHeight() \"screen.height()\";\\\n\\\nmin(leftVal, rightVal) \"min(%s, %s)\";\\\nmax(leftVal, rightVal) \"max(%s, %s)\";\\\nrnd(minVal, maxVal) \"rnd(%s, %s)\";\\\n\\\nscreenWidth_double() \"screen.width.d()\";\\\nscreenHeight_double() \"screen.height.d()\";\\\nget_UISize() \"option.ui.size()\";\\\n\\\ntime_now() \"timestamp.now()\";\\\ntime_utcnow() \"timestamp.utcnow()\";\\\n\\\ntime_delta() \"time.delta()\";\\\ntime_unscaled() \"time.unscaledDelta()\";\\\nget_timeScale() \"time.scale()\";\\\n\\\nfloor(floor_value) \"double.floor(%s)\";\\\nceil(ceil_value) \"double.ceil(%s)\";\\\nround(round_value) \"double.round(%s)\";\\\n\\\nsin(sin_value) \"double.sin(%s)\";\\\ncos(cos_value) \"double.cos(%s)\";\\\ntan(tan_value) \"double.tan(%s)\";\\\nasin(asin_value) \"double.asin(%s)\";\\\nacos(acos_value) \"double.acos(%s)\";\\\natan(atan_value) \"double.atan(%s)\";\\\natan2(atan2_value) \"double.atan2(%s)\";\\\n\\\nvector_xCoord(vector_value) \"vec2.x(%s)\";\\\nvector_yCoord(vector_value) \"vec2.y(%s)\";\\\nvec(vector_coord_x, vector_coord_y) \"vec.fromCoords(%s, %s)\";\\\n\\\ngetMousePosition() \"mouse.position()\";\\\nget_leftMouseState() \"mouse.0.state()\";\\\nget_rightMouseState() \"mouse.1.state()\";\\\nget_middleMouseState() \"mouse.2.state()\";\\\n\\\nconvertDataType(originalType, desiredType, value) \"%s2%s(%s)\";\\\nconvertFromString(desiredType, value, fallback) \"s2%s(%s, %s)\";\\\n\\\nconvertIntToDouble(value) \"i2d(%s)\";\\\nconvertIntToString(value) \"i2s(%s)\";\\\n\\\nconvertDoubleToInt(value) \"d2i(%s)\";\\\nconvertDoubleToString(value) \"d2s(%s)\";\\\n\\\nconvertStringToInt(value, fallback) \"s2i(%s, %s)\";\\\nconvertStringToDouble(value, fallback) \"s2d(%s, %s)\";\\\n\\\nvisibilityGet(windowID) \"visibility.get(%s)\";\\\nchildVisibilityGet(windowID, elementID) \"child.visibility.get(%s, %s)\";\\\n\\\ncreateWindow(windowID, windowType) \"window.create(%s, %s)\";\\\ndestroyWindow(windowID) \"window.destroy(%s)\";\\\ndestroyWindow_all() \"window.destroy.all()\";\\\n\\\nsetWindowPosition(windowID, position) \"window.position.set(%s, %s)\";\\\n\\\nsetTextInWindow(windowID, elementID, value) \"window.text.set(%s, %s, %s)\";\\\nsetSpriteInWindow(windowID, elementID, spriteID) \"window.sprite.set(%s, %s, %s)\";\\\n\\\nsetWindowVisibility(windowID, visibility) \"window.visibility.set(%s, %s)\";\\\nsetChildVisibility(windowID, elementID, visibility) \"window.child.visibility.set(%s, %s, %s)\";\\\n\\\nresource(resourceID) \"resource(%s)\";\\\n\\\nisopen(roomID) \"town.window.isopen(%s)\";\\\nanyopen() \"town.window.anyopen()\";\\\nshow(roomID, enter) \"town.window.show(%s)\";\\\n\\\nsoftwareEnabled(softwareID) \"software.enabled(%s)\";\\\nsoftwareFind(softwareName) \"software.find(%s)\";\\\n\\\ntowerHealth(percentage) \"tower.health(%s)\";\\\ntowerEnergy(percentage) \"tower.energy(%s)\";\\\ntowerShield(percentage) \"tower.shield(%s)\";\\\nmoduleCooldown(module_index) \"tower.module.cooldown(%s)\";\\\n\\\nhighscore(type, region, difficulty) \"highscore.%s(%s, %s)\";\\\n\\\nhighscoreWave(region, difficulty) \"highscore.wave(%s, %s)\";\\\nhighscoreEra(region, difficulty) \"highscore.era(%s, %s)\";\\\nhighscoreInfinity(region, difficulty) \"highscore.infinity(%s, %s)\";\\\n\\\ndisableCost(element_name) \"disable.cost(%s)\";\\\nactiveID(active_spell_index) \"active.id(%s)\";\\\nactiveIndex(moduleId) \"active.index(%s)\";\\\n\\\nworkerPaused(workerID) \"worker.paused(%s)\";\\\nworkerGroup(workerID) \"worker.group(%s)\";\\\nworkerName(workerID) \"worker.name(%s)\";\\\nworkerTask(workerID) \"worker.task(%s)\";\\\n\\\nadventureCountEntities(entityType) \"adventure.countEntities(%s)\";\\\nadventureHasItem(item_name) \"adventure.hasItem(%s)\";\\\nadventureIsWall(tile_coords) \"adventure.isWall(%s)\";\\\nadventureIsBomb(tile_coords) \"adventure.isBomb(%s)\";\\\nadventureIsEnemy(tile_coords) \"adventure.isEnemy(%s)\";\\\nadventureIsCompleted(room_coords) \"adventure.isCompleted(%s)\";\\\nadventureEntityType(tile_coords) \"adventure.entityType(%s)\";\\\n\\\nisMachineActive(machine_name) \"active(%s)\";\\\nfactoryCountItems(item_name, tier) \"count(%s, %s)\";\\\nfactoryCountMachineItems(machine_name) \"machine.item.count(%s)\";\\\nfactoryItemInMachine(machine_name) \"machine.item(%s)\";\\\nfactoryFindItem(item_name) \"factory.find(%s)\";\\\n\\\nmarketPreference(stone_element) \"museum.pref(%s)\";\\\nisMarketSlotLocked(stone_index) \"museum.isLocked(%s)\";\\\nmuseumFreeSlots(target_menu) \"museum.freeSlots(%s)\";\\\nmaxStoneTier(element) \"museum.maxTier(%s)\";\\\nslotTier(offerSlot) \"museum.slotTier(%s)\";\\\ntrashTier(trashSlot) \"museum.trashTier(%s)\";\\\nslotElement(offerSlot) \"museum.slotElement(%s)\";\\\ntrashElement(trashSlot) \"museum.trashElement(%s)\";\\\n\\\nlabel(label, action) \"%s: %s\";\\\ngoto(label) \"goto(%s)\";\\\ngotoif(label, condition) \"gotoif(%s, %s)\";\\\n\\\nexecute(script_to_execute) \"execute(%s)\";\\\nexecutesync(script_to_execute) \"executesync(%s)\";\\\n]==];\\\n  --[[/*\\\n    * Now that the string has been defined,\\\n    * let the function define our actions\\\n  */]]\\\n  create_Editor_functions(Editor_actions);\\\n)}\n"]]}}
```

## What am I importing?

The source import contains just the library.<br>
To access the library, place `:import Editor_actions lib` at the top of your script or right before the first lua macro that needs it.

You're also getting access to the constructor function `Editor.assemble_error()` through which you pass in the action you've build.<br>
If you want the output to be formatted, you'll need to set `Editor.format_error_message = true` at the top of the macro or at any point where you think it's worth doing.

The formatting is far from perfect, but it's functional enough to help you in debugging.

## How do I use this?

It might be hard to see how this can be used, so here's an example of an expression taken out of D0S.DustManager.

```
; Nested expressions for calculating the tier of ore to crush. This factors in
; the need to save 1000 ore based on ore_buffer, and returns
; 0 if there is no crushable ore.
#nest2_9(macro, final) {{macro}(2,{{macro}(3,{{macro}(4,{{macro}(5,{{macro}(6,{{macro}(7,{{macro}(8,{{macro}(9,{final})})})})})})})})}
#orecount_cond(value) (count("ore", {value}) <= min(ore_buffer, count("dust", {value})))
#orestate_nest(value, rest) if({orecount_cond(10 - {value})}, {rest}, 10 - {value})
#dust_inc if(active("mixer"), 0, 11)
#orestate if(active("crusher"), {dust_inc}, {orestate_nest(0,{orestate_nest(1,{nest2_9(orestate_nest,{dust_inc})})})})
```

All these macros are in place to calculate the orestate macro.<br>
Writing this in lua makes understanding the code a lot easier.

The downside is that I'm not able to write the macro perfectly as I don't fully understand the purose of all these calculations, but I hope that this shows you how you can use it.

```
{lua(\
  --[[global table that holds our global functions]]\
  Manager = {};\
  \
  --[[Enable formatting our instruction for debugging]]\
  Editor.format_error_message = false;\
  \
  local active = Editor_isMachineActive;\
  --[[/*\
      * Shorten the active("machine") call by assigning the "memory address"\
      * of our Editor_action to the variable "active"\
     */]]\
  local function orecount_cond(tier)\
    --[[/*\
        * Counts the ammount of ore and dust we have of the requested tier\
        * The min operation ensures we never process more dust than ore_buffer\
        * permits\
       */]]\
    local count = Editor_factoryCountItems;\
    local ore = [["ore"]];\
    local dust = [["dust"]]\
    local ore_count = count(ore, tier);\
    local dust_count = count(dust, tier);\
    local ore_buffer = "ore_buffer";\
    local min = Editor_min(ore_buffer, dust_count);\
    return Editor_math(ore_count, "<=", min);\
  end\
  local function orestate_nest(value, rest)\
    --[[Creates an if statement to make it easier to calculate orestate]]\
    local tier = math.tointeger(value);\
    local condition = orecount_cond(tier);\
    return Editor_if(condition, rest, tier);\
  end\
  local mixer = Editor_stringify_value("mixer");\
  local dust_inc = Editor_if(active(mixer), 0, 11);\
  \
  function Manager.orestate()\
    local crusher = Editor_stringify_value("crusher");\
    local condition = active(crusher);\
    local ore_nest = dust_inc;\
    for i = 1, 10 do\
      --[[/*\
          * Create the nested if for all tiers\
          * starting from 1 and ending with 10.\
          * \
          * Because the expression uses ore_nest as the last\
          * parameter, tier 10 is processed before tier 9\
         */]]\
      ore_nest = orestate_nest(i, ore_nest);\
    end\
    return Editor_if(condition, dust_inc, ore_nest);\
  end\
  \
  --[[/*\
    * Structure used to only build the error message when formatting is enabled.\
    * This is the cod-proof compliant setup\
  */]]\
  if Editor.format_error_message then\
    Editor.assemble_error(Manager.orestate())\
  end\
)}

#orestate {lua(return Manager.orestate())}
```
