# Editor_actions lib

This is a library for use within the [External AI Editor by d0sboots](https://d0sboots.github.io/perfect-tower/) that holds multiple functions that output the editors syntax. By doing this, you can build complex conditions and ternary expressions fully within lua to better modify/documment what you're building.

This is source import
```
{"workspaces":{"Editor Actions lib":[["Editor_actions lib","; Script that defines multiple helper lua functions\n; that let you easily build and return large expressions\n; by using a lua macro instead of multiple line breaks\n;\n; Building expressions in lua can greately improve script\n; readability and maintinability if used correctly\n;\n\n;\n; For this library, I will take a page out of d0s's book and\n; just write the functions out in a string\n;\n; I'm pretty sure this should make everything easier\n;\n; The library is made to read from the Editor_actions string and\n; create a function that the user can call, that returns\n; the formatted value requested by the syntax\n;\n; Function name is defined first, its name ends at the first instance of\n; an open parenthesis (\n;\n; Function parameters are the contents within the set of\n; (enclosed parenthesies), the match() pattern matches the\n; first instance of the (enclosed parenthesies) set\n;\n; Function return output is found at the first instance of a\n; closed parenthesis ) and a space. It stops reading when it reaches ;\n;\n; A function sequence ends with a semicolon ;\n{lua(\\\n  Editor = {};\\\n  Editor.format_error_message = false;\\\n  Editor.error_message_params = {};\\\n  Editor.output_table = false;\\\n  \\\n  Editor.cache = {};\\\n  Editor.cache.coma = \", \";\\\n  Editor.cache.parens = table.pack(\"(\", \")\");\\\n  \\\n  --[[Internal variable for debugging, logs the function]]\\\n  local logging = false;\\\n  \\\n  --[[Internal variable that stores an error message]]\\\n  local err_msg = {};\\\n  \\\n  --[[Function that processes all the actions to form the desired output]]\\\n  function Editor.process_action(output, param_count, ...);\\\n    local params = table.pack(...);\\\n    Editor.error_message_params[#Editor.error_message_params + 1] = \"\";\\\n    if #params < param_count then\\\n      err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nMissing \", (#params == 0) and \"all\" or (param_count - #params), \" parameter(s)!\",\\\n        \"\\nExpected \", param_count, \" but obtained \", #params, \" parameters\"\\\n      );\\\n      error(table.concat(err_msg));\\\n    end\\\n    local acc = {};\\\n    local param = 1;\\\n    local passed_paren = false;\\\n    output = \";\" .. output:gsub(\"%%s\", \"PARAM\");\\\n    for word in output:gmatch(\"[^PARAM]+\") do\\\n      if param_count > 1 and word:match(\"[%(%)]\") ~= nil then\\\n        --[[/*\\\n          * we only care if we've passed the first paren\\\n          * when we're formatting for an error message\\\n        */]]\\\n        passed_paren = Editor.format_error_message;\\\n      end\\\n      \\\n      if param == 1 then\\\n        --[[get rid of the `;` we added to the output]]\\\n        word = word:sub(2);\\\n      end\\\n      \\\n      if param > param_count and passed_paren then\\\n        acc[#acc + 1] = \"\\\\n%0s\";\\\n      end\\\n      acc[#acc + 1] = word;\\\n      if param <= param_count then\\\n      \\\n        if passed_paren then\\\n          Editor.error_message_params[#Editor.error_message_params + 1] = \"\";\\\n          acc[#acc + 1] = \"\\\\n%0s\";\\\n        end\\\n        \\\n        local str;\\\n        if type(params[param]) ~= \"table\" then\\\n          str = tostring(params[param]);\\\n          if Editor.format_error_message and str == \"%\" then\\\n            acc[#acc + 1] = \"%%\";\\\n          else\\\n            acc[#acc + 1] = str;\\\n          end\\\n        else\\\n          local params_count = #params[param];\\\n          if params_count > math.maxinteger then\\\n            error(\"table input is too large!\\n\" .. params_count .. \" elements\");\\\n          elseif Editor.format_error_message then\\\n            for i = 1, params_count do\\\n              str = tostring(params[param][i]);\\\n              acc[#acc + 1] = (str == \"%\") and \"%%\" or str;\\\n            end\\\n          else\\\n            for i = 1, params_count do\\\n              acc[#acc + 1] = tostring(params[param][i]);\\\n            end\\\n          end\\\n        end\\\n      end\\\n      param = param + 1;\\\n    end\\\n    return Editor.output_table and acc or table.concat(acc);\\\n  end\\\n  \\\n  function Editor.assemble_error(input)\\\n    local action = (type(input) ~= \"table\") and input or table.concat(input);\\\n    \\\n    if not Editor.format_error_message then\\\n      err_msg = table.pack(\\\n        \"Cod-proofing violation!\\n\\n\",\\\n        \"Editor.assemble_error was called when Editor.format_error_message is false.\\n\",\\\n        \"Why are you trying to assemble an error when the output is un-formatted?\"\\\n      );\\\n    elseif not action:match(\",\") then\\\n      err_msg = table.pack(\\\n        \"Cod-proofing violation!\\n\\n\",\\\n        \"Editor.assemble_error called for an input without multiple parameters.\\n\",\\\n        \"Any formatting applied would only make the output harder to read.\"\\\n      );\\\n    end\\\n    \\\n    if err_msg[1] ~= nil then\\\n      err_msg[#err_msg + 1] = \"\\n\\n\";\\\n      err_msg[#err_msg + 1] = \"Unformatted input message:\\n\";\\\n      err_msg[#err_msg + 1] = action;\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local spaces = 0;\\\n    \\\n    local idx = 1;\\\n    local args = {};\\\n    \\\n    local pos = 0;\\\n    while pos < #action do\\\n      local pos_copy = pos;\\\n      \\\n      --[[/*\\\n        * Extract the text up to and including the first parenthesee.\\\n        * Add pos as our offset, so acc doesn't have repeat contents.\\\n      */]]\\\n      args[idx] = action:match(\"^([^%(%)]+.)\", pos + 1);\\\n      pos = pos + #(args[idx] or \"\")\\\n      if not args[idx] then\\\n        --[[extract just 1 parenthesee]]\\\n        args[idx] = action:sub(pos + 1, pos + 1);\\\n        pos = pos + 1;\\\n      elseif action:sub(pos_copy + 1, pos_copy + 1) == Editor.cache.parens[1] then\\\n        --[[/*\\\n          * If the first character was a paranthesee,\\\n          * the match wouldn't have hit it, so we have to add it\\\n        */]]\\\n        args[idx] = Editor.cache.parens[1] .. args[idx];\\\n        pos = pos - 1;\\\n      end\\\n      \\\n      if args[idx]:sub(#args[idx], #args[idx]) == Editor.cache.parens[1] then\\\n        args[idx] = args[idx]:gsub(\"%%0s\", \"%%\" .. spaces .. \"s\");\\\n        spaces = spaces + 2;\\\n      else\\\n        local _, count = args[idx]:gsub(\"%%0s\", \"\");\\\n        args[idx] = args[idx]:gsub(\"%%0s\", \"%%\" .. spaces .. \"s\", count - 1);\\\n        spaces = spaces - 2;\\\n        args[idx] = args[idx]:gsub(\"%%0s\", \"%%\" .. spaces .. \"s\");\\\n      end\\\n      \\\n      idx = idx + 1;\\\n      if pos == pos_copy then\\\n        error(\"Prevent infinite loop\");\\\n      end\\\n    end\\\n    \\\n    action = table.concat(args);\\\n    action = \"\\n\" .. action:gsub(\"\\\\n\", \"\\n\");\\\n    action = action:format(table.unpack(Editor.error_message_params))\\\n    error(action, 0);\\\n  end\\\n  \\\n  local function create_Editor_functions(actions_string)\\\n    --[[/*\\\n      * Every action must end with a ;\\\n      * If the actions_string doesn't contain a `;`, throw an error\\\n    */]]\\\n    if actions_string:match(\";\") == nil then\\\n      error(\"\\n\\nMalformed action string.\\nInput contains no `;`.\", 0);\\\n    end\\\n    \\\n    local action_count = 0;\\\n    --[[/*\\\n      * Keep count of our actions for additional helpful information\\\n      * \\\n      * Create a pattern that defines an action.\\\n    */]]\\\n    local actions_pattern = \"([%w_]+)(%b())%s+(.+)\";\\\n    for line in actions_string:gmatch(\"[^;]+\") do\\\n      --[[line is the action without the EOL character]]\\\n      \\\n      action_count = action_count + 1;\\\n      local action = table.pack(line:match(actions_pattern))\\\n      --[[Extracts our action name, parameters and output]]\\\n      \\\n      if #action ~= 3 then\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Cannot compute actions string:\\n\",\\\n          \"|'\", line, \"'\\n\",\\\n          \"|Was only able to extract \" .. #action .. \" values of the expected 3:\\n\",\\\n          \"|name = '\", action[1] or \"nil\", \"'\\n\",\\\n          \"|params = '\", action[2] or \"nil\", \"'\\n\",\\\n          \"|output = '\", action[3] or \"nil\", \"'\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      --[[/*\\\n        * now that all 3 parameters have been obtained,\\\n        * we can assign them to their respective variables\\\n        * so it's easier to know what we're doing\\\n      */]]\\\n      local name, params, output = table.unpack(action);\\\n      params = params:sub(2, -2);\\\n      \\\n      --[[Create the name of our function and check if it has already been defined]]\\\n      local func_name = \"Editor_\" .. name;\\\n      if _G[func_name] ~= nil then\\\n        --[[/*\\\n          * If the function already exists, throw an error telling us that we messed up.\\\n          * Access the functions \"root\" to be able to compare the input and output of the 2\\\n        */]]\\\n        local root = \"root_\" .. func_name;\\\n        local origin = Editor[root];\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Action duplicate detected on action string:\\n\",\\\n          \"|'\", line, \"'\\n|\\n\",\\\n          \"|line number = \", action_count, \"\\n\",\\\n          \"|root line number = \", origin.action_count, \"\\n|\\n\",\\\n          \"|name = '\", name, \"'\\n\",\\\n          \"|root name = '\", origin.name, \"'\\n|\\n\",\\\n          \"|params = '\", params, \"'\\n\",\\\n          \"|original params = '\", origin.params, \"'\\n|\\n\",\\\n          \"|output = '\", output, \"'\\n\",\\\n          \"|original output = '\", origin.output, \"'\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      local params_count = 0;\\\n      for _ in params:gmatch(\",\") do\\\n        params_count = params_count + 1;\\\n      end\\\n      params_count = params_count + 1;\\\n      \\\n      --[[Now we handle logging the action, so we can check if our error handling is faulty]]\\\n      if logging then\\\n        local print_msg = table.pack(\\\n          \"|Logging action number \", action_count, \"\\n\",\\\n          \"|Line = \", line, \"\\n\",\\\n          \"|name = '\", name, \"'\\n\",\\\n          \"|params = '\", params, \"'\\n\",\\\n          \"|params_count = \", params_count, \"\\n\",\\\n          \"|output = '\", output, \"'\\n\"\\\n        );\\\n        print(table.concat(print_msg));\\\n      end\\\n      \\\n      --[[/*\\\n        * Time to create the function body.\\\n        * Since this is activated using load(), we need to return the function definition,\\\n        * Additionally, every escape character must be doubled, meaning that,\\\n        * to create %s, you'd need to do %%s\\\n      */]]\\\n      local func_body = string.format(\\\n        [==[\\\n          return function(%s)\\\n            local output, params_count = [[%s]], %d;\\\n            return Editor.process_action(output, params_count, %s)\\\n          end\\\n        ]==],\\\n        params, output, params_count, params\\\n      );\\\n      --[[/*\\\n        * With our function defined, we must load the function in a chunk\\\n        * We assign 2 values here:\\\n        * - chunk is the actual function we're loading\\\n        * - err is an error message returned if the function failed to load\\\n        * \\\n        * The parameters in load are as follows:\\\n        * - The function to load\\\n        * - The \"chunk\" we're loading it into. This provides the function name.\\\n        * - The mode of our function.\\\n        *   The mode \"t\" reprezents text, as our function body is defined as a string\\\n        *   and its parameters are treated as strings\\\n        * - The environment is global, as we need to have access to our Editor body\\\n      ]]\\\n      local chunk, err = load(func_body, func_name, \"t\", _G);\\\n      if not chunk then\\\n        --[[If the chunk failed to load, throw an error and include the error message]]\\\n        err_msg = table.pack(\\\n          \"\\n\\n\",\\\n          \"|Error while loading function '\", name, \"'\\n\",\\\n          \"|Error message =\\n\",\\\n          \"|`\", err, \"`\"\\\n        );\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      \\\n      _G[func_name] = chunk();\\\n      --[[/*\\\n        * We've successfully created the function called func_name,\\\n        * Add it to the global scope instead of our Editor table\\\n        * so that the call Editor.Editor_name() can just be Editor_name()\\\n        * \\\n        * Also define the root properties of our function.\\\n        * Since these aren't useful to anyone other than ourselves, we can add them to our\\\n        * Editor table instead, purely for organization purposes.\\\n      */]]\\\n      local root = \"root_\" .. func_name;\\\n      Editor[root] = {};\\\n      local root_data = Editor[root];\\\n      \\\n      root_data.name = name;\\\n      root_data.params = params;\\\n      root_data.output = output;\\\n      root_data.action_count = action_count;\\\n    end\\\n  end\\\n  \\\n  local Editor_actions = [==[\\\nstringify_value(value_to_stringify) \"%s\";\\\nencase_value(value_to_encase) (%s);\\\n\\\nsetVar(var_type, dataType, name, set_value) %s.%s.set(%s, %s);\\\nset_globalVar(dataType, name, set_value) global.%s.set(%s, %s);\\\nset_localVar(dataType, name, set_value) local.%s.set(%s, %s);\\\n\\\ngetVar(var_type, dataType, name) %s.%s.get(%s);\\\nget_globalVar(dataType, name) global.%s.get(%s);\\\nget_localVar(dataType, name) local.%s.get(%s);\\\n\\\nunsetVar(var_type, name) %s.unset(%s);\\\nunset_globalVar(name) global.unset(%s);\\\nunset_localVar(name) local.unset(%s);\\\n\\\nmath(leftVal, op_name, rightVal) %s %s %s;\\\n\\\nprimitive_math(primitive_op, dataType, leftVal, op_name, rightVal) %s.%s(%s, %s, %s);\\\nprimitive_comparison(dataType, leftVal, op_name, rightVal) comparison.%s(%s, %s, %s);\\\nprimitive_arithmetic(dataType, leftVal, op_name, rightVal) arithmetic.%s(%s, %s, %s);\\\n\\\nnot(value_to_negate) not(%s);\\\n\\\nif(condition, valueTrue, valueFalse) if(%s, %s, %s);\\\n\\\ncontains(parent_string, checker_string) contains(%s, %s);\\\n\\\nlen(string_value) len(%s);\\\nindex(parent_string, checker_string, string_offset) index(%s, %s, %s);\\\n\\\nconcat(left_string, right_string) concat(%s, %s);\\\nsub(parent_string, string_offset, substring_lenght) sub(%s, %s, %s);\\\n\\\nlower(string_to_manipulate) lower(%s);\\\nupper(string_to_manipulate) upper(%s);\\\n\\\nmin(leftVal, rightVal) min(%s, %s);\\\nmax(leftVal, rightVal) max(%s, %s);\\\nrnd(minVal, maxVal) rnd(%s, %s);\\\n\\\nfloor(floor_value) floor(%s);\\\nceil(ceil_value) ceil(%s);\\\nround(round_value) round(%s);\\\n\\\nsin(sin_value) sin(%s);\\\ncos(cos_value) cos(%s);\\\ntan(tan_value) tan(%s);\\\nasin(asin_value) asin(%s);\\\nacos(acos_value) acos(%s);\\\natan(atan_value) atan(%s);\\\natan2(atan2_value) atan2(%s);\\\n\\\nvector_xCoord(vector_value) x(%s);\\\nvector_yCoord(vector_value) y(%s);\\\nvec(vector_coord_x, vector_coord_y) vec(%s, %s);\\\n\\\nconvertDataType(originalType, desiredType, value) %s2%s(%s);\\\nconvertFromString(desiredType, value, fallback) s2%s(%s, %s);\\\n\\\nconvertIntToDouble(value) i2d(%s);\\\nconvertIntToString(value) i2s(%s);\\\n\\\nconvertDoubleToInt(value) d2i(%s);\\\nconvertDoubleToString(value) d2s(%s);\\\n\\\nconvertStringToInt(value, fallback) s2i(%s, %s);\\\nconvertStringToDouble(value, fallback) s2d(%s, %s);\\\n\\\nvisibilityGet(windowID) visibility.get(%s);\\\nchildVisibilityGet(windowID, elementID) child.visibility.get(%s, %s);\\\n\\\ncreateWindow(windowID, windowType) window.create(%s, %s);\\\ndestroyWindow(windowID) window.destroy(%s);\\\n\\\nsetWindowPosition(windowID, position) window.position.set(%s, %s);\\\n\\\nsetTextInWindow(windowID, elementID, value) window.text.set(%s, %s, %s);\\\nsetSpriteInWindow(windowID, elementID, spriteID) window.sprite.set(%s, %s, %s);\\\n\\\nsetWindowVisibility(windowID, visibility) window.visibility.set(%s, %s);\\\nsetChildVisibility(windowID, elementID, visibility) window.child.visibility.set(%s, %s, %s);\\\n\\\nresource(resourceID) resource(%s);\\\n\\\nsoftwareEnabled(softwareID) software.enabled(%s);\\\nsoftwareFind(softwareName) software.find(%s);\\\n\\\ntowerHealth(percentage) health(%s);\\\ntowerEnergy(percentage) energy(%s);\\\ntowerShield(percentage) shield(%s);\\\nmoduleCooldown(module_index) cooldown(%s);\\\n\\\nhighscore(type, region, difficulty) highscore.%s(%s, %s);\\\n\\\nhighscoreWave(region, difficulty) highscore.wave(%s, %s);\\\nhighscoreEra(region, difficulty) highscore.era(%s, %s);\\\nhighscoreInfinity(region, difficulty) highscore.infinity(%s, %s);\\\n\\\ndisableCost(element_name) disable.cost(%s);\\\nactiveID(active_spell_index) active.id(%s);\\\nactiveIndex(moduleId) active.index(%s);\\\n\\\nworkerPaused(workerID) worker.paused(%s);\\\nworkerGroup(workerID) worker.group(%s);\\\nworkerName(workerID) worker.name(%s);\\\nworkerTask(workerID) worker.task(%s);\\\n\\\nadventureCountEntities(entityType) adventure.countEntities(%s);\\\nadventureHasItem(item_name) adventure.hasItem(%s);\\\nadventureIsWall(tile_coords) adventure.isWall(%s);\\\nadventureIsBomb(tile_coords) adventure.isBomb(%s);\\\nadventureIsEnemy(tile_coords) adventure.isEnemy(%s);\\\nadventureIsCompleted(room_coords) adventure.isCompleted(%s);\\\nadventureEntityType(tile_coords) adventure.entityType(%s);\\\n\\\nisMachineActive(machine_name) active(%s);\\\nfactoryCountItems(item_name, tier) count(%s, %s);\\\nfactoryCountMachineItems(machine_name) machine.item.count(%s);\\\nfactoryItemInMachine(machine_name) machine.item(%s);\\\nfactoryFindItem(item_name) factory.find(%s);\\\n\\\nmarketPreference(stone_element) museum.pref(%s);\\\nisMarketSlotLocked(stone_index) museum.isLocked(%s);\\\nmuseumFreeSlots(target_menu) museum.freeSlots(%s);\\\nmaxStoneTier(element) museum.maxTier(%s);\\\nslotTier(offerSlot) museum.slotTier(%s);\\\ntrashTier(trashSlot) museum.trashTier(%s);\\\nslotElement(offerSlot) museum.slotElement(%s);\\\ntrashElement(trashSlot) museum.trashElement(%s);\\\n\\\n]==];\\\n  --[[/*\\\n    * Now that the string has been defined,\\\n    * let the function define our actions\\\n  */]]\\\n  create_Editor_functions(Editor_actions);\\\n)}\n"]]}}
```

## What am I importing?

The source import contains just the library.<br>
To access the library, place `:import Editor_actions lib` at the top of your script or right before the first lua macro that needs it.

You're also getting access to the constructor function `Editor.assemble_error()` through which you pass in the action you've build.<br>
If you want the output to be formatted, you'll need to set `Editor.format_error_message = true` at the top of the macro or at any point where you think it's worth doing.

If you're making a large number of copies through 1 single variable, you can set `Editor.output_table = true` and switch out the variable for a table. This will calculate the output faster.

## How do I use this?

It might be hard to see how this can be used, so here's an example of an expression taken out of D0S.DustManager.

```
; Nested expressions for calculating the tier of ore to crush. This factors in
; the need to save 1000 ore based on ore_buffer, and returns
; 0 if there is no crushable ore.
#nest2_9(macro, final) {{macro}(2,{{macro}(3,{{macro}(4,{{macro}(5,{{macro}(6,{{macro}(7,{{macro}(8,{{macro}(9,{final})})})})})})})})}
#orecount_cond(value) (count("ore", {value}) <= min(ore_buffer, count("dust", {value})))
#orestate_nest(value, rest) if({orecount_cond(10 - {value})}, {rest}, 10 - {value})
#dust_inc if(active("mixer"), 0, 11)
#orestate if(active("crusher"), {dust_inc}, {orestate_nest(0,{orestate_nest(1,{nest2_9(orestate_nest,{dust_inc})})})})
```

All these macros are in place to calculate the orestate macro.<br>
Writing this in lua makes understanding the code a lot easier.

The downside is that I'm not able to write the macro perfectly as I don't fully understand the purose of all these calculations, but I hope that this shows you how you can use it.

```
{lua(\
  --[[global table that holds our global functions]]\
  Manager = {};\
  \
  --[[Enable formatting our instruction for debugging]]\
  Editor.format_error_message = false;\
  \
  local active = Editor_isMachineActive;\
  --[[/*\
      * Shorten the active("machine") call by assigning the "memory address"\
      * of our Editor_action to the variable "active"\
     */]]\
  local function orecount_cond(tier)\
    --[[/*\
        * Counts the ammount of ore and dust we have of the requested tier\
        * The min operation ensures we never process more dust than ore_buffer\
        * permits\
       */]]\
    local count = Editor_factoryCountItems;\
    local ore = [["ore"]];\
    local dust = [["dust"]]\
    local ore_count = count(ore, tier);\
    local dust_count = count(dust, tier);\
    local ore_buffer = "ore_buffer";\
    local min = Editor_min(ore_buffer, dust_count);\
    return Editor_math(ore_count, "<=", min);\
  end\
  local function orestate_nest(value, rest)\
    --[[Creates an if statement to make it easier to calculate orestate]]\
    local tier = math.tointeger(value);\
    local condition = orecount_cond(tier);\
    return Editor_if(condition, rest, tier);\
  end\
  local mixer = Editor_stringify_value("mixer");\
  local dust_inc = Editor_if(active(mixer), 0, 11);\
  \
  function Manager.orestate()\
    local crusher = Editor_stringify_value("crusher");\
    local condition = active(crusher);\
    local ore_nest = dust_inc;\
    for i = 1, 10 do\
      --[[/*\
          * Create the nested if for all tiers\
          * starting from 1 and ending with 10.\
          * \
          * Because the expression uses ore_nest as the last\
          * parameter, tier 10 is processed before tier 9\
         */]]\
      ore_nest = orestate_nest(i, ore_nest);\
    end\
    return Editor_if(condition, dust_inc, ore_nest);\
  end\
  \
  --[[/*\
    * Structure used to only build the error message when formatting is enabled.\
    * This is the cod-proof compliant setup\
  */]]\
  if Editor.format_error_message then\
    Editor.assemble_error(Manager.orestate())\
  end\
)}

#orestate {lua(return Manager.orestate())}
```
