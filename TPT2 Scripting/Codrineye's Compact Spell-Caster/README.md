# Codrineye's Compact Spell-Caster
This is a library to be used within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) with the purpose of condensing all the programming behind the activation logic of a blueprint into one single script called 'sync'<br>
This tool comes with an indepth explanation for how it works within the source code, so you can simply import it, or use the provided `.tpt2` files which include these comments, [Cods Spell Compactor](Cods%20Spell%20Compactor.tpt2) [Spell Config](Spell%20Config.tpt2) and [winAI_lib](winAI_lib.tpt2) respectively.

## The import package
In order to showcase this package in action, I have adapted the AI for winAI4 to work within this compacted format<br>
The reason I chose winAI4 was also because it is one of the only blueprint AI's that could benifit from it.

## The downsides
I will admit that, as the creator of this package, this tool will hardly ever get used.<br>
I say this because of how rare it is for the activation logic of an AI to surpass the size of a single script, and because I made this tool specifically to streamline the programming of large blueprint activation sequences.

## Introducing Batches
Batches are a simple, yet powerful adition to the compactor.<br>
One of the major struggles of implementing multiple blueprints within the compactor is the clunky manner you get to a desired package of skills, well not anymore,<br>
Thanks to the introduction of batches, all the broken up sections are a dynamically defined length stored within the :const int variable `batch`, which works in tandumn with `increment` to get the full length of all our segments by multiplying them together.

# Source code
the source code is imported within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/)
```
{"workspaces":{"Codrineye's Compact Spell-Caster":[["Spell Config",":import Cods Spell Compactor\n\n; Welcome to the configuration\n; This is the only area you have to make changes to\n; Here you will configure the following properties\n; *  what active modules you want to be used\n; *  the order in which you want them to be used\n; *  the timings of the activation\n; *  and lastly\n; *  if the module is placed, you will have to specify the coordinates\n; \n; you have 4 functions at your disposal:\n; All of these macros generate :const <type> <token> 'contents'\n; \n; syncronize_module_activation()\n; This macro will create a token sync<sync count> containing the value 'module_count - 1'\n; You will need to specify the amount of modules you want to activate at this time and\n; a delay to the activation\n; This will make it so you have <module_count> sync scripts active at once\n; The excess scripts will remove themselves after spell activation\n; \n; add_batch()\n; This macro will declare the end of one batch and the start of another\n;   it's curently the only macro that returns a :const int, with the token being batch<batch count>\n; A 'batch' means a sellection of modules so that you may separate module sequences\n;   with only needing arithmetic operations\n; By default you're in batch1, if you call for this macro you will move to batch2\n;   by calling this macro, you change the string within sync created by <active_module_list> \n;   so that each batch has equal length\n; \n; add_active_module.type()\n; This macro will create a token spellname<spell count> containing the following values\n; 'spell_timer' . 'coord_x' . 'coord_y' . 'attribute' . 'spell_name' . ';'\n; \n; add_active_module.instant()\n; The first type of addition, where you need to specify the spell name and the timer\n; coord_x and coord_y are 0.0 and the attribute is 'instant '\n; the extra ' ' is there for consistent spacing\n; \n; add_active_module.grounded()\n; The second type of addition, where you need to specify everything field\n; The field meaning spell_name, spell_timer, coord_x and coord_y\n; the attribute for it is 'grounded'\n; \n; I do not recommend defining a ground module as an instant module nor vice versa\n; the system will accept your input, but you will not cast anything\n\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(barrier.temporal, 0.0)}\n{add_active_module.instant(spell.floof, 0.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 0.0)}\n{add_active_module.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 1.0)}\n{add_active_module.instant(spell.recharge, 1.0)}\n{add_active_module.instant(spell.cooling, 1.0)}\n{add_active_module.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 2.0)}\n{add_active_module.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n{add_active_module.instant(spell.refresh, 28.0)}\n{add_active_module.instant(spell.recharge, 28.0)}\n{add_active_module.instant(barrier.temporal, 28.0)}\n{add_active_module.instant(spell.floof, 28.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(spell.cooling, 29.0)}\n{add_active_module.instant(spell.recharge, 29.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 31.0)}\n{add_active_module.instant(spell.recharge, 31.0)}\n{add_active_module.instant(spell.refresh, 31.0)}\n{add_active_module.instant(barrier.temporal, 31.0)}\n{add_active_module.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 33.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 57.0)}\n\n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file rather than copy them\n; Putting the const declaration here is also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n\n:const int spells_count {lua(return #spell.active_module.module_instance)}\n\n:const int sync_precision {lua(return spell.sync_precision)}\n:const int time_precision {lua(return 2 + spell.timer_precision)}\n:const int placement_precision {lua(return 2 + spell.placement_precision)}\n:const int attribute_size {lua(return spell.attribute_size)}\n\n:const int batch {lua(return spell.batch_max_size)}\n:const int increment {lua(return spell.max_name_size)}\n\n"],["Cods Spell Compactor",":name Lua Madness\n; \n; Package found on discord or on my github repo\n; discord: https://discord.com/channels/488444879836413975/1275961817151307847/1275961817151307847\n; github: https://github.com/Codrineye/Codrineye-s-TPT2-Compendium/blob/main/TPT2%20Scripting/Codrineye's%20Compact%20Spell-Caster/README.md\n; \n; This macro handles every single action\n; The way it works is by creating a string value\n; :const string spellname<spell number> 'data given for the spell'\n; you will get a string dictated as the following values\n; \n; A timer for the module activation, this works in conjunction with winemast\n;   this timer is cut/extended to contain the number of digits seen\n;   in spell.timer_precision\n; \n; A coordinate x for the module, if this spell is placed\n;  similarly to our timer, this too is cut but it is linked\n;  to spell.placement_precision\n; Coordinate y is the same as coordinate x\n; \n; An attribute that is either 'instant ' or 'grounded'\n;   This is always sized 8 characters\n; That permits active modules to be used without a delay\n; \n; And finally, the spell name\n; It is the internal spell name, followed by a ';' to mark its end\n; \n; an extra function of this macro is to create a \"sync\" constant\n; This constant is given a precision dictated by spell.sync_precision\n; \n; There is no need to look beneath this, sync already\n; has you covered on the activation sequence\n; The only requirement is that you have the following macros\n;  * a pointer macro that \"points\" to our curent index block\n;  * a pointer_get that gets the value of your pointer\n;  * a pointer_set that updates your pointer via the pre-defined 'increment'\n;  * a timer macro that indicates the winemast timer\n;  and finally\n;  * a timer_get macro, that retrieves the value of our timer\n; \n; All of these macros are defined inside of winAI_lib\n; \n; \n\n{lua(\\\n  spell = {};\\\n  spell.active_module = {};\\\n  spell.active_module.module_instance = {};\\\n  spell.active_module.placement_positions = {};\\\n  spell.active_module.syncronization = {};\\\n  spell.sync_delay = 0.0;\\\n  spell.sync_precision = 2;\\\n  spell.timer_precision = 6;\\\n  spell.placement_precision = 4;\\\n  spell.attribute_size = 8;\\\n  spell.max_name_size = 0;\\\n  spell.batch = {};\\\n  spell.batch_instance = 1;\\\n  spell.batch_max_size = 0;\\\n\\\n  local function x_digit_precision(digits, input)\\\n    return string.sub(string.format(\"%.\" .. digits .. \"f\", input), 1, digits + 2);\\\n  end\\\n\\\n  function spell.add_spell(name, timer, attribute, coord_1, coord_2)\\\n    local excess = table.pack(coord_1, coord_2);\\\n    local spell_index = 1 + #spell.active_module.module_instance;\\\n    local new_spell = {};\\\n\\\n    local batch_update = 1;\\\n    if spell.batch[spell.batch_instance] ~= nil then\\\n      batch_update = batch_update + spell.batch[spell.batch_instance];\\\n    end\\\n    spell.batch_max_size = math.max(\\\n      spell.batch_max_size, \\\n      batch_update\\\n    );\\\n    spell.batch[spell.batch_instance] = batch_update;\\\n\\\n    new_spell.name = string.gsub(name, \" \", \"\");\\\n    local syncronization_timer_delay = 0.0;\\\n    if #spell.active_module.syncronization ~= 0 then\\\n      local syncronization_index = #spell.active_module.syncronization;\\\n      local syncronization_parent = spell.active_module.syncronization[syncronization_index].name;\\\n      syncronization_timer_delay = spell.sync_delay * (spell_index - syncronization_parent);\\\n    end\\\n    \\\n    new_spell.timer = x_digit_precision(spell.timer_precision, syncronization_timer_delay + timer);\\\n    new_spell.attribute = string.gsub(attribute, \" \", \"\");\\\n    local attribute_fit = string.rep([[.]], spell.attribute_size);\\\n    new_spell.attribute = string.sub(new_spell.attribute .. attribute_fit, 1, spell.attribute_size);\\\n    new_spell.identifier = [[spellname]] .. spell_index;\\\n    \\\n    if excess[1] == nil then\\\n      excess[1] = 0.0;\\\n    end\\\n    if excess[2] == nil then\\\n      excess[2] = 0.0;\\\n    end\\\n    new_spell.coords = {};\\\n    new_spell.coords[1] = x_digit_precision(spell.placement_precision, excess[1]);\\\n    new_spell.coords[2] = x_digit_precision(spell.placement_precision, excess[2]);\\\n    new_spell.constant = new_spell.timer .. \\\n      new_spell.coords[1] .. new_spell.coords[2] .. \\\n      new_spell.attribute .. new_spell.name;\\\n    new_spell.name_size = spell.sync_precision + #new_spell.constant;\\\n    \\\n    spell.active_module.module_instance[spell_index] = new_spell;\\\n    spell.active_module.placement_positions[spell_index] = new_spell.coords;\\\n    spell.max_name_size = math.max(\\\n      spell.max_name_size, \\\n      new_spell.name_size\\\n    );\\\n    return [[:const string ]] .. new_spell.identifier .. \\\n      [[ ']] .. new_spell.constant .. [[']];\\\n  end\\\n\\\n  function spell.concatinate_spell_names()\\\n    local batch = 1;\\\n    local increment = 1;\\\n    local syncronize = 1;\\\n    local spells_concat = {};\\\n    spells_concat[1] = [[\"]];\\\n    while increment < #spell.active_module.module_instance do\\\n      for i = 1, spell.batch[batch] do\\\n        if increment == spell.active_module.syncronization[syncronize].name then\\\n          spells_concat[1 + #spells_concat] = [[\" . sync]] .. syncronize .. [[ . \"]];\\\n          syncronize = math.min(syncronize + 1, #spell.active_module.syncronization);\\\n        else\\\n          spells_concat[1 + #spells_concat] = string.sub(math.floor(10 ^ spell.sync_precision), 2);\\\n        end\\\n        spells_concat[1 + #spells_concat] = [[\" . spellname]] .. increment .. [[ . \"]];\\\n        spells_concat[1 + #spells_concat] = string.rep(\\\n          [[.]], \\\n          spell.max_name_size - spell.active_module.module_instance[increment].name_size\\\n        );\\\n        increment = increment + 1;\\\n      end\\\n      local spacer = spell.batch_max_size - spell.batch[batch];\\\n      spacer = spacer * spell.max_name_size;\\\n      spells_concat[1 + #spells_concat] = string.rep([[.]], spacer);\\\n      batch = math.min(\\\n        batch + 1,\\\n        spell.batch_instance\\\n      );\\\n    end\\\n    spells_concat[#spells_concat + 1] = [[\"]];\\\n    return table.concat(spells_concat);\\\n  end\\\n\\\n  function spell.syncronize(copies, delay)\\\n    local syncronization = {};\\\n    syncronization.count = math.floor(10 ^ spell.sync_precision + copies - 1);\\\n    syncronization.name = 1 + #spell.active_module.module_instance;\\\n    local syncronization_index = 1 + #spell.active_module.syncronization;\\\n    spell.active_module.syncronization[syncronization_index] = syncronization;\\\n    spell.sync_delay = delay;\\\n    return [[:const string sync]] .. syncronization_index .. \\\n      [[ ']] .. string.sub(syncronization.count, spell.sync_precision) .. [[']];\\\n  end\\\n\\\n  function spell.add_batch()\\\n    local batch_recording = spell.batch[spell.batch_instance];\\\n    local batch_checkpoint = spell.batch_instance;\\\n    spell.batch_instance = spell.batch_instance + 1;\\\n    return [[:const int batch]] .. batch_checkpoint .. [[ ]] .. batch_recording;\\\n  end\\\n)}\n\n#syncronize_module_activation(modules_count, added_dellay) {lua(\\\n  return spell.syncronize(\\\n    [[{modules_count}]], \\\n    [[{added_dellay}]]\\\n  );\\\n)}\n#add_active_module.instant(spell_name, spell_timer) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[instant]],\\\n    0.0,\\\n    0.0\\\n  );\\\n)}\n#add_active_module.grounded(spell_name, spell_timer, spell_location_x, spell_location_y) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[grounded]], \\\n    {spell_location_x}, \\\n    {spell_location_y}\\\n  );\\\n)}\n#add_batch {lua(\\\n  return spell.add_batch()\\\n)}\n\n; This is the macro that concatinates every\n; added active module together\n#active_module_list {lua(\\\n  return spell.concatinate_spell_names();\\\n)}\n\n"],["sync",":import winAI_lib\n:import Spell Config\n:name {package(sync)}\n\n#substring(value, size) sub(\\\n  {active_module_list}, \\\n  index + {value}, \\\n  {size}\\\n)\n#substring_index(search, value) index(\\\n  {active_module_list}, \\\n  {search}, \\\n  index + {value}\\\n) - (index + {value})\n\n:const double threshold 0.50\n\n:local string spell_name\n:local double timer\n:local double placement_x\n:local double placement_y\n:local int index\n:local int syncronize\n:local bool copy_activator\n\ncopy_activator = contains(impulse(), \"{package(sync)}\")\ncheck:\nindex = {pointer_get}\ngotoif(if(\\\n    copy_activator, \\\n    skip, \\\n    syncronization_needed\\\n  ), false == contains(\"00\", {substring(0, sync_precision)})\\\n)\nskip:\n{pointer_set(increment)}\ntimer = s2d(\\\n  {substring(sync_precision, time_precision)}, \\\n  0.0\\\n)\nplacement_x = s2d(\\\n  {substring(\\\n    sync_precision + time_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nplacement_y = s2d(\\\n  {substring(\\\n    sync_precision + time_precision + placement_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nspell_name = {substring(\\\n  sync_precision + time_precision + placement_precision + placement_precision + attribute_size, \\\n  {substring_index(\\\n    \";\",\\\n    sync_precision + time_precision + placement_precision + placement_precision + attribute_size\\\n  )}\\\n)}\n\nwaitwhile(time.scale() == 0.0 || {timer_get} % timer > threshold || {timer_get} < timer)\nuseinstant(active.index(spell_name))\nuseposition(active.index(spell_name), vec(placement_x, placement_y))\ngoto(if(copy_activator, 99, check))\n\nsyncronization_needed:\nsyncronize = s2i({substring(0, sync_precision)}, 0)\n\ncopy:\nsyncronize = syncronize - 1\n{execute_package(sync)}\ngoto(if(syncronize <= 0, check, copy))\n\n"],["winAI_lib","; Consistent naming across scripts\n#package(name) winAI:{name}\n#execute_package(script) execute(\"{package({script})}\")\n\n; A package identifier used within\n; the names of global variables for a unique value\n#identifier \"winAI\"\n\n#pointer \"<size=0>\" . \"pointer\" . {identifier}\n#pointer_get global.int.get({pointer})\n#pointer_set(value) global.int.set(\\\n  {pointer}, \\\n  ({pointer_get} + {value}) % (spells_count * increment)\\\n)\n\n; The pointer chunk\n; Since I do not want to messy up the users screen\n; the pointer is a block hider, so you don't have to\n; see the pointer increment and decrement\n; \n; pointer_get is self explanetory\n; Make sure your pointer is an int, as sub() requires integers\n; \n; pointer_set is also self explanetory, but the set value is interesting\n; We add the value to our pointer, however, we're working with strings\n; Because of this, we loop over after we've exhausted our space\n; \n; our space is dictated by spells_count * increment, which are\n; :const int values found at the end of Spell Config\n\n#timer \"t\"\n#timer_get global.double.get({timer})\n"],["era",":import winAI_lib\n:name {package(era)}\n\ngame.newround()\n:const int element_length 12\n\n:const string element1 'light;      '\n:const string element2 'darkness;   '\n:const string element3 'nature;     '\n:const string element4 'electricity;'\n:const string element5 'universal;  '\n:const string element6 'fire;       '\n:const string element7 'neutral;    '\n:const string element8 'water;      '\n:const string element9 'earth;      '\n\n:local string element_name\n:local int index\n\n#elements_list element1 . element2 . element3 . element4 . element5 . element6 . element7 . element8 . element9\n\nera:\nelement_name = sub({elements_list}, index, index({elements_list}, \";\", index) - index)\n\nloop:\ndisable.era(element_name)\nglobal.string.set(\"no more hiding\", \"</size>\")\n\ngotoif(loop, disable.cost(element_name) >= 0.0)\nindex = index + element_length\ngotoif(era, contains(sub({elements_list}, index, element_length), \";\"))\n"],["tick",":import winAI_lib\n:name {package(tick)}\n\nglobal.double.set({timer}, {timer_get} + time.delta())\n{execute_package(tick)}\ngotoif(99, contains(impulse(), \"{package(tick)}\"))\n\nstop(\"Codrineye's TowerTesting:Stats Exit Diff_Change\")\nexecute(if(true, \"Codrineye's TowerTesting:Stats Exit Diff_Change\", \"{package(Null_Cond)}\"))\nwaituntil({timer_get} >= 2.0)\n{execute_package(3spam)}\n"],["3spam",":import winAI_lib\n:name {package(3spam)}\n\nwait(0.2)\nuseinstant(active.index(\"spell.response.neutral\"))\ngoto(1)\n"],["init",":import winAI_lib\n:name {package(init)}\n\ngame.newround()\n\nglobal.int.set({pointer}, 0)\nuseinstant(active.index(\"barrier.temporal\"))\n\nstop(\"{package(3spam)}\")\nstop(\"{package(tick)}\")\nstop(\"{package(sync)}\")\n\nloop:\nstop(\"{package(inf)}\")\ngoto(if(\\\n  isTowerTesting() && contains(impulse(), \"game.newround\"), \\\n  if(tower.health(false) > 0.0, exit, loop), \\\n  99\\\n))\nexit:\n\nglobal.double.set({timer}, time.delta() * 2.0)\nuseinstant(active.index(\"barrier.temporal\"))\n\n{execute_package(tick)}\n{execute_package(sync)}\n{execute_package(inf)}\n\nuseinstant(active.index(\"crate.rex\"))\nwaitwhile(health(false) > 0.0 && disable.cost(\"nature\") < 0.0)\nexecute(if(health(false) <= 0.0, \"{package(init)}\", \"{package(Null_Cond)}\"))\n"],["inf",":import winAI_lib\n:name {package(inf)}\n\nupgrade.era(\"health\", 42069)\ngotoif(0, xp() < disable.inf.cost())\n\ndisable.inf(\"aura.death\")\ndisable.inf(\"reflect.wince\")\ndisable.inf(\"reflect.captain\")\ndisable.inf(\"barrier.temporal\")\ndisable.inf(\"spell.void\")\ndisable.inf(\"spell.snapOfDestiny\")\ndisable.inf(\"spell.response.neutral\")\n\ngoto(0)\n"]]}}
```

# Import code
Requirements:
- impulse: 1
- conditions: 0
- lines: 16
- scripts: 6
```
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
```

