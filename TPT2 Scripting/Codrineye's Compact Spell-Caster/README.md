# Codrineye's Compact Spell-Caster
This is a library to be used within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) with the purpose of condensing all the programming behind the activation logic of a blueprint into one single script called 'sync'<br>
This tool comes with an indepth explanation for how it works within the source code, so you can simply import it, or use the provided `.tpt2` files which include these comments, [Cods Spell Compactor](Cods%20Spell%20Compactor.tpt2) [Spell Config](Spell%20Config.tpt2) and [winAI_lib](winAI_lib.tpt2) respectively.

## The import package
In order to showcase this package in action, I have adapted the AI for winAI4 to work within this compacted format<br>
The reason I chose winAI4 was also because it is one of the only blueprint AI's that could benifit from it.

## The downsides
I will admit that, as the creator of this package, this tool will hardly ever get used.<br>
I say this because of how rare it is for the activation logic of an AI to surpass the size of a single script, and because I made this tool specifically to streamline the programming of large blueprint activation sequences.

# Source code
the source code is imported within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/)
```
{"workspaces":{"Codrineye's Compact Spell-Caster":[["Spell Config",":import Cods Spell Compactor\n\n; Welcome to the configuration\n; This is the only area you have to make changes to\n; Here you will configure the following properties\n; *  what active modules you want to be used\n; *  the order in which you want them to be used\n; *  the timings of the activation\n; *  and lastly\n; *  if the module is placed, you will have to specify the coordinates\n; \n; you have 3 functions at your disposal:\n; All of these macros generate :const string <token> 'contents'\n; \n; syncronize_module_activation()\n; This macro will create a token sync<sync count> containing the value 'module_count - 1'\n; You will need to specify the amount of modules you want to activate at this time and\n; a delay to the activation, if you so please\n; This will make it so you have module_count sync scripts active at once\n; The excess scripts will remove themselves after spell activation\n; \n; add_active_module.type()\n; This macro will create a token spellname<spell count> containing the following values\n; 'spell_timer' . 'coord_x' . 'coord_y' . 'attribute' . 'spell_name' . ';'\n; \n; add_active_module.instant()\n; The first type of addition, where you need to specify the spell name and the timer\n; coord_x and coord_y are 0.0 and the attribute is 'instant '\n; the extra ' ' is there for consistent spacing\n; \n; add_active_module.grounded()\n; The second type of addition, where you need to specify everything field\n; The field meaning spell_name, spell_timer, coord_x and coord_y\n; the attribute for it is 'grounded'\n; \n; I do not recommend defining a ground module as an instant module nor vice versa\n; the system will accept your input, but you will not cast anything\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(barrier.temporal, 0.0)}\n{add_active_module.instant(spell.floof, 0.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 0.0)}\n{add_active_module.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 1.0)}\n{add_active_module.instant(spell.recharge, 1.0)}\n{add_active_module.instant(spell.cooling, 1.0)}\n{add_active_module.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 2.0)}\n{add_active_module.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n{add_active_module.instant(spell.refresh, 28.0)}\n{add_active_module.instant(spell.recharge, 28.0)}\n{add_active_module.instant(barrier.temporal, 28.0)}\n{add_active_module.instant(spell.floof, 28.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(spell.cooling, 29.0)}\n{add_active_module.instant(spell.recharge, 29.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 31.0)}\n{add_active_module.instant(spell.recharge, 31.0)}\n{add_active_module.instant(spell.refresh, 31.0)}\n{add_active_module.instant(barrier.temporal, 31.0)}\n{add_active_module.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 33.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 57.0)}\n\n\n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file rather than copy them\n; Putting the const declaration here is also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n\n:const int spells_count {lua(return #spell.active_module.module_instance)}\n\n:const int sync_precision {lua(return spell.sync_precision)}\n:const int time_precision {lua(return 2 + spell.timer_precision)}\n:const int placement_precision {lua(return 2 + spell.placement_precision)}\n:const int attribute_size {lua(return spell.attribute_size)}\n\n:const int increment {lua(return spell.max_name_size)}\n\n"],["Cods Spell Compactor",":name Lua Madness\n; \n; This macro handles every single action\n; The way it works is by creating a string value\n; :const string spellname<spell number> 'data given for the spell'\n; you will get a string dictated as the following values\n; \n; A timer for the module activation, this works in conjunction with winemast\n;   this timer is cut/extended to contain the number of digits seen\n;   in spell.timer_precision\n; \n; A coordinate x for the module, if this spell is placed\n;  similarly to our timer, this too is cut but it is linked\n;  to spell.placement_precision\n; Coordinate y is the same as coordinate x\n; \n; An attribute that is either 'instant ' or 'grounded'\n;   This is always sized 8 characters\n; That prevents active modules to be used with a delay\n; \n; And finally, the spell name\n; It is the internal spell name, followed by a ';' to mark its end\n; \n; an extra function of this macro is to create a \"sync\" constant\n; This constant is given a precision dictated by spell.sync_precision\n; \n; There is no need to look beneath this, sync already\n; has you covered on the activation sequence\n; The only requirement is that you have the following macros\n;  * a pointer macro that \"points\" to our curent index block\n;  * a pointer_get that gets the value of your pointer\n;  * a pointer_set that updates your pointer via the pre-defined 'increment'\n;  * a timer macro that indicates the winemast timer\n;  and finally\n;  * a timer_get macro, that retrieves the value of our timer\n; \n; All of these macros are defined inside of winAI_lib\n; \n; \n{lua(\\\n  spell = {};\\\n  spell.active_module = {};\\\n  spell.active_module.module_instance = {};\\\n  spell.active_module.placement_positions = {};\\\n  spell.active_module.syncronization = {};\\\n  spell.sync_delay = 0.0;\\\n  spell.sync_precision = 2;\\\n  spell.timer_precision = 6;\\\n  spell.placement_precision = 4;\\\n  spell.attribute_size = 8;\\\n  spell.max_name_size = 0;\\\n\\\n  local function x_digit_precision(digits, input)\\\n    return string.sub(string.format(\"%.\" .. digits .. \"f\", input), 1, digits + 2);\\\n  end\\\n\\\n  function spell.add_spell(name, timer, attribute, coord_1, coord_2)\\\n    local excess = table.pack(coord_1, coord_2);\\\n    local spell_index = 1 + #spell.active_module.module_instance;\\\n    local new_spell = {};\\\n    new_spell.coords = {};\\\n\\\n    new_spell.name = string.gsub(name, \" \", \"\");\\\n    local syncronization_timer_delay = 0.0;\\\n    if #spell.active_module.syncronization ~= 0 then\\\n      local syncronization_index = #spell.active_module.syncronization;\\\n      local syncronization_parent = spell.active_module.syncronization[syncronization_index].name;\\\n      syncronization_timer_delay = spell.sync_delay * (spell_index - syncronization_parent);\\\n    end\\\n    \\\n    new_spell.timer = x_digit_precision(spell.timer_precision, syncronization_timer_delay + timer);\\\n    new_spell.attribute = string.gsub(attribute, \" \", \"\");\\\n    local attribute_fit = string.rep([[.]], spell.attribute_size);\\\n    new_spell.attribute = string.sub(new_spell.attribute .. attribute_fit, 1, spell.attribute_size);\\\n    new_spell.identifier = [[spellname]] .. spell_index;\\\n    \\\n    if excess[1] == nil then\\\n      excess[1] = 0.0;\\\n    end\\\n    new_spell.coords[1] = x_digit_precision(spell.placement_precision, excess[1]);\\\n    if excess[2] == nil then\\\n      excess[2] = 0.0;\\\n    end\\\n    new_spell.coords[2] = x_digit_precision(spell.placement_precision, excess[2]);\\\n    new_spell.constant = new_spell.timer .. \\\n      new_spell.coords[1] .. new_spell.coords[2] .. \\\n      new_spell.attribute .. new_spell.name;\\\n    new_spell.name_size = spell.sync_precision + #new_spell.constant;\\\n    \\\n    spell.active_module.module_instance[spell_index] = new_spell;\\\n    spell.active_module.placement_positions[spell_index] = new_spell.coords;\\\n    spell.max_name_size = math.max(\\\n      spell.max_name_size, \\\n      new_spell.name_size\\\n    );\\\n    return [[:const string ]] .. new_spell.identifier .. \\\n      [[ ']] .. new_spell.constant .. [[']];\\\n  end\\\n\\\n  function spell.concatinate_spell_names()\\\n    local syncronize = 1;\\\n    local spells_concat = {};\\\n    spells_concat[1] = [[\"]];\\\n    for i = 1, #spell.active_module.module_instance do\\\n      if i == spell.active_module.syncronization[syncronize].name then\\\n        spells_concat[1 + #spells_concat] = [[\" . sync]] .. syncronize .. [[ . \"]];\\\n        syncronize = math.min(syncronize + 1, #spell.active_module.syncronization);\\\n      else\\\n        spells_concat[1 + #spells_concat] = string.sub(math.floor(10 ^ spell.sync_precision), 2);\\\n      end\\\n    \\\n      spells_concat[1 + #spells_concat] = [[\" . spellname]] .. i .. [[ . \"]];\\\n    \\\n      for j = 1, spell.max_name_size - spell.active_module.module_instance[i].name_size do\\\n        spells_concat[1 + #spells_concat] = [[.]];\\\n      end\\\n      \\\n    end\\\n    spells_concat[#spells_concat + 1] = [[\"]];\\\n    return table.concat(spells_concat);\\\n  end\\\n\\\n  function spell.syncronize(copies, delay)\\\n    local syncronization = {};\\\n    syncronization.count = math.floor(10 ^ spell.sync_precision + copies - 1);\\\n    syncronization.name = 1 + #spell.active_module.module_instance;\\\n    local syncronization_index = 1 + #spell.active_module.syncronization;\\\n    spell.active_module.syncronization[syncronization_index] = syncronization;\\\n    spell.sync_delay = delay;\\\n    return [[:const string sync]] .. syncronization_index .. \\\n      [[ ']] .. string.sub(syncronization.count, spell.sync_precision) .. [[']];\\\n  end\\\n)}\n\n#syncronize_module_activation(modules_count, added_dellay) {lua(\\\n  return spell.syncronize(\\\n    [[{modules_count}]], \\\n    [[{added_dellay}]]\\\n  );\\\n)}\n#add_active_module.instant(spell_name, spell_timer) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[instant]],\\\n    0.0,\\\n    0.0\\\n  );\\\n)}\n#add_active_module.grounded(spell_name, spell_timer, spell_location_x, spell_location_y) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[grounded]], \\\n    {spell_location_x}, \\\n    {spell_location_y}\\\n  );\\\n)}\n\n; This is the macro that concatinates every\n; added active module together\n#active_module_list {lua(\\\n  return spell.concatinate_spell_names();\\\n)}\n\n"],["sync",":import winAI_lib\n:import Spell Config\n:name {package(sync)}\n\n#root_substring(value, size) sub(\\\n  {active_module_list}, \\\n  {pointer_get} + {value}, \\\n  {size}\\\n)\n#substring(value, size) sub(\\\n  {active_module_list}, \\\n  index + {value}, \\\n  {size}\\\n)\n#substring_index(search, value) index(\\\n  {active_module_list}, \\\n  {search}, \\\n  index + {value}\\\n) - (index + {value})\n\n:const double threshold 0.50\n\n:local string spell_name\n:local double timer\n:local double placement_x\n:local double placement_y\n:local int index\n:local int syncronize\n:local bool copy_activator\n\ncopy_activator = contains(impulse(), \"{package(sync)}\")\ncheck:\ngotoif(if(\\\n    copy_activator, \\\n    skip, \\\n    syncronization_needed\\\n  ), false == contains(\"00\", {root_substring(0, sync_precision)})\\\n)\nskip:\nindex = {pointer_get}\n{pointer_set(increment)}\ntimer = s2d(\\\n  {substring(sync_precision, time_precision)}, \\\n  0.0\\\n)\nplacement_x = s2d(\\\n  {substring(\\\n    sync_precision + time_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nplacement_y = s2d(\\\n  {substring(\\\n    sync_precision + time_precision + placement_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nspell_name = {substring(\\\n  sync_precision + time_precision + placement_precision + placement_precision + attribute_size, \\\n  {substring_index(\\\n    \";\",\\\n    sync_precision + time_precision + placement_precision + placement_precision + attribute_size\\\n  )}\\\n)}\n\nwaitwhile(time.scale() == 0.0 || {timer_get} % timer > threshold || {timer_get} < timer)\ngotoif(ground, contains({substring(0, increment)}, \"ground\"))\n\nuseinstant(active.index(spell_name))\ngoto(ground_or_instant_end)\n\nground:\nuseposition(active.index(spell_name), vec(placement_x, placement_y))\n\nground_or_instant_end:\ngoto(if(copy_activator, 99, check))\n\nsyncronization_needed:\nsyncronize = s2i({substring(0, sync_precision)}, 0)\n\ncopy:\nsyncronize = syncronize - 1\n{execute_package(sync)}\ngoto(if(syncronize <= 0, check, copy))\n\n"],["winAI_lib","; Consistent naming across scripts\n#package(name) winAI:{name}\n#execute_package(script) execute(\"{package({script})}\")\n\n; A package identifier used within\n; the names of global variables for a unique value\n#identifier \"winAI\"\n\n#pointer \"<size=0>\" . \"pointer\" . {identifier}\n#pointer_get global.int.get({pointer})\n#pointer_set(value) global.int.set(\\\n  {pointer}, \\\n  ({pointer_get} + {value}) % (spells_count * increment)\\\n)\n\n; The pointer chunk\n; Since I do not want to messy up the users screen\n; the pointer is a block hider, so you don't have to\n; see the pointer increment and decrement\n; \n; pointer_get is self explanetory\n; Make sure your pointer is an int, as sub() requires integers\n; \n; pointer_set is also self explanetory, but the set value is interesting\n; We add the value to our pointer, however, we're working with strings\n; Because of this, we loop over after we've exhausted our space\n; \n; our space is dictated by spells_count * increment, which are\n; :const int values found at the end of Spell Config\n\n#timer \"t\"\n#timer_get global.double.get({timer})\n"],["era",":import winAI_lib\n:name {package(era)}\n\ngame.newround()\n:const int element_length 12\n\n:const string element1 'light;      '\n:const string element2 'darkness;   '\n:const string element3 'nature;     '\n:const string element4 'electricity;'\n:const string element5 'universal;  '\n:const string element6 'fire;       '\n:const string element7 'neutral;    '\n:const string element8 'water;      '\n:const string element9 'earth;      '\n\n:local string element_name\n:local int index\n\n#elements_list element1 . element2 . element3 . element4 . element5 . element6 . element7 . element8 . element9\n\nera:\nelement_name = sub({elements_list}, index, index({elements_list}, \";\", index) - index)\nglobal.string.set(\"no more hiding\", \"</size>\")\n\nloop:\ndisable.era(element_name)\n\ngotoif(loop, disable.cost(element_name) >= 0.0)\nindex = index + element_length\ngotoif(era, contains(sub({elements_list}, index, element_length), \";\"))\n"],["tick",":import winAI_lib\n:name {package(tick)}\n\nglobal.double.set({timer}, {timer_get} + time.delta())\n{execute_package(tick)}\ngotoif(99, contains(impulse(), \"{package(tick)}\"))\n\nstop(\"Codrineye's TowerTesting:Stats Exit Diff_Change\")\nexecute(if(true, \"Codrineye's TowerTesting:Stats Exit Diff_Change\", \"{package(Null_Cond)}\"))\nwaituntil({timer_get} >= 2.0)\n{execute_package(3spam)}\n"],["3spam",":import winAI_lib\n:name {package(3spam)}\n\nwait(0.2)\nuseinstant(active.index(\"spell.response.neutral\"))\ngoto(1)\n"],["init",":import winAI_lib\n:name {package(init)}\n\ngame.newround()\n\nglobal.int.set({pointer}, 0)\nuseinstant(active.index(\"barrier.temporal\"))\n\nstop(\"{package(3spam)}\")\nstop(\"{package(tick)}\")\nstop(\"{package(sync)}\")\n\nloop:\nstop(\"{package(inf)}\")\ngoto(if(\\\n  isTowerTesting() && contains(impulse(), \"game.newround\"), \\\n  if(tower.health(false) > 0.0, exit, loop), \\\n  99\\\n))\nexit:\n\nglobal.double.set({timer}, time.delta() * 2.0)\nuseinstant(active.index(\"barrier.temporal\"))\n\n{execute_package(tick)}\n{execute_package(sync)}\n{execute_package(inf)}\n\nuseinstant(active.index(\"crate.rex\"))\nwaitwhile(health(false) > 0.0 && disable.cost(\"nature\") < 0.0)\nexecute(if(health(false) <= 0.0, \"{package(init)}\", \"{package(Null_Cond)}\"))\n"],["inf",":import winAI_lib\n:name {package(inf)}\n\nupgrade.era(\"health\", 42069)\ngotoif(0, xp() < disable.inf.cost())\n\ndisable.inf(\"aura.death\")\ndisable.inf(\"reflect.wince\")\ndisable.inf(\"reflect.captain\")\ndisable.inf(\"barrier.temporal\")\ndisable.inf(\"spell.void\")\ndisable.inf(\"spell.snapOfDestiny\")\ndisable.inf(\"spell.response.neutral\")\n\ngoto(0)\n"]]}}
```

# Import code
Requirements:
- impulse: 1
- conditions: 0
- lines: 18
```
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
```
