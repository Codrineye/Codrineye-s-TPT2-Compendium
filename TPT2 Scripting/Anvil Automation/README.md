# AutoNode

```
{"workspaces":{"Anvil":[["Anvil Constants",":import Anvil Assembly\n\n; Define all anvil nodes in a way similar to the desmos graph\n; You can find the desmos graph at this link\n; https://discord.com/channels/488444879836413975/967563045964500992/1179025327956181052\n; \n; You have the macro call <create_node> that asks\n; for the following parameters:\n;  * the name of our node\n;  * the x coordinate of our node \n;  * the y coordinate of our node\n;  * the radius of our node\n;  * the speed of our node\n;  * the node type\n; and lastly\n;  * the node color\n; \n; At the time of creating this AI, facility AI cannot interact\n; with our anvil, so these names can be arbitrary\n; \n; The x, y coordinates reprezent the starting coordinate of our node\n; This point in space uses the radius to determine the size of our orbit\n; The smaller the radius, the smaller the orbit, and vice versa\n; \n; The speed of our node means how many seconds it takes our node to\n; complete a full orbit, using it we can determine how fast it moves\n; The speed can be positive or negative:\n; A positive speed means that the node is traveling clockwise\n; A negative speed means that the node is traveling counter-clockwise\n; \n; Following it, we have our node type\n; we have 3 types:\n;  * special is an effect on this entire property\n;  * damage  is an effect on the outgoing damage for this element\n;  * defense is an effect on the incoming damage for this element\n; \n; What makes \"special\" types so **special** is their lack of limits\n; for instance:\n;  * (special damage) is a boost on **all** outgoing damage\n;  * (damage neutral) is a boost on **all** outgoing damage !! of type neutral !!\n; \n;  * (special defense) is a boost on **all** incoming damage\n;  * (defense neutral) is a boost on **all** incoming damage !! of type neutral !!\n; \n; We end this command with the hex color used to represent the orbit\n; This color is taken from the desmos graph\n\n; |=============================|\n; | +- Begin Assigning Nodes -+ |\n; |=============================|\n\n{create_node(damage, +0.1, +0.1, +0.3, +604800, special, \"#6042A6\")}\n{create_node(resistance, +0.6, -0.35, +0.3, -172800, special, \"#6042A6\")}\n{create_node(range, +0.6, +0.0, +0.3, -21600, special, \"#6042A6\")}\n\n; Moving on to damage nodes\n\n{create_node(neutral, +0.45, +0.5, +0.15, +28800, damage, \"#808080\")}\n{create_node(fire, +0.35, +0.6752613187, +0.16, +32401, damage, \"#FF0000\")}\n{create_node(water, +0.25, +0.3311343193, +0.17, +36000, damage, \"#0080FF\")}\n{create_node(earth, +0.15, +0.487442106, +0.18, +39601, damage, \"#804000\")}\n{create_node(air, +0.05, +0.6809653044, +0.19, +43201, damage, \"#00FFFF\")}\n{create_node(nature, +0.05, +0.3381964564, +0.2, +46800, damage, \"#00FF00\")}\n{create_node(light, +0.15, +0.4749338031, +0.21, +50401, damage, \"#FFEC19\")}\n{create_node(darkness, +0.25, +0.6859552264, +0.22, +54000, damage, \"#8000FF\")}\n{create_node(electricity, +0.35, +0.3458969593, +0.23, +57600, damage, \"#CCAA00\")}\n{create_node(universal, +0.45, +0.4625244737, +0.24, +61200, damage, \"#000000\")}\n\n; Moving on to resistance nodes\n\n{create_node(neutral, +0.45, -0.5, +0.15, -21600, defense, \"#808080\")}\n{create_node(fire, +0.35, -0.6752613187, +0.16, -25200, defense, \"#FF0000\")}\n{create_node(water, +0.25, -0.3311343193, +0.17, -28799, defense, \"#0080FF\")}\n{create_node(earth, +0.15, -0.487442106, +0.18, -32400, defense, \"#804000\")}\n{create_node(air, +0.05, -0.6809653044, +0.19, -35999, defense, \"#00FFFF\")}\n{create_node(nature, +0.05, -0.3381964564, +0.2, -39600, defense, \"#00FF00\")}\n{create_node(light, +0.15, -0.4749338031, +0.21, -43200, defense, \"#FFEC19\")}\n{create_node(darkness, +0.25, -0.6859552264, +0.22, -46799, defense, \"#8000FF\")}\n{create_node(electricity, +0.35, -0.3458969593, +0.23, -50400, defense, \"#CCAA00\")}\n{create_node(universal, +0.45, -0.4625244737, +0.24, -53999, defense, \"#000000\")}\n\n; Finishing with the last nodes\n\n{create_node(health, -0.04, -0.7, +0.2, -302400, special, \"#C74440\")}\n{create_node(shield, +0.09, -0.5, +0.2, -345600, special, \"#2D70B3\")}\n{create_node(resources, -0.7, +0.0, +0.2, -86400, special, \"#FA7E19\")}\n{create_node(cooldown, -0.7, -0.3, +0.2, -172800, special, \"#FA7E19\")}\n{create_node(xp, +0.0, +0.0, +0.8, -43200, special, \"#FA7E19\")}\n{create_node(townxp, +0.0, +0.0, +0.9, +86400, special, \"#FA7E19\")}\n\n; |==============================|\n; | -+ Nodes Are Now Assigned +- |\n; |==============================|\n\n; Folloing this, we now form a data string\n; This is used to separate one set of data from another\n; The data string that results from this macro is as follows\n; `|` + `constant` + `color` + `radius` + `coordx` + `coordy` + `orbital_speed`\n; \n; the `|` is to act as a seperator between one node and another\n; the `constant` is to act as a node identifier\n; the `color` is the node color\n; the `radus`, `coordx`, `coordy` and `orbital_speed` are diferentiated by\n; one another thanks to an increasing space\n; This means that we're getting the following pattern\n; ` radius` + `  coordx` + `   coordy` + `    orbital_speed`\n\n#data_string {lua(\\\n  anvil.assembly = {};\\\n  anvil.assembly[1] = [[\"]];\\\n  for i = 1, #anvil.nodes do\\\n    local selected_anvil = anvil.nodes[i];\\\n    if selected_anvil.id == (selected_anvil.node_type .. \"_\" .. selected_anvil.name) then\\\n      return \"Invalid node \" .. i .. \" has name nil\";\\\n    end\\\n    local assembly = anvil.assembly;\\\n    assembly[#assembly + 1] = [[\"|\" . ]];\\\n    assembly[#assembly + 1] = selected_anvil.node_type;\\\n    assembly[#assembly + 1] = \"_\";\\\n    assembly[#assembly + 1] = selected_anvil.name;\\\n    assembly[#assembly + 1] = [[ . \"]];\\\n    assembly[#assembly + 1] = selected_anvil.color;\\\n    assembly[#assembly + 1] = \".\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_radius;\\\n    assembly[#assembly + 1] = \"..\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_X;\\\n    assembly[#assembly + 1] = \"...\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_Y;\\\n    assembly[#assembly + 1] = \"....\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_orbital_speed;\\\n    assembly[#assembly + 1] = [[\" . ]];\\\n  end\\\n  return table.concat(anvil.assembly) .. [[\"\"]];\\\n)}\n"],["Anvil Assembly",":name lua madness\n\n; The data string that results from this macro is as follows\n; `|` + `constant` + `color` + `radius` + `coordx` + `coordy` + `orbital_speed`\n; \n; the `|` is to act as a seperator between one node and another\n; the `constant` is to act as a node identifier\n; the `color` is the node color\n; the `radus`, `coord_x`, `coord_y` and `orbital_speed` are diferentiated by\n; one another thanks to an increasing space\n; This means that we're getting the following pattern\n; `.radius` + `..coord_x` + `...coord_y` + `....orbital_speed`\n\n; \n; define type\n; define properties\n; define node (name)\n\n{lua(\\\n  anvil = {};\\\n  anvil.node = {};\\\n)}\n\n{lua(\\\n  \\\n  function add_property(property, value)\\\n    \\\n  end\\\n)}\n\n#create_node(a, b, c, d, e, f, g) {lua(return;)}\n"],["Anvil Macros 2","; name of the package\n#package(name) AutoNode:{name}\n#garbage_requested {package(garbage_requested)}\n\n; This acts like an identifier for this script\n; Every global variable used in this script will\n; Contain this identifier so that it doesn't clash\n; with other scripts\n#identifier \"Anvil_Node\"\n\n#hider \"<size=0>\" . \"hide\" . {identifier}\n\n#toggle \"toggle\" . {identifier}\n#toggle_get global.bool.get({toggle})\n#toggle_compare(value) global.bool.set({toggle}, {toggle_get} == {value})\n"],["Data Setup",":import Anvil Macros\n:name {package(Data Setup)}\n\n\n:local int increment\n\n; get_data is essential so that it our AI\n; doesn't need to perform this search for every node\n; \n; We use the spacing inside of data_string to\n; Make our search as precise as possible\n; We use spaces because we convert string values\n; to double values for 4 of our data sets\n\n#get_data(target, end) sub(\\\n  sub(gsg ({status}), index(gsg({status}), \"|\" . increment, 0), 9999), \\\n  index(sub(gsg({status}), index(gsg({status}), \"|\" . increment, 0), 9999), {target}, 1), \\\n  index(sub(gsg({status}), index(gsg({status}), \"|\" . increment, 0), 9999), {end}, 1) - \\\n  index(sub(gsg({status}), index(gsg({status}), \"|\" . increment, 0), 9999), {target}, 1)\\\n)\n\nexecutesync(\"TE2.2:stop\")\nloop:\nincrement = increment + 1\n\ngss(\"color\" . increment . {identifier}, {get_data(\"#\", \" \")})\ngvs(\"vector\" . increment . {identifier}, vec(\\\n  s2d({get_data(\"  \", \"   \")}, 0.0), \\\n  s2d({get_data(\"   \", \"    \")}, 0.0)\\\n))\ngds(\"radius\" . increment . {identifier}, s2d({get_data(\" \", \"  \")}, 0.0))\ngds(\"orbit_speed\" . increment . {identifier}, s2d({get_data(\"    \", \"|\")}, 0.0))\n\ngotoif(loop, contains (gsg({status}), \"|\" . (increment + 1)))\n; Repete loop until we reach increment 29\n; This gotoif() is a no-op setup, and we're manually stopping the script\n; Anyway\nexecutesync(\"TE2.2:start\")\nwait(0.0)\n"],["init",":import Anvil Constants\n:name {package(init)}\n\n:global double selector\n\nkey.x()\n\n; This script is reliant on turbo\n; The way turbo works is to make it so that\n; when scripts reach the final line\n; instead of exiting said script, it will continuously\n; execute the last command\n\nexecutesync(if(gbg(\"toggle\" . {identifier}),\"TE2.2:stop\", \"TE2.2:start\"))\ngotoif(quit, gbg(\"toggle\" . {identifier}))\n\nselector = selector\n\n; Begin the hiding block\ngss({status}, {data_string})\n\n; Call Data Setup if we're new\n; otherwise, call garbage\nexecutesync(if(\\\n  contains(gsg(\"color29\" . {identifier}), \"#\"), \\\n  \"{garbage_requested}\", \\\n  \"{package(Data Setup)}\"\\\n))\n\n; Data Setup only has 1 purpose\n; This means we can stop the script\n; Even if we aren't new\nstop(\"{package(Data Setup)}\")\n\n; Set up the latest global variables\ngds(\"incrementer\" . {identifier}, gdg(\"incrementer\" . {identifier}))\ngbs(\"toggle\" . {identifier}, gbg(\"toggle\" . {identifier}))\ngss({identifier} . \"{garbage_requested}\", \"</size>\")\n\n\n; The scripts have an implemented self-call logic\n; It's easier to call these once, even if we need 2 of each\nexecute(\"{package(Drawer)}\")\nexecutesync(\"{package(Main)}\")\n\nquit:\ngbs(\"toggle\" . {identifier}, false)\n\nend:\nwait (0.0)\n"],["Drawer","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Drawer\n\n:global double selector\n:local vector direction\n\n; This macro concatinates the corresponding variable provided the right name\n; These names are vector, color, radius and orbit_speed\n#variablename(name) \"{name}\" . d2i(selector) . {identifier}\n\n\n#relativecoordonate_x 400.0 + \\\ngdg({variablename(radius)}) * sin(const.pi() * x(gvg({variablename(vector)}))) - (x(direction) % 2.0)\n\n#relativecoordonate_y 225.0 + \\\ngdg({variablename(radius)}) * cos(const.pi() * y(gvg({variablename(vector)}))) - (y(direction) % 2.0)\n\ndirection = if(gbg(\"toggle\" . {identifier}), vec(1.0, 2.0), vec(2.0, 1.0))\ngbs(\"toggle\" . {identifier}, true)\nexecute(if(1.0 == x(direction), \"{package}:Drawer\" . {identifier}, \"{package}:Drawer\"))\nloop:\ncanvas.rect(\\\n  {pos.relative(\\\n    {relativecoordonate_x} / 800.0, \\\n    {relativecoordonate_y} / 450.0, \\\n    0.5, \\\n    0.5\\\n  )}, \\\n  {pos.relative(x(direction), y(direction), 0.0, 0.0)}, \\\n  gsg({variablename(color)})\\\n)\ngotoif(loop, gbg(\"toggle\" . {identifier}))\n\n; Space for convenience\n"],["Main","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Main\n\n:local string name\n\nexecute(if(contains(impulse(), \"init\"), \"{package}:Main\", \"{package}:Anvil Constants\" . {identifier}))\nname = if(contains(impulse(), \"init\"), \"incrementer\" . {identifier}, \"selector\")\nloop:\ngds(name, if(\\\n  contains(name, {identifier}), \\\n  (gdg(name) + 0.01) % 2.0, \\\n  if(gdg(\"incrementer\" . {identifier}) > 0.0, gdg(name), (gdg(name) % 29.0) + 1.0)\\\n))\ngotoif(loop, gbg(\"toggle\" . {identifier}))\n\n; Space for convenience\n"],["Anvil Constants","\n; Space for convenience\n\n:import Anvil Macros\n\n{special(damage, 0.1, 0.1, 0.3, 604800, \"#6042A6\")}\n{special(resistance, 0.6, -0.35, 0.3, -172800, \"#6042A6\")}\n{special(range, -0.6, 0.0, 0.3, -21600, \"#6042A6\")}\n\n{damage(neutral, -0.45, 0.5, 0.15, 28800, \"#808080\")}\n{damage(fire, -0.35, 0.6752613187, 0.16, 32401, \"#FF0000\")}\n{damage(water, -0.25, 0.3311343193, 0.17, 36000, \"#0080FF\")}\n{damage(earth, -0.15, 0.487442106, 0.18, 39601, \"#804000\")}\n{damage(air, -0.05, 0.6809653044, 0.19, 43201, \"#00FFFF\")}\n{damage(nature, 0.05, 0.3381964564, 0.2, 46800, \"#00FF00\")}\n{damage(light, 0.15, 0.4749338031, 0.21, 50401, \"#FFEC19\")}\n{damage(darkness, 0.25, 0.6859552264, 0.22, 54000, \"#8000FF\")}\n{damage(electricity, 0.35, 0.3458969593, 0.23, 57600, \"#CCAA00\")}\n{damage(universal, 0.45, 0.4625244737, 0.24, 61200, \"#000000\")}\n\n{resistance(neutral, 0.45, -0.5, 0.15, -21600, \"#808080\")}\n{resistance(fire, 0.35, -0.6752613187, 0.16, -25200, \"#FF0000\")}\n{resistance(water, 0.25, -0.3311343193, 0.17, -28799, \"#0080FF\")}\n{resistance(earth, 0.15, -0.487442106, 0.18, -32400, \"#804000\")}\n{resistance(air, 0.05, -0.6809653044, 0.19, -35999, \"#00FFFF\")}\n{resistance(nature, -0.05, -0.3381964564, 0.2, -39600, \"#00FF00\")}\n{resistance(light, -0.15, -0.4749338031, 0.21, -43200, \"#FFEC19\")}\n{resistance(darkness, -0.25, -0.6859552264, 0.22, -46799, \"#8000FF\")}\n{resistance(electricity, -0.35, -0.3458969593, 0.23, -50400, \"#CCAA00\")}\n{resistance(universal, -0.45, -0.4625244737, 0.24, -53999, \"#000000\")}\n\n{special(health, -0.04, -0.7, 0.2, -302400, \"#C74440\")}\n{special(shield, 0.09, -0.5, 0.2, -345600, \"#2D70B3\")}\n{special(resources, -0.7, 0.0, 0.2, -86400, \"#FA7E19\")}\n{special(cooldown, -0.7, -0.3, 0.2, -172800, \"#FA7E19\")}\n{special(xp, 0.0, 0, 0.8, -43200, \"#FA7E19\")}\n{special(townxp, 0.0, 0.0, 0.9, 86400, \"#FA7E19\")}\n\n#data_string {lua(\\\n  anvil.assembly = {};\\\n  for i = 1, #anvil.nodes do\\\n    local selected_anvil = anvil.nodes[i];\\\n    if selected_anvil.id == (selected_anvil.node_type .. \"_\" .. selected_anvil.name) then\\\n      return \"Invalid node \" .. i .. \" has name nil\";\\\n    end\\\n    local assembly = anvil.assembly;\\\n    assembly[#assembly + 1] = [[\"|\" . ]];\\\n    assembly[#assembly + 1] = selected_anvil.node_type;\\\n    assembly[#assembly + 1] = \"_\";\\\n    assembly[#assembly + 1] = selected_anvil.name;\\\n    assembly[#assembly + 1] = [[ . \"]];\\\n    assembly[#assembly + 1] = selected_anvil.color;\\\n    assembly[#assembly + 1] = \".\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_radius;\\\n    assembly[#assembly + 1] = \"..\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_X;\\\n    assembly[#assembly + 1] = \"...\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_Y;\\\n    assembly[#assembly + 1] = \"....\";\\\n    assembly[#assembly + 1] = selected_anvil.coordinate_orbital_speed;\\\n    assembly[#assembly + 1] = [[\" . ]];\\\n  end\\\n  return table.concat(anvil.assembly) .. [[\"\"]];\\\n)}\n{data_string}\"\n; Space for convenience\n"],["Anvil Macros","\n; Space for convenience\n\n; name of the package\n#package AutoNode\n\n#identifier \"Anvil_Node data string\"\n#status \"<size=0>\" . {identifier}\n\n{lua(\\\n  anvil = {}; --[[Root Variable]]\\\n  anvil.nodes = {}; --[[Storage for nodes]]\\\n  anvil.node_names = {}; --[[Storage for node names]]\\\n  anvil.node_types = {}; --[[Keep one of the three node types]]\\\n  anvil.node_coordinates = {}; --[[Storage of Orbit Specific Data]]\\\n  anvil.name_max_size = 0;\\\n  anvil.name_sizes = {};\\\n  anvil.name_sizes.node = 0;\\\n  anvil.name_sizes.node_types = 0;\\\n\\\n  function anvil.add_node(name, coordX, coordY, radius, speed, node_type, node_color)\\\n    local node = {};\\\n    node.id = #anvil.nodes + 1;\\\n    if node.id > 35 then\\\n      return \"Too many nodes: Over the limit while adding \" .. name;\\\n    end\\\n    node.name = name;\\\n    node.color = node_color;\\\n    node.coordinate_X = coordX;\\\n    node.coordinate_Y = coordY;\\\n    node.coordinate_radius = radius;\\\n    node.coordinate_orbital_speed = speed;\\\n    node.node_type = node_type;\\\n    anvil.nodes[node.id] = node;\\\n    anvil.node_names[node_type .. \"_\" .. name] = node;\\\n    anvil.node_coordinates[node_type .. \"_\" .. name] = node;\\\n    if #(node_type .. \"_\" .. name) > anvil.name_max_size then\\\n      anvil.name_max_size = #(node_type .. \"_\" .. name);\\\n    end\\\n    return \":const int \" .. node_type .. \"_\" .. name .. \" \" .. #anvil.nodes;\\\n  end\\\n)}\n\n#add_node(name, coord_x, coord_y, radius, speed, type, color) {lua(\\\n  return anvil.add_node(\\\n    {name},\\\n    {coord_x},\\\n    {coord_y},\\\n    {radius},\\\n    {speed},\\\n    {type},\\\n    {color}\\\n  );\\\n)}\n\n; A node to increase damage of an element\n#damage(name, coord_x, coord_y, radius, speed, color) {add_node(\\\n  \"{name}\",\\\n  {coord_x},\\\n  {coord_y},\\\n  {radius},\\\n  {speed},\\\n  \"damage\",\\\n  {color}\\\n)}\n\n; A node to increase resistance against an element\n#resistance(name, coord_x, coord_y, radius, speed, color) {add_node(\\\n  \"{name}\",\\\n  {coord_x},\\\n  {coord_y},\\\n  {radius},\\\n  {speed},\\\n  \"resistance\",\\\n  {color}\\\n)}\n\n; A node to increase an effect universally\n#special(name, coord_x, coord_y, radius, speed, color) {add_node(\\\n  \"{name}\",\\\n  {coord_x},\\\n  {coord_y},\\\n  {radius},\\\n  {speed},\\\n  \"special\",\\\n  {color}\\\n)}\n\n\n; Space for convenience\n"],["init","\n; Space for convenience\n\n:import Anvil Constants\n:name {package}:init\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:local int increment\n\nkey.x()\n\n#get_data(target, end) sub (\\\n  gsg ({status}), \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {target}, 1), \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {end}, 1) - \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {target}, 1)\\\n)\n\n\nexecutesync (if (gbg (\"checker\" . {identifier}), \"TE2.2:stop\", \"TE2.2:start\"))\ngoto (if (\\\n  gbg (\"checker\" . {identifier}), \\\n  end, \\\n  if (contains (gsg (\"color29\" . {identifier}), \"#\"), skip, continue)\\\n))\n\ncontinue:\ncanvas.clear()\ngss ({status}, {data_string})\n\nexecute (\"{package}:Drawer\")\nexecute (\"{package}:Drawer\")\n\nturbo.cycles.max = max (turbo.cycles.max, turbo.cycles + 5000)\n\nloop:\nincrement = increment + 1\ngss (\"color\" . increment . {identifier}, {get_data(\"#\", \" \")})\ngvs (\"vector\" . increment . {identifier}, vec (\\\n  s2d ({get_data(\"  \", \"   \")}, 0.0), \\\n  s2d ({get_data(\"   \", \"    \")}, 0.0)\\\n))\ngds (\"radius\" . increment . {identifier}, s2d ({get_data(\" \", \"  \")}, 0.0))\ngds (\"orbit_speed\" . increment . {identifier}, s2d ({get_data(\"    \", \"|\")}, 0.0))\ngotoif (loop, contains (gsg ({status}), \"|\" . increment))\n\nskip:\ngss ({status} . {identifier}, \"</size>\")\nexecute (\"{package}:Main\")\ngbs (\"checker\" . {identifier}, gbg (\"checker\" . {identifier}) == false)\n\nend:\nwait (0.0)\n\n; Space for convenience\n"],["Drawer","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Drawer\n\n:global double selector\n:local vector direction\n\ngds (\"incrementer\" . {identifier}, 0.0)\ndirection = if (gbg (\"checker\" . {identifier}), vec (1.0, 2.0), vec(2.0, 1.0))\ngbs (\"checker\" . {identifier}, true)\ncanvas.rect (\\\n  {pos.relative(\\\n    (400.0 / 800.0) + sin (const.pi() * x (gvg (\"vector\" . d2i(selector) . {identifier}))) - (x (direction) % 2.0), \\\n    (225.0 / 450.0) + cos (const.pi() * y (gvg (\"vector\" . d2i(selector) . {identifier}))) - (y (direction) % 2.0), \\\n    0.5, \\\n    0.5\\\n  )}, \\\n  {pos.relative(x(direction), y(direction), 0.0, 0.0)}, \\\n  gsg (\"color\" . selector . {identifier})\\\n)\n\n; Space for convenience\n"],["Main","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Main\n\n:local string name\n\nexecute (if (contains (impulse(), \"init\"), \"{package}:Main\", \"{package}:Anvil Constants\" . {status}))\nname = if (contains (impulse(), \"init\"), \"incrementer\" . {identifier}, \"selector\")\ngds (name, if (\\\n  contains (name, {identifier}), \\\n  (gdg (name) + 0.01) % 2.0, \\\n  if (gdg (\"incrementer\" . {identifier}) > 0.0, gdg (name), (gdg (name) % 29.0) + 1.0)\\\n))\n\n; Space for convenience\n"],["New 4","{lua(\\\n  test = {};\\\n)}\n\n#assign(value) {lua(test[{value}] = 1;)}\n\n{assign(\"test\")}{assign(\"tester\")}"]]}}
```
