# AutoNode

```
{"workspaces":{"Anvil":[["Anvil Constants","\n; Space for convenience\n\n:import Anvil Macros\n\n{special(damage, 0.1, 0.1, 0.3, 604800, \"#6042A6\")}\n{special(resistance, 0.6, -0.35, 0.3, -172800, \"#6042A6\")}\n{special(range, -0.6, 0, 0.3, -21600, \"#6042A6\")}\n\n{damage(neutral, -0.45, 0.5, 0.15, 28800, \"#808080\")}\n{damage(fire, -0.35, 0.6752613187, 0.16, 32401, \"#FF0000\")}\n{damage(water, -0.25, 0.3311343193, 0.17, 36000, \"#0080FF\")}\n{damage(earth, -0.15, 0.487442106, 0.18, 39601, \"#804000\")}\n{damage(air, -0.05, 0.6809653044, 0.19, 43201, \"#00FFFF\")}\n{damage(nature, 0.05, 0.3381964564, 0.2, 46800, \"#00FF00\")}\n{damage(light, 0.15, 0.4749338031, 0.21, 50401, \"#FFEC19\")}\n{damage(darkness, 0.25, 0.6859552264, 0.22, 54000, \"#8000FF\")}\n{damage(electricity, 0.35, 0.3458969593, 0.23, 57600, \"#CCAA00\")}\n{damage(universal, 0.45, 0.4625244737, 0.24, 61200, \"#000000\")}\n\n{resistance(neutral, 0.45, -0.5, 0.15, -21600, \"#808080\")}\n{resistance(fire, 0.35, -0.6752613187, 0.16, -25200, \"#FF0000\")}\n{resistance(water, 0.25, -0.3311343193, 0.17, -28799, \"#0080FF\")}\n{resistance(earth, 0.15, -0.487442106, 0.18, -32400, \"#804000\")}\n{resistance(air, 0.05, -0.6809653044, 0.19, -35999, \"#00FFFF\")}\n{resistance(nature, -0.05, -0.3381964564, 0.2, -39600, \"#00FF00\")}\n{resistance(light, -0.15, -0.4749338031, 0.21, -43200, \"#FFEC19\")}\n{resistance(darkness, -0.25, -0.6859552264, 0.22, -46799, \"#8000FF\")}\n{resistance(electricity, -0.35, -0.3458969593, 0.23, -50400, \"#CCAA00\")}\n{resistance(universal, -0.45, -0.4625244737, 0.24, -53999, \"#000000\")}\n\n{special(health, -0.04, -0.7, 0.2, -302400, \"#C74440\")}\n{special(shield, 0.09, -0.5, 0.2, -345600, \"#2D70B3\")}\n{special(resources, -0.7, 0, 0.2, -86400, \"#FA7E19\")}\n{special(cooldown, -0.7, -0.3, 0.2, -172800, \"#FA7E19\")}\n{special(xp, 0, 0, 0.8, -43200, \"#FA7E19\")}\n{special(townxp, 0, 0, 0.9, 86400, \"#FA7E19\")}\n\n#data_string {lua(\\\n  anvil.assembly = {};\\\n  for i = 1, #anvil.nodes do\\\n    local selected_anvil = anvil.nodes[i];\\\n    if selected_anvil.name == nil then\\\n      return \"Invalid node \" .. i .. \" has name nil\";\\\n    end\\\n    anvil.assembly[#anvil.assembly + 1] = \"|\" .. i .. selected_anvil.node_type .. \"_\" .. selected_anvil.name;\\\n    anvil.assembly[#anvil.assembly] = anvil.assembly[#anvil.assembly] .. selected_anvil.color;\\\n    anvil.assembly[#anvil.assembly] = anvil.assembly[#anvil.assembly] .. \" \" .. selected_anvil.coordinate_radius;\\\n    anvil.assembly[#anvil.assembly] = anvil.assembly[#anvil.assembly] .. \"  \" .. selected_anvil.coordinate_X;\\\n    anvil.assembly[#anvil.assembly] = anvil.assembly[#anvil.assembly] .. \"   \" .. selected_anvil.coordinate_Y;\\\n    anvil.assembly[#anvil.assembly] = anvil.assembly[#anvil.assembly] .. \"    \" .. selected_anvil.coordinate_orbital_speed;\\\n  end\\\n  return [[\"]] .. table.concat(anvil.assembly) .. [[\"]]\\\n)}\n\n; Space for convenience\n"],["Anvil Macros","\n; Space for convenience\n\n; name of the package\n#package AutoNode\n\n#identifier \"Anvil_Node data string\"\n#status \"<size=0>\" . {identifier}\n\n{lua(\\\n  anvil = {}; --[[Root Variable]]\\\n  anvil.nodes = {}; --[[Storage for nodes]]\\\n  anvil.node_names = {}; --[[Storage for node names]]\\\n  anvil.node_types = {}; --[[Keep one of the three node types]]\\\n  anvil.node_coordinates = {}; --[[Storage of Orbit Specific Data]]\\\n  anvil.name_max_size = 0;\\\n  anvil.name_sizes = {};\\\n  anvil.name_sizes.node = 0;\\\n  anvil.name_sizes.node_types = 0;\\\n\\\n  function anvil.add_node(name, coordX, coordY, radius, speed, node_type, node_color)\\\n    local node = {};\\\n    node.id = #anvil.nodes + 1;\\\n    if node.id > 35 then\\\n      return \"Too many nodes: Over the limit while adding \" .. name;\\\n    end\\\n    node.name = name;\\\n    node.color = node_color;\\\n    node.coordinate_X = coordX;\\\n    node.coordinate_Y = coordY;\\\n    node.coordinate_radius = radius;\\\n    node.coordinate_orbital_speed = speed;\\\n    node.node_type = node_type;\\\n    anvil.nodes[node.id] = node;\\\n    anvil.node_names[node_type .. \"_\" .. name] = node;\\\n    anvil.node_coordinates[node_type .. \"_\" .. name] = node;\\\n    if #(node_type .. \"_\" .. name) > anvil.name_max_size then\\\n      anvil.name_max_size = #(node_type .. \"_\" .. name);\\\n    end\\\n    return \":const int \" .. node_type .. \"_\" .. name .. \" \" .. #anvil.nodes;\\\n  end\\\n)}\n\n; A node to increase damage of an element\n#damage(name, coordonateX, coordonateY, radius, speed, color) {lua(\\\n  return anvil.add_node(\"{name}\", {coordonateX}, {coordonateY}, {radius}, {speed}, \"damage\", {color})\\\n)}\n\n; A node to increase resistance against an element\n#resistance(name, coordonateX, coordonateY, radius, speed, color) {lua(\\\n  return anvil.add_node(\"{name}\", {coordonateX}, {coordonateY}, {radius}, {speed}, \"resistance\", {color})\\\n)}\n\n; A node to specify\n#special(name, coordonateX, coordonateY, radius, speed, color) {lua(\\\n  return anvil.add_node(\"{name}\", {coordonateX}, {coordonateY}, {radius}, {speed}, \"special\", {color})\\\n)}\n\n\n; Space for convenience\n"],["init","\n; Space for convenience\n\n:import Anvil Constants\n:name {package}:init\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:local int increment\n\nkey.x()\n\n#get_data(target, end) sub (\\\n  gsg ({status}), \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {target}, 1), \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {end}, 1) - \\\n  index (sub (gsg ({status}), index (gsg ({status}), \"|\" . increment, 0), 9999), {target}, 1)\\\n)\n\n\nexecutesync (if (gbg (\"checker\" . {identifier}), \"TE2.2:stop\", \"TE2.2:start\"))\ngoto (if (\\\n  gbg (\"checker\" . {identifier}), \\\n  end, \\\n  if (contains (gsg (\"color29\" . {identifier}), \"#\"), skip, continue)\\\n))\n\ncontinue:\ncanvas.clear()\ngss ({status}, {data_string})\n\nexecute (\"{package}:Drawer\")\nexecute (\"{package}:Drawer\")\n\nloop:\nturbo.cycles.max = max (turbo.cycles.max, turbo.cycles + 5000)\n\nincrement = increment + 1\ngss (\"color\" . increment . {identifier}, {get_data(\"#\", \" \")})\ngvs (\"vector\" . increment . {identifier}, vec (\\\n  s2d ({get_data(\"  \", \"   \")}, 0.0), \\\n  s2d ({get_data(\"   \", \"    \")}, 0.0)\\\n))\ngds (\"radius\" . increment . {identifier}, s2d ({get_data(\" \", \"  \")}, 0.0))\ngds (\"orbit_speed\" . increment . {identifier}, s2d ({get_data(\"    \", \"|\")}, 0.0))\ngotoif (loop, contains (gsg ({status}), \"|\" . increment))\n\nskip:\ngss ({status}, \"</size>\")\nexecute (\"{package}:Main\")\n\nend:\nwait (0.0)\n\n; Space for convenience\n"],["Drawer","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Drawer\n\n:global double selector\n:local vector direction\n\ngds (\"incrementer\" . {identifier}, 0.0)\ndirection = if (gbg (\"checker\" . {identifier}), vec (1.0, 2.0), vec(2.0, 1.0))\ngbs (\"checker\" . {identifier}, true)\ncanvas.rect (\\\n  {pos.relative(\\\n    (400.0 / 800.0) + sin (const.pi() * x (gvg (\"vector\" . d2i(selector) . {identifier}))) - (x (direction) % 2.0), \\\n    (225.0 / 450.0) + cos (const.pi() * y (gvg (\"vector\" . d2i(selector) . {identifier}))) - (y (direction) % 2.0), \\\n    0.5, \\\n    0.5\\\n  )}, \\\n  {pos.relative(x(direction), y(direction), 0.0, 0.0)}, \\\n  gsg (\"color\" . selector . {identifier})\\\n)\n\n; Space for convenience\n"],["Main","\n; Space for convenience\n\n:import Anvil Macros\n:name {package}:Main\n\n:local string name\n\nexecute (if (contains (impulse(), \"init\"), \"{package}:Main\", \"{package}:Anvil Constants\" . {status}))\nname = if (contains (impulse(), \"init\"), \"incrementer\" . {identifier}, \"selector\")\ngds (name, if (\\\n  contains (name, {identifier}), \\\n  (gdg (name) + 0.01) % 2.0, \\\n  if (gdg (\"incrementer\" . {identifier}) > 0.0, gdg (name), (gdg (name) % 29.0) + 1.0)\\\n))\n\n; Space for convenience\n"]]}}
```