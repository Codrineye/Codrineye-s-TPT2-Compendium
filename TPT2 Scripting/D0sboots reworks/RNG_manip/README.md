# RNG_manip

This is a refactored version of rng_manip by d0sboots that translates to the same code.

Source Export
```
{"workspaces":{"RNG_manip":[["RNG_manip hdr","; This is the header of the RNG manipulation library\n; It's purpose is to explain what you're looking at and what the library implements\n;\n; This library exists to do RNG manipulation in TPT2.\n; If you don't know what RNG manipulation is, you can find plenty of info on the web.\n; Also, this library is probably not for you.\n\n{lua(\\\n  --[[Core RNG table that everything is built ontop of]]\\\n  RNG = {};\\\n  \\\n  --[[Table that holds all our usable data]]\\\n  RNG.code_cache = nil;\\\n  \\\n  --[[Return the appropiate macro body]]\\\n  function RNG.macro_body(id, arg1, arg2) end\\\n)}\n\n; There are three sets of macros defined in this library\n; The first is the 3-part rng_init sequence\n#rng.line_1 {lua(return RNG.macro_body(\"line_1\"))}\n#rng.line_2 {lua(return RNG.macro_body(\"line_2\"))}\n#rng.line_3(label) {lua(return RNG.macro_body(\"line_3\", [[{label}]]))}\n;\n; To use these, place this sequence *immediately* before the event you want to manipulate\n; {rng.line_1}\n; {rng.line_2}\n; {rng.line_3(continue)}\n; continue:\n;\n; The last one makes a label to `goto` to when it is done.\n; You can define the lable on the next line if you just want it to continue there.\n; You can also use more complicated conditional expressions if you want\n; \n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n; \n; If you need to re-initialize the state, jump to label `rng.line_2`.\n;\n; To simulate future rolls of the rng, use this macro:\n#rng.next {lua(return RNG.macro_body(\"next\"))}\n; You will need to call this (at least) once before calling rng.get_int.\n; Every call to {rng.next} should correspond to one call to the RNG (generally via rnd()),\n; except for the last one(s) which you want to save for the actual in-game event(s)\n; that are rolling the RNG.\n\n\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng.get_int {lua(return RNG.macro_body(\"get_int\"))}\n#rng.get_double {lua(return RNG.macro_body(\"get_double\"))}\n; Don't forget that you need one call to {rng.next} before the result is valid.\n; {rng.get_int} could be negative if the high bit is set.\n; {rng.get_double} avoids this issue by using a double,\n; so the result will always be a non-negative integer.\n\n; Return a float value between 0.0 and 1.0 (inclusive).\n#rng.get_uniform {lua(return RNG.macro_body(\"get_uniform\"))}\n; This performs the same function as UnityEngine.Random.value. Although the number returned\n; is a double because of TPT2 type limitations, it only has single-precision values.\n; If you need to do math that accurately mimics single-precision game math, keep that in\n; mind (you may need to use the vector type to keep the behavior consistent.)\n\n; This simpulates the same behaviour as the rnd() function.\n#rng.get_range(min, max) {lua(return RNG.macro_body(\"get_range\", [[{min}]], [[{max}]]))}\n; The range is inclusive, so we can also return the values in `min` and in `max`.\n; Just like with {rng.get_int}, {rng.next} needs to be called before this is valid."],["RNG_manip lib","; Import the header file to define the functions and get the macros\n:import RNG_manip hdr\n\n; This is the functional RNG manip library\n; \n; Every lua variable and function in the global field is part of the global table called RNG\n\n#rng_varType local\n; Change this to \"global\" for debugging\n\n; The 128-bit state of the rng, stored as 128 \"1\"s and \"0\"s.\n; It is exactly as pathetic as it sounds, but it is actually most efficient to compute\n; xor and bitshifting with numbers in string form, because we can do xor via\n; precomputed tables and bitshifts become (sub)string manipulation.\n; You'd think the same could be done with integers with * and /, but the fact that we only\n; have signed integers makes everything too awful.\n; This is used by {rng.next} to compute the next state, and {rng.get_int} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate\n; multiple rng seeds at once.\n:{rng_varType} string rng_state\n\n; A temporary variable used during int-to-binary conversion.\n; A double is used to avoid issues with the sign bit.\n:{rng_varType} double rng_temp\n\n{lua(\\\n  --[[/*\\\n    * The structure of code is broken up into multiple lua functions, to allow regular comments\\\n    * to explain them. Lua functions are used to construct the code, instead of regular macros,\\\n    * so that we could define our user-visible macros such as {rng.line_1}, {rng.next} etc.\\\n    * at the top without having to give the full implementation; instead, a stub implementation\\\n    * was given and the function is re=implemented at the bottom of the file here. This allows us\\\n    * to use the macros freely in comments, since macros are always expanded, where otherwise we\\\n    * could not comment on them before they were defined.\\\n    * As a side benefit, before the full definition takes effect, they will expand to nothing,\\\n    * which is very fast to evaluate.\\\n    *\\\n    * Time to construct our data, starting off with the lookup tables.\\\n    * The data string is 256 entries, each 23 bytes long:\\\n    * - 8 bytes for the name suffix of \"rng_form\"\\\n    * - 11 bytes for the entire name of the xor table (entries like \"0001xor0110\")\\\n    * - 4 bytes for the value of the xor table\\\n    * All of these are binary strings (the characters \"0\" and \"1\"), except also containing\\\n    * xor in the name for the xor table.\\\n  */]]\\\n  local function create_lookupString()\\\n    local digits = string.byte(\"0\");\\\n    local conv4 = {};\\\n    --[[/*\\\n      * table holding 4 bits at each index\\\n      * \\\n      * build up the table, we've got 4 bits meaning 2 ^ 4, which is 16\\\n      * i = 15 is our 16th iteration\\\n    */]]\\\n    for i = 0, 15 do\\\n      --[[shift & 1 forces the output to be either 0 or 1]]\\\n      local bits = table.pack(\\\n        string.char(((i >> 3) & 1) + digits),\\\n        string.char(((i >> 2) & 1) + digits),\\\n        string.char(((i >> 1) & 1) + digits),\\\n        string.char(((i >> 0) & 1) + digits)\\\n      );\\\n      conv4[i] = table.concat(bits);\\\n    end\\\n    \\\n    local code_table = {};\\\n    --[[/*\\\n      * Using the bits stored in conv4, we create our code table\\\n      *\\\n      * We've got 256 cases to build, because 16 * 16 = 256\\\n      * i = 255 is our 256th iteration\\\n    */]]\\\n    for i = 0, 255 do\\\n      local hi = i >> 4;\\\n      local lo = i & 15;\\\n      \\\n      --[[/*\\\n        * Each iteration adds 3 elements to our code_table\\\n        * First, we construct the byte through concatenating the hi_bit to the lo_bit\\\n        * Next, we do the same but this time we add an xor in the middle\\\n        * Lastly, we xor the high and low bits together.\\\n      */]]\\\n      \\\n      code_table[#code_table + 1] = conv4[hi] .. conv4[lo];\\\n      code_table[#code_table + 1] = conv4[hi] .. \"xor\" .. conv4[lo];\\\n      code_table[#code_table + 1] = conv4[hi ~ lo];\\\n    end\\\n    \\\n    return table.concat(code_table);\\\n  end\\\n  --[[/*\\\n    * Now, we construct the code for {rng.line_1}, {rng.line_2} and {rng.line_3()} macros.\\\n    * The code for these is truly awful, because what should be ~7 lines has been crammed into\\\n    * the minimum possible of 3 lines to save space in user code.\\\n    *\\\n    * At a high level, {rng.line_1} is a local.int.set, {rng.line_2} is a local.string.set\\\n    * and {rng.line_3()} is a goto. Each of these performs multiple different functions, depending\\\n    * on the phase of execution; the act together as a state machine,\\\n    * in order to initialize everything that needs initialization.\\\n    *\\\n    * The first phase is setting the \"rng_from\" and \"xor\" tables.\\\n    * Both tables have 256 entries, and the data for them is encoded together in the code_table\\\n    * defined above. In this phase, we first assign the code_table data to rng_state, and then\\\n    * use entires from it to set rng_from (a double table) and xor (a string table).\\\n    * We use substring to discard the front of rng_state, which is the current working entry,\\\n    * to both load a new entry and also because the length of rng_state also functions\\\n    * as the way to calculate the value we assign to rng_from.\\\n    *\\\n    * The second phase is used to read 4 values from the rng and convert them\\\n    * into individual bits. It lasts for 128 iterations as a result. We use either\\\n    * contains(local.string.get(\"1111xor1111\", \"0\")) (the final table entry) or\\\n    * contains(rng_state, \"xor\") to determine when the first phase is over;\\\n    * the two have slight differences at both start and end of phase 1 which dictate\\\n    * the use of one or the other in specific places.\\\n    *\\\n    * Reading bits is relatively straightforward:\\\n    * A value from rnd() is stored in rng_temp and then multiplied by an appropriate power of 2\\\n    * to check the sign bit. There is an additional quirk where if the value is exactly 0,\\\n    * it indicates a condition where we have to restart the process.\\\n    * This is because, the nature of rnd() is that it adds one to range_max, so there is a hole\\\n    * where both 0 and 2 ^ 32 - 1 map to the same value and we cannot distinguish them.\\\n    * Since this is very rare, we just restart and roll again.\\\n    *\\\n    * Tricks that are used:\\\n    * Since contains(\"\", \"\") is true, contains(\"\", var) is a cheap test to determine\\\n    * if a variable is unset.\\\n    * Also, since if() and boolean logic have the same number of nodes,\\\n    * ternaries are sometimes used to slightly optimize node counts\\\n  */]]\\\n  function RNG.cache_lines(cache)\\\n    --[[/*\\\n      * If we are in phase 1, set rng_from appropriately.\\\n      * If we are in phase 2, get a new rng value and save it to rng_temp.\\\n      * We add back the minimum value to get the raw bits.\\\n      * We're using a double to avoid issues with the sign bit.\\\n      * There is also one wrinkle in that the very first iteration will write 256 to \"rng_from\"\\\n      * (not technically part of the table), but this is harmless as we never access \"rng_from\"\\\n      * directly. We only use rng_from + a byte (eg. 0000 0000).\\\n      * This is the simplest line, because {rng.line_3()} skips it whenever it isn't needed.\\\n    */]]\\\n    cache.line_1 = [==[\\\n      rng.line_1: {rng_varType}.double.set(\\\n        if(\\\n          contains({rng_varType}.string.get(\"1111xor1111\"), \"0\"),\\\n          \"rng_temp\",\\\n          concat(\"rng_from\", sub(rng_state, 0, 8))\\\n        ),\\\n        if(\\\n          contains({rng_varType}.string.get(\"1111xor1111\"), \"0\"),\\\n          i2d(rnd(-2147483648, 2147483646)) + 2147483648.0,\\\n          i2d(256 - len(rng_state) / 23)\\\n        )\\\n      )\\\n    ]==];\\\n    \\\n    --[[/*\\\n      * This line does the bulk of the work, and thus is the most complicated.\\\n      * It gets called a total of 641 times:\\\n      * 513 times in phase 1 (twice per value and one for initial init)\\\n      * and 128 times in phase 2.\\\n      *\\\n      * In phase 1, the sequence is as follows:\\\n      * first, {rng.line_1} is called to set rng_from, and then this line sets the xor value\\\n      * After the xor value is set, this line is looped again to shorten rng_state\\\n      * so we can access the next entry.\\\n      *\\\n      * In phase 2, the size of rng_state is multiplied by a power of 2 in order to determine\\\n      * which bit to select. Since 2 ^ 31 doesn't fit in an integer and the arithmetic.int()\\\n      * function throws an exception instead of wrapping it to negative, that value is dealt with\\\n      * as a special case.\\\n      * Several extra quirks:\\\n      * If rng_temp is 0, we reset state because of the ambiguity mentioned above.\\\n      * This also covers the case where we're doing the final loop of phase 1,\\\n      * as rng_temp is 0 by default.\\\n      * rng_temp is also reset when the state is of length 128 (meaning we are calling back\\\n      * into this code after prior initialization, to get a new set of random numbers).\\\n    */]]\\\n    cache.line_2 = [==[\\\n      rng.line_2: {rng_varType}.string.set(\\\n        if(\\\n          contains(\"\", rng_state),\\\n          \"rng_state\",\\\n          if(\\\n            contains({rng_varType}.string.get(\"1111xor1111\"), \"0\"),\\\n            \"rng_state\",\\\n            if(\\\n              contains(\"\", {rng_varType}.string.get(sub(rng_state, 8, 11))),\\\n              sub(rng_state, 8, 11),\\\n              \"rng_state\"\\\n            )\\\n          )\\\n        ),\\\n        if(\\\n          contains({rng_varType}.string.get(\"1111xor1111\"), \"0\"),\\\n          if(\\\n            rng_temp == 0.0 || len(rng_state) >= 128,\\\n            \"\",\\\n            concat(\\\n              rng_state,\\\n              if(\\\n                rng_temp * (2.0 ^ i2d(len(rng_state) % 32)) % (2.0 ^ 32.0) >= 2.0 ^ 31.0,\\\n                \"1\",\\\n                \"0\"\\\n              )\\\n            )\\\n          ),\\\n          if(\\\n            contains(\"\", {rng_varType}.string.get(sub(rng_state, 8, 11))),\\\n            if(\\\n              contains(\"\", rng_state),\\\n              \"CODE_TABLE\",\\\n              sub(rng_state, 19, 4)\\\n            ),\\\n            sub(rng_state, 23, 999999)\\\n          )\\\n        )\\\n      )\\\n    ]==];\\\n    do\\\n      local code_table = create_lookupString();\\\n      cache.line_2 = cache.line_2:gsub(\"CODE_TABLE\", code_table);\\\n    end\\\n    --[[/*\\\n      * Continue the loop at the appropiate line.\\\n      * Here we check if we're in phase 1 through contains(rng_state, \"xor\").\\\n      * This is important because we only enter phase 2 when rng_state is empty.\\\n      *\\\n      * In phase 1, we jump to {rng.line_1} when the table values need to be set,\\\n      * otherwise we skip straight to line 2 to advance to the next table entry.\\\n      * (This also works at the end of the phase.)\\\n      *\\\n      * In phase 2, we jump to the first line only when we need a new rng_entry,\\\n      * which is every 32 bits. Otherwise, we loop to line 2.\\\n      * The exit condition is accessed when we've filled all 128 bits.\\\n      * This exit jump point is marked as EXTERNAL_LABEL, which gets replaced\\\n      * with the actual label in rng_code().\\\n    */]]\\\n    cache.line_3 = [[\\\n      goto(if(\\\n        contains(rng_state, \"xor\"),\\\n        if(\\\n          contains(\"\", {rng_varType}.string.get(sub(rng_state, 8, 11))),\\\n          rng.line_1,\\\n          rng.line_2\\\n        ),\\\n        if(\\\n          len(rng_state) % 32 != 0,\\\n          rng.line_2,\\\n          if(len(rng_state) != 128, rng.line_1, EXTERNAL_LABEL)\\\n        )\\\n      ))\\\n    ]];\\\n    \\\n    --[[Now, we remove all spaces from the end result]]\\\n    for i = 1, 3 do\\\n      local name = \"line_\" .. i;\\\n      cache[name] = cache[name]:gsub(\" +\", \"\");\\\n    end\\\n  end\\\n)}\n\n; All functions defined previously are in the global field,\n; so ending the lua macro doesn't lose anything of importance\n; \n; The reason I'm separating these 2 macros is because the following functions\n; form actions dynamically, not statically like seen above\n:import Editor_actions lib\n; Import Editor_actions lib to form parsable code through lua macros with more ease\n\n{lua(\\\n  --[[/*\\\n    * Control variable from Editor_actions lib\\\n    * false means nothing happens\\\n    * true means we can pass in an to Editor.assemble_error() and it throw an error\\\n    * that's a formatted version of the action\\\n  */]]\\\n  Editor.format_error_message = false;\\\n  \\\n  local rng_varType = \"{rng_varType}\";\\\n  \\\n  --[[Shortened version to perform double to int conversion]]\\\n  local function d2i(input)\\\n    return Editor_convertDoubleToInt(input);\\\n  end\\\n  \\\n  --[[/*\\\n    * Now that we've finished setting up, we can get back to our functions\\\n    *\\\n    * Construct the code for {rng.get_int}.\\\n    * Since rng_from has an 8-bit lookup table, we can convert binary strings to numbers\\\n    * by looking up just 4 substrings and multiplying by 256 to shift them\\\n    * into the appropriate place. The upper bit may overflow into the sign bit,\\\n    * but that's what we want in this case.\\\n    *\\\n    * {rng.get_uniform} has a bit more to it, but also doesn't use as many bits from rng_state.\\\n    * We use a vector type, which is a pair of single-precision numbers, to get accurate\\\n    * single-precision rounding for the calculation to mirror what Unity does.\\\n  */]]\\\n  function RNG.cache_get_int(cache)\\\n    local rng_from = [[\"rng_from\"]];\\\n    local rng_state = \"rng_state\";\\\n    \\\n    local bytes = {};\\\n    for offset = 96, 120, 8 do\\\n      local name_append = Editor_sub(rng_state, offset, 8);\\\n      local name = Editor_concat(rng_from, name_append);\\\n      bytes[#bytes + 1] = Editor_getVar(rng_varType, \"double\", name);\\\n    end\\\n    \\\n    cache.get_int = bytes[2];\\\n    cache.get_double = bytes[1];\\\n    cache.get_uniform = \"\";\\\n    do\\\n      local name_append = Editor_sub(rng_state, 105, 7);\\\n      local name = Editor_concat([[\"rng_from0\"]], name_append);\\\n      cache.get_uniform = Editor_getVar(rng_varType, \"double\", name);\\\n    end\\\n    for i = 2, #bytes do\\\n      if i ~= 2 then\\\n        cache.get_int = Editor_math(cache.get_int, \"*\", 256.0);\\\n        cache.get_int = Editor_math(cache.get_int, \"+\", bytes[i]);\\\n        \\\n        cache.get_uniform = Editor_math(cache.get_uniform, \"*\", 256.0);\\\n        cache.get_uniform = Editor_math(cache.get_uniform, \"+\", bytes[i]);\\\n        if i < #bytes then\\\n          cache.get_int = Editor_encase_value(cache.get_int);\\\n          cache.get_uniform = Editor_encase_value(cache.get_uniform);\\\n        end\\\n      end\\\n      cache.get_double = Editor_math(cache.get_double, \"*\", 256.0);\\\n      cache.get_double = Editor_math(cache.get_double, \"+\", bytes[i]);\\\n      cache.get_double = Editor_encase_value(cache.get_double);\\\n    end\\\n    cache.get_int = d2i(cache.get_int);\\\n    \\\n    do\\\n      local first_int = d2i(bytes[1]);\\\n      first_int = Editor_math(first_int, \"*\", 16777216);\\\n      cache.get_int = Editor_math(first_int, \"+\", cache.get_int);\\\n    end\\\n    cache.get_int = Editor_encase_value(cache.get_int);\\\n    \\\n    cache.get_uniform = Editor_vec(cache.get_uniform, 0.0);\\\n    do\\\n      local mult = Editor_vec(\"1.192093e-7\", 0.0);\\\n      cache.get_uniform = Editor_math(cache.get_uniform, \"*\", mult)\\\n    end\\\n    cache.get_uniform = Editor_vector_xCoord(cache.get_uniform)\\\n  end\\\n  \\\n  do\\\n    --[[This is an example of the xorshift128 function]]\\\n    local state = {};\\\n    --[[/*\\\n      * Our state is a table holding 4 values state[0], state[1], state[2] and state[3];\\\n      * Lua still lets us index tables by 0, so don't let this indexing by 0 confuse you.\\\n      *\\\n      * state reprezents a 128 bit register holding 4 32-bit unsigned integers\\\n      *\\\n      * We have our xorshift table, that manipulates our state and returns a modified 32-bit int\\\n    */]]\\\n    local function xorshift128()\\\n      local last = state[3];\\\n      --[[We make a copy of the last value in our table and then rearrange our state]]\\\n      state[3] = state[2];\\\n      state[2] = state[1];\\\n      state[1] = state[0];\\\n      \\\n      --[[/*\\\n        * We must perform bit operations on our variable `last`\\\n        *\\\n        * For this I'll create a helper variable `shift` that performs the bitshifts.\\\n      */]]\\\n      \\\n      local shift = last << 11;\\\n      --[[/*\\\n        * To start, we shift last by 11 bits to the left\\\n        * Then, we take an xor between last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = last >> 8;\\\n      --[[/*\\\n        * We then take the new value of last and shift it by 8 bits to the right\\\n        * Then, we take an xor between the new value of last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = state[0] >> 19;\\\n      --[[/*\\\n        * Lastly, we shift our first integer by 19 bits to the right\\\n        * Then, we xor the first integer by our shift\\\n        * And then we xor the last value with our new state[0]\\\n      */]]\\\n      state[0] = state[0] ~ shift;\\\n      state[0] = last ~ state[0];\\\n      \\\n      --[[We end the function by returning the modified bit]]\\\n      return state[0];\\\n    end\\\n    --[[/*\\\n      * As xorshift128 is written in C, it uses little-endian encoding. To show this,\\\n      * here is a binary representation of status if it held the number\\\n      * 2 ^ 128 - 2 ^ 97 - 2 ^ 96 + 2 ^ 32 - 3\\\n      *\\\n      * status = (\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      * );\\\n      * last = status[3];\\\n      * status[3] = status[2];\\\n      * status[2] = status[1];\\\n      * status[1] = status[0];\\\n      * shift = last << 11 = 00000000 00010111 11111111 11111111\\\n      * last = last ~ shift = 10111111 11101000 00000000 00000000\\\n      * shift = last >> 8 = 11101000 00000000 00000000 00000000\\\n      * last = last ~ shift = 01010111 11101000 00000000 00000000\\\n      * shift = status[0] >> 19 = 11111111 11111000 00000000 00000000\\\n      * status[0] = status[0] ~ shift = 01000000 00010000 000000000 00000000\\\n      * status[0] = last ~ status[0] = 00010111 11111000 00000000 00000000\\\n      *\\\n      * status = (\\\n      *   00010111 11111000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      * )\\\n    */]]\\\n  end\\\n  \\\n  --[[/*\\\n    * Construct {rng.next}.\\\n    *\\\n    * This is simply Margsaglia's xorshift128 (defined above), modified for our arhitecture.\\\n    * Most importantly, we must do everything in parallel (all at once).\\\n    * Additionally, our representation is in bit-wise big-endian encoding.\\\n    * example of a 4-bit register holding the number 3:\\\n    * little endian = 1100\\\n    * in big endian = 0011\\\n    *\\\n    * For our implementation, we can remove the return for the function (as that's unneeded)\\\n    * and to fit with our big endian representation, last = status[0] instead of status[3].\\\n    *\\\n    * To do this simultaneously and in parallel, we want to compute:\\\n    * rng_state = sub(rng_state, 32, 96) . (\\\n    *   sub(rng_state, [96...124], 4) ~ sub(rng_state, [96...124] + 19, 4) ; s = s ~ (s >> 19)\\\n    * ~ sub(rng_state, [0...28], 4)   ~ sub(rng_state, [0...28] - 11, 4)   ; \\\n    * ~ sub(rng_state, [0...28] + 8)  ~ sub(rng_state, [0...28] - 3, 4)    ; \\\n    * )\\\n    * rng_state = rng_state[32..128] .. (\\\n    *   rng_state[96..128] ^ rng_state[96..108]      ; s ^ (s >> 19)\\\n    * ^ rng_state[0..32] ^ (rng_state[11..32] << 11) ; t ^ (t << 11)\\\n    * ^ rng_state[0..24] ^ (rng_state[11..32] << 3)  ; t ^ (t << 11) >> 8\\\n    * )\\\n    *\\\n    * We aligh each of those into 4-bit aligned chunks and compute each chunk separately\\\n    * by using the 4x4 bit xor table to compute the xors, concatenating them at the end.\\\n    * each index here is the base, extending +4 (or sometimes fewer) bits.\\\n    *  96 100 104 108 112 116 120 124\\\n    *   -   -   -   -  96  97 101 105\\\n    *   0   4   8  12  16  20  24  28\\\n    *  11  15  19  23  27  31   -   -\\\n    *   -   -   0   4   8  12  16  20\\\n    *   -   -  11  15  19  23  27  31\\\n  */]]\\\n  local function test()\\\n    local state = {};\\\n    state[1] = Editor_sub(\"rng_state\", 32, 96);\\\n    --[==[Performs state[3], state[2], state[1] = state[2], state[1], state[0] ]==]\\\n    for i = 0, 32, 4 do\\\n      local term = \"\";\\\n      if i == 32 then\\\n        \\\n      end\\\n    end\\\n  end\\\n  function RNG.cache_next(cache)\\\n    --[[/*\\\n      * To access state[0], we do sub(rng_state, [0 - 27], 4);\\\n      * To access state[3], we do sub(rng_state, [96-124], 4);\\\n      *\\\n      * Given how Editor_actions lib works, we can work backwards, so the logic flow\\\n      * can mimic that seen in the \\\n      * This requires explanation through example, so here are some formatting rules:\\\n      * a bit is 1 or 0, a byte is 8 bits. 2 ^ 8 - 1 in bits = 1111 1111\\\n      * I use the separator `|` to separate a byte from another\\\n      * 2 ^ 16 - 1 is 2 bytes (16 bits) = 1111 1111|1111 1111\\\n      *\\\n      * The biggest restriction is that we only have 4-bit registers to work with, as apposed to\\\n      * the 32 bit registers used in the code. To help with understanding what's going on, I'll\\\n      * show the raw bits of the number 2 ^ 128 - 2 ^ 97 - 2 ^ 96 + 2 ^ 32 - 3 in binary\\\n      * rng_state = (\\\n      *   1111 1111|1111 1111|1111 1111|1111 1101 state[0]\\\n      *   0000 0000|0000 0000|0000 0000|0000 0000 state[1]\\\n      *   0000 0000|0000 0000|0000 0000|0000 0000 state[2]\\\n      *   1111 1111|1111 1111|1111 1111|1111 1101 state[3]\\\n      * )\\\n      *\\\n      * So, passing rng_state to xorshift128 we'd get\\\n      * final = state[0]\\\n      * shift = final << 11 = 1111 1111|1111 1111|1110 1000|0000 0000\\\n      * final = final ~ shift = 0000 0000|0000 0000|0001 0111|1111 1111\\\n      * shift = final >> 8 = 0000 0000|0000 0000|0000 0000|0001 0111\\\n      * final = final ~ shift = 0000 0000|0000 0000|0001 0111|1110 1000\\\n      * shift = state[3] >> 19 = 0000 0000|0000 0000|0001 1111|1111 1111\\\n      * state[3] = state[3] ~ shift = 1111 1111|1111 1111|1110 0000|0000 0010\\\n      * state[3] = final ~ state[3] = 1111 1111|1111 1111|1110 0000|0000 1001\\\n      *\\\n      * Which will get translated to this:\\\n      * var1 = state[0];\\\n      * var2 = var1 << 11;\\\n      * var3 = var1 ~ var2;\\\n      * var4 = var3 >> 8;\\\n      * var5 = state[3];\\\n      * var6 = var5 >> 19;\\\n      * var7 = var5 ~ var6;\\\n      * var8 = var4 ~ var7;\\\n      *\\\n      *\\\n      * To construct a single 4-bit term in the formula, we pass this varargs function the offsets\\\n      * from a column in the table above, and the last value indicates the number of bits for the\\\n      * partial term. Some chunks can be made entirely with 4-bit terms, but others have a partial\\\n      * term made with a smaller number of bits. Thankfully, there's at most 1 of these per chunk.\\\n      * We use a positive value to indicate a term that needs padding on the left, and a negative\\\n      * value to indicate a term that needs padding on the right.\\\n      *\\\n      * The indexing is a little complicated; This example shows how the indices work for args=3.\\\n      *        1    2       3     4    5       6     7    8 9 \\\n      *       lsg( sub() .\"xor\". lsg( sub() .\"xor\". sub() ) ) \\\n    */]]\\\n    \\\n    local function singleTerm(...)\\\n      local input = table.pack(...);\\\n      local args = #input - 1;\\\n      local res = \"\";\\\n      if input[#input] >= 0 then\\\n        res = Editor_sub(\"rng_state\", input[args], input[#input]);\\\n        local xor = \"xor\" .. string.rep(\"0\", 4 - input[#input]);\\\n        res = Editor_concat(Editor_stringify_value(xor), res);\\\n      else\\\n        res = Editor_sub(\"rng_state\", input[args], -input[#input]);\\\n      end\\\n      \\\n      for i = args - 1, 1, -1 do\\\n        local next = Editor_sub(\"rng_state\", input[i], 4);\\\n        \\\n        if i ~= args - 1 then\\\n          local xor = [[\"xor\"]];\\\n          res = Editor_concat(xor, res);\\\n          res = Editor_concat(next, res);\\\n        elseif input[#input] >= 0 then\\\n          res = Editor_concat(next, res);\\\n        else\\\n          local xor = string.rep(\"0\", 4 + input[#input]) .. \"xor\";\\\n          next = Editor_concat(Editor_stringify_value(xor), next);\\\n          res = Editor_concat(res, next);\\\n        end\\\n        res = Editor_getVar(rng_varType, \"string\", res);\\\n      end\\\n      return res;\\\n    end\\\n    \\\n    local result = table.pack(\\\n      singleTerm( 96,  0,     11,               4),\\\n      singleTerm(100,  4,     15,               4),\\\n      singleTerm(104,  8,  0, 19, 11,           4),\\\n      singleTerm(108, 12,  4, 23, 15,           4),\\\n      singleTerm(112, 16,  8, 27, 19, 96,       1),\\\n      singleTerm(116, 20, 12,     23, 97,  31, -1),\\\n      singleTerm(120, 24, 16,     27, 101,      4),\\\n      singleTerm(124, 28, 20,         105, 31, -1)\\\n    );\\\n    cache.next = \"rng_state = sub(rng_state, 32, 96) . \" .. table.concat(result, \" . \");\\\n  end\\\n  \\\n  function RNG.get_range(min, max)\\\n    local min_nr = tonumber(min);\\\n    local max_nr = tonumber(max);\\\n    local range;\\\n    if min_nr and max_nr then\\\n      range = string.format(\"%.1f\", max_nr + 0.0 - min_nr + 1);\\\n    else\\\n      range = string.format([[(i2d(%s) - i2d(%s) + 1.0)]], max, min);\\\n    end\\\n    \\\n    local modulus = Editor_math(RNG.code_cache.get_double, \"%\", range);\\\n    if min_nr then\\\n      if min_nr == 0 then\\\n        return \"d2i(\" .. modulus .. \")\";\\\n      end\\\n      return string.format(\"d2i(%.1f + %s)\", min_nr, modulus);\\\n    end\\\n    return string.format([[d2i(i2d(%s) + %s)]], min, modulus);\\\n  end\\\n  \\\n  --[[/*\\\n    * Return the appropriate code (macro body) given the passed in \"id\".\\\n    * All this does is lookup the precomputed code and return that;\\\n    * If the code hasn't been computed yet, it calls the helper functions that exist\\\n    * specifically to set that up.\\\n    * The one wrinkle is that {rng.line_3()} has a parameter, and that's substituted in here.\\\n  */]]\\\n  function RNG.macro_body(id, arg1, arg2)\\\n    local cache = RNG.code_cache;\\\n    \\\n    if cache == nil then\\\n      RNG.code_cache = {};\\\n      cache = RNG.code_cache;\\\n      RNG.cache_lines(cache);\\\n      RNG.cache_next(cache);\\\n      RNG.cache_get_int(cache);\\\n    end\\\n    if id == \"get_range\" then\\\n      return RNG.get_range(arg1, arg2);\\\n    end\\\n    local res = cache[id];\\\n    if arg1 then\\\n      res = res:gsub(\"EXTERNAL_LABEL\", arg1);\\\n    end\\\n    return res;\\\n  end\\\n)}\n"],["rng_test",":import RNG_manip lib\n:budget_cap 100\n\n:global int predicted_rng\n:global int actual_rng\n\nkey.t()\n\ngoto(rng.line_2)\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_range(0, 1)}\nactual_rng = rnd(0, 1)\n"],["rng_testuniform",":import RNG_manip lib\n:budget_cap 100\n\n:global double predicted_rng\n:global double actual_rng\n\nkey.t()\n\ngoto(rng.line_2)\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_uniform}\nactual_rng = rnd(0.0, 1.0)\n"],["COD.RakStack",":import RNG_manip lib\n:name COD.RakStack\n:budget_cap 200\n\n:global string rak_stacks\n\n:local int rak_index\n\n:local double stacks\n:local double waves\n\n#raw_waves wave() + 1e11 * (era() + infinity() * 1e11)\n\nwakeup()\ngame.newround()\n;\nisTowerTesting()\n\nrak_index = active.index(\"spell.raksCurse\")\n; Terminate the instance if we're not the first running instance\n; or if the blueprint doesn't have raks curse\n;\n; active.index(spell not in blueprint) == 0\ngoto(if(\\\n  contains(rak_stacks, \";\") || rak_index == 0,\\\n  99,\\\n  wait\\\n))\n\nuse_instant:\nuseinstant(rak_index)\nstacks += min(1.0, ceil(cooldown(rak_index)))\n\nwait:\n; Update our shown stacks\nrak_stacks = concat(d2s(stacks), \";\")\nwaves = {raw_waves}\nwaitframe()\n; Terminate the instance if:\n; - we're dead\n; - the user restarted and doesn't have wave restart active\n; - we've reached 5 stacks\n; Otherwise, if raks curse is on cooldown we keep waiting otherwise we jump to line 2\ngoto(if(\\\n  health(false) <= 0.0 || {raw_waves} < waves || contains(rak_stacks, \"5\"),\\\n  end,\\\n  if(cooldown(rak_index) > 0.0, wait, rng.line_2)\\\n))\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\n; Look for the rng value.\n;\n; raks curse has a 99.8% chance to do nothing,\n; 0.1% chance to kill the tower and a 0.1% chance to add a stack\n; This means that we're generating from a pool of 100 / 0.1 = 1000 values\n; Since it's 0-inclusive, we actually have 1000 - 1 values = 999\n; By there being a 1 in 1000 chance that we get a stack, we only use raks curse if\n; the number is smaller than 1. Otherwise, we need to move to the next rng value,\n; for this next value to correlate with the internal rng value, we must also call for rnd()\ngoto(if(\\\n  {rng.get_range(0, 999)} < 1,\\\n  use_instant,\\\n  guess + rnd(0, 0)\\\n))\n\nend:\nrak_stacks = d2s(stacks)"],["New 11","{lua(\\\n  local digits = string.byte(\"0\");\\\n  local conv4 = {};\\\n  --[[/*\\\n    * table holding 4 bits at each index\\\n    *\\\n    * build up the table, we've got 4 bits meaning 2 ^ 4, which is 16\\\n    * i = 15 is our 16th iteration\\\n  */]]\\\n  for i = 0, 15 do\\\n    --[[shift & 1 forces the output to be either 0 or 1]]\\\n    local bits = table.pack(\\\n      string.char(((i >> 3) & 1) + digits),\\\n      string.char(((i >> 2) & 1) + digits),\\\n      string.char(((i >> 1) & 1) + digits),\\\n      string.char(((i >> 0) & 1) + digits)\\\n    );\\\n    conv4[i] = table.concat(bits);\\\n  end\\\n  error(conv4[15 ~ 13])\\\n)}"],["New 9",":import RNG_manip lib\n\n{lua(\\\n  local ans = {};\\\n  \\\n  local bin = {};\\\n  bin.conv_4 = {};\\\n  bin.nibble = {};\\\n  \\\n  local digits = string.byte(\"0\");\\\n  for i = 0, 15 do\\\n    --[[shift & 1 forces the output to be either 0 or 1]]\\\n    local bits = table.pack(\\\n      string.char(((i >> 3) & 1) + digits),\\\n      string.char(((i >> 2) & 1) + digits),\\\n      string.char(((i >> 1) & 1) + digits),\\\n      string.char(((i >> 0) & 1) + digits)\\\n    );\\\n    bin.conv_4[i] = table.concat(bits);\\\n    bin.nibble[bin.conv_4[i]] = i;\\\n  end\\\n  \\\n  local rng_next = RNG.macro_body(\"next\"):gsub(\"local.string.get\", \"get_string\");\\\n  local meta = {};\\\n  for chunk in rng_next:gmatch(\"[^%.]+\") do\\\n    meta[#meta + 1] = {};\\\n    local helper = meta[#meta];\\\n    helper.numbers = {};\\\n    helper.xor = {};\\\n    local numbers = helper.numbers;\\\n    for num in chunk:gmatch(\"%d+\") do\\\n      if num ~= \"000\" then\\\n        numbers[#numbers + 1] = num;\\\n      end\\\n    end\\\n    local xor = helper.xor;\\\n    for add in chunk:gmatch(\"%d*xor%d*\") do\\\n      xor[#xor + 1] = add;\\\n    end\\\n  end\\\n  \\\n  local bits = table.pack(\\\n    \"1111\", \"0000\", \"1011\", \"1011\", \"0100\", \"1001\", \"0001\", \"0010\",\\\n    \"0100\", \"0001\", \"0010\", \"0101\", \"1100\", \"1111\", \"0000\", \"0101\",\\\n    \"1100\", \"1111\", \"0100\", \"1101\", \"0001\", \"1011\", \"0011\", \"0100\",\\\n    \"1100\", \"1111\", \"1100\", \"1000\", \"0000\", \"0011\", \"1110\", \"1010\"\\\n  );\\\n  local str = table.concat(bits)\\\n  local function sub(offset, size)\\\n    return str:sub(offset + 1, offset + size);\\\n  end\\\n  \\\n  local acc = table.pack(\"\\n\");\\\n  for i = 1, #meta do\\\n    local numbers = meta[i].numbers;\\\n    local xor = meta[i].xor;\\\n    local idx = 1;\\\n    local binary = {};\\\n    for j = 1, #numbers, 2 do\\\n      if j ~= 1 then\\\n        binary[#binary + 1] = xor[idx];\\\n        idx = idx + 1;\\\n      end\\\n      binary[#binary + 1] = sub(numbers[j], numbers[j + 1]);\\\n    end\\\n    if #binary == 1 then\\\n      acc[#acc + 1] = table.concat(binary)\\\n      ans[#ans + 1] = acc[#acc];\\\n      acc[#acc + 1] = \"\\n\"\\\n    else\\\n      local operation = binary[#binary];\\\n      for j = #binary - 1, 1, -2 do\\\n        local res = binary[j - 1] .. binary[j] .. operation;\\\n        local hi_bit = bin.nibble[res:sub(1, 4)];\\\n        local lo_bit = bin.nibble[res:sub(8, -1)];\\\n        operation = bin.conv_4[hi_bit ~ lo_bit];\\\n        acc[#acc + 1] = res;\\\n        acc[#acc + 1] = \"=\";\\\n        acc[#acc + 1] = operation;\\\n        acc[#acc + 1] = \"\\n\";\\\n      end\\\n      ans[#ans + 1] = operation;\\\n    end\\\n    acc[#acc + 1] = \"\\n\"\\\n  end\\\n  error(table.concat(acc))\\\n)}\n"],["New 10",":local string rng_state\n\n\nrng_state = sub(rng_state, 32, 96) . local.string.get(concat(\\\n  substring(rng_state, 96, 4),\\\n  concat(\"xor\", local.string.get(concat(\\\n    substring(rng_state, 0, 4),\\\n    concat(\"xor\", substring(rng_state, 11, 4))\\\n  )))\\\n)) . local.string.get(concat(\\\n  substring(rng_state, 100, 4),\\\n  concat(\"xor\", local.string.get(concat(\\\n    substring(rng_state, 4, 4),\\\n    concat(\"xor\", substring(rng_state, 15, 4))\\\n  )))\\\n)) . local.string.get(concat(\\\n  substring(rng_state, 104, 4),\\\n  concat(\"xor\", local.string.get(concat(\\\n    substring(rng_state, 8, 4),\\\n    concat(\"xor\", local.string.get(concat(\\\n      substring(rng_state, 0, 4),\\\n      concat(\"xor\", local.string.get(concat(\\\n        substring(rng_state, 19, 4),\\\n        concat(\"xor\", substring(rng_state, 11, 4))\\\n      )))\\\n    )))\\\n  )))\\\n)) . local.string.get(concat(\\\n  substring(rng_state, 108, 4),\\\n  concat(\"xor\", local.string.get(concat(\\\n    substring(rng_state, 12, 4),\\\n    concat(\"xor\", local.string.get(concat(\\\n      substring(rng_state, 4, 4),\\\n      concat(\"xor\", local.string.get(concat(\\\n        substring(rng_state, 23, 4),\\\n        concat(\"xor\", substring(rng_state, 15, 4))\\\n      )))\\\n    )))\\\n  )))\\\n)) . local.string.get(concat(\\\n    substring(rng_state, 112, 4),\\\n    concat(\"xor\", local.string.get(\\\n      concat(\\\n        substring(rng_state, 16, 4),\\\n        concat(\"xor\", local.string.get(\\\n          concat(\\\n            substring(rng_state, 8, 4),\\\n            concat(\"xor\", local.string.get(\\\n              concat(\\\n                substring(rng_state, 27, 4),\\\n                concat(\"xor\", local.string.get(\\\n                  concat(\\\n                    substring(rng_state, 19, 4),\\\n                    concat(\"xor000\", substring(rng_state, 96, 1))\\\n                  )\\\n                ))\\\n              )\\\n            ))\\\n          )\\\n        ))\\\n      )\\\n    ))\\\n  )) . local.string.get(concat(\\\n    substring(rng_state, 116, 4),\\\n    concat(\"xor\", local.string.get(\\\n      concat(\\\n        substring(rng_state, 20, 4),\\\n        concat(\"xor\", local.string.get(\\\n          concat(\\\n            substring(rng_state, 12, 4),\\\n            concat(\"xor\", local.string.get(\\\n              concat(\\\n                substring(rng_state, 23, 4),\\\n                concat(\"xor\", local.string.get(\\\n                  concat(\\\n                    substring(rng_state, 31, 1),\\\n                    concat(\"000xor\", substring(rng_state, 97, 4))\\\n                  )\\\n                ))\\\n              )\\\n            ))\\\n          )\\\n        ))\\\n      )\\\n    ))\\\n  )) . local.string.get(concat(\\\n    substring(rng_state, 120, 4),\\\n    concat(\"xor\", local.string.get(\\\n      concat(\\\n        substring(rng_state, 24, 4),\\\n        concat(\"xor\", local.string.get(\\\n          concat(\\\n            substring(rng_state, 16, 4),\\\n            concat(\"xor\", local.string.get(\\\n              concat(\\\n                substring(rng_state, 27, 4),\\\n                concat(\"xor\", substring(rng_state, 101, 4))\\\n              )\\\n            ))\\\n          )\\\n        ))\\\n      )\\\n    ))\\\n  )) . local.string.get(concat(\\\n    substring(rng_state, 124, 4),\\\n    concat(\"xor\", local.string.get(concat(\\\n      substring(rng_state, 28, 4),\\\n      concat(\"xor\", local.string.get(concat(\\\n        substring(rng_state, 20, 4),\\\n        concat(\"xor\", local.string.get(concat(\\\n          substring(rng_state, 31, 1),\\\n          concat(\"000xor\", substring(rng_state, 105, 4))\\\n        )))\\\n      )))\\\n    )))\\\n  ))\n"],["New 12","{lua(\\\n  test = \"11110000101110110100100100010010010000010010010111001111000001011100111101001101000110110011010011001111110010000000001111101010\";\\\n  local acc = {};\\\n  for i = 1, 129, 4 do\\\n    if i % 32 ==1 then\\\n      acc[#acc + 1] = \",\\\\\\n\"\\\n    elseif i % 4 == 1 then\\\n      acc[#acc + 1] = \", \";\\\n    end\\\n    acc[#acc + 1] = test:sub(i, i + 3);\\\n  end\\\n  error(table.concat(acc))\\\n)}"]]}}
```