# RNG_manip

This is a refactored version of rng_manip by d0sboots that translates to the same code.

Source Export
```
{"workspaces":{"RNG_manip":[["RNG_manip hdr","; This is the header of the RNG manipulation library\n; It's purpose is to explain what you're looking at and what the library implements\n;\n; This library exists to do RNG manipulation in TPT2.\n; If you don't know what RNG manipulation is, you can find plenty of info on the web.\n; Also, this library is probably not for you.\n\n{lua(\\\n  --[[Core RNG table that everything is built ontop of]]\\\n  RNG = {};\\\n  \\\n  --[[Table that holds all our usable data]]\\\n  RNG.code_cache = nil;\\\n  \\\n  --[[Return the appropiate macro body]]\\\n  function RNG.macro_body(id, arg1, arg2) end\\\n)}\n\n; There are three sets of macros defined in this library\n; The first is the 2-part rng_init sequence\n#rng.line_1 {lua(return RNG.macro_body(\"line_1\"))}\n#rng.line_2(label) {lua(return RNG.macro_body(\"line_2\", [[{label}]]))}\n;\n; To use these, place this sequence *immediately* before the event you want to manipulate\n; {rng.line_1}\n; {rng.line_2(continue)}\n; continue:\n;\n; The last one makes a label to `goto` to when it is done.\n; You can define the lable on the next line if you just want it to continue there.\n; You can also use more complicated conditional expressions if you want\n; \n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n; \n; If you need to re-initialize the state, jump to label `rng.line_1`.\n;\n; To simulate future rolls of the rng, use this macro:\n#rng.next {lua(return RNG.macro_body(\"next\"))}\n; You will need to call this (at least) once before calling rng.get_int.\n; Every call to {rng.next} should correspond to one call to the RNG (generally via rnd()),\n; except for the last one(s) which you want to save for the actual in-game event(s)\n; that are rolling the RNG.\n\n\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng.get_int {lua(return RNG.macro_body(\"get_int\"))}\n#rng.get_double {lua(return RNG.macro_body(\"get_double\"))}\n; Don't forget that you need one call to {rng.next} before the result is valid.\n; {rng.get_int} could be negative if the high bit is set.\n; {rng.get_double} avoids this issue by using a double,\n; so the result will always be a non-negative integer.\n\n; Return a float value between 0.0 and 1.0 (inclusive).\n#rng.get_uniform {lua(return RNG.macro_body(\"get_uniform\"))}\n; This performs the same function as UnityEngine.Random.value. Although the number returned\n; is a double because of TPT2 type limitations, it only has single-precision values.\n; If you need to do math that accurately mimics single-precision game math, keep that in\n; mind (you may need to use the vector type to keep the behavior consistent.)\n\n; This simulates the same behaviour as the rnd() function.\n#rng.get_range.int(min, max) {lua(return RNG.macro_body(\"get_range.int\", [[{min}]], [[{max}]]))}\n; The range is inclusive, so we can also return the values in `min` and in `max`.\n; Just like with {rng.get_int}, {rng.next} needs to be called before this is valid.\n\n; This simulates the same behaviour as the rnd() function for double values\n#rng.get_range.double(min, max) {lua(\\\n  return RNG.macro_body(\"get_range.double\", [[{min}]], [[{max}]]);\\\n)}\n\n; This simulates internal UnityEngine.Random$$Range() calls used for more complex things\n#rng.get_range.float(min, max) {lua(\\\n  return RNG.macro_body(\"get_range.float\", [[{min}]], [[{max}]]);\\\n)}\n"],["RNG_manip lib","; Import the header file to define the functions and get the macros\n:import RNG_manip hdr\n\n; This is the functional RNG manip library\n; \n; Every lua variable and function in the global field is part of the global table called RNG\n\n#rng_varType local\n; Change this to \"global\" for debugging\n\n; The 128-bit state of the rng, stored as 128 \"1\"s and \"0\"s.\n; It is exactly as pathetic as it sounds, but it is actually most efficient to compute\n; xor and bitshifting with numbers in string form, because we can do xor via\n; precomputed tables and bitshifts become (sub)string manipulation.\n; You'd think the same could be done with integers with * and /, but the fact that we only\n; have signed integers makes everything too awful.\n; This is used by {rng.next} to compute the next state, and {rng.get_int} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate\n; multiple rng seeds at once.\n:{rng_varType} string rng_state\n\n{lua(\\\n  --[[/*\\\n    * The structure of code is broken up into multiple lua functions, to allow regular comments\\\n    * to explain them. Lua functions are used to construct the code, instead of regular macros,\\\n    * so that we could define our user-visible macros such as {rng.line_1}, {rng.next} etc.\\\n    * at the top without having to give the full implementation; instead, a stub implementation\\\n    * was given and the function is re=implemented at the bottom of the file here. This allows us\\\n    * to use the macros freely in comments, since macros are always expanded, where otherwise we\\\n    * could not comment on them before they were defined.\\\n    * As a side benefit, before the full definition takes effect, they will expand to nothing,\\\n    * which is very fast to evaluate.\\\n    *\\\n    * This constructs the code for the {rng.line_1} and {rng.line_2()} macros.\\\n    * At a high level, {rng.line_1} is a local.string.set, and {rng.line_2()} is a goto.\\\n    *\\\n    * Setting the state is relatively straightfowrard: A value from rnd() is just converted to\\\n    * a string and padded. We can easily do this 4 times in 1 expression.\\\n    */]]\\\n  function RNG.cache_lines(cache)\\\n    cache.line_1 = [[\\\n      rng.line_1: rng_state =\\\n        sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"OFFSET\", 0, 11) .\\\n        sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"OFFSET\", 0, 11) .\\\n        sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"OFFSET\", 0, 11) .\\\n        sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"OFFSET\", 0, 11)\\\n    ]];\\\n    cache.line_1 = cache.line_1:gsub(\"^ +\", \"\"):gsub(\"OFFSET\", \"          \");\\\n    --[[/*\\\n      * There is an additional quirt here where, if the value is exactly 0, it indicates\\\n      * a condition where we restart the process. This is because the nature of rnd() is that\\\n      * it adds one to range_max, so there is a hole where both 0 and 2 ^ 32 - 1\\\n      * map to the same value and we cannot distinguish them. Since this is very rare, we just\\\n      * restart in this case and roll again. This is the purpose of the second line\\\n      */]]\\\n    cache.line_2 = [[goto(if(contains(rng_state, \"0          \"), rng.line_1, EXTERNAL_LABEL))]];\\\n  end\\\n)}\n\n{lua(\\\n  --[[/*\\\n    * Construct the {rng.get_int} code. This is simply the last number in the state.\\\n    *\\\n    * Internally, get_int() and get_double() are functions so that we can use them\\\n    * in the implementation of {rng.next}. The pos will always be either 33 or 0\\\n    * to select either `last` or `shift`.\\\n    *\\\n    * {rng.get_uniform} has a bit more to it, but also only uses 23 bits from rng_state.\\\n    * We use the vector type, is is a pair of single-precision numbers, to get accurate\\\n    * single-precision rounding for the calculation to mirror what Unity does\\\n    */]]\\\n  function RNG.cache_get_int(cache)\\\n    cache.get_int = function(pos)\\\n      return string.format(\"s2i(sub(rng_state, %s, 11), 0)\", pos);\\\n    end\\\n    cache.get_double = function(pos)\\\n      return string.format(\"(i2d(%s %%^ -2147483648) + 2147483648.0)\", cache.get_int(pos));\\\n    end\\\n    cache.get_uniform_vec = string.format(\\\n      \"vec(i2d(%s %%& 8388607), 0.0) * vec(1.192093e-7, 0.)\",\\\n      cache.get_int(33)\\\n    );\\\n    cache.get_uniform = \"x(\" .. cache.get_uniform_vec .. \")\";\\\n  end\\\n)}\n\n{lua(\\\n  do\\\n    --[[This is an example of the xorshift128 function]]\\\n    local state = {};\\\n    --[[/*\\\n      * Our state is a table holding 4 values state[0], state[1], state[2] and state[3];\\\n      * Lua still lets us index tables by 0, so don't let this indexing by 0 confuse you.\\\n      *\\\n      * state reprezents a 128 bit register holding 4 32-bit unsigned integers\\\n      *\\\n      * We have our xorshift table, that manipulates our state and returns a modified 32-bit int\\\n    */]]\\\n    local function xorshift128()\\\n      local last = state[3];\\\n      --[[We make a copy of the last value in our table and then rearrange our state]]\\\n      state[3] = state[2];\\\n      state[2] = state[1];\\\n      state[1] = state[0];\\\n      \\\n      --[[/*\\\n        * We must perform bit operations on our variable `last`\\\n        *\\\n        * For this I'll create a helper variable `shift` that performs the bitshifts.\\\n      */]]\\\n      \\\n      local shift = last << 11;\\\n      --[[/*\\\n        * To start, we shift last by 11 bits to the left\\\n        * Then, we take an xor between last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = last >> 8;\\\n      --[[/*\\\n        * We then take the new value of last and shift it by 8 bits to the right\\\n        * Then, we take an xor between the new value of last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = state[0] >> 19;\\\n      --[[/*\\\n        * Lastly, we shift our first integer by 19 bits to the right\\\n        * Then, we xor the first integer by our shift\\\n        * And then we xor the last value with our new state[0]\\\n      */]]\\\n      state[0] = state[0] ~ shift;\\\n      state[0] = last ~ state[0];\\\n      \\\n      --[[We end the function by returning the modified bit]]\\\n      return state[0];\\\n    end\\\n    --[[/*\\\n      * As xorshift128 is written in C, it uses little-endian encoding. To show this,\\\n      * here is a binary representation of status if it held the number\\\n      * 2 ^ 128 - 2 ^ 97 - 2 ^ 96 + 2 ^ 32 - 3\\\n      *\\\n      * status = (\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      * );\\\n      * last = status[3];\\\n      * status[3] = status[2];\\\n      * status[2] = status[1];\\\n      * status[1] = status[0];\\\n      * shift = last << 11 = 00000000 00010111 11111111 11111111\\\n      * last = last ~ shift = 10111111 11101000 00000000 00000000\\\n      * shift = last >> 8 = 11101000 00000000 00000000 00000000\\\n      * last = last ~ shift = 01010111 11101000 00000000 00000000\\\n      * shift = status[0] >> 19 = 11111111 11111000 00000000 00000000\\\n      * status[0] = status[0] ~ shift = 01000000 00010000 000000000 00000000\\\n      * status[0] = last ~ status[0] = 00010111 11111000 00000000 00000000\\\n      *\\\n      * status = (\\\n      *   00010111 11111000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      * )\\\n    */]]\\\n  end\\\n  --[[/*\\\n    * Construct {rng.next}.\\\n    *\\\n    * This is simply Margsaglia's xorshift128 (defined above), modified to deal with the fact\\\n    * that we're using a single 128-bit string and doing all the work in parallel.\\\n    * Bear in mind that the number indexing is \"reversed\", i.e state[3] is rng_state[0...11].\\\n    *\\\n    * In generalized, simplified pseudocode, xorshift128 is:\\\n    * x[3]..x[2]..x[1]..x[0] = rng_state;\\\n    * s = x[0];\\\n    * t = x[3];\\\n    * t ^= t << 11;\\\n    * t ^= t >> 8;\\\n    * s ^= s >> 19;\\\n    * rng_state = x[2]..x[1]..x[0]..t ^ s;\\\n    *\\\n    *\\\n    * To do this simultaneously and in parallel, we want to compute:\\\n    * rng_state = rng_state[11..44] .. (\\\n    *   x[0] ^ (x[0] >> 19)                     ; s ^ (s >> 19)\\\n    * ^ x[3] ^ (x[3] << 11)                     ; t ^ (t << 11)\\\n    * ^ ((x[3] >> 8) ^ (x[3] << 3)) & 0xFFFFFF  ; t ^ (t << 11) >> 8\\\n    * )\\\n    *\\\n    * Left-shifts can be accomplished by multiplying by a constant. Right-shifts are trickier:\\\n    * We can divide by a power of twu, but negative values will copy the sign bit\\\n    * and round to zero, messing everything up. Instead, we use get_double to\\\n    * operate on an unsigned version, and floor the result\\\n    */]]\\\n  --[[\\\n    state = sub(state, 11, 33) . ;\\\n  ]]\\\n  function RNG.cache_next(cache)\\\n    cache.next = string.format(\\\n      \"rng_state = sub(rng_state, 11, 33) . sub(\\\n        %s %%^ d2i(floor(%s / 524288.0)) %%^\\\n        %s %%^ %s * 2048 %%^\\\n        d2i(floor(%s / 256.0)) %%^ (%s * 8) %%& 16777215 . '          ', 0, 11)\",\\\n      cache.get_int(33), cache.get_double(33),\\\n      cache.get_int(0), cache.get_int(0),\\\n      cache.get_double(0), cache.get_int(0)\\\n    ):gsub(\"^ +\", \"\");\\\n  end\\\n)}\n\n\n; All functions defined previously are in the global field,\n; so ending the lua macro doesn't lose anything of importance\n; \n; The reason I'm separating these 2 macros is because the following functions\n; form actions dynamically, not statically like seen above\n:import Editor_actions lib\n; Import Editor_actions lib to form parsable code through lua macros with more ease\n\n{lua(\\\n  function RNG.get_range(tag, min, max)\\\n    if tag ~= \"int\" and tag ~= \"double\" and tag ~= \"float\" then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nUnrecognised get_range tag encountered!\",\\\n        \"\\nExpected tags are 'int', 'double' and 'float', but got \", tag\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local min_num = tonumber(min);\\\n    local max_num = tonumber(max);\\\n    \\\n    local range;\\\n    if tag == \"double\" then\\\n      if min_num and max_num then\\\n        range = math.max(min_num, max_num) - min_num;\\\n      else\\\n        range = Editor_max(min, max);\\\n        range = Editor_math(range, \"-\", min);\\\n      end\\\n      range = Editor_encase_value(range);\\\n      range = Editor_math(RNG.code_cache.get_uniform, \"*\", range);\\\n      if not min_num or min_num ~= 0 then\\\n        range = Editor_math(range, \"-\", min);\\\n      end\\\n      return range;\\\n    \\\n    elseif tag == \"float\" then\\\n      local uniform = RNG.code_cache.get_uniform_vec;\\\n      \\\n      if max_val and max_val == 0 then\\\n        range = \"vec(0.0, 0.0)\";\\\n      else\\\n        range = Editor_math(\"vec(1.0, 0.0)\", \"-\", uniform);\\\n        range = Editor_encase_value(range);\\\n        max_val = Editor_vec(max, 0.0);\\\n        range = Editor_math(range, \"*\", max_val);\\\n      end\\\n      \\\n      if not min_val or min_val ~= 0 then\\\n        min_val = Editor_vec(min, 0.0);\\\n        min_val = Editor_math(min_val, \"*\", uniform);\\\n        if range == \"vec(0.0, 0.0)\" then\\\n          range = min_val;\\\n        else\\\n          range = Editor_math(range, \"+\", min_val);\\\n        end\\\n      end\\\n      \\\n      return Editor_vector_xCoord(range);\\\n    \\\n    elseif tag == \"int\" then\\\n      if max_num and min_num then\\\n        local max_nr = max_num + 1;\\\n        min_num = min_num + 0.0;\\\n        range = math.max(max_nr - min_num, min_num - max_nr);\\\n      else\\\n        local left_arg, right_arg;\\\n        \\\n        if max_num then\\\n          local max_nr = max_num + 1;\\\n          left_arg = Editor_math(max_nr, \"-\", min);\\\n          right_arg = Editor_math(min, \"-\", max_nr);\\\n        elseif min_num then\\\n          local min_nr = min_num - 1;\\\n          left_arg = Editor_math(max, \"-\", min_nr);\\\n          right_arg = Editor_math(min_nr, \"-\", max);\\\n          min_num = min_num + 0.0;\\\n        else\\\n          local max_nr = Editor_math(max, \"+\", 1);\\\n          left_arg = Editor_math(max_nr, \"-\", min);\\\n          right_arg = Editor_math(min, \"-\", max_nr);\\\n        end\\\n        \\\n        range = Editor_max(left_arg, right_arg);\\\n        range = Editor_convertIntToDouble(range);\\\n      end\\\n      \\\n      range = Editor_math(RNG.code_cache.get_double(33), \"%\", range);\\\n      \\\n      if max_num and min_num then\\\n        if min_num ~= 0.0 or max_num < min_num then\\\n          range = Editor_math(min_num, min_num < max_num and \"+\" or \"-\", range);\\\n        end\\\n        \\\n        range = Editor_convertDoubleToInt(range);\\\n      else\\\n        local cond = Editor_math(min, \"<\", max);\\\n        local op = Editor_if(cond, [[\"-\"]], [[\"+\"]]);\\\n        \\\n        if min_num then\\\n          range = Editor_primitive_arithmetic(min_num, op, range);\\\n          range = Editor_convertDoubleToInt(range);\\\n        else\\\n          range = Editor_convertDoubleToInt(range);\\\n          range = Editor_primitive_arithmetic(\"int\", min, op, range);\\\n        end\\\n      end\\\n      return range;\\\n    end\\\n    \\\n  end\\\n  \\\n  local get_range_size = string.len(\"get_range.\");\\\n  \\\n  --[[/*\\\n    * Return the appropriate code (macro body) given the passed in \"id\".\\\n    * All this does is lookup the precomputed code and return that;\\\n    * If the code hasn't been computed yet, it calls the helper functions that exist\\\n    * specifically to set that up.\\\n    * The one wrinkle is that {rng.line_2()} has a parameter, and that's substituted in here.\\\n  */]]\\\n  function RNG.macro_body(id, arg1, arg2)\\\n    local cache = RNG.code_cache;\\\n    \\\n    if cache == nil then\\\n      RNG.code_cache = {};\\\n      cache = RNG.code_cache;\\\n      RNG.cache_lines(cache);\\\n      RNG.cache_get_int(cache);\\\n      RNG.cache_next(cache);\\\n    end\\\n    \\\n    if id:sub(1, get_range_size) == \"get_range.\" then\\\n      return RNG.get_range(id:sub(get_range_size + 1), arg1, arg2);\\\n    end\\\n    local res = cache[id];\\\n    if arg1 then\\\n      res = res:gsub(\"EXTERNAL_LABEL\", arg1);\\\n    end\\\n    return res;\\\n  end\\\n)}\n\n{lua(\\\n  Editor.format_error_message = false;\\\n)}\n"],["COD.RakStack",":import RNG_manip lib\n:name COD.RakStack\n:budget_cap 200\n\n:const string rak_stacks \"<size=0>@rm!S\"\n#rak.get global.string.get(rak_stacks)\n#rak.set(value) global.string.set(rak_stacks, {value} . \"</size>\")\n\n:local int rak_index\n\n:local double stacks\n:local double waves\n\n#raw_waves wave() + 1e11 * (era() + infinity() * 1e11)\n\nwakeup()\ngame.newround()\n;\nisTowerTesting()\n\nrak_index = active.index(\"spell.raksCurse\")\n; Terminate the instance if we're not the first running instance\n; or if the blueprint doesn't have raks curse\n;\n; active.index(spell not in blueprint) == 0\ngoto(if(\\\n  contains({rak.get}, \";\") || rak_index == 0,\\\n  99,\\\n  wait\\\n))\n\nuse_instant:\nuseinstant(rak_index)\nstacks += 1.0\n\nwait:\n; Update our shown stacks\n{rak.set(concat(d2s(stacks), \";\"))}\nwaves = {raw_waves}\nwaitframe()\n; Terminate the instance if:\n; - we're dead\n; - the user restarted and doesn't have wave restart active\n; - we've reached 5 stacks\n; Otherwise, if raks curse is on cooldown we keep waiting otherwise we jump to line 2\ngoto(if(\\\n  health(false) <= 0.0 || {raw_waves} < waves || contains({rak.get}, \"5\"),\\\n  end,\\\n  if(cooldown(rak_index) > 0.0, wait, rng.line_1)\\\n))\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\n; Look for the rng value.\n;\n; raks curse has a 99.8% chance to do nothing,\n; 0.1% chance to kill the tower and a 0.1% chance to add a stack\n; This means that we're generating from a pool of 100 / 0.1 = 1000 values\n; Since it's 0-inclusive, we actually have 1000 - 1 values = 999\n; By there being a 1 in 1000 chance that we get a stack, we only use raks curse if\n; the number is smaller than 1. Otherwise, we need to move to the next rng value,\n; for this next value to correlate with the internal rng value, we must also call for rnd()\ngoto(if(\\\n  {rng.get_range.int(0, 999)} < 1,\\\n  use_instant,\\\n  rnd(guess, 0)\\\n))\n\nend:\n{rak.set(d2s(stacks))}"],["rng_test",":import RNG_manip lib\n:budget_cap 100\n;\n:local int predicted_rng\n:local int actual_rng\n\n:local string target\n\n:global int count\n\nkey.t()\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_range.int(0, 2147483646)}\nactual_rng = rnd(0, 2147483646)\n\ncount += 1\ntarget = if(actual_rng == predicted_rng, \"true\", \"false\")\nglobal.int.set(target, global.int.get(target) + 1)\ngotoif(guess, count < 100000)"],["rng_testuniform",":import RNG_manip lib\n:budget_cap 100\n;\n:global bool equal_rng\n;\n:global double predicted_rng\n:global double actual_rng\n\n\nkey.t()\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_uniform}\nactual_rng = rnd(0.0, 1.0)\n\nequal_rng = predicted_rng == actual_rng"],["rng_test double_range",":import RNG_manip lib\n:budget_cap 100\n;\n:global bool equal_rng\n;\n:global double predicted_rng\n:global double actual_rng\n:local double a\n:local double b\n\n\nkey.t()\n\na = 0.0\nb = 10000.0\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_range.double(a, b)}\nactual_rng = rnd(a, b)\n\nequal_rng = predicted_rng == actual_rng\n"],["rng.show calls",":import RNG_manip lib\n:name rng.show calls\n:budget_cap 200\n;\n:local bool c_hit\n:local bool hit\n;\n:global double rolls\n:global double rng_val\n:global double target_val\n;\n:global int frame_difference\n:global int hit_frame\n;\n:local int i\n:local int start_frame\n:local int target\n:local string state_0\n:local string state_1\n\nkey.t()\n\nrng_val = 0.0\ntarget_val = 0.0\nrolls = 0.0\nstart_frame = time.frame()\ntarget = guess\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nstart:\nrng_state = state_0\n\nloop:\nrolls += 1.0\nframe_difference = time.frame() - start_frame\nguess:\n{rng.next}\nc_hit = hit\n; if hit is true, we won't roll the rng again\nhit = hit || rnd(-2147483648, 2147483646) != {rng.get_range.int(-2147483648, 2147483646)}\nglobal.double.set(if(i == 1, \"target\", \"rng\") . \"_val\", {rng.get_uniform})\ngoto(if(\\\n  not(c_hit),\\\n  if(hit, guess, waitframe),\\\n  if(\\\n    state_1 == \"\",\\\n    init,\\\n    if(\\\n      target_val == rng_val,\\\n      99,\\\n      if(rolls % 1e3 == 0.0, waitframe, loop)\\\n    )\\\n  )\\\n))\n\ninit:\nlocal.string.set(\"state_\" . i, rng_state)\ni = (i + 1) % 2\ntarget = loop\ngoto(if(\\\n  i == 0,\\\n  start,\\\n  rng.line_1\\\n))\n\nwaitframe:\nwaitframe()\ngoto(target)\n"],["rng.show interference",":import RNG_manip lib\n:name rng.show interference\n:budget_cap 200\n;\n:global double rolls\n:global double rng_val\n:global double target_val\n;\n:local int i\n;\n:local string state_0\n\n#states.get global.string.get(\"states<br><size\")\n#states.set(value) global.string.set(\"states<br><size\", {value})\n\nkey.t()\n\nglobal.string.set(\"<size=0><line-height=0><color\", \"white></line-height></size>\")\nrng_val = 0.0\ntarget_val = 0.0\nrolls = 0.0\n{states.set(\"20>\")}\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nstart:\nrng_state = state_0\n\nloop:\n; Lower the size block by 4 for every 11 rolls and then add the remaining values back\n{states.set(concat(\\\n  sub(d2s(120.0 - (2.0 * floor(rolls / 11.0))), 1, 2),\\\n  sub({states.get}, 2, 999999)\\\n) . if(rolls >= 4.0, rng_val . \"<br>\", \"\"))}\n; Add a new value only if the rolls are higher than 4.0 to ignore the background rolls\n\nrolls += 1.0\n\nguess:\n{rng.next}\nglobal.double.set(if(i == 1, \"target\", \"rng\") . \"_val\", {rng.get_uniform})\nstate_0 = if(state_0 == \"\", rng_state, state_0)\ni += if(i == 2, 0, 1)\ngoto(if(\\\n  i == 1,\\\n  add_interference,\\\n  if(\\\n    rolls == 0.0,\\\n    start,\\\n    if(\\\n      target_val == rng_val,\\\n      99,\\\n      if(rolls % 1e3 == 0.0, waitframe, loop)\\\n    )\\\n  )\\\n))\n\nwaitframe:\nwaitframe()\ngoto(loop)\n\nadd_interference:\n; add the action here\n; This will show you how much interference is caused by that action\n;adventure.move(if(\\\n  x(adventure.playerPos()) == 9.0,\\\n  vec(0.0, if(y(adventure.playerPos()) == 0.0, -1.0, 1.0)),\\\n  vec(if(x(adventure.playerPos()) == 0.0, -1.0, 1.0), 0.0)\\\n))\n\ngoto(rng.line_1)\n"],["adventure infinite_bombs",":import RNG_manip lib\n:budget_cap 200\n\n:local int start_bombs\n\nkey.t()\n\nstart_bombs = adventure.bombs()\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\ngoto(if(\\\n  {rng.get_range.float(0.0, 1.0)} > 0.1,\\\n  rnd(guess, 0),\\\n  bomb\\\n))\n\nbomb:\nadventure.placeBomb() \ngss(\"<size=200%>Infinite bombs\", \"<color=\" . if(\\\n  adventure.bombs() == start_bombs,\\\n  \"#0F0>SUCCESS!\",\\\n  \"red>FAIL!\"\\\n) . \"</color></size>\")"],["adventure guaranteeElites",":import RNG_manip lib\n:budget_cap 100\n\n:local int rolls\n:local int counter\n:local double distance\n\nkey.t()\n\n; get the distance\ndistance = max(x(adventure.roomCoords()), 254. - x(adventure.roomCoords()))\\\n         + max(y(adventure.roomCoords()), 254. - y(adventure.roomCoords()))\\\n         - if(min(x(adventure.playerPos()), y(adventure.playerPos())) == 0.0, 253.0, 255.0)\n\n\n{rng.line_1}\n{rng.line_2(guess)}\n\nguess:\n{rng.next}\nrolls += if(rolls < 24, 1, rnd(0, 0))\n; advance the rng if we've reached our desired rolls\n\ngoto(if(\\\n  {rng.get_range.float(0.0, 1.0)} <= distance * 0.0005 && rolls == 24,\\\n  move,\\\n  guess\\\n))\n\nmove:\nlu(\"rolls\")\nadventure.move(if(\\\n  x(adventure.playerPos()) == 9.0,\\\n  vec(0.0, if(y(adventure.playerPos()) == 0.0, -1.0, 1.0)),\\\n  vec(if(x(adventure.playerPos()) == 0.0, -1.0, 1.0), 0.0)\\\n))\n"]]}}
```

## **IMPORTANT**
Source import requires [Editor Actions lib](../../Editor%20Actions%20lib/README.md) to calculate data-retrieval actions.