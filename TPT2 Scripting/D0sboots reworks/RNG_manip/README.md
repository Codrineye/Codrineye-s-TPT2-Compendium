# RNG_manip

This is a refactored version of rng_manip by d0sboots that translates to the same code.

Source Export
```
{"workspaces":{"RNG_manip":[["RNG_manip hdr","; This is the header of the RNG manipulation library\n; It's purpose is to explain what you're looking at and what the library implements\n;\n; This library exists to do RNG manipulation in TPT2.\n; If you don't know what RNG manipulation is, you can find plenty of info on the web.\n; Also, this library is probably not for you.\n\n{lua(\\\n  --[[Core RNG table that everything is built ontop of]]\\\n  RNG = {};\\\n  \\\n  --[[Table that holds all our usable data]]\\\n  RNG.code_cache = nil;\\\n  \\\n  --[[Return the appropiate macro body]]\\\n  function RNG.macro_body(id, arg1, arg2) end\\\n)}\n\n; There are three sets of macros defined in this library\n; The first is the 3-part rng_init sequence\n#rng.line_1 {lua(return RNG.macro_body(\"line_1\"))}\n#rng.line_2 {lua(return RNG.macro_body(\"line_2\"))}\n#rng.line_3(label) {lua(return RNG.macro_body(\"line_3\", [[{label}]]))}\n;\n; To use these, place this sequence *immediately* before the event you want to manipulate\n; {rng.line_1}\n; {rng.line_2}\n; {rng.line_3(continue)}\n; continue:\n;\n; The last one makes a label to `goto` to when it is done.\n; You can define the lable on the next line if you just want it to continue there.\n; You can also use more complicated conditional expressions if you want\n; \n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n; \n; If you need to re-initialize the state, jump to label `rng.line_2`.\n;\n; To simulate future rolls of the rng, use this macro:\n#rng.next {lua(return RNG.macro_body(\"next\"))}\n; You will need to call this (at least) once before calling rng.get_int.\n; Every call to {rng.next} should correspond to one call to the RNG (generally via rnd()),\n; except for the last one(s) which you want to save for the actual in-game event(s)\n; that are rolling the RNG.\n\n\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng.get_int {lua(return RNG.macro_body(\"get_int\"))}\n#rng.get_double {lua(return RNG.macro_body(\"get_double\"))}\n; Don't forget that you need one call to {rng.next} before the result is valid.\n; {rng.get_int} could be negative if the high bit is set.\n; {rng.get_double} avoids this issue by using a double,\n; so the result will always be a non-negative integer.\n\n; Return a float value between 0.0 and 1.0 (inclusive).\n#rng.get_uniform {lua(return RNG.macro_body(\"get_uniform\"))}\n; This performs the same function as UnityEngine.Random.value. Although the number returned\n; is a double because of TPT2 type limitations, it only has single-precision values.\n; If you need to do math that accurately mimics single-precision game math, keep that in\n; mind (you may need to use the vector type to keep the behavior consistent.)\n\n; This simulates the same behaviour as the rnd() function.\n#rng.get_range.int(min, max) {lua(return RNG.macro_body(\"get_range.int\", [[{min}]], [[{max}]]))}\n; The range is inclusive, so we can also return the values in `min` and in `max`.\n; Just like with {rng.get_int}, {rng.next} needs to be called before this is valid.\n\n; This simulates the same behaviour as the rnd() function for double values\n#rng.get_range.double(min, max) {lua(\\\n  return RNG.macro_body(\"get_range.double\", [[{min}]], [[{max}]]);\\\n)}\n\n; This simulates internal UnityEngine.Random$$Range() calls used for more complex things\n#rng.get_range.float(min, max) {lua(\\\n  return RNG.macro_body(\"get_range.float\", [[{min}]], [[{max}]]);\\\n)}\n"],["RNG_manip lib","; Import the header file to define the functions and get the macros\n:import RNG_manip hdr\n\n; This is the functional RNG manip library\n; \n; Every lua variable and function in the global field is part of the global table called RNG\n\n#rng_varType local\n; Change this to \"global\" for debugging\n\n; The 128-bit state of the rng, stored as 128 \"1\"s and \"0\"s.\n; It is exactly as pathetic as it sounds, but it is actually most efficient to compute\n; xor and bitshifting with numbers in string form, because we can do xor via\n; precomputed tables and bitshifts become (sub)string manipulation.\n; You'd think the same could be done with integers with * and /, but the fact that we only\n; have signed integers makes everything too awful.\n; This is used by {rng.next} to compute the next state, and {rng.get_int} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate\n; multiple rng seeds at once.\n:{rng_varType} string rng_state\n\n; A temporary variable used during int-to-binary conversion.\n; A double is used to avoid issues with the sign bit.\n:{rng_varType} double rng_temp\n\n{lua(\\\n  --[[/*\\\n    * The structure of code is broken up into multiple lua functions, to allow regular comments\\\n    * to explain them. Lua functions are used to construct the code, instead of regular macros,\\\n    * so that we could define our user-visible macros such as {rng.line_1}, {rng.next} etc.\\\n    * at the top without having to give the full implementation; instead, a stub implementation\\\n    * was given and the function is re=implemented at the bottom of the file here. This allows us\\\n    * to use the macros freely in comments, since macros are always expanded, where otherwise we\\\n    * could not comment on them before they were defined.\\\n    * As a side benefit, before the full definition takes effect, they will expand to nothing,\\\n    * which is very fast to evaluate.\\\n    *\\\n    * Time to construct our data, starting off with the lookup tables.\\\n    * The data string is 256 entries, each 23 bytes long:\\\n    * - 8 bytes for the name suffix of \"rng_form\"\\\n    * - 11 bytes for the entire name of the xor table (entries like \"0001xor0110\")\\\n    * - 4 bytes for the value of the xor table\\\n    * All of these are binary strings (the characters \"0\" and \"1\"), except also containing\\\n    * xor in the name for the xor table.\\\n  */]]\\\n  local function create_lookupString()\\\n    local digits = string.byte(\"0\");\\\n    local conv4 = {};\\\n    --[[/*\\\n      * table holding 4 bits at each index\\\n      * \\\n      * build up the table, we've got 4 bits meaning 2 ^ 4, which is 16\\\n      * i = 15 is our 16th iteration\\\n    */]]\\\n    for i = 0, 15 do\\\n      --[[shift & 1 forces the output to be either 0 or 1]]\\\n      local bits = table.pack(\\\n        string.char(((i >> 3) & 1) + digits),\\\n        string.char(((i >> 2) & 1) + digits),\\\n        string.char(((i >> 1) & 1) + digits),\\\n        string.char(((i >> 0) & 1) + digits)\\\n      );\\\n      conv4[i] = table.concat(bits);\\\n    end\\\n    \\\n    local code_table = {};\\\n    --[[/*\\\n      * Using the bits stored in conv4, we create our code table\\\n      *\\\n      * We've got 256 cases to build, because 16 * 16 = 256\\\n      * i = 255 is our 256th iteration\\\n    */]]\\\n    for i = 0, 255 do\\\n      local hi = i >> 4;\\\n      local lo = i & 15;\\\n      \\\n      --[[/*\\\n        * Each iteration adds 2 elements to our code_table\\\n        * First, we construct the byte through concatenating the hi_bit to the lo_bit\\\n        * Lastly, we xor the high and low bits together.\\\n      */]]\\\n      \\\n      code_table[#code_table + 1] = conv4[hi] .. \"xor\" .. conv4[lo];\\\n      code_table[#code_table + 1] = conv4[hi ~ lo];\\\n    end\\\n    \\\n    return table.concat(code_table);\\\n  end\\\n  --[[/*\\\n    * Now, we construct the code for {rng.line_1}, {rng.line_2} and {rng.line_3()} macros.\\\n    * The code for these is truly awful, because what is 5 lines has been crammed into\\\n    * the minimum possible of 3 lines to save space in user code.\\\n  */]]\\\n  --[[/*\\\n    *\\\n    * At a high level, {rng.line_1} is a local.int.set, {rng.line_2} is a local.string.set\\\n    * and {rng.line_3()} is a goto. Each of these performs multiple different functions, depending\\\n    * on the phase of execution; the act together as a state machine,\\\n    * in order to initialize everything that needs initialization.\\\n    *\\\n    * The first phase is setting the \"rng_from\" and \"xor\" tables.\\\n    * Both tables have 256 entries, and the data for them is encoded together in the code_table\\\n    * defined above. In this phase, we first assign the code_table data to rng_state, and then\\\n    * use entires from it to set rng_from (a double table) and xor (a string table).\\\n    * We use substring to discard the front of rng_state, which is the current working entry,\\\n    * to both load a new entry and also because the length of rng_state also functions\\\n    * as the way to calculate the value we assign to rng_from.\\\n    *\\\n    * The second phase is used to read 4 values from the rng and convert them\\\n    * into individual bits. It lasts for 128 iterations as a result. We use either\\\n    * contains(local.string.get(\"1111xor1111\", \"0\")) (the final table entry) or\\\n    * contains(rng_state, \"xor\") to determine when the first phase is over;\\\n    * the two have slight differences at both start and end of phase 1 which dictate\\\n    * the use of one or the other in specific places.\\\n    *\\\n    * Reading bits is relatively straightforward:\\\n    * A value from rnd() is stored in rng_temp and then multiplied by an appropriate power of 2\\\n    * to check the sign bit. There is an additional quirk where if the value is exactly 0,\\\n    * it indicates a condition where we have to restart the process.\\\n    * This is because, the nature of rnd() is that it adds one to range_max, so there is a hole\\\n    * where both 0 and 2 ^ 32 - 1 map to the same value and we cannot distinguish them.\\\n    * Since this is very rare, we just restart and roll again.\\\n    *\\\n    * Tricks that are used:\\\n    * Since contains(\"\", \"\") is true, contains(\"\", var) is a cheap test to determine\\\n    * if a variable is unset.\\\n    * Also, since if() and boolean logic have the same number of nodes,\\\n    * ternaries are sometimes used to slightly optimize node counts\\\n  */]]\\\n  function RNG.cache_lines(cache)\\\n    --[[/*\\\n      * If we are in phase 1, set rng_from appropriately.\\\n      * If we are in phase 2, get a new rng value and save it to rng_temp.\\\n      * We add back the minimum value to get the raw bits.\\\n      * We're using a double to avoid issues with the sign bit.\\\n      * There is also one wrinkle in that the very first iteration will write 256 to \"rng_from\"\\\n      * (not technically part of the table), but this is harmless as we never access \"rng_from\"\\\n      * directly. We only use rng_from + a byte (eg. 0000 0000).\\\n      * This is the simplest line, because {rng.line_3()} skips it whenever it isn't needed.\\\n    */]]\\\n    cache.line_1 = [==[\\\n      rng.line_1: {rng_varType}.double.set(\\\n        if(\\\n          contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n          concat(\"rng_from\", concat(sub(rng_state, 0, 4), sub(rng_state, 7, 4))),\\\n          \"rng_temp\"\\\n        ),\\\n        if(\\\n          contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n          i2d(256 - len(rng_state) / 15),\\\n          i2d(rnd(-2147483648, 2147483646)) + 2147483648.0\\\n        )\\\n      )\\\n    ]==];\\\n    \\\n    --[[/*\\\n      * This line does the bulk of the work, and thus is the most complicated.\\\n      * It gets called a total of 641 times:\\\n      * 513 times in phase 1 (twice per value and one for initial init)\\\n      * and 128 times in phase 2.\\\n      *\\\n      * In phase 1, the sequence is as follows:\\\n      * first, {rng.line_1} is called to set rng_from, and then this line sets the xor value\\\n      * After the xor value is set, this line is looped again to shorten rng_state\\\n      * so we can access the next entry.\\\n      *\\\n      * In phase 2, the size of rng_state is multiplied by a power of 2 in order to determine\\\n      * which bit to select. Since 2 ^ 31 doesn't fit in an integer and the arithmetic.int()\\\n      * function throws an exception instead of wrapping it to negative, that value is dealt with\\\n      * as a special case.\\\n      * Several extra quirks:\\\n      * If rng_temp is 0, we reset state because of the ambiguity mentioned above.\\\n      * This also covers the case where we're doing the final loop of phase 1,\\\n      * as rng_temp is 0 by default.\\\n      * rng_temp is also reset when the state is of length 128 (meaning we are calling back\\\n      * into this code after prior initialization, to get a new set of random numbers).\\\n    */]]\\\n    cache.line_2 = [==[\\\n      rng.line_2: {rng_varType}.string.set(\\\n        if(\\\n          contains(\"\", rng_state),\\\n          \"rng_state\",\\\n          if(\\\n            contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n            if(\\\n              contains(\"\", {rng_varType}.string.get(sub(rng_state, 0, 11))),\\\n              sub(rng_state, 0, 11),\\\n              \"rng_state\"\\\n            ),\\\n            \"rng_state\"\\\n          )\\\n        ),\\\n        if(\\\n          contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n          if(\\\n            contains(\"\", {rng_varType}.string.get(sub(rng_state, 0, 11))),\\\n            if(\\\n              contains(\"\", rng_state),\\\n              \"CODE_TABLE\",\\\n              sub(rng_state, 11, 4)\\\n            ),\\\n            sub(rng_state, 15, 999999)\\\n          ),\\\n          if(\\\n            rng_temp == 0.0 || len(rng_state) >= 128,\\\n            \"\",\\\n            concat(rng_state, if(\\\n              rng_temp * (2.0 ^ i2d(len(rng_state) % 32)) % (2.0 ^ 32.0) >= 2.0 ^ 31.0,\\\n              \"1\",\\\n              \"0\"\\\n            ))\\\n          )\\\n        )\\\n      )\\\n    ]==];\\\n    do\\\n      local code_table = create_lookupString();\\\n      cache.line_2 = cache.line_2:gsub(\"CODE_TABLE\", code_table);\\\n    end\\\n    --[[/*\\\n      * Continue the loop at the appropiate line.\\\n      * Here we check if we're in phase 1 through contains(rng_state, \"xor\").\\\n      * This is important because we only enter phase 2 when rng_state is empty.\\\n      *\\\n      * In phase 1, we jump to {rng.line_1} when the table values need to be set,\\\n      * otherwise we skip straight to line 2 to advance to the next table entry.\\\n      * (This also works at the end of the phase.)\\\n      *\\\n      * In phase 2, we jump to the first line only when we need a new rng_entry,\\\n      * which is every 32 bits. Otherwise, we loop to line 2.\\\n      * The exit condition is accessed when we've filled all 128 bits.\\\n      * This exit jump point is marked as EXTERNAL_LABEL, which gets replaced\\\n      * with the actual label in rng_code().\\\n    */]]\\\n    cache.line_3 = [[\\\n      goto(if(\\\n        contains(rng_state, \"xor\"),\\\n        if(\\\n          contains(\"\", {rng_varType}.string.get(sub(rng_state, 0, 11))),\\\n          rng.line_1,\\\n          rng.line_2\\\n        ),\\\n        if(\\\n          len(rng_state) % 32 != 0,\\\n          rng.line_2,\\\n          if(len(rng_state) != 128, rng.line_1, EXTERNAL_LABEL)\\\n        )\\\n      ))\\\n    ]];\\\n    \\\n    --[[Now, we remove all spaces from the end result]]\\\n    for i = 1, 3 do\\\n      local name = \"line_\" .. i;\\\n      cache[name] = cache[name]:gsub(\" +\", \"\");\\\n    end\\\n  end\\\n)}\n\n; All functions defined previously are in the global field,\n; so ending the lua macro doesn't lose anything of importance\n; \n; The reason I'm separating these 2 macros is because the following functions\n; form actions dynamically, not statically like seen above\n:import Editor_actions lib\n; Import Editor_actions lib to form parsable code through lua macros with more ease\n\n{lua(\\\n  local rng_varType = \"{rng_varType}\";\\\n  \\\n  --[[Shortened version to perform double to int conversion]]\\\n  local function d2i(input)\\\n    return Editor_convertDoubleToInt(input);\\\n  end\\\n  local function i2d(input)\\\n    return Editor_convertIntToDouble(input);\\\n  end\\\n  \\\n  --[[/*\\\n    * Now that we've finished setting up, we can get back to our functions\\\n    *\\\n    * Construct the code for {rng.get_int}.\\\n    * Since rng_from has an 8-bit lookup table, we can convert binary strings to numbers\\\n    * by looking up just 4 substrings and multiplying by 256 to shift them\\\n    * into the appropriate place. The upper bit may overflow into the sign bit,\\\n    * but that's what we want in this case.\\\n    *\\\n    * {rng.get_uniform} has a bit more to it, but also doesn't use as many bits from rng_state.\\\n    * We use a vector type, which is a pair of single-precision numbers, to get accurate\\\n    * single-precision rounding for the calculation to mirror what Unity does.\\\n  */]]\\\n  function RNG.cache_get_int(cache)\\\n    local rng_from = [[\"rng_from\"]];\\\n    local rng_state = \"rng_state\";\\\n    \\\n    local bytes = {};\\\n    for offset = 96, 120, 8 do\\\n      local name_append = Editor_sub(rng_state, offset, 8);\\\n      local name = Editor_concat(rng_from, name_append);\\\n      bytes[#bytes + 1] = Editor_getVar(rng_varType, \"double\", name);\\\n    end\\\n    \\\n    cache.get_int = bytes[2];\\\n    cache.get_double = bytes[1];\\\n    cache.get_uniform = \"\";\\\n    do\\\n      local name_append = Editor_sub(rng_state, 105, 7);\\\n      local name = Editor_concat([[\"rng_from0\"]], name_append);\\\n      cache.get_uniform = Editor_getVar(rng_varType, \"double\", name);\\\n    end\\\n    for i = 2, #bytes do\\\n      if i ~= 2 then\\\n        cache.get_int = Editor_math(cache.get_int, \"*\", 256.0);\\\n        cache.get_int = Editor_math(cache.get_int, \"+\", bytes[i]);\\\n        \\\n        cache.get_uniform = Editor_math(cache.get_uniform, \"*\", 256.0);\\\n        cache.get_uniform = Editor_math(cache.get_uniform, \"+\", bytes[i]);\\\n        if i < #bytes then\\\n          cache.get_int = Editor_encase_value(cache.get_int);\\\n          cache.get_uniform = Editor_encase_value(cache.get_uniform);\\\n        end\\\n      end\\\n      cache.get_double = Editor_math(cache.get_double, \"*\", 256.0);\\\n      cache.get_double = Editor_math(cache.get_double, \"+\", bytes[i]);\\\n      cache.get_double = Editor_encase_value(cache.get_double);\\\n    end\\\n    cache.get_int = d2i(cache.get_int);\\\n    \\\n    do\\\n      local first_int = d2i(bytes[1]);\\\n      first_int = Editor_math(first_int, \"*\", 16777216);\\\n      cache.get_int = Editor_math(first_int, \"+\", cache.get_int);\\\n    end\\\n    cache.get_int = Editor_encase_value(cache.get_int);\\\n    \\\n    cache.get_uniform = Editor_vec(cache.get_uniform, 0.0);\\\n    do\\\n      local mult = Editor_vec(\"1.192093e-7\", 0.0);\\\n      cache.get_uniform = Editor_math(cache.get_uniform, \"*\", mult);\\\n      cache.get_uniform_vec = cache.get_uniform;\\\n    end\\\n    cache.get_uniform = Editor_vector_xCoord(cache.get_uniform);\\\n  end\\\n  \\\n  do\\\n    --[[This is an example of the xorshift128 function]]\\\n    local state = {};\\\n    --[[/*\\\n      * Our state is a table holding 4 values state[0], state[1], state[2] and state[3];\\\n      * Lua still lets us index tables by 0, so don't let this indexing by 0 confuse you.\\\n      *\\\n      * state reprezents a 128 bit register holding 4 32-bit unsigned integers\\\n      *\\\n      * We have our xorshift table, that manipulates our state and returns a modified 32-bit int\\\n    */]]\\\n    local function xorshift128()\\\n      local last = state[3];\\\n      --[[We make a copy of the last value in our table and then rearrange our state]]\\\n      state[3] = state[2];\\\n      state[2] = state[1];\\\n      state[1] = state[0];\\\n      \\\n      --[[/*\\\n        * We must perform bit operations on our variable `last`\\\n        *\\\n        * For this I'll create a helper variable `shift` that performs the bitshifts.\\\n      */]]\\\n      \\\n      local shift = last << 11;\\\n      --[[/*\\\n        * To start, we shift last by 11 bits to the left\\\n        * Then, we take an xor between last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = last >> 8;\\\n      --[[/*\\\n        * We then take the new value of last and shift it by 8 bits to the right\\\n        * Then, we take an xor between the new value of last and the shift\\\n      */]]\\\n      last = last ~ shift;\\\n      \\\n      shift = state[0] >> 19;\\\n      --[[/*\\\n        * Lastly, we shift our first integer by 19 bits to the right\\\n        * Then, we xor the first integer by our shift\\\n        * And then we xor the last value with our new state[0]\\\n      */]]\\\n      state[0] = state[0] ~ shift;\\\n      state[0] = last ~ state[0];\\\n      \\\n      --[[We end the function by returning the modified bit]]\\\n      return state[0];\\\n    end\\\n    --[[/*\\\n      * As xorshift128 is written in C, it uses little-endian encoding. To show this,\\\n      * here is a binary representation of status if it held the number\\\n      * 2 ^ 128 - 2 ^ 97 - 2 ^ 96 + 2 ^ 32 - 3\\\n      *\\\n      * status = (\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      * );\\\n      * last = status[3];\\\n      * status[3] = status[2];\\\n      * status[2] = status[1];\\\n      * status[1] = status[0];\\\n      * shift = last << 11 = 00000000 00010111 11111111 11111111\\\n      * last = last ~ shift = 10111111 11101000 00000000 00000000\\\n      * shift = last >> 8 = 11101000 00000000 00000000 00000000\\\n      * last = last ~ shift = 01010111 11101000 00000000 00000000\\\n      * shift = status[0] >> 19 = 11111111 11111000 00000000 00000000\\\n      * status[0] = status[0] ~ shift = 01000000 00010000 000000000 00000000\\\n      * status[0] = last ~ status[0] = 00010111 11111000 00000000 00000000\\\n      *\\\n      * status = (\\\n      *   00010111 11111000 00000000 00000000\\\n      *   10111111 11111111 11111111 11111111\\\n      *   00000000 00000000 00000000 00000000\\\n      *   00000000 00000000 00000000 00000000\\\n      * )\\\n    */]]\\\n  end\\\n  \\\n  --[[/*\\\n    * Construct {rng.next}.\\\n    *\\\n    * This is simply Margsaglia's xorshift128 (defined above), modified for our arhitecture.\\\n    * Most importantly, we must do everything in parallel (all at once).\\\n    * Additionally, our representation is in bit-wise big-endian encoding.\\\n    * example of a 4-bit register holding the number 3:\\\n    * little endian = 1100\\\n    * in big endian = 0011\\\n    *\\\n    * For our implementation, we can remove the return for the function (as that's unneeded)\\\n    * and to fit with our big endian representation, last = status[0] instead of status[3].\\\n    *\\\n    * To do this simultaneously and in parallel, we want to compute:\\\n    * rng_state = sub(rng_state, 32, 96) . (\\\n    *   sub(rng_state, [96...124], 4) ~ sub(rng_state, [96...124] + 19, 4) ; s = s ~ (s >> 19)\\\n    * ~ sub(rng_state, [0...28], 4)   ~ sub(rng_state, [0...28] - 11, 4)   ; \\\n    * ~ sub(rng_state, [0...28] + 8)  ~ sub(rng_state, [0...28] - 3, 4)    ; \\\n    * )\\\n    * rng_state = rng_state[32..128] .. (\\\n    *   rng_state[96..128] ^ rng_state[96..108]      ; s ^ (s >> 19)\\\n    * ^ rng_state[0..32] ^ (rng_state[11..32] << 11) ; t ^ (t << 11)\\\n    * ^ rng_state[0..24] ^ (rng_state[11..32] << 3)  ; t ^ (t << 11) >> 8\\\n    * )\\\n    *\\\n    * We aligh each of those into 4-bit aligned chunks and compute each chunk separately\\\n    * by using the 4x4 bit xor table to compute the xors, concatenating them at the end.\\\n    * each index here is the base, extending +4 (or sometimes fewer) bits.\\\n    *  96 100 104 108 112 116 120 124\\\n    *   -   -   -   -  96  97 101 105\\\n    *   0   4   8  12  16  20  24  28\\\n    *  11  15  19  23  27  31   -   -\\\n    *   -   -   0   4   8  12  16  20\\\n    *   -   -  11  15  19  23  27  31\\\n  */]]\\\n  local function test()\\\n    local state = {};\\\n    state[1] = Editor_sub(\"rng_state\", 32, 96);\\\n    --[==[Performs state[3], state[2], state[1] = state[2], state[1], state[0] ]==]\\\n    for i = 0, 32, 4 do\\\n      local term = \"\";\\\n      if i == 32 then\\\n        \\\n      end\\\n    end\\\n  end\\\n  function RNG.cache_next(cache)\\\n    --[[/*\\\n      * To access state[0], we do sub(rng_state, [0 - 27], 4);\\\n      * To access state[3], we do sub(rng_state, [96-124], 4);\\\n      *\\\n      * Given how Editor_actions lib works, we can work backwards, so the logic flow\\\n      * can mimic that seen in the \\\n      * This requires explanation through example, so here are some formatting rules:\\\n      * a bit is 1 or 0, a byte is 8 bits. 2 ^ 8 - 1 in bits = 1111 1111\\\n      * I use the separator `|` to separate a byte from another\\\n      * 2 ^ 16 - 1 is 2 bytes (16 bits) = 1111 1111|1111 1111\\\n      *\\\n      * The biggest restriction is that we only have 4-bit registers to work with, as apposed to\\\n      * the 32 bit registers used in the code. To help with understanding what's going on, I'll\\\n      * show the raw bits of the number 2 ^ 128 - 2 ^ 97 - 2 ^ 96 + 2 ^ 32 - 3 in binary\\\n      * rng_state = (\\\n      *   1111 1111|1111 1111|1111 1111|1111 1101 state[0]\\\n      *   0000 0000|0000 0000|0000 0000|0000 0000 state[1]\\\n      *   0000 0000|0000 0000|0000 0000|0000 0000 state[2]\\\n      *   1111 1111|1111 1111|1111 1111|1111 1101 state[3]\\\n      * )\\\n      *\\\n      * So, passing rng_state to xorshift128 we'd get\\\n      * final = state[0]\\\n      * shift = final << 11 = 1111 1111|1111 1111|1110 1000|0000 0000\\\n      * final = final ~ shift = 0000 0000|0000 0000|0001 0111|1111 1111\\\n      * shift = final >> 8 = 0000 0000|0000 0000|0000 0000|0001 0111\\\n      * final = final ~ shift = 0000 0000|0000 0000|0001 0111|1110 1000\\\n      * shift = state[3] >> 19 = 0000 0000|0000 0000|0001 1111|1111 1111\\\n      * state[3] = state[3] ~ shift = 1111 1111|1111 1111|1110 0000|0000 0010\\\n      * state[3] = final ~ state[3] = 1111 1111|1111 1111|1110 0000|0000 1001\\\n      *\\\n      * Which will get translated to this:\\\n      * var1 = state[0];\\\n      * var2 = var1 << 11;\\\n      * var3 = var1 ~ var2;\\\n      * var4 = var3 >> 8;\\\n      * var5 = state[3];\\\n      * var6 = var5 >> 19;\\\n      * var7 = var5 ~ var6;\\\n      * var8 = var4 ~ var7;\\\n      *\\\n      *\\\n      * To construct a single 4-bit term in the formula, we pass this varargs function the offsets\\\n      * from a column in the table above, and the last value indicates the number of bits for the\\\n      * partial term. Some chunks can be made entirely with 4-bit terms, but others have a partial\\\n      * term made with a smaller number of bits. Thankfully, there's at most 1 of these per chunk.\\\n      * We use a positive value to indicate a term that needs padding on the left, and a negative\\\n      * value to indicate a term that needs padding on the right.\\\n      *\\\n      * The indexing is a little complicated; This example shows how the indices work for args=3.\\\n      *        1    2       3     4    5       6     7    8 9 \\\n      *       lsg( sub() .\"xor\". lsg( sub() .\"xor\". sub() ) ) \\\n    */]]\\\n    \\\n    local function singleTerm(...)\\\n      local input = table.pack(...);\\\n      local args = #input - 1;\\\n      local res = \"\";\\\n      if input[#input] >= 0 then\\\n        res = Editor_sub(\"rng_state\", input[args], input[#input]);\\\n        local xor = \"xor\" .. string.rep(\"0\", 4 - input[#input]);\\\n        res = Editor_concat(Editor_stringify_value(xor), res);\\\n      else\\\n        res = Editor_sub(\"rng_state\", input[args], -input[#input]);\\\n      end\\\n      \\\n      for i = args - 1, 1, -1 do\\\n        local next = Editor_sub(\"rng_state\", input[i], 4);\\\n        \\\n        if i ~= args - 1 then\\\n          local xor = [[\"xor\"]];\\\n          res = Editor_concat(xor, res);\\\n          res = Editor_concat(next, res);\\\n        elseif input[#input] >= 0 then\\\n          res = Editor_concat(next, res);\\\n        else\\\n          local xor = string.rep(\"0\", 4 + input[#input]) .. \"xor\";\\\n          next = Editor_concat(Editor_stringify_value(xor), next);\\\n          res = Editor_concat(res, next);\\\n        end\\\n        res = Editor_getVar(rng_varType, \"string\", res);\\\n      end\\\n      return res;\\\n    end\\\n    \\\n    local result = table.pack(\\\n      singleTerm( 96,  0,     11,               4),\\\n      singleTerm(100,  4,     15,               4),\\\n      singleTerm(104,  8,  0, 19, 11,           4),\\\n      singleTerm(108, 12,  4, 23, 15,           4),\\\n      singleTerm(112, 16,  8, 27, 19, 96,       1),\\\n      singleTerm(116, 20, 12,     23, 97,  31, -1),\\\n      singleTerm(120, 24, 16,     27, 101,      4),\\\n      singleTerm(124, 28, 20,         105, 31, -1)\\\n    );\\\n    cache.next = \"rng_state = sub(rng_state, 32, 96) . \" .. table.concat(result, \" . \");\\\n  end\\\n  \\\n  function RNG.get_range(tag, min, max)\\\n    if tag ~= \"int\" and tag ~= \"double\" and tag ~= \"float\" then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nUnrecognised get_range tag encountered!\",\\\n        \"\\nExpected tags are 'int', 'double' and 'float', but got \", tag\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local min_num = tonumber(min);\\\n    local max_num = tonumber(max);\\\n    \\\n    local range;\\\n    if tag == \"double\" then\\\n      if min_num and max_num then\\\n        range = math.max(min_num, max_num) - min_num;\\\n      else\\\n        range = Editor_max(min, max);\\\n        range = Editor_math(range, \"-\", min);\\\n      end\\\n      range = Editor_encase_value(range);\\\n      range = Editor_math(RNG.code_cache.get_uniform, \"*\", range);\\\n      if not min_num or min_num ~= 0 then\\\n        range = Editor_math(range, \"-\", min);\\\n      end\\\n      return range;\\\n    \\\n    elseif tag == \"float\" then\\\n      local uniform = RNG.code_cache.get_uniform_vec;\\\n      \\\n      if max_val and max_val == 0 then\\\n        range = \"vec(0.0, 0.0)\";\\\n      else\\\n        range = Editor_math(\"vec(1.0, 0.0)\", \"-\", uniform);\\\n        range = Editor_encase_value(range);\\\n        max_val = Editor_vec(max, 0.0);\\\n        range = Editor_math(range, \"*\", max_val);\\\n      end\\\n      \\\n      if not min_val or min_val ~= 0 then\\\n        min_val = Editor_vec(min, 0.0);\\\n        min_val = Editor_math(min_val, \"*\", uniform);\\\n        if range == \"vec(0.0, 0.0)\" then\\\n          range = min_val;\\\n        else\\\n          range = Editor_math(range, \"+\", min_val);\\\n        end\\\n      end\\\n      \\\n      return Editor_vector_xCoord(range);\\\n    \\\n    \\\n    elseif tag == \"int\" then\\\n      if max_num and min_num then\\\n        local max_nr = max_num + 1;\\\n        min_num = min_num + 0.0;\\\n        range = math.max(max_nr - min_num, min_num - max_nr);\\\n      else\\\n        local left_arg, right_arg;\\\n        \\\n        if max_num then\\\n          local max_nr = max_num + 1;\\\n          left_arg = Editor_math(max_nr, \"-\", min);\\\n          right_arg = Editor_math(min, \"-\", max_nr);\\\n        elseif min_num then\\\n          local min_nr = min_num - 1;\\\n          left_arg = Editor_math(max, \"-\", min_nr);\\\n          right_arg = Editor_math(min_nr, \"-\", max);\\\n          min_num = min_num + 0.0;\\\n        else\\\n          local max_nr = Editor_math(max, \"+\", 1);\\\n          left_arg = Editor_math(max_nr, \"-\", min);\\\n          right_arg = Editor_math(min, \"-\", max_nr);\\\n        end\\\n        \\\n        range = Editor_max(left_arg, right_arg);\\\n        range = i2d(range);\\\n      end\\\n      \\\n      range = Editor_math(RNG.code_cache.get_double, \"%\", range);\\\n      \\\n      if max_num and min_num then\\\n        if min_num ~= 0.0 or max_num < min_num then\\\n          range = Editor_math(min_num, min_num < max_num and \"+\" or \"-\", range);\\\n        end\\\n        \\\n        range = d2i(range);\\\n      else\\\n        local cond = Editor_math(min, \"<\", max);\\\n        local op = Editor_if(cond, [[\"-\"]], [[\"+\"]]);\\\n        \\\n        if min_num then\\\n          range = Editor_primitive_arithmetic(min_num, op, range);\\\n          range = d2i(range);\\\n        else\\\n          range = d2i(range);\\\n          range = Editor_primitive_arithmetic(\"int\", min, op, range);\\\n        end\\\n      end\\\n      return range;\\\n    end\\\n    \\\n  end\\\n  \\\n  local get_range_size = string.len(\"get_range.\");\\\n  \\\n  --[[/*\\\n    * Return the appropriate code (macro body) given the passed in \"id\".\\\n    * All this does is lookup the precomputed code and return that;\\\n    * If the code hasn't been computed yet, it calls the helper functions that exist\\\n    * specifically to set that up.\\\n    * The one wrinkle is that {rng.line_3()} has a parameter, and that's substituted in here.\\\n  */]]\\\n  function RNG.macro_body(id, arg1, arg2)\\\n    local cache = RNG.code_cache;\\\n    \\\n    if cache == nil then\\\n      RNG.code_cache = {};\\\n      cache = RNG.code_cache;\\\n      RNG.cache_lines(cache);\\\n      RNG.cache_next(cache);\\\n      RNG.cache_get_int(cache);\\\n    end\\\n    \\\n    if id:sub(1, get_range_size) == \"get_range.\" then\\\n      return RNG.get_range(id:sub(get_range_size + 1), arg1, arg2);\\\n    end\\\n    local res = cache[id];\\\n    if arg1 then\\\n      res = res:gsub(\"EXTERNAL_LABEL\", arg1);\\\n    end\\\n    return res;\\\n  end\\\n)}\n\n{lua(\\\n  Editor.format_error_message = false;\\\n)}"],["rng_testuniform",":import RNG_manip lib\n:budget_cap 100\n;\n:global bool equal_rng\n;\n:global double predicted_rng\n:global double actual_rng\n\n\nkey.t()\n\ngoto(rng.line_2)\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_uniform}\nactual_rng = rnd(0.0, 1.0)\n\nequal_rng = predicted_rng == actual_rng"],["COD.RakStack",":import RNG_manip lib\n:name COD.RakStack\n:budget_cap 200\n\n:const string rak_stacks \"<size=0>@rm!S\"\n#rak.get global.string.get(rak_stacks)\n#rak.set(value) global.string.set(rak_stacks, {value} . \"</size>\")\n\n:local int rak_index\n\n:local double stacks\n:local double waves\n\n#raw_waves wave() + 1e11 * (era() + infinity() * 1e11)\n\nwakeup()\ngame.newround()\n;\nisTowerTesting()\n\nrak_index = active.index(\"spell.raksCurse\")\n; Terminate the instance if we're not the first running instance\n; or if the blueprint doesn't have raks curse\n;\n; active.index(spell not in blueprint) == 0\ngoto(if(\\\n  contains({rak.get}, \";\") || rak_index == 0,\\\n  99,\\\n  wait\\\n))\n\nuse_instant:\nuseinstant(rak_index)\nstacks += 1.0\n\nwait:\n; Update our shown stacks\n{rak.set(concat(d2s(stacks), \";\"))}\nwaves = {raw_waves}\nwaitframe()\n; Terminate the instance if:\n; - we're dead\n; - the user restarted and doesn't have wave restart active\n; - we've reached 5 stacks\n; Otherwise, if raks curse is on cooldown we keep waiting otherwise we jump to line 2\ngoto(if(\\\n  health(false) <= 0.0 || {raw_waves} < waves || contains({rak.get}, \"5\"),\\\n  end,\\\n  if(cooldown(rak_index) > 0.0, wait, rng.line_2)\\\n))\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\n; Look for the rng value.\n;\n; raks curse has a 99.8% chance to do nothing,\n; 0.1% chance to kill the tower and a 0.1% chance to add a stack\n; This means that we're generating from a pool of 100 / 0.1 = 1000 values\n; Since it's 0-inclusive, we actually have 1000 - 1 values = 999\n; By there being a 1 in 1000 chance that we get a stack, we only use raks curse if\n; the number is smaller than 1. Otherwise, we need to move to the next rng value,\n; for this next value to correlate with the internal rng value, we must also call for rnd()\ngoto(if(\\\n  {rng.get_range.int(0, 999)} < 1,\\\n  use_instant,\\\n  rnd(guess, guess)\\\n))\n\nend:\n{rak.set(d2s(stacks))}"],["rng_test double_range",":import RNG_manip lib\n:budget_cap 100\n;\n:global bool equal_rng\n;\n:global double predicted_rng\n:global double actual_rng\n:local double a\n:local double b\n\n\nkey.t()\n\na = 0.0\nb = 10000.0\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_range.double(a, b)}\nactual_rng = rnd(a, b)\n\nequal_rng = predicted_rng == actual_rng\n"],["rng_test1",":import RNG_manip lib\n:budget_cap 100\n;\n:global bool equal_rng\n;\n:global int predicted_rng\n:global int actual_rng\n\nkey.t()\n\ngoto(rng.line_2)\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\npredicted_rng = {rng.get_range.int(0, 10000)}\nactual_rng = rnd(0, 10000)\n\nequal_rng = predicted_rng == actual_rng"],["rng_test2",":import RNG_manip lib\n\n; Test that attempts to break the 3 line macros into 5 lines\n\n\n:global bool equal_rng\n:global int predicted_rng\n:global int actual_rng\n:budget_cap 100\n\nkey.t()\n\n:const string code_table \"{lua(\\\n  local digits = string.byte(\"0\");\\\n  local conv4 = {};\\\n  --[[/*\\\n    * table holding 4 bits at each index\\\n    *\\\n    * build up the table, we've got 4 bits meaning 2 ^ 4, which is 16\\\n    * i = 15 is our 16th iteration\\\n  */]]\\\n  for i = 0, 15 do\\\n    --[[shift & 1 forces the output to be either 0 or 1]]\\\n    local bits = table.pack(\\\n      string.char(((i >> 3) & 1) + digits),\\\n      string.char(((i >> 2) & 1) + digits),\\\n      string.char(((i >> 1) & 1) + digits),\\\n      string.char(((i >> 0) & 1) + digits)\\\n    );\\\n    conv4[i] = table.concat(bits);\\\n  end\\\n  \\\n  local code_table = {};\\\n  --[[/*\\\n    * Using the bits stored in conv4, we create our code table\\\n    *\\\n    * We've got 256 cases to build, because 16 * 16 = 256\\\n    * i = 255 is our 256th iteration\\\n  */]]\\\n  for i = 0, 255 do\\\n    local hi = i >> 4;\\\n    local lo = i & 15;\\\n    \\\n    --[[/*\\\n      * Each iteration adds 3 elements to our code_table\\\n      * First, we construct the byte through concatenating the hi_bit to the lo_bit\\\n      * Next, we do the same but this time we add an xor in the middle\\\n      * Lastly, we xor the high and low bits together.\\\n    */]]\\\n    \\\n    code_table[#code_table + 1] = conv4[hi] .. \"xor\" .. conv4[lo];\\\n    code_table[#code_table + 1] = conv4[hi ~ lo];\\\n  end\\\n  \\\n  return table.concat(code_table);\\\n)}\"\n\nline_1:\nrng_temp = if(\\\n  contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n  0.0,\\\n  i2d(rnd(-2147483648, 2147483646)) + 2147483648.0\\\n)\n\nphase_1:\n{rng_varType}.double.set(\\\n  if(\\\n    contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n    \"rng_from\" . sub(rng_state, 0, 4) . sub(rng_state, 7, 4),\\\n    \"rng_from00000000\"\\\n  ),\\\n  if(\\\n    contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n    i2d(256 - len(rng_state) / 15),\\\n    0.0\\\n  )\\\n)\n\nline_2:\nrng_state = if(\\\n  contains(\"\", {rng_varType}.string.get(\"1111xor1111\")),\\\n  if(contains(\"\", rng_state), code_table, sub(rng_state, 15, 4000)),\\\n  if(\\\n    rng_temp == 0.0 || len(rng_state) >= 128,\\\n    \"\",\\\n    rng_state . if(\\\n      rng_temp * (2.0 ^ i2d(len(rng_state) % 32)) % 2.0 ^ 32.0 >= 2.0 ^ 31.0,\\\n      \"1\",\\\n      \"0\"\\\n    )\\\n  )\\\n)\n\n{rng_varType}.string.set(\\\n  if(contains(\"\", {rng_varType}.string.get(\"1111xor1111\")), sub(rng_state, 0, 11), \"0000xor0000\"),\\\n  if(contains(\"\", {rng_varType}.string.get(\"1111xor1111\")), sub(rng_state, 11, 4), \"0000\")\\\n)\n\ngoto(if(\\\n  contains(rng_state, \"xor\"),\\\n  phase_1,\\\n  if(\\\n    len(rng_state) == 128,\\\n    next,\\\n    if(len(rng_state) % 32 == 0, line_1, line_2)\\\n  )\\\n))\n\n:local string segment\nnext:\n\n{rng.next}\n\npredicted_rng = {rng.get_range.int(-2147483648, 2147483646)}\nactual_rng = rnd(-2147483648, 2147483646)\n\nequal_rng = predicted_rng == actual_rng"],["rng_test3",":import RNG_manip lib\n:budget_cap 100\n;\n; Script that attempts to break up the rng.next into its xor shift\n;\n:global bool equal_rng\n;\n:global int predicted_rng\n:global int actual_rng\n\nkey.t()\n\ngoto(rng.line_2)\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\n:local int i\n:local string t\nguess:\nt = sub(rng_state, 0, 32)\nrng_state = sub(rng_state, 32, 128 - 32)\nt .= sub(t, 0, 32 - 11) . \"00000000000\"\n; perform t << 11\n; We now perform t xor (t << 11)\nloop1:\nt .= {rng_varType}.string.get(sub(t, i * 4, 4) . \"xor\" . sub(t, 32 + i * 4, 4))\ni = (i + 1) % (32 / 4)\ngotoif(loop1, i != 0)\n; remove the previous 64 values of t and do t >> 8\nt = sub(t, 64, 32) . \"00000000\" . sub(t, 64 + 8, 32 - 8)\n; We now do t xor t >> 8\nloop2:\nt .= {rng_varType}.string.get(sub(t, i * 4, 4) . \"xor\" . sub(t, 32 + i * 4, 4))\ni = (i + 1) % (32 / 4)\ngotoif(loop2, i != 0)\n; remove the previous 64 values of t\nt = sub(t, 64, 32)\n; now we have to do rng_state[4] >> 19\nrng_state .= \"{lua(return string.rep(0, 19))}\" . sub(rng_state, 96 + 19, 32 - 19)\nloop3:\nrng_state .= {rng_varType}.string.get(\\\n  sub(rng_state, 96 + i * 4, 4) . \"xor\" .\\\n  sub(rng_state, 128 + i * 4, 4)\\\n)\n; We now do rng_state[4] xor rng_state[4] >> 19\n; and then do t xor rng_state[4]\nrng_state = sub(rng_state, 0, 128 + 32 + i * 4) . {rng_varType}.string.get(\\\n  sub(t, i * 4, 4) . \"xor\" .\\\n  sub(rng_state, 128 + 32 + i * 4, 4)\\\n)\ni = (i + 1) % (32 / 4)\ngotoif(loop3, i != 0)\n\npredicted_rng = {rng.get_range.int(0, 10000)}\nactual_rng = rnd(0, 10000)\n\nequal_rng = predicted_rng == actual_rng"],["rng.show calls",":import RNG_manip lib\n:name rng.show calls\n:budget_cap 200\n;\n:local bool c_hit\n:local bool hit\n;\n:global double rolls\n:global double rng_val\n:global double target_val\n;\n:global int frame_difference\n:global int hit_frame\n;\n:local int i\n:local int start_frame\n:local int target\n:local string state_0\n:local string state_1\n\nkey.t()\n\nrng_val = 0.0\ntarget_val = 0.0\nrolls = 0.0\nstart_frame = time.frame()\ntarget = guess\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nstart:\nrng_state = state_0\n\nloop:\nrolls += 1.0\nframe_difference = time.frame() - start_frame\nguess:\n{rng.next}\nc_hit = hit\n; if hit is true, we won't roll the rng again\nhit = hit || rnd(-2147483648, 2147483646) != {rng.get_range.int(-2147483648, 2147483646)}\nglobal.double.set(if(i == 1, \"target\", \"rng\") . \"_val\", {rng.get_uniform})\ngoto(if(\\\n  not(c_hit),\\\n  if(hit, guess, waitframe),\\\n  if(\\\n    state_1 == \"\",\\\n    init,\\\n    if(\\\n      target_val == rng_val,\\\n      99,\\\n      if(rolls % 1e3 == 0.0, waitframe, loop)\\\n    )\\\n  )\\\n))\n\ninit:\nlocal.string.set(\"state_\" . i, rng_state)\ni = (i + 1) % 2\ntarget = loop\ngoto(if(\\\n  i == 0,\\\n  start,\\\n  rng.line_2\\\n))\n\nwaitframe:\nwaitframe()\ngoto(target)\n"],["rng.show interference",":import RNG_manip lib\n:name rng.show interference\n:budget_cap 200\n;\n:global double rolls\n:global double rng_val\n:global double target_val\n;\n:local int i\n;\n:local string state_0\n\n#states.get global.string.get(\"states<br><size\")\n#states.set(value) global.string.set(\"states<br><size\", {value})\n\nkey.t()\n\nglobal.string.set(\"<size=0><line-height=0><color\", \"white></line-height></size>\")\nrng_val = 0.0\ntarget_val = 0.0\nrolls = 0.0\n{states.set(\"20>\")}\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nstart:\nrng_state = state_0\n\nloop:\n; Lower the size block by 4 for every 11 rolls and then add the remaining values back\n{states.set(concat(\\\n  sub(d2s(120.0 - (2.0 * floor(rolls / 11.0))), 1, 2),\\\n  sub({states.get}, 2, 999999)\\\n) . if(rolls >= 4.0, rng_val . \"<br>\", \"\"))}\n; Add a new value only if the rolls are higher than 4.0 to ignore the background rolls\n\nrolls += 1.0\n\nguess:\n{rng.next}\nglobal.double.set(if(i == 1, \"target\", \"rng\") . \"_val\", {rng.get_uniform})\nstate_0 = if(state_0 == \"\", rng_state, state_0)\ni += if(i == 2, 0, 1)\ngoto(if(\\\n  i == 1,\\\n  add_interference,\\\n  if(\\\n    rolls == 0.0,\\\n    start,\\\n    if(\\\n      target_val == rng_val,\\\n      99,\\\n      if(rolls % 1e3 == 0.0, waitframe, loop)\\\n    )\\\n  )\\\n))\n\nwaitframe:\nwaitframe()\ngoto(loop)\n\nadd_interference:\n; add the action here\n; This will show you how much interference is caused by that action\nadventure.move(if(\\\n  x(adventure.playerPos()) == 9.0,\\\n  vec(0.0, if(y(adventure.playerPos()) == 0.0, -1.0, 1.0)),\\\n  vec(if(x(adventure.playerPos()) == 0.0, -1.0, 1.0), 0.0)\\\n))\n\ngoto(rng.line_2)\n"],["adventure infinite_bombs",":import RNG_manip lib\n:budget_cap 200\n\n:local int start_bombs\n\nkey.t()\n\nstart_bombs = adventure.bombs()\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\ngoto(if(\\\n  {rng.get_range.float(0.0, 1.0)} > 0.1,\\\n  rnd(guess, 0),\\\n  bomb\\\n))\n\nbomb:\nadventure.placeBomb() \ngss(\"<size=200%>Infinite bombs\", \"<color=\" . if(\\\n  adventure.bombs() == start_bombs,\\\n  \"#0F0>SUCCESS!\",\\\n  \"red>FAIL!\"\\\n) . \"</color></size>\")"],["adventure guaranteeElites",":import RNG_manip lib\n:budget_cap 100\n\n:local int rolls\n:local int counter\n:local double distance\n\nkey.t()\n\n; get the distance\ndistance = max(x(adventure.roomCoords()), 254. - x(adventure.roomCoords()))\\\n         + max(y(adventure.roomCoords()), 254. - y(adventure.roomCoords()))\\\n         - if(min(x(adventure.playerPos()), y(adventure.playerPos())) == 0.0, 253.0, 255.0)\n\n\n{rng.line_1}\n{rng.line_2}\n{rng.line_3(guess)}\n\nguess:\n{rng.next}\nrolls += if(rolls < 24, 1, rnd(0, 0))\n; advance the rng if we've reached our desired rolls\n\ngoto(if(\\\n  {rng.get_range.float(0.0, 1.0)} <= distance * 0.0005 && rolls == 24,\\\n  move,\\\n  guess\\\n))\n\nmove:\nlu(\"rolls\")\nadventure.move(if(\\\n  x(adventure.playerPos()) == 9.0,\\\n  vec(0.0, if(y(adventure.playerPos()) == 0.0, -1.0, 1.0)),\\\n  vec(if(x(adventure.playerPos()) == 0.0, -1.0, 1.0), 0.0)\\\n))\n"]]}}
```

## **IMPORTANT**
Source import requires [Editor Actions lib](../../Editor%20Actions%20lib/README.md) to calculate data-retrieval actions.