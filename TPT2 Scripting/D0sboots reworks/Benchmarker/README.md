# AI Script/Instruction Benchmarker

This utility benchmarks the execution speed of instructions in the TPT2 AI. Using it is a bit more involved than other scripts, because it's designed for programmers and is mainly of interest to programmers.<br>
Here's how to use it.
1. Disable _all_ scripts you have with impulses wakeup() and/or key.b() to get minimal interference when you run the script.
2. Import the source code bellow into the _external editor_ at https://d0sboots.github.io/perfect-tower/. It's the source code, so you can't import it in the game anyway.
3. Modify `benchmark_1` to test what you want. If you're making a simple expression, you should use `:import COD.Benchmark lib`. If you're chaining together the same expression multiple times to perform a 'stress test' of sorts, you'll want to use `COD.Benchmark utils` to gain access to [Editor_actions lib](../../Editor%20Actions%20lib/README.md). You can read the contents of [COD.Benchmark utils](COD.Benchmark%20utils.tpt2) to understand how to use the macros `function` and `dup`.
4. (Optional) Tweak the constants in [COD.Benchmark lib](COD.Benchmark lib.tpt2) if they're not to your liking. Changing NUM_BENCHMARKS is required if you add more benchmark scrits.
5. Export the workspace and import the result into the game, you press `b` to start the benchmark suite. Pressing `b` again while the benchmarker is running will stop the benchmark process.

By default, it will take quite a while for the benchmark to finish, but it converges to a near-final value pretty quickly. The most relevant number is the `self` value for each benchmark_N result: This is the amount of time that is attributable to specifically the code under test, per iteration. The other values are `best`, which is the best (minimum) time for the entire execution, and `last`, which is the value for the last (most recent) run. `self` = `best` - `best_of_baseline`, where baseline is all the benchmark machinery run without any benchmark script.

This benchmarker is still being worked on. If you want to use the benchmarker, it's advised you use the turbo exec benchmarker by d0sboots https://github.com/d0sboots/PerfectTower/blob/main/benchmarker/README.md.

```
{"workspaces":{"C0D.Benchmark":[["COD.Benchmark lib","; Macro for keeping all the names consistent\n; Changing this package name here changes it for all scripts\n#package(name) C0D.Benchmark v1.0:{name}\n;\n; Use this macro to create the `Benchmark_N` script\n#benchmark(num) {package(Benchmark_{num})}\n;\n\n;\n; How many cycles to run each measurment for.\n; Although the precision of the timer is much higher, the actual accuracy of the now()\n; function appears to be 0.5ms. This means that, to achieve a timing accuracy of 0.1us, we need\n; at least 5000 cycles.\n:const int NUM_CYCLES 5000\n\n; The number of benchmark programs to run.\n; Each one must be names \"Benchmark_N\" inside this package.\n:const int NUM_BENCHMARKS 1\n\n;\n; How many times to repeat the measurment, to try to get the best, stable value.\n; Note that you'll be able to see in-progress results before this point, and\n; that you can interrupt the process with F4, so there's little downside to this being large\n:const int NUM_REPEATS 1000\n\n;\n; Display variable for the number of elapsed cycles.\n; As a user, you'll only see the final count as that's when the frame ends.\n:global int benchmark_cycles\n"],["COD.Benchmark utils",":import COD.Benchmark lib\n; This is the file imported in your `Benchmark_N` script to create a complex action.\n\n:import Editor_actions lib\n\n; Macro used to inable output formatting\n#show_command(val) {lua(Editor.format_error_message = {val};)}\n\n; Form an action through Editor_actions lib\n; func must be a valid Editor_func (such as Editor_if)\n; args is a string of `n` arguments, where you separate them with `;`\n; replace is the argument you want to be replaced\n; copies is the number of copies you want to form\n;\n; For instance\n; if(true, 0, if(true, 0, 1)) looks like [Editor_if, true; 0; 1, 3, 1]\n; We call for the function `Editor_if` with the arguments `true, 0 and 1`\n; We want to replace the 3rd parameter and we want to copy this one more time;\n\n#function(func, args, replace, copies) {lua(\\\n  local args = {};\\\n  do\\\n    local input = [[{args}]];\\\n    --[[Extract our arguments]]\\\n    for arg in input:gmatch(\"[^;]+\") do\\\n      args[#args + 1] = arg:gsub(\" +\", \"\");\\\n    end\\\n  end\\\n  local func = string.gsub([[{func}]], \" +\", \"\");\\\n  --[[/*\\\n    * remove all spaces from the function name,\\\n    * Editor_actions has function names without spaces inside\\\n    *\\\n    * Throw an error if the requested func doesn't exist\\\n  */]]\\\n  if _G[func] == nil then\\\n    error([[Trying to call a non-function ]] .. func);\\\n  end\\\n  \\\n  local copies = tonumber({copies});\\\n  if copies == nil then\\\n    error(\"num_copies = {copies} is a nil argument.\");\\\n  elseif math.type(copies) ~= \"integer\" then\\\n    error(\"num_copes {copies} must be an integer!\\nGot type \" .. math.type(copies));\\\n  end\\\n  \\\n  local replace = tonumber([[{replace}]]);\\\n  if replace == nil then\\\n    error(\"replace = {replace} is nil.\");\\\n  elseif math.type(replace) ~= \"integer\" then\\\n    error(\"replace = {replace} must be an integer!\\nGot type \" .. math.type(replace))\\\n  end\\\n  \\\n  if #args < replace then\\\n    error(\"cannot replace argument {replace} when we have \" .. #args .. \" arguments\");\\\n  end\\\n  local action = _G[func](table.unpack(args));\\\n  for i = 1, copies do\\\n    local params = args;\\\n    params[replace] = action;\\\n    action = _G[func](table.unpack(params));\\\n  end\\\n  \\\n  if Editor.format_error_message == true then\\\n    Editor.assemble_error(action);\\\n  end\\\n  return action;\\\n)}\n\n; copy the term num_copies times\n#dup(term, num_copies) {lua(\\\n  if {num_copies} <= 1000 then\\\n    return string.rep([[{term}]], {num_copies});\\\n  end\\\n  local acc = {};\\\n  for i = 1, {num_copies} do\\\n    acc[i] = [[{term}]];\\\n  end\\\n  return table.concat(acc);\\\n)}\n"],["Budget_exec",":import COD.Benchmark lib\n:name {package(Budget_exec)}\n:budget_cap 200\n\n; This is an internal implementation of budget_exec so we can avoid the\n; extra checks needed to make to ensure that the package is working properly\nstop(impulse())\n;\n; This is standard for working with the budget system\n; We stop the script that started us to remove it from the execution queue and then\n; we call it to add it back to the execution queue\n;\nexecute(impulse())\n"],["Main",":import COD.Benchmark lib\n:name {package(Main)}\n:budget_cap 300\n\n; This is the main program for benchmarking.\n; There should be no need for manual modifications here; all the constants that need tweaking\n; are in COD.Benchmark lib. But it might be useful to understand how it works\n\n:global int benchmark_idx\n:local double start_time\n\nkey.b()\n\n#current_benchmark (benchmark_idx % (NUM_BENCHMARKS + 1))\n#bench_time local.double.get(\"b_time\" . {current_benchmark})\n#nanos(time) round(({time}) * (100.0 / NUM_CYCLES))\n\nglobal.string.set(\\\n  \"<size=0>c^0B\",\\\n  if(global.string.get(\"<size=0>c^0B\") == \"0</size>\", \"1\", \"0\") . \"</size>\"\\\n)\n; Toggle the script on/off\n;\ngotoif(if(impulse() == \"key.b\", start, end), contains(global.string.get(\"<size=0>c^0B\"), \"1\"))\nstop(\"{benchmark()}\" . {current_benchmark})\nstop(\"{package(Budget_exec)}\")\nexecute(\"{package(Budget_exec)}\")\n\nstart:\n; reset the idx to 0 in case we've already been run\nbenchmark_idx = 0\nloop:\n\n; Reset the benchmark cycles\nbenchmark_cycles = 0\nexecute(\"{benchmark()}\" . {current_benchmark})\n;\n; record our start time\nstart_time = now()\n\ngoto(if({current_benchmark} == 0, calc_base, wait_frame))\n; wait a frame if we're not calculating the base time\n;\ncalc_base:\ngotoif(wait_frame, benchmark_cycles == NUM_CYCLES)\n; Calculate the base payload i.e how much time it takes to\n; reach NUM_CYCLES without anything extra\nbenchmark_cycles += 1\ngotoif(calc_base, budget() > 200)\n\nwait_frame:\n; and trigger a waitframe to start the benchmark process\nwaitframe()\n\nlocal.double.set(\\\n  \"b_time\" . {current_benchmark},\\\n  min(\\\n    now() - start_time,\\\n    if({bench_time} == 0.0, 1.0 / 0.0, {bench_time})\\\n  )\\\n)\n;\n; Update the result display for the benchmark run\nglobal.string.set(\\\n  \"<color=#FFF>\" . if({current_benchmark} == 0, \"base\", \"benchmark_\" . {current_benchmark}),\\\n  \"last: \" . {nanos(now() - start_time)} . \"nS, \" .\\\n  \"best: \" . {nanos({bench_time})} . if(\\\n    {current_benchmark} == 0,\\\n    \"\",\\\n    \"nS, self: \" . {nanos({bench_time} - local.double.get(\"b_time0\"))}\\\n  ) . \"nS</color>\"\\\n)\n\n; Move to the next benchmark target\nbenchmark_idx += 1\ngotoif(loop, benchmark_idx < NUM_REPEATS * (NUM_BENCHMARKS + 1))\n\nend:\n; Toggle the script off when we're done\nglobal.string.set(\"<size=0>c^0B\", \"0</size>\")"],["Benchmark_1",":import COD.Benchmark utils\n:name {benchmark(1)}\n:budget_cap 10000\n\n{show_command(false)}\n\ngotoif(99, benchmark_cycles >= NUM_CYCLES)\n; Start of the benchmarker\n\n; The code to benchmark goes here\nwaituntil({function(Editor_math, true; ||; false, 3, 30)})\n\n;\n; End of the benchmarker\nbenchmark_cycles += 1\n; You increment benchmark_cycles by the number of actions you have\n; You have to increment by at least 1\n;\ngotoif(0, budget() > 200)\nre_exec:\nstop(\"{package(Budget_exec)}\")\nexecute(\"{package(Budget_exec)}\")\n"]]}}
```