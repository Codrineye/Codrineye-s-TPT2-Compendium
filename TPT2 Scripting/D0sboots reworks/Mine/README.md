# Autominer Collection

This is a collection of all D0S.Autominer iterations made for archival purposes.<br>
I've gone through and reworked a few things to make the code easier to understand and created additional comments for more details.<br>

```
{"workspaces":{"Autominer Collection":[["D0S.Autominer","; Script made before the introduction of the execution budget\n; Where every action took 1 frame, even atomics\n\n\n; Set this to 1 to get infinite-loop behavior\n#infinite 0\n\n; Compile-time code switch for small bits of code that are different\n; between infinite and non-infinite versions\n#if_infinite(true_part, false_part) {lua(\\\n  return {infinite}~=0 and [[{true_part}]] or [[{false_part}]]\\\n)}\n\n#name D0S.{if_infinite(InfiniMiner,Autominer)}\n:name {name}\n\nwakeup()\nopen.mine()\n\nisopen(\"mine\")\n\n:global int diggerpos\n:local int pos\n\n\ndiggerpos = diggerpos + 1\n; The execute is a no-op for the last one.\n; We create an extra Miner because, due to timing the\n; last two can't be distinguished by drillpos # by the time it's\n; assigned to pos.\n; This creates 35 copies, which will end up numbered 2-35 (with\n; two copies of 35).\nexecute(if(diggerpos < 35, \"{name}\", \"\"))\n\n; diggerpos is inc'd once by this script and once by the script we spawn\n; before this line is executed.\n; We use the 3rd-to-last copy as a control, and assign it the number 33.\n; It will handle tabbing. The last two copies get assigned\n; number position 32, and are responsible for new layers. All the rest\n; dig, according to their position. By having two copies for everything\n; (including layers) using numbers that are sequential, we guarantee that\n; each pair will alternate positions in the 2-action long loop, and thus\n; hit one action per frame.\n; We choose a late numbers for the tab/layer scripts so that all the\n; diggers are already rolling by the time they get to their logic.\nsetpos:\npos = if(\\\n  pos > 0,\\\n  {if_infinite(if(pos > 43, 33, pos + 1), pos + 1)},\\\n  if(\\\n    diggerpos == 34,\\\n    33,\\\n    if(diggerpos == 35, 32, diggerpos - 2)\\\n  )\\\n)\ntab(pos - 32)\n\ndigloop:\ndig(pos % 8 / 2, pos / 8)\nstall:\ngoto(if(\\\n  isopen(\"mine\") & diggerpos > 0,\\\n  if(\\\n    pos < 32,\\\n    digloop,\\\n    if(\\\n      pos == 32,\\\n      new_layer,\\\n      if(\\\n        hasLayers(),\\\n        stall,\\\n        {if_infinite(setpos, if(pos > 43, done, setpos))}\\\n      )\\\n    )\\\n  ),\\\n  done\\\n))\n\nnew_layer:\nnewlayer()\ngotoif(new_layer, isopen(\"mine\") & diggerpos > 0)\n\ndone:\ngu(\"diggerpos\")\n"],["D0S.AutominerV3","#script_name D0S.AutominerV3\n:name {script_name}\n\n; This line enables high-speed mode.\n:budget_cap max\n\n; These two impulses + one condition collectively mean that when you\n; enter the mine or start the AI while in the mine, the program will run.\nwakeup()\nopen.mine()\n\nisopen(\"mine\")\n\n; Our two state variables are \"tab\" and \"pos\".\n; These get stored in the global state when an instance is about to end,\n; so that each script instance is synced on what it needs to do.\n; When \"tab\" is 0, then \"pos\" is counting how many scripts remain to be launched.\n; 1 <= tab <= 12 means tab is the current tab, and \"pos\" denotes the current dig square.\n; If \"pos\" is 16, then we are switching tabs or refreshing layers, not digging.\n; If tab is 13, the script is ending, or (when should_loop = true)\n; waiting to try again next frame.\n\n:local int tab\n:local int pos\n\n:local bool should_loop\n:local bool first_script\n:local bool should_layer\n:local bool has_budget\n\n; Name of our global variable, used for hiding tab and pos\n; name includes @ and * to decrease the likelyhood that it's modified\n; by any other script other than ourselves\n#state \"<size=0>@m*\"\n#state.get global.string.get({state})\n#state.set(value) global.string.set({state}, {value})\n\n; Should the script loop infinitely?\nshould_loop = false\n\ngotoif(read_state, impulse() == \"{script_name}\")\n; Only set for the first out of all the parallel scripts,\n; used when looping to reset our state.\n\nfirst_script = true\npos = 89\ngoto(advance_state)\n\nread_state:\ntab = s2i(sub({state.get}, 1, 2), 1)\npos = s2i(sub({state.get}, 4, 2), 16)\n\n; abort if we're not in mine\n; advance state if there's a tab we can advance to\n; abort if we're not allowed to loop, otherwise, reset state\n; if we're the first instance, or waitframe if we're a digger\ngoto(if(not(isopen(\"mine\")), abort, if(\\\n  tab <= 12,\\\n  advance_state,\\\n  if(\\\n    should_loop,\\\n    if(first_script, reset_state, waitframe),\\\n    abort\\\n  )\\\n)))\n\nreset_state:\n; advance state will advance to a proper tab-change\ntab = 0\npos = 0\n\nadvance_state:\npos -= 1\ngotoif(check_budget, pos >= 0)\n; pos wrapped, need to advance tab properly\n\npos = 16\nshould_layer = tab >= 1 && hasLayers()\ntab += if(tab > 12 || should_layer, 0, 1)\n\ncheck_budget:\nhas_budget = budget() > 100\ngotoif(apply_state, has_budget && tab <= 12)\n\n{state.set(100 + tab . 100 + pos . \"</size>\" . if(\\\n  tab <= 12 || should_loop,\\\n  \"<color=#7B3F00>Mining...</color>\",\\\n  \"\"\\\n))}\n\napply_state:\ngoto(if(\\\n  tab == 0,\\\n  exec,\\\n  if(\\\n    tab > 12,\\\n    if(should_loop, waitframe, abort),\\\n    if(\\\n      pos == 16,\\\n      if(should_layer, newlayer, newtab),\\\n      dig\\\n    )\\\n  )\\\n))\n\nexec:\nexecute(\":{script_name}\")\ngoto(loop_end)\n\nnew_tab:\nnewtab:\ntab(tab)\ngoto(loop_end)\n\nnew_layer:\nnewlayer:\nnewlayer()\ngoto(loop_end)\n\nwaitframe:\nwaitframe()\ngoto(read_state)\n\ndig:\ndig(pos % 4, pos / 4)\n\nloop_end:\ngoto(if(has_budget, advance_state, read_state))\n\nabort:\n{state.set(\"113100</size>\")}\n"],["D0S.ExampleMiner","; A mining program that works quickly, but is also meant as an\n; example of how to code.\n;\n; This code is meant for the external editor at\n; https://d0sboots.github.io/perfect-tower/\n\n;\n; Sets the name of the script\n:name D0S.ExampleMiner\n\n; This line enables high-speed mode.\n:budget_cap max\n\n; These two impulses + one condition collectively mean that when you\n; enter the mine or start the AI while in the mine, the program will run.\nwakeup()\nopen.mine()\n\nisopen(\"mine\")\n\n; Local variables have their values contained within a single copy of the script,\n; and don't show in the \"variables\" list on the UI.\n; \n; boolean variables start with the value false.\n:local bool should_loop\n; \n; int variables start with the value 0.\n:local int tab\n:local int x\n:local int y\n\n; This is a label, which lets you goto() this line\n; without needing to figure out its line number.\n\nbegin:\n; Should the script loop infinitely?\nshould_loop = false\n\n; The rest of this is a relatively straightforward fast-mining script.\n\nnewtab:\n; this determines which tab in the mine we can enter\n; since tab(0) isn't a valid option, tab can have the values 1 through 12\n; he take advantage in priority order, 1 + happens after tab % 12\ntab = 1 + tab % 12\ntab(tab)\n; Skip newlayer after setting tab, because the first layer might have stuff\ngoto(loop)\n\nnewlayer:\nnewlayer()\n\n; The \"%\" returns the remainder after division. In this case it is being used\n; for wrap-around; when x is 3, (x+1) is 4 and 4%4 is 0. So it allows x to count\n; 0, 1, 2, 3, and back to 0 again in a cycle.\nloop:\ndig(x, y)\nx = (x + 1) % 4\ngotoif(loop, x != 0)\n\ny = (y + 1) % 4\ngotoif(loop, y != 0)\n\n; The most complicated line:\n; fall through the gotoif into `end` if we're not in the mine\n; jump to the lable `newlayer` if the tab has layers\n; jump to new tab if we aren't on the last tab\n; otherwise, jump to end\ngotoif(\\\n  if(\\\n    hasLayers(),\\\n    newlayer,\\\n    if(tab < 12, newtab, end)\\\n  ),\\\n  isopen(\"mine\")\\\n)\n\nend:\n; Wait for the end of the frame, so we don't waste time switching tabs\n; and checking things that can't have changed yet.\nwaitframe()\ngotoif(begin, should_loop && isopen(\"mine\"))"],["D0S.TurboMiner","; A mining program that uses turbo exec v2.2 to mine everything in\n; a single frame. (Unlike many of my scripts) it is designed to be\n; simple to understand, so that others can use it as a base for their\n; turbo-based programs.\n\n; D0S.TurboMiner is included for archival purposes\n; The turbo exec v2.2 (TE2.2) package was made so that scripts\n; could utilize the execution budget system before\n; it got implemented in version 0.49\n\n\nwakeup()\nopen.mine()\n\nisopen(\"mine\")\n\n; These are defined in turbo exec v2.2, and are available for public\n; use. turbo.cycles should never be written to, only read from.\n:global int turbo.cycles\n:global int turbo.cycles.max\n\n:local int tab\n:local int row\n:local int should_loop\n\nbegin:\n; This is the command to start turbo. Always use \"executesync\", so that you\n; know that turbo has started completely by the time it returns. Otherwise,\n; there may be timing complications if you set turbo.max.cycles.\nexecutesync(\"TE2.2:start\")\n\n; Increase the number of max cycles, so that we finish in one frame.\n; Always use this formula, which is designed to work even if another script\n; has started turbo before yours, or requested more cycles than yours needs.\n;\n; The number 3500 comes from the fact that each layer takes 25 cycles to mine.\n; With a maximum of 11*12 layers, that's 3300 cycles. 200 cycles are added\n; for additional potential overhead in the outer loops and other code.\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 3500)\n\n; Should the script loop infinitely?\nshould_loop = 0\n\n; The rest of this is a relatively straightforward fast-mining script.\n\nnewtab:\ntab = (tab % 12) + 1\ntab(tab)\n; Skip newlayer after setting tab, because the first layer might have stuff\ngoto(loop)\n\nnewlayer:\nnewlayer()\n\n; This loop is \"unrolled\" for speed.\n; Why does speed matter, when we're using turbo exec?\n; Well, even though everything will happen within one frame,\n; each line executed still takes some amount of real-word CPU time to process.\n; By cutting down on lines executed, we make that frame shorter, improving\n; the framerate.\n; Without unrolling, every dig takes 3 instructions.\n; With it, we execute 4 digs in 6 instructions, which is a huge improvement\n; from 200% overhead to just 50%.\n; Further unrolling, or optimizations elsewhere in the script would not\n; accomplish very much. (This is a general maxim: Make sure you are optimizing\n; what matters.)\nloop:\ndig(0, row)\ndig(1, row)\ndig(2, row)\ndig(3, row)\nrow = (row + 1) % 4\n\n; The most complicated line: jump to the correct place based on various conditions.\ngotoif(\\\n  if(\\\n    row != 0,\\\n    loop,\\\n    if(\\\n      hasLayers(),\\\n      newlayer,\\\n      if(tab < 12, newtab, end)\\\n    )\\\n  ),\\\n  isopen(\"mine\")\\\n)\n\nend:\n; This is the command to stop turbo. Just like with starting, always use\n; executesync so that the return is timed with the ending of the frame.\nexecutesync(\"TE2.2:stop\")\n\n; \"turbo stop\" gives us one extra cycle of turbo after it returns, because\n; that allows us to \"goto\" or do something else to make a loop and only have\n; a single frame break.\n; But that means it is *vital* that there's a no-op or other safe instruction\n; after \"turbo stop\", otherwise it will get run again because of turbo exec's\n; property that scripts keep running their last instruction instead of\n; exiting.\n; In this case, we'll either be looping to the beginning or stalling at\n; the end until the frame break.\ngotoif(begin, should_loop != 0 && isopen(\"mine\"))\n"]]}}
```