## D0S.Crates

This is a copy of the original D0S.Crates made by d0sboots kept for archival purposes.<br>
The version uses TE2.2 and was the best version we could have used at the time.

### Trading Post Crate Spam
I believe this to use the most efficient crate-gaining strategy currently possible, much better than using the e60 perk. It gets me 5e15 crates/sec from an idle income of 6e56/sec, and scales 10x per e5 of additional resources.
It uses turbo exec v2.2 to rapidly move between crate trading and idle mode, such that every rendered frame is in idle mode. **Turbo exec v2.2 is required:** (https://github.com/d0sboots/TPT2_scripts/blob/main/common/turbo_exec/README.md)

This requires the Air Stone to be active, and remember to put all your Town Perks into crate gain. Go to Tower Testing and enable 100% for cubes in Idle Mode, then press "o".

**This script is a bit finicky. It is working correctly if you are "staying" in idle mode, but the gains keep jumping around instead of increasing.**

`D0S.Crates:Idler_v2 1 1 22`
`D0S.Crates:Benchmark 1 1 12`
```
7VpRb+NEEP4rOQsJBMW1nV5PCklKOfqAhBASvOHqZK/Hyar2rtndNC13JxAgHW/wdoK3gz/ACw9IICTnj6G1ncRxdpNNk9BCUSXL2ezOznw7883spE8tjhjOBLc6nz21AiQwJfLd8keO4zqCjok9xiSiY5sP6dgPESVcBETI752j4hkKFkSYDDLKRWOCWzwd68BUXizoGJgALjAZKIW5lTAnHgABhpENV4BGAlS6ue33nU/sxywQwDsfRAmwJ5feTJuEoiCxIzoKE7A5NJU/8gWBK/FE4BR8Jp9cBGlmEzo2FxECiUoJcr4bMCyGKQiMqkUKMYPVmqiOwH2rMdwugV9+5r9MXuWvTqcGuFMQxwEWIyJwUg4jmmYBw5ySqZ6LAKi16G9szVyPhIZBYnPBMBkokZTT4i7HX0DPc/pdRBPKeuMhFtAPgaBhGrCLYuoxogQFQvuuUt1zOiVukcf9uFI9Tihlq87txsc59woljm/vyCsOjb3i28nL/OXpHAKNdfcPmckPxY4eOlUKaqc0MhVVf772rlJc3D0s/LrfPZSO3r8RVd0NopkDJ42YkfWAClplDWAkYNc2LiUtcE5JAypmUOksp0VqZqhSkzrmez3luNMY9fxYY+RKG3YJu9ftbRk/XkmBCkOa88jynA1ZevOzcI/PrrBM+Rr/N0hTt+sy/1QeU21+HGMSJLX8tTkvK4ZN8r0pG68h9U2Ll/1S+hIHnx9YiJIIL9bGXr2WxZxmQNZWx1IUTrNRwqEQdAHXdigHSZCC1bHem56/dWBlAboIBnJ0XsJazw8Wi3RWQo+J0Lma8zChNOPNKD/z5xX1XoJcToQpPc5j04FayFas6UC1ozRDF6yOGLGQ2ugaJcDtNLgyjE9Pm4cb6x9VZjCI+h8BRK1iw5a8XLQuPdt7MHeLBffQWXqHyEm5AXzMgPMWbQna4oJmTbM2ZOk7meAfKAHZ0HSvNN0gcxbsoc2eC26ui6plN5ffPZJLph92ES2lTc7rqvhv1wjLZhAz4MMZN9S/k+/qMmN9uLXzn/IfZ3+/n/y/+a1tbpBDXFx6Xq1KmHF3Y6wmTeOcUppRGeAt5yg9n5U3MYPdy3w4j8kabeFYqcFDDbjNVLaF6UrOUZ3nBlziQEkCDAaYC2DGR2hIMkvy93CoZYW5K8c7ZpCBpohWXOQ97VEoVX3TdLm+G6opJdRF0x2zf4vSa2XXd/se831FdQ1uxs12NuVIlGB04cdTKC8BVTVPDciQ0uTeoOs9e3abtubfFR7fvomd+Yu1axfyXv5V/pfyM1wCsmNG08eUsmjT5gOpugYpLttOwBEDkPEbiaEd6ZYpbvoumrz4fPYy+eNEx9KFx1bbDAEPhsJuIrswF2gmL9z2CNvyemBG/u3JN5Pf3vD9/PvJ1/mfJ1uisqSuOSzrGtGTn1cC1TyPnePkk3c+PCdf5r+a1qLTINlDjJkXK2Y33v8cB6qM3O5a74RlEclFoP4FV3eJd45wtOTx5bX2aK3l2qv6HizcYSfnJo0LxxANV3HLmV1NG7+082uClvQjn555tteRapXRUYIzIjKQR/+2bqB+dM15qrvFyhLJqIW8vjSuipCdNaRprSFd+5cJdT/6/Pnf
```

Also included is a benchmarking utility, useful for tuning the loop constant for your machine (for maximum performance). If you don't care, you can safely delete/disable it with no ill effect. Pressing "b" will run the crate trader for 15 seconds, and display the *exact* amount of time it ran, to let you calculate precise crates/sec. Obviously, you have to record crates before/after to make this work.

## Idler_v3

This is an unreleased, prototype version made by d0sboots that I took as a blueprint to understand the limitations of the budget system.<br>
This runs a master instance, 95 trading instances and a final version that enters idle mode.

```
1VhLj9s2EP4rrA5tkDiKtN4kwMYPNJsECZCi6QY91YuAokYSsTJHIal1t0lQoDm0t57bY9Mf0B4CNEBysf5YIVN+rEytvfbmBQMyNSS/Gc6beuYoJnmmlbP3wzOHMs1RlGNnEMUgQHLmxqhxkHueF2iQgsoTlws9IQDDYUYlVyjmtDjFgKbluxuDHgQMhdK0mt2dPK+niJmyTvm9GnnHkCdP79TTss7ftaz7yKIvC2MV3YvWXGdBdVrO0gFUwwGCjuI/QdfrfcnkuvKeB9+qoFXIvl8hKy25iBvBbyhNda6MMFOTmj1Gh9V+hkJTLpQNu8myU2zb3E0taVgysU52rpUq7TVKZfe1KrqCPGySyO9Yfdz76gwf2Q0qaYyZd7xeh2GKsish7N09OPj2oPtAqDyKOOMgNDHsvyDfZ7GkIZDHII9BkoOvvyFcEJ0Auf+d27k2wehND1pjud/AcpRwDb1Kdd1HEpQiSDQSpTGrYZaOsEbG+cAGNn4brI5MZnft2YlGlOvT/hFiHqSwVS46I5TNgp1ud8OU1C7+TYpX49/Gr4v/ir/rFm83ory3BPKkGXSmZPgRWK7Bhuq373iP3X1JNai9B2EK8slxe558FqwUSTqEzy0tNTD2dzSOhDviIsSRyxVmIJaAIo0jkBqUnu7aTjJcmYDuUZ5CWCYCCTqXohzxMAWX3EFygjlJ6DEQjUiGVJwQmQvBRUyqRqVfz0bnF3njejnZRCXXyRA0Z/NotdEuIoL9Kxu2Q2Z7e4hhHeBR8dJWgb1FV1EJjlY4yulZ/7xgJrsb981Q1dVj8PxPuSrc2LgqbJcJV+TYi9L9hTrGxJByakiWcnZktHAMzI0kDvcRZVjZbSGW5kXSRhbm3x1yYdAUkwClrKFO3LBpm6WW+az49elsULzt24PxcuVthk0CPE60Ww+wU2sBs/JG5ebcLSO9aWm9+L4sXl8aDMa/F7+M3/W31MqSuOurZVVZL/46U1F1e1y4ngbi1sND8fP4n/5yongvobhNrj/r5nh13Sw/Dcr2Qvi6EiIJKpk1LYtz5biuzrWbwPGf4z9mvzf9D8VgfjkqLckj6y3oegOPjS9bS7f31rIRtm85D1sOQxHy+XeWCd6C0AFiOtisebPeAZ4/XxutXhhKafkwy1MFE1mP4MTFkijKHnnPWWikM8qOaFwS56d2Wo5RuLN31W85uYLb1auWObw4fPE/
```

It also includes an idea of a built-in benchmarker that'd tell you how many crates you achieved, but it was scrapped when d0s realised that resource("crates") wouldn't exist until after version 1.0 got released.

## Source import

This is the re-formed source import.

```
{"workspaces":{"D0S.Crates":[["D0S.Crates lib","#package(name) D0S.Crates:{name}\n\n#benchmark b\n#start o\n\n#trading \"<size=20><color=white>trading\"\n#trading.get global.string.get({trading})\n#trading.set(msg) global.string.set({trading}, {msg})\n\n#exiting \"Exiting</color></size>\"\n"],["Benchmark",":import D0S.Crates lib\n; Script for benchmarking the efficiency of D0S.Idler_Crates.\n; Use this for tuning the loop constant.\n;\n; Use Full Precision for maximum resolution in benchmarking.\n\n:name {package(Benchmark)}\n\nisopen(\"tradingpost\")\n\nkey.{benchmark}()\n\n:local double next_time\n:local double end_time\n:global int turbo.register\n\n#bench \"<size=20><color=white>benchmark\"\n#bench.get global.string.get({bench})\n#bench.set(time) global.string.set({bench}, {time})\n\n#remaining (end_time - next_time)\n\n#seconds(x) (1e7 * {x})\n\nshow(\"tradingpost\", false)\nshow(\"towertesting\", true)\nexecute(\"{package(Idler_v2)}\")\n\nnext_time = now()\nend_time = next_time + {seconds(15)}\n\nloop:\nwaituntil(now() > next_time)\n{bench.set(\"0:\"\\\n  . floor({remaining} / {seconds(10)})\\\n  . floor({remaining} / {seconds(1)}) % 10.0\\\n  . \"</color></size>\"\\\n)}\n\nnext_time += {seconds(1)}\ngoto(if({trading.get} == \"\", end, if(next_time <= end_time, loop, cleanup)))\n\ncleanup:\n{trading.set({exiting})}\nwaituntil(gsg({trading}) == \"\")\n\nend:\n{bench.set(\"final:\" . (now() - end_time + {seconds(15)}) / {seconds(1)} . \"</color></size>\")}\n"],["Idler_v2","; Alternates between idle mode and trading crates.\n;\n; To use this, the air stone must be active, and you must be in\n; Tower Testing, with the correct idle mode already selected.\n;\n; Turbo Exec v2.2 is *required*!\n\n:import D0S.Crates lib\n:name {package(Idler_v2)}\n\nisopen(\"towertesting\") || isopen(\"tradingpost\")\n\nkey.o()\n\n:global int turbo.cycles.max\n:global int turbo.register\n:global string turbo.state\n:local int i\n:local int repeat\n:local int loops\n\n; Macro our status variable for readability.\n#running \"Press o to stop</color></size>\"\n\n; The ternary is for memory relief, see below.\n#click_launch click(\\\n  if(repeat % 2 == 0 || repeat % 5000 == 4999,\\\n    vec(-1., -1.),\\\n    {pos.relative(93.0 / 800.0, 29.0 / 450.0, 0.0, 0.0)}\\\n  )\\\n)\n\n; This variable is tunable, to reach the maximum crates/sec.\nloops = 325\n\n; This creates the toggle functionality.\n{trading.set(if(\\\n  turbo.cycles.max == 0,\\\n  \"<color=red>Need turbo exec v2.2!</color></color></size>\",\\\n  if({trading.get} == \"\", {running}, {exiting})\\\n))}\ngoto(if({trading.get} != {running}, end, repeat_loop))\n\n; This loop runs two frames:\n; The first starts in the Tower Testing screen in idle mode, leaves to go\n; to the trading post to trade crates, and then comes back and ends the\n; frame in Tower Testing, clicking the \"launch\" button to restart idle mode.\n;\n; The second frame simply runs one frame in idle mode without anything else\n; hapenning.\n;\n; It *seems* like you could merge the two into a single frame that does\n; everything. However, if you try that, the trades don't function, despite\n; the fact that you can tell (from the idle counter being reset each frame)\n; that it is still leaving and coming back, interrupting idle mode each frame.\n;\n; The only conclusion I have is that the end-of-frame click \"locks in\" a\n; transition effect to the idle screen on the next frame; with this locked in,\n; the trading post doesn't function correctly. With a one frame cooldown,\n; everything works as expected.\n\nmain_loop:\n; This is hoisted here, so that it occurs sufficiently far after starting\n; turbo.\nturbo.cycles.max = max(turbo.cycles.max, 10000)\n\n; This loop is unrolled by four iterations to reduce the overhead of the\n; looping constructs. We spend most of our time in this loop (even with\n; turbo, and accounting for the fact that we spend an entire frame elsewhere),\n; so it pays to keep it efficient.\nloop:\nrefresh()\ntrade(0, 0.1)\nrefresh()\ntrade(0, 0.1)\nrefresh()\ntrade(0, 0.1)\nrefresh()\ntrade(0, 0.1)\ni = (i + 1) % loops\ngotoif(loop, i > 0)\n\n; Starting and stopping turbo is handled by this mini-loop. It is handled\n; at a low-level here by directly manipulating the \"turbo.register\" variable,\n; instead of calling \"turbo start\" and \"turbo stop\". This is done for speed,\n; and also to save lines, because it allows us to handle two halves of the\n; code by repeating this block.\n;\n; Everything is controlled by the \"repeat\" variable, which is always either\n; even or odd. Normally the loop is exited when repeat is odd, and thus it\n; will be odd on the first iteration, *except* when the script starts.\n;\n; When repeat is odd, register is decremented, stopping turbo. Then we move\n; from the trading post back to towertesting, and click the launch button.\n; Finally, we increment repeat. The turbo framework has enough delay built-in\n; to let us do all this before turbo expires, or more accurately usually\n; turbo will expire at the end of incrementing repeat.\n;\n; There is one extra wrinkle here: Very rarely, we will not leave the trading\n; post, and thus spend two frames in the trading post doing nothing.\n; This is to prevent a Unity bug where work accumulates due to moving in\n; and out of idle while never displaying a frame that is not in idle mode.\n; When the run is eventually finished, all this work is dispatched, causing\n; a large memory bump that may cause a crash. Instead, we periodically let\n; a \"useless\" frame render to discharge this work. By hapenning rarely\n; enough, it doesn't impact crates/sec too badly.\n;\n; The next instruction is the master \"goto\", which dispatches depending on\n; state. At this point, repeat is even, so we repeat the instruction until\n; turbo.state is \"idle\". Usually it will already by \"idle\" by the time we\n; get to this instruction, but this ensures that we are sync'd to the\n; proper frame boundary. Specifically, we spend one frame on the transition\n; from \"active\" to \"idle\", and one frame after we jump to the top of\n; repeat_loop. This ensures the 2-frame pattern.\n;\n; Now that repeat is even, we enable turbo. This is where we enter the loop\n; when the script first starts. We then move to the tradingpost, and the\n; click fires on an inert part of the UI. Lastly, we increment repeat\n; back to odd.\n;\n; In the second half of the master goto, we abort the script if it's been\n; signalled that it should stop, otherwise we jump back to the top.\n;\n; Being compound statements, all of these are more expensive to execute\n; than simple statements. But they are only run twice per overall iteration,\n; i.e. they make up a handful of cycles out of thousands, so the cost is\n; negligible.\n\nrepeat_loop:\nturbo.register = turbo.register + 1 - (repeat % 2) * 2\nshow(if(repeat % 2 == 0, \"towertesting\", \"tradingpost\"), false)\nshow(if(repeat % 2 == 0, \"tradingpost\", \"towertesting\"), true)\n{click_launch}\nrepeat = repeat + 1\n\n; We spend an extra frame on this wait, because it happens outside of turbo.\n; (The last cycle of turbo expires on the click above.) It is vital that this\n; *does* happen outside of turbo; if there is another script running with\n; turbo on, it will mess up the timing here. (It would be a bad idea anyway,\n; because it would be hogging CPU and slowing down your trades.)\nwait:\ngoto(if(\\\n  repeat % 2 == 0,\\\n  if(turbo.state != \"idle\", wait, repeat_loop),\\\n  if(gsg({trading}) == {running}, main_loop, exit)\\\n))\n\nexit:\nexecutesync(\"TE2.2:stop\")\n\nend:\nglobal.unset(if(turbo.cycles.max == 0, \"\", {trading}))"],["Idler_v3","; Alternates between idle mode and trading crates.\n;\n; To use this, the air stone must be active, and you must be in\n; Tower Testing or Trading Post, with resources set up in idle mode.\n;\n; Doesn't use Turbo Exec.\n\n#name D0S.Crates:Idler_v3\n:name {name}\n:budget_cap max\n\n; Used to begin the variable hiding block, also counts overall iterations (frames)\n#iter \"<size=0>&cr\"\n#get_iter gig({iter})\n#set_iter(v) gis({iter}, {v})\n\n:global int loops\n:global string status\n\n:local double last_now\n:local double last_crates\n:local double time_sum\n:local double crates_sum\n\n#status(msg) \"</size><size=20>{msg}</color></size>\"\n#running {status(<color=white>trading=Press o to stop)}\n#finished \"</size>\"\n\nisopen(\"towertesting\") || isopen(\"tradingpost\")\n\nkey.o()\n\ngoto(if(\\\n  loops > 1,\\\n  trade,\\\n  if(loops > 0, to_idle, setup)\\\n))\n\nsetup:\n{set_iter(0)}\nloops = 0\nstatus = if(\\\n  contains(status, \"trading\"),\\\n  {finished},\\\n  if(\\\n    budget() < 10000,\\\n    {status(<color=red>ERROR=Insufficient budget! Upgrade Server RAM in the HQ.)},\\\n    {running}\\\n  )\\\n)\ngoto(if(contains(status, \"trading\"), main_begin, end))\n\nmain:\n; Every 50000 iterations, we wait a frame before trading. Waiting for 0\n; does nothing, while waiting for a positive value waits (at least) a whole frame.\n; This is to prevent a Unity bug where work accumulates due to moving in\n; and out of idle while never displaying a frame that is not in idle mode.\n; When the run is eventually finished, all this work is dispatched, causing\n; a large memory bump that may cause a crash. Instead, we periodically let\n; a \"useless\" frame render to discharge this work. By hapenning rarely\n; enough, it doesn't impact crates/sec too badly.\nwait(if({get_iter} == 0, 0.00001, 0.))\n\n; Dispatch to ourselves to do the actual trading. Each copy will do 33 trades and then\n; create a new child in turn. The final copy will clean up by returning to idle mode,\n; before the frame finishes.\nloops = 95\nexecute(\"{name}\")\n\nwaitframe()\nstatus = if(\\\n  contains(status, \"trading\"),\\\n  if(\\\n    isopen(\"towertesting\"),\\\n    status,\\\n    {status(<color=red>ERROR=Failed to return to idle. Do you have too many running scripts?)}\\\n  ),\\\n  status\\\n)\n\nmain_begin:\n{set_iter(({get_iter} + 1) % 50000)}\n\nshow(\"towertesting\", false)\nshow(\"tradingpost\", true)\n\ngoto(if(contains(status, \"trading\"), main, end))\n\nto_idle:\nloops = 0\n\nshow(\"tradingpost\", false)\nshow(\"towertesting\", true)\n\n{click.relative(93.0 / 800.0, 29.0 / 450.0, 0.0, 0.0)}\ngoto(end)\n\ntrade:\nloops -= 1\n\ntrade_loop:\nrefresh()\ntrade(0, 0.1)\ntrade(0, 0.1)\n\ngotoif(trade_loop, budget() > 300)\nexecute(\"{name}\")\nend:\n"]]}}
```
