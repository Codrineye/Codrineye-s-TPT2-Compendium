# C0D.Trader

This is an adaptation of [D0S.Crates](../D0S.Crates/README.md) to use the execution budget.<br>
Just like its predecesor, this script travels between the idle screen and the trading post. The frame always ends with you back in the idle screen.

## The import package

The package comes with 2 scripts.<br>
* [Main](./Main.tpt2) is the script that holds all of the logic for trading.<br>
  This has the following 3 variables used for configuration:
  - `prioritize_trades` (false by default) determines if the script will prioritize trades over crates of vice versa.
  - `traders` (20 by default) is an integer value that specifies how many trading scripts are made.
  - `cycles` (5 by default) is another integer that reprezents how many "sets" of traders are created before the script takes a break.

* [Benchmarker](./Benchmarker.tpt2) is a utility script made for you to fine tune the number of `traders` and `cycles`.<br>
  This has the following 4 variables used for configuration:
  - `counting_up` (false by default) modifies if the benchmark timer is counting up or down.
  - `seconds` (15 by default) is a double value that dictates for how many seconds you'd like a benchmark run to last for.
  - `minutes` (0 by default) is a double value that dictates for how many minutes you'd like a benchmark run to last for.
  - `hours` (0 by default) is a double value that dictates for how many hours you'd like a benchmark run to last for.

`Main` features an information UI that can either give you an error or tell you that you're trading.<br>
The minimum budget that still works at "full efficiency" is of 501. If `prioritize_trades` is true, you'll need a minimum budget of 1601 for the script to finish all 12 trades before running out of budget.<br>
You start/stop the script by pressing `key.o`, altho this is configurable in the [source import](#source-import).

`Benchmarker` features a clock in its UI that will always end with `benchmark=final_time:` when `Main` is stopped.<br>
If `counting_up` is false, then the timer will read `benchmark=remaining_time:` and it'll end `Main` when the same number of seconds elapse as the sum of your inputed seconds, minutes and hours.<br>
If `counting_up` is false, then the timer will read `benchmark=elapsed_time:` and it'll ignore the inputed seconds, minutes and hours.<br>
You start the script by pressing `key.b` whilst in the trading post. You cannot start another benchmark process until `Main` terminates.<br>
This impulse is also configurable in the [source import](#source-import).

## Pre-requisits

For this script to be useful, you must toggle on the Air Stone infinity perk to make the refresh() action functional.<br>
Additionally, you must select your Town Resource Idle Production inside of your idle screen.

If `prioritize_trades` is false, you'll also want to put all your skill points into the crate factor town perk to improve the ammount of crates you get.

## Script Import

The script import requires:
- minimum budget_cap of 501 or 1601
- 1 impulse
- 2 conditions
- 35 max actions
- 2 script slots

This package is also dependent on [Budget_exec](../../../Budget%20Exec/README.md). `Main` will throw an error if it cannot detect it to be running.

```
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
```

## Source Import

The source import is strictly for the [external editor](https://d0sboots.github.io/perfect-tower/).<br>
This lets you see how the code works, and modify the impulses defined in [COD.Trader lib](COD.Trader%20lib.tpt2).

```
{"workspaces":{"C0D.Trader":[["COD.Trader lib","; Keep naming between the trader and benchmarker consistent\n; so they're in the same package\n#package(name) C0D.Trader:{name}\n;\n\n; Impulse macros\n#start o\n#benchmark b\n;\n; Import budget exec so we can extend our budget.\n:import budget exec_lib\n\n; Variable definitions\n;\n; Iterations holds the frame at which we're activated.\n; This value is important to prevent a unity bug that's explained in Main.\n:const string iteration \"<size=0>C%t.I\"\n#iteration.get global.int.get(iteration)\n#iteration.set(value) global.int.set(iteration, {value})\n;\n; Number of loops we want to do in a frame.\n:const string loops \"C%t.L\"\n#loops.get global.int.get(loops)\n#loops.set(loops) global.int.set(loops, {loops})\n;\n;\n; Status holds the scripts status and it communicates with the user.\n; Its name stops the hiding block and it starts an unfinished <color block that gets filled\n; when we set it.\n:const string status \"C%t.S</size><color\"\n#status.get global.string.get(status)\n#status.set(status) global.string.set(status, {status})\n"],["Main",":import COD.Trader lib\n:name {package(Main)}\n:budget_cap max\n\n; Variable definitions\n;\n:local bool prioritize_trades\n; Determine if we prioritise trades over crates\n;\n; Variables used to configure number of loops\n:local int traders ; How many instances to create in a cycle\n:local int cycles  ; How many cycles to run in a frame\n\nkey.{start}()\n\n; Don't activate if outside of towertesting or tradinpost\nisopen(\"towertesting\") || isopen(\"tradingpost\")\n\n; A comment written in lua.\n; This offers a small TLDR inside of a condition such that the user\n; doesn't have to leave the game if they're confused about anything\n;\n#condition_comment {lua(\\\n  local msg = table.pack(\\\n    \"</size>\",\\\n      \"<br>prioritize_trades changes your priority\",\\\n        \"<br>\\ttrue = prioritize trades over crates\",\\\n        \"<br>\\tfalse = prioritize crates over trades\",\\\n      \"<br>traders = how many scripts do the trading\",\\\n      \"<br>cycles = how many traders you want to have before leaving trading post\",\\\n      \"<br>\",\\\n      \"<br>\",\\\n      \"<br>more traders = better efficiency\",\\\n      \"<br>more cycles = faster speeds\",\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg);\\\n)}\n\n; This is the conditional comment. It checks if a string contains an empty string,\n; which is always true.\ncontains(concat(\"click here for info!<size=0>\", \"{condition_comment}\"), \"\")\n\nprioritize_trades = false\n\ntraders = 20\ncycles = 5\n\n; Initialize our globals\n{iteration.set(if(impulse() == \"key.{start}\", time.frame(), {iteration.get}))}\n{loops.set(-1 + if(\\\n  {loops.get} == 0 || impulse() == \"key.{start}\",\\\n  traders * cycles,\\\n  {loops.get}\\\n))}\n\n; We need a budget of at least 501 to perform a trade in the worst case scenario.\n; Having less than that would mean that we have cycles * (traders - 1) ammount of trades\n; instead of cycles * traders.\n{status.set(if(\\\n  contains(\"{accelerate_budget}|{package(Main)}\", impulse()),\\\n  {status.get},\\\n  if(\\\n    contains({status.get}, \"#\")\\\n    || budget() < 501 || gsg(budget_exec_var) != \"</size>\" || traders > 99,\\\n    \"red\",\\\n    \"#FFF\"\\\n  ) . \">\" . if(\\\n    budget() > 500 && gsg(budget_exec_var) == \"</size>\" && traders < 100,\\\n    if(contains({status.get}, \"#\"), \"\", \"trade=Press {start} to stop!\"),\\\n    \"ERROR=\" . if(\\\n      global.string.get(budget_exec_var) != \"</size>\",\\\n      \"{accelerate_budget} IS NOT RUNNING\",\\\n      if(\\\n        budget() < 501,\\\n        \"INSUFFICIENT BUDGET! Upgrade Server RAM in HQ\",\\\n        \"TOO MANY TRADERS! You can have at most 99 traders\"\\\n      )\\\n    ) . \"!\"\\\n  ) . \"</color>\"\\\n))}\n\ngoto(if(\\\n  contains(\"{accelerate_budget}|{package(Main)}\", impulse()),\\\n  if({loops.get} == -1 + traders * cycles, enter_idle, refresh),\\\n  if(contains({status.get}, \"trade=\"), start, end)\\\n))\n\nenter_idle:\n{status.set(if(contains({status.get}, \"trade=\"), {status.get}, \"red></color>\"))}\ngotoif(end, contains({status.get}, \"red><\"))\n\nshow(\"tradingpost\", false) ; Exit trading post\nshow(\"towertesting\", true) ; Enter towertesting\n\n; clicks the idle mode button on the towertesting screen\n{click.relative(93.0 / 800.0, 29.0 / 450.0, 0.0, 0.0)}\nwaitframe() ; Let our resources build up for the remaning frame\n\nstart:\nshow(\"towertesting\", false) ; Exit towertesting\nshow(\"tradingpost\", true)   ; Enter trading post\n\ngotoif(refresh, (time.frame() - {iteration.get}) % 50001 < 50000)\n\n; Wait a frame if we've been running for 50000 frames\n; This is to prevent a unity bug where work builds up and eventually offloads all at once, which\n; can cause the game to crash.\n; 50000 is just a random value picked by d0sboots a while ago.\n\nwaitframe:\nwaitframe()\n\ntrader:\ngotoif(prevent_waste, impulse() != \"{accelerate_budget}\" || {loops.get} == -1 + traders * cycles)\nstop(\"{accelerate_budget}\")\n\nprevent_waste:\nexecute(if({loops.get} % traders == 0, \"{accelerate_budget}\", \"{package(Main)}\"))\ngoto(refresh)\n\n; To lower stress on the users device, this operation is unrolled.\n; Otherwise, making a trade() gotoif() would increase the number of operations to process from\n; 11 to 22. Doubling the stress that's already being put on it.\n\ntop:\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\n\n; We refresh the available trades, so we have 12 available trades once again.\nrefresh:\nrefresh()\n\n; We take the first trade.\ntrade:\ntrade(1, 0.0)\n\n; If we're about to use up our last action, or prioritize_trades is active, we\n; go to the top. Otherwise, we refresh.\ngoto(if(prioritize_trades || budget() == 100, top, refresh))\n\n\nend:"],["Benchmarker",":import COD.Trader lib\n:name {package(Benchmarker)}\n:budget_cap 200\n\n:local bool counting_up\n; Determines if the timer is counting up or down\n;\n; Get the seconds, minutes and hours that you want the timer to be running for\n; Ignored if we're counting up\n:local double seconds\n:local double minutes\n:local double hours\n;\n:local double time_sum\n;\n:local double start_time ; The time we started at\n:local double time       ; The time we're at\n\n; Macro definitions\n; Get seconds in relation to time.now()\n#seconds(time) (1e7 * ({time}))\n;\n; Display the tens and ones digit of a number, to display a clock\n#clock(offset) floor(time / {seconds(({offset}) * 10.0)}) % 6.0\\\n             . floor(time / {seconds({offset})}) % 10.0\n\n;\n:const string benchmark \"<color=#FFF>Benchmark\"\n\n;\nkey.{benchmark}()\n\nisopen(\"tradingpost\")\n\n; Only make an instance if the status is shut down.\n; This works even if status.get is uninitialized.\ncontains(\"red></color>\", {status.get})\n\ncounting_up = false\nseconds = 15.0\nminutes = a.d(0.0, \"*\", 60.0)\nhours = a.d(0.0, \"*\", 60.0 * 60.0)\n\nstart_time = now()\ntime_sum = start_time + {seconds(seconds + minutes + hours)}\nexecute(\"{package(Main)}\")\n\nloop:\nwaitwhile(\\\n  contains({status.get}, \"trade=\") && now() < time + {seconds(1.0)} && (\\\n    counting_up ||\\\n    now() < time_sum\\\n  )\\\n)\n\ntime = if(counting_up, now() - start_time, time_sum - now())\nglobal.string.set(benchmark, if(counting_up, \"elapsed\", \"remaining\") . \"_time:\" . if(\\\n  time < {seconds(60.0)},\\\n  \"\",\\\n  if(time < {seconds(60.0 * 60.0)}, \"0\", {clock(60.0 * 60.0)}) . \":\"\\\n) . if(time < {seconds(60.0)}, \"0\", {clock(60.0)}) . \":\" . {clock(1.0)})\n\n{status.set(if(\\\n  counting_up || now() < time_sum,\\\n  {status.get},\\\n  \"\"\\\n))}\ngotoif(loop, contains({status.get}, \"trade=\"))\n\nwaituntil({status.get} == \"red></color>\")\n\ntime = now() - start_time\nglobal.string.set(benchmark, \"final_time:\" . if(\\\n  time < {seconds(60.0)},\\\n  \"\",\\\n  if(time < {seconds(60.0 * 60.0)}, \"0\", {clock(60.0 * 60.0)}) . \":\"\\\n) . if(time < {seconds(60.0)}, \"0\", {clock(60.0)}) . \":\" . floor(time / {seconds(10.0)}) % 6.0\\\n  . (time / {seconds(1.0)}) % 10.0)\n"],["Benchmark results","; Configuration of the benchmarker\n;\n; Use the determine_stats function to see what gives the best trades and crates/second\n; This is done to plop it into a text editor to view things easier.\n;\n; You have a data string called data. You start by defining the test environment\n; number of traders, number of cycles, count of trades and crates before the tests\n;\n; Every configuration will have 10 tests. First 5 are with prioritise_trades = true\n; Last 5 are with prioritise_trades = false.\n;\n; You start with the number of trades you got, then the number of crates you got and finally\n; the ammount of time it took\n;\n; traders cycles\n; start count of crates\n; start count of trades\n;   trades on test 1\n;   crates on test 1\n;   time on test 1\n;\n;   trades on test 2\n;   crates on test 2\n;   time on test 2\n;\n; after 10 tests. you add a `|` to declair a new configuration\n; Set adding_data to true when you're adding data and to false when you want the output\n\n{lua(\\\n  local adding_data = true\\\n  local function determine_stats(data_string)\\\n    if not data_string:find(\"|\") then\\\n      error(\"\\n\\nMark a new data set with |\", 0)\\\n    end\\\n    local chunk = {};\\\n    \\\n    for config in data_string:gmatch(\"[^|]+\") do\\\n      local new = {};\\\n      new.crates, new.trades, new.time = {}, {}, {};\\\n      local counter = 0;\\\n      for data in config:gmatch(\"[^%s+]+\") do\\\n        \\\n        data = tonumber(data);\\\n        \\\n        if counter == 0 then\\\n          new.traders = data;\\\n        elseif counter == 1 then\\\n          new.cycles = data;\\\n        elseif counter % 3 == 2 then\\\n          new.crates[#new.crates + 1] = data;\\\n        elseif counter == 3 or counter % 3 == 1 then\\\n          new.trades[#new.trades + 1] = data;\\\n        else\\\n          new.time[#new.time + 1] = data;\\\n        end\\\n        counter = counter + 1;\\\n      end\\\n      if new.traders ~= nil then\\\n        chunk[#chunk + 1] = new;\\\n      end\\\n    end\\\n    local msg = {};\\\n    for i = 1, #chunk do\\\n      local target = chunk[i];\\\n      local text = table.pack(\\\n        \"\\n\",\\\n        \"\\nConfig \", i,\\\n        \"\\ntraders = \", target.traders,\\\n        \"\\ncycles = \", target.cycles\\\n      );\\\n      for word = 1, #text do\\\n        msg[#msg + 1] = text[word];\\\n      end\\\n      for j = 1, #target.time do\\\n        text = table.pack(\\\n          \"\\n\",\\\n          \"\\nTest \", j, \", prioritise_trades = \", j <=#target.time / 2 and \"true\" or \"false\",\\\n          \"\\ntest duration = \", target.time[j],\\\n          \"\\ntrades = \", target.trades[j + 1] - target.trades[j],\\\n          \"\\ntrades / sec = \", (target.trades[j + 1] - target.trades[j]) / target.time[j],\\\n          \"\\ncrates = \", target.crates[j + 1] - target.crates[j],\\\n          \"\\ncrates / sec = \", (target.crates[j + 1] - target.crates[j]) / target.time[j]\\\n        );\\\n        for word = 1, #text do\\\n          msg[#msg + 1] = text[word];\\\n        end\\\n      end\\\n    end\\\n    error(table.concat(msg), 0)\\\n  end\\\n  local data = [[\\\n  20 5\\\n  2791376028566030000000000000000\\\n  575786419\\\n    576726547\\\n    2792986956747540000000000000000\\\n    15.2138496\\\n    \\\n    577649803\\\n    2794561524976010000000000000000\\\n    15.1472256\\\n    \\\n    578581453\\\n    2796146386094370000000000000000\\\n    15.3313152\\\n    \\\n    579504709\\\n    2797720353187240000000000000000\\\n    15.1209216\\\n    \\\n    580453147\\\n    2799319087079480000000000000000\\\n    15.129584\\\n    \\\n    {lua(-- switch to prioritise_trades = false)}\\\n    \\\n    580942607\\\n    2801071869914700000000000000000\\\n    15.1803392\\\n    \\\n    581417082\\\n    2802790240354360000000000000000\\\n    15.1952512\\\n    \\\n    581901547\\\n    2804539933268360000000000000000\\\n    15.1787392\\\n    \\\n    582391007\\\n    2806309085112850000000000000000\\\n    15.1235072\\\n    \\\n    582865482\\\n    2808037289317270000000000000000\\\n    15.3402624\\\n  |\\\n  \\\n  10 5\\\n  2808037289317270000000000000000\\\n  582865482\\\n    \\\n    583309962\\\n    2845068782632830000000000000000\\\n    15.2086016\\\n    \\\n    583750248\\\n    2882112258090570000000000000000\\\n    15.2338176\\\n    \\\n    584190534\\\n    2918916980694460000000000000000\\\n    15.164672\\\n    \\\n    584630820\\\n    2955888262403150000000000000000\\\n    15.2775488\\\n    \\\n    585058524\\\n    2991803579912580000000000000000\\\n    15.1440512\\\n    \\\n    585290509\\\n    3028619208521580000000000000000\\\n    15.1865088\\\n    \\\n    585539959\\\n    3068019436287960000000000000000\\\n    15.17504\\\n    \\\n    585784419\\\n    3106914707420250000000000000000\\\n    15.1992704\\\n    \\\n    586021394\\\n    3144729780652870000000000000000\\\n    15.175488\\\n    \\\n    586263359\\\n    3183065893727480000000000000000\\\n    15.1019008\\\n  |\\\n  20 5\\\n  3183065893727480000000000000000\\\n  586263359\\\n    586273349\\\n    3183152957436000000000000000000\\\n    0.2448512\\\n  |\\\n  1 1\\\n  3183152957436000000000000000000\\\n  586273349\\\n    586278200\\\n    3183153020358770000000000000000\\\n    0.1588992\\\n  |\\\n  20 5\\\n  3183153020358770000000000000000\\\n  586278200\\\n    589216100\\\n    3318569381902810000000000000000\\\n    60.220979200000002\\\n    \\\n    590739525\\\n    3468381171991390000000000000000\\\n    60.2045952\\\n    \\\n  |\\\n  ]];\\\n  \\\n  if adding_data then\\\n    return;\\\n  end\\\n  determine_stats(data);\\\n)}\n\n"]]}}
```

The source also gives you access to [Benchmark results](Benchmark%20results.tpt2), which is a helper lua macro I made to help configure the default value of `traders` and `cycles`.<br>
This also covers how to use the benchmarker.

## How to use the benchmarker

To use the benchmarker, you import the [source import](#source-import) and enter `Benchmark results`.<br>
You're going to look for a variable defined as `local data`, and this is where you'll want to input your data.<br>
You start by the number of traders and cycles. Then, the number of crates you have and then the number of trades you have.

To get the numer of crates you have, you enable full notation in settings, enter the Trading Post and look at the **Production Bodus** Trading Reward. Since this reward is number of crates ^ 1, that value is just the number of crates you have.

Then, after you've put in the number of crates and trades, you input the data.<br>
Run the benchmarker, input the number of trades you have, input the number of crates you have and input the value of `benchmark=final_time:`. This program does not work with the formatted time, that's just for it to look pretty. You can either modify the benchmarker to no longer format the `final_time` or you can just do some multiplication.<br>

Once you've got a number of benchmarker tests you're happy with, you can set the value of `local adding_data = true` to `local adding_data = false` for an error message to get formed. That shows you all the inputed data.<br>

You can ignore when it tells you when `prioritize_trades = true` or ` = false` because that shouldn't matter for you.