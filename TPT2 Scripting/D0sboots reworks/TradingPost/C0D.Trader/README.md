# C0D.Trader

This is an adaptation of [D0S.Crates](../D0S.Crates/README.md) to use the execution budget.<br>
Just like its predecesor, this script travels between the idle screen and the trading post. The frame always ends with you back in the idle screen.

# Additionally, this script requires **mt12+**

## The import package

The package comes with 2 scripts.<br>
* [Main](./Main.tpt2) is the script that holds all of the logic for trading.<br>
  This has the following 3 variables used for configuration:
  - `prioritize_trades` (false by default) determines if the script will prioritize trades over crates of vice versa.
  - `traders` (20 by default) is an integer value that specifies how many trading scripts are made.
  - `cycles` (5 by default) is another integer that reprezents how many "sets" of traders are created before the script takes a break.

* [Benchmarker](./Benchmarker.tpt2) is a utility script made for you to fine tune the number of `traders` and `cycles`.<br>
  This has the following 4 variables used for configuration:
  - `counting_up` (false by default) modifies if the benchmark timer is counting up or down.
  - `seconds` (15 by default) is a double value that dictates for how many seconds you'd like a benchmark run to last for.
  - `minutes` (0 by default) is a double value that dictates for how many minutes you'd like a benchmark run to last for.
  - `hours` (0 by default) is a double value that dictates for how many hours you'd like a benchmark run to last for.

`Main` features an information UI that can either give you an error or tell you that you're trading.<br>
The minimum budget that still works at "full efficiency" is of 501. If `prioritize_trades` is true, you'll need a minimum budget of 1601 for the script to finish all 12 trades before running out of budget.<br>
You start/stop the script by pressing `key.o`, altho this is configurable in the [source import](#source-import).

`Benchmarker` features a clock in its UI that will always end with `benchmark=final_time:` when `Main` is stopped.<br>
If `counting_up` is false, then the timer will read `benchmark=remaining_time:` and it'll end `Main` when the same number of seconds elapse as the sum of your inputed seconds, minutes and hours.<br>
If `counting_up` is false, then the timer will read `benchmark=elapsed_time:` and it'll ignore the inputed seconds, minutes and hours.<br>
You start the script by pressing `key.b` whilst in the trading post. You cannot start another benchmark process until `Main` terminates.<br>
This impulse is also configurable in the [source import](#source-import).

## Prerequisits

For this script to be useful, you must toggle on the Air Stone infinity perk to make the refresh() action functional.<br>
Additionally, you must select your Town Resource Idle Production inside of your idle screen.

If `prioritize_trades` is false, you'll also want to put all your skill points into the crate factor town perk to improve the ammount of crates you get.

## Script Import

The script import requires:
- minimum budget_cap of 501 or 1601
- 1 impulse
- 2 conditions
- 30 max actions
- 2 script slots

This package is also dependent on [Budget_exec](../../../Budget%20Exec/README.md). `Main` will throw an error if it cannot detect it to be running.

```
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
```

## Source Import

The source import is strictly for the [external editor](https://d0sboots.github.io/perfect-tower/).<br>
If you get the error `C0D.Trader lib:11: Import failed: Script "budget exec_lib" does not exist!`, you'll also need the source import of [Budget Exec](../../../Budget%20Exec/MANUAL.md#import).<br>
This lets you see how the code works, and modify the impulses defined in [COD.Trader lib](COD.Trader%20lib.tpt2).

```
{"workspaces":{"C0D.Trader":[["COD.Trader lib","; Keep naming between the trader and benchmarker consistent\n; so they're in the same package\n#package(name) C0D.Trader v1.2:{name}\n;\n\n; Impulse macros\n#start o\n#benchmark b\n;\n; Import budget exec so we can extend our budget.\n:import budget exec_lib\n\n; Variable definitions\n;\n; Number of loops we want to do in a frame.\n:const string loops \"<size=0>C%t.L\"\n#loops.get global.int.get(loops)\n#loops.set(loops) global.int.set(loops, {loops})\n;\n;\n; Status holds the scripts status and it communicates with the user.\n; Its name stops the hiding block and it starts an unfinished <color block that gets filled\n; when we set it.\n:const string status \"C%t.S</size><color\"\n#status.get global.string.get(status)\n#status.set(status) global.string.set(status, {status})\n"],["Main",":import COD.Trader lib\n:name {package(Main)}\n:budget_cap max\n\n; Variable definitions\n;\n:local bool prioritize_trades\n; Determine if we prioritise trades over crates\n;\n; Variables used to configure number of loops\n:local int traders ; How many instances to create in a cycle\n:local int cycles  ; How many cycles to run in a frame\n\nkey.{start}()\n\n; Don't activate if outside of towertesting or tradinpost\nisopen(\"towertesting\") || isopen(\"tradingpost\")\n\n; A comment written in lua.\n; This offers a small TLDR inside of a condition such that the user\n; doesn't have to leave the game if they're confused about anything\n;\n#condition_comment {lua(\\\n  local msg = table.pack(\\\n    \"</size>\",\\\n      \"<br>prioritize_trades changes your priority\",\\\n        \"<br>\\ttrue = prioritize trades over crates\",\\\n        \"<br>\\tfalse = prioritize crates over trades\",\\\n      \"<br>traders = how many scripts do the trading\",\\\n      \"<br>cycles = how many traders you want to have before leaving trading post\",\\\n      \"<br>\",\\\n      \"<br>\",\\\n      \"<br>more traders = better efficiency\",\\\n      \"<br>more cycles = faster speeds\",\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg);\\\n)}\n\n; This is the conditional comment. It checks if a string contains an empty string,\n; which is always true.\ncontains(concat(\"click here for info!<size=0>\", \"{condition_comment}\"), \"\")\n\nprioritize_trades = false\n\ntraders = 20\ncycles = 5\n\n; Initialize our globals\n{loops.set(-1 + if(\\\n  {loops.get} == 0 || impulse() == \"key.{start}\",\\\n  traders * cycles,\\\n  {loops.get}\\\n))}\n\n; We need a budget of at least 501 to perform a trade in the worst case scenario.\n; Having less than that would mean that we have cycles * (traders - 1) ammount of trades\n; instead of cycles * traders.\n{status.set(if(\\\n  contains(\"{accelerate_budget}|{package(Main)}\", impulse()),\\\n  {status.get},\\\n  if(\\\n    contains({status.get}, \"#\")\\\n    || budget() < 501 || gsg(budget_exec_var) != \"</size>\" || traders > 99,\\\n    \"red\",\\\n    \"#FFF\"\\\n  ) . \">\" . if(\\\n    budget() > 500 && gsg(budget_exec_var) == \"</size>\" && traders < 100,\\\n    if(contains({status.get}, \"#\"), \"\", \"trade=Press {start} to stop!\"),\\\n    \"ERROR=\" . if(\\\n      global.string.get(budget_exec_var) != \"</size>\",\\\n      \"{accelerate_budget} IS NOT RUNNING\",\\\n      if(\\\n        budget() < 501,\\\n        \"INSUFFICIENT BUDGET! Upgrade Server RAM in HQ\",\\\n        \"TOO MANY TRADERS! You can have at most 99 traders\"\\\n      )\\\n    ) . \"!\"\\\n  ) . \"</color>\"\\\n))}\n\ngoto(if(\\\n  contains(\"{accelerate_budget}|{package(Main)}\", impulse()),\\\n  if({loops.get} == -1 + traders * cycles, enter_idle, trader),\\\n  if(contains({status.get}, \"trade=\"), start, end)\\\n))\n\nenter_idle:\n{status.set(if(contains({status.get}, \"trade=\"), {status.get}, \"red></color>\"))}\ngotoif(end, contains({status.get}, \"d><\"))\n\nshow(\"tradingpost\", false) ; Exit trading post\nshow(\"towertesting\", true) ; Enter towertesting\n\n; clicks the idle mode button on the towertesting screen\n{click.relative(93.0 / 800.0, 29.0 / 450.0, 0.0, 0.0)}\nwaitframe() ; Let our resources build up for the remaning frame\n\nstart:\nshow(\"towertesting\", false) ; Exit towertesting\nshow(\"tradingpost\", true)   ; Enter trading post\n\ntrader:\nexecute(if({loops.get} % traders == 0, \"{accelerate_budget}\", \"{package(Main)}\"))\ngoto(refresh)\n\n; To lower stress on the users device, this operation is unrolled.\n; Otherwise, making a trade() gotoif() would increase the number of operations to process from\n; 11 to 22. Doubling the stress that's already being put on it.\n\ntop:\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\ntrade(1, 0.0)\n\n; We refresh the available trades, so we have 12 available trades once again.\nrefresh:\nrefresh()\n\n; We take the first trade.\ntrade:\ntrade(1, 0.0)\n\n; If we're about to use up our last action, or prioritize_trades is active, we\n; go to the top. Otherwise, we refresh.\ngoto(if(prioritize_trades || budget() == 100, top, refresh))\n\nend:"],["Benchmarker",":import COD.Trader lib\n:name {package(Benchmarker)}\n:budget_cap 200\n\n:local bool counting_up\n; Determines if the timer is counting up or down\n;\n; Get the seconds, minutes and hours that you want the timer to be running for\n; Ignored if we're counting up\n:local double seconds\n:local double minutes\n:local double hours\n;\n:local double time_sum\n;\n:local double start_time ; The time we started at\n:local double time       ; The time we're at\n\n:local double crates\n:local double crates_per_sec\n:local double crates_exponent\n\n; Macro definitions\n; Get seconds in relation to time.now()\n#seconds(time) (1e7 * ({time}))\n;\n; Display the tens and ones digit of a number, to display a clock\n#clock(offset) floor(time / {seconds(({offset}) * 10.0)}) % 6.0\\\n             . floor(time / {seconds({offset})}) % 10.0\n\n;\n:const string benchmark \"<color=#FFF>Benchmark\"\n#benchmark.get global.string.get(benchmark)\n#benchmark.set(text) global.string.set(benchmark, {text})\n\n;\nkey.{benchmark}()\n\nisopen(\"tradingpost\")\n\n; Only make an instance if the status is shut down.\n; This works even if status.get is uninitialized.\ncontains(\"red></color>\", {status.get})\n\ncounting_up = false\nseconds = 15.0\nminutes = a.d(0.0, \"*\", 60.0)\nhours = a.d(0.0, \"*\", 60.0 * 60.0)\n\nstart_time = now()\ntime_sum = start_time + {seconds(seconds + minutes + hours)}\ncrates = resource(\"crates\")\nexecute(\"{package(Main)}\")\n\nloop:\nwaitwhile(\\\n  contains({status.get}, \"trade=\") && now() < time + {seconds(1.0)} && (\\\n    counting_up ||\\\n    now() < time_sum\\\n  )\\\n)\n\ntime = if(counting_up, now() - start_time, time_sum - now())\n{benchmark.set(\\\n  if(counting_up, \"elapsed\", \"remaining\") . \"_time:\" . if(\\\n    time < {seconds(60.0)},\\\n    \"\",\\\n    if(time < {seconds(60.0 * 60.0)}, \"0\", {clock(60.0 * 60.0)} . \":\")\\\n  ) . if(time < {seconds(60.0)}, \"0\", {clock(60.0)}) . \":\" . {clock(1.0)}\\\n)}\n\n{status.set(if(\\\n  counting_up || now() < time_sum,\\\n  {status.get},\\\n  \"\"\\\n))}\ngotoif(loop, contains({status.get}, \"trade=\"))\n\nwaituntil({status.get} == \"red></color>\")\n\ntime = now() - start_time\ncrates_per_sec = (resource(\"crates\") - crates) / time\ncrates_exponent = floor(crates_per_sec // 10.0)\n{benchmark.set(\\\n  \"final_time:\" . if(\\\n    time < {seconds(60.0)},\\\n    \"\",\\\n    if(time < {seconds(60.0 * 60.0)}, \"0\", {clock(60.0 * 60.0)} . \":\")\\\n  ) . if(time < {seconds(60.0)}, \"0\", {clock(60.0)}) . \":\"\\\n    . floor(time / {seconds(10.0)}) % 6.0 . (time / {seconds(1.0)} % 10.0)\\\n  . \"<br>crates_per_second:<br>\" . if(\\\n    crates_exponent > 6.0,\\\n    sub(d2s(crates_per_sec), 0, 1) . \".\" . sub(d2s(crates_per_sec), 1, 3) . \"E\" . crates_exponent,\\\n    sub(\"000\" . floor(crates_per_sec / 1000.0), 0, 3) . \",\" .\\\n    sub(\"000\" . floor(crates_per_sec % 1000.0), 0, 3)\\\n  )\\\n)}\n"],["Benchmark results","; Configuration of the benchmarker\n;\n; Use the determine_stats function to see what gives the best trades and crates/second\n; This is done to plop it into a text editor to view things easier.\n;\n; You have a data string called data. You start by defining the test environment\n; number of traders, number of cycles, count of trades and crates before the tests\n;\n; Every configuration will have 10 tests. First 5 are with prioritise_trades = true\n; Last 5 are with prioritise_trades = false.\n;\n; You start with the number of trades you got, then the number of crates you got and finally\n; the ammount of time it took\n;\n; traders cycles\n; start count of crates\n; start count of trades\n;   trades on test 1\n;   crates on test 1\n;   time on test 1\n;\n;   trades on test 2\n;   crates on test 2\n;   time on test 2\n;\n; after 10 tests. you add a `|` to declair a new configuration\n; Set adding_data to true when you're adding data and to false when you want the output\n\n{lua(\\\n  local adding_data = true\\\n  local function determine_stats(data_string)\\\n    if not data_string:find(\"|\") then\\\n      error(\"\\n\\nMark a new data set with |\", 0)\\\n    end\\\n    local chunk = {};\\\n    \\\n    for config in data_string:gmatch(\"[^|]+\") do\\\n      local new = {};\\\n      new.crates, new.trades, new.time = {}, {}, {};\\\n      local counter = 0;\\\n      for data in config:gmatch(\"[^%s+]+\") do\\\n        \\\n        data = tonumber(data);\\\n        \\\n        if counter == 0 then\\\n          new.traders = data;\\\n        elseif counter == 1 then\\\n          new.cycles = data;\\\n        elseif counter % 3 == 2 then\\\n          new.crates[#new.crates + 1] = data;\\\n        elseif counter == 3 or counter % 3 == 1 then\\\n          new.trades[#new.trades + 1] = data;\\\n        else\\\n          new.time[#new.time + 1] = data;\\\n        end\\\n        counter = counter + 1;\\\n      end\\\n      if new.traders ~= nil then\\\n        chunk[#chunk + 1] = new;\\\n      end\\\n    end\\\n    local msg = {};\\\n    for i = 1, #chunk do\\\n      local target = chunk[i];\\\n      local text = table.pack(\\\n        \"\\n\",\\\n        \"\\nConfig \", i,\\\n        \"\\ntraders = \", target.traders,\\\n        \"\\ncycles = \", target.cycles\\\n      );\\\n      for word = 1, #text do\\\n        msg[#msg + 1] = text[word];\\\n      end\\\n      for j = 1, #target.time do\\\n        text = table.pack(\\\n          \"\\n\",\\\n          \"\\nTest \", j, \", prioritise_trades = \", j <=#target.time / 2 and \"true\" or \"false\",\\\n          \"\\ntest duration = \", target.time[j],\\\n          \"\\ntrades = \", target.trades[j + 1] - target.trades[j],\\\n          \"\\ntrades / sec = \", (target.trades[j + 1] - target.trades[j]) / target.time[j],\\\n          \"\\ncrates = \", target.crates[j + 1] - target.crates[j],\\\n          \"\\ncrates / sec = \", (target.crates[j + 1] - target.crates[j]) / target.time[j]\\\n        );\\\n        for word = 1, #text do\\\n          msg[#msg + 1] = text[word];\\\n        end\\\n      end\\\n    end\\\n    error(table.concat(msg), 0)\\\n  end\\\n  local data = [[\\\n  20 5\\\n  2791376028566030000000000000000\\\n  575786419\\\n    576726547\\\n    2792986956747540000000000000000\\\n    15.2138496\\\n    \\\n    577649803\\\n    2794561524976010000000000000000\\\n    15.1472256\\\n    \\\n    578581453\\\n    2796146386094370000000000000000\\\n    15.3313152\\\n    \\\n    579504709\\\n    2797720353187240000000000000000\\\n    15.1209216\\\n    \\\n    580453147\\\n    2799319087079480000000000000000\\\n    15.129584\\\n    \\\n    {lua(-- switch to prioritise_trades = false)}\\\n    \\\n    580942607\\\n    2801071869914700000000000000000\\\n    15.1803392\\\n    \\\n    581417082\\\n    2802790240354360000000000000000\\\n    15.1952512\\\n    \\\n    581901547\\\n    2804539933268360000000000000000\\\n    15.1787392\\\n    \\\n    582391007\\\n    2806309085112850000000000000000\\\n    15.1235072\\\n    \\\n    582865482\\\n    2808037289317270000000000000000\\\n    15.3402624\\\n  |\\\n  \\\n  10 5\\\n  2808037289317270000000000000000\\\n  582865482\\\n    \\\n    583309962\\\n    2845068782632830000000000000000\\\n    15.2086016\\\n    \\\n    583750248\\\n    2882112258090570000000000000000\\\n    15.2338176\\\n    \\\n    584190534\\\n    2918916980694460000000000000000\\\n    15.164672\\\n    \\\n    584630820\\\n    2955888262403150000000000000000\\\n    15.2775488\\\n    \\\n    585058524\\\n    2991803579912580000000000000000\\\n    15.1440512\\\n    \\\n    585290509\\\n    3028619208521580000000000000000\\\n    15.1865088\\\n    \\\n    585539959\\\n    3068019436287960000000000000000\\\n    15.17504\\\n    \\\n    585784419\\\n    3106914707420250000000000000000\\\n    15.1992704\\\n    \\\n    586021394\\\n    3144729780652870000000000000000\\\n    15.175488\\\n    \\\n    586263359\\\n    3183065893727480000000000000000\\\n    15.1019008\\\n  |\\\n  20 5\\\n  3183065893727480000000000000000\\\n  586263359\\\n    586273349\\\n    3183152957436000000000000000000\\\n    0.2448512\\\n  |\\\n  1 1\\\n  3183152957436000000000000000000\\\n  586273349\\\n    586278200\\\n    3183153020358770000000000000000\\\n    0.1588992\\\n  |\\\n  20 5\\\n  3183153020358770000000000000000\\\n  586278200\\\n    589216100\\\n    3318569381902810000000000000000\\\n    60.220979200000002\\\n    \\\n    590739525\\\n    3468381171991390000000000000000\\\n    60.2045952\\\n    \\\n  |\\\n  ]];\\\n  \\\n  if adding_data then\\\n    return;\\\n  end\\\n  determine_stats(data);\\\n)}\n\n"]]}}
```
