# Source Export

```
{"workspaces":{"C0D.Adventure":[["Adventure lib","; Name for the package\n#package(name) C0D.Adventure:{name}\n\n; Key assignments\n;\n; start/stop the script\n#start r\n; Tries to kill all enemies in the room\n; Tries to perform the farm-keys sequence\n#kill k\n\n; Don't compile the script if key.start would be the same as key.kill\n{lua(\\\n  if \"{start}\" == \"{kill}\" then\\\n    local err_msg = table.pack(\\\n      \"\\n\",\\\n      \"\\nImpulses must be different!\",\\\n      \"\\nkey.{start} for start cannot be the same as key.{kill} for kill!\"\\\n    );\\\n    error(table.concat(err_msg), 0)\\\n  end\\\n)}\n\n; Variable definitions\n;\n; Scripts status determines if we're shut down or not\n; It also communicates with the user\n:const string status \"<size=0>A^qSt\"\n#status.get global.bool.get(status)\n#status.set(toggle) global.bool.set(status, {toggle})\n;\n; The path variable holds the path we follow.\n:const string path \"A^qPh\"\n#path.get global.string.get(path)\n#path.set(path) global.string.set(path, {path})\n;\n; The scripts target positions.\n; This is a list that holds the direction of the exit we must take to reach our target room\n:const string target_positions \"A^qTn\"\n#target.get global.string.get(target_positions)\n#target.set(position) global.string.set(target_positions, {position})\n;\n; Lastly, the encoding.\n; This string holds a list of everything that's in the room.\n:const string room \"A^qEc<color\"\n#room.get global.string.get(room)\n#room.set(room) global.string.set(room, {room})\n; The room encoding stops the hiding block and acts as a UI for the script.\n; Since this is also used for UI, it has the start of a <color block that'll get finished\n; when we set its value.\n;\n\n; Macros for processing data\n;\n; operations to determine the next direction to move into\n; Uses the UDLR direction to determine what value to return\n; Returns vec(0.0, 0.0) if an invalid direction is given\n; \n#nextX(dir) s2d(sub(\" 0 0 1-1\", index(\"U D L R\", {dir}, 0), 2), 0.0)\n#nextY(dir) s2d(sub(\" 1-1 0 0\", index(\"U D L R\", {dir}, 0), 2), 0.0)\n#nextDir(dir) vec({nextX({dir})}, {nextY({dir})})\n;\n; Determine the current difficulty we're at\n#curr_diff(inc) min(\\\n  x(adventure.roomCoords()),\\\n  254.0 - x(adventure.roomCoords())\\\n) + min(\\\n  y(adventure.roomCoords()),\\\n  254.0 - y(adventure.roomCoords())\\\n) - (254.0 - {inc})"],["How to adventure",";\n; Adventure is composed of 3 parts:\n; The rooms\n; The enemies/player\n; The loot\n;\n; Rooms are a 19x19 square with 4 exits/entrances \n; The tiles are indexed by 0 and start from the bottom right corner\n; Exits:\n; R = 00, 09\n; U = 09, 18\n; L = 18, 09\n; D = 09, 00\n;\n; The tiles spanning 01,01 -> 17,17 hold a maze that must be traversed \n; This maze consists of different tiles:\n; Empty tiles can be traversed through \n; Wall tiles cannot be moved through. You need to clear the room and have the Phase Boots item\n; Rock and Gate tiles are like Wall tiles, but these can be destroyed by using a bomb\n;\n; Apart from tiles, the room also contains entities \n; The player is the entity you control. You move into entity tiles to turn them into Empty tiles\n; if you have the right item. Moving into an entity tile pushes the player back, so 2 entity tiles\n; will never overlap.\n; 1. Chests require no item to be opened. All chests from a room must become empty tiles\n;    for a room to be considered cleared.\n; 2. Gates require 1 key to be opened. They are placed before chests, so it's required to\n;    open all gates to reach all chests.\n; 3. Rocks require the Hammer item to be broken. They are the same as Gates.\n;\n; The final entities are enemies. These are directly linked to the rooms distance\n; Rooms are controlled by distance\n; d0 = room 127,127\n; d1 = rooms 128,127 + 127,128 + 126,127 + 127,126\n; all the way up to d255 = 0,255 + 255,255 + 255,0 + 0,0 (the 4 corners of the map)\n;\n; 255 + 255 = 0 + 255 = 0 + 0 = 255 + 0 = 255\n; so the distance is calculated as max(x, 254 - x) + max(y, 254 - y) - 254\n; with the only wrinkle being that 255, 255 = d256, but the game only goes up to 255\n\n;\n; There are 3 types of enemies:\n; \"Enemy\" is found from d1.\n; Number in room = round(distance * 0.1 + 3.0)\n; Health = min(round(difficulty * 0.38 + 1.0), 99)\n; Attack = min(ceil(difficulty * 0.39), 99)\n; Armor = min(round(difficulty * 0.08), 99)\n;\n;\n; \"Elite\" is found from d80.\n; Number in room = floor(distance * 0.01) + 1.0\n; Health = min(ceil(round(difficulty * 0.38 + 1.0) * 1.8), 99)\n; Attack = min(ceil(ceil(difficulty * 0.39) * 1.5), 99)\n; Armor = min(round(difficulty * 0.08), 99)\n;\n;\n; \"Mimic\" is found from d101.\n; There are `n` chests in any given room, every chest has a chance to be a mimic\n; Health = min(ceil(round(distance * 0.38 + 1.0) / 1.2), 99)\n; Attack = min(ceil(ceil(distance * 0.39) * 1.2), 99)\n; Armor = min(floor(round(distance * 0.8) * 2.0 + 1.0), 99)\n\n;\n;\n; \"Enemy\"s have a 25% chance to drop a key once killed \n;\n; Elites have a 0.05% chance to spawn but always spawn in the same number.\n; They are the 24th roll in any given room.\n; Additionally, killing an elite will guarantee a bomb drop\n;\n; Mimics are disguised as chests and become mimics after casting IdentifyRoom or interacting \n; with the mimic. This is the chance that a chest is a mimic (d - 100) * 0.003 + 0.05\n;\n;\n; Chests are guaranteed to spawn in every room except for the starting room\n; Starting from d1, every room has 1 chest in it\n; Starting from d3, every room has 2 chests in it\n; From d5, rnd(2, 3) chests\n; d9 = rnd(2, 4) chests\n; d16 = rnd(3, 6) chests\n; d31 = rnd(4, places_of_interest) chests\n; d129 = maximum number of chests\n;\n; Chests always have 3 walls around them, so there can only ever be 1 obstacle in your way\n; from d0, if `0.32 < rnd(0.0, 1.0)` then an obstacle spawns\n; from d16, if `0.65 < rnd(0.0, 1.0)` then an obstacle spawns\n; from d100, there's always an obstacle spawns\n;\n; If an obstacle spawns, if rock_chance > 0.8 then a rock is spawned, otherwise, a gate spawns.\n; from d0, rock_chance is 0\n; from d16, rock_chance is rnd(0.0, 1.0)\n; from d100, rock_chance is rnd(0.6, 1.0)\n; from d128, rock_chance is 1\n"],["Adventure game-plan","; How to AI Adventure\n;\n; The script needs to move by using adventure.move(vec()), with the vector being\n; vec(0, 1/-1) or vec(1/-1, 0), as vec(0, 0) doesn't move anywhere and we can't move diagonally\n;\n; Making only 1 move and then re-evaluating the game map is slow, so I create a list of\n; every move that I'll do. Since we can only move Up Down Left and Right, we can easily\n; use the characters UDLR to indicate where to move. Our other options are to place a bomb\n; and to wait, so Bomb can be denoted as B and Wait can be W. This gives us a dictionary of\n; UDLRWB = Up Down Left Right Wait Bomb\n;\n; When we clear a room, we must first kill all enemies and then pick our chests\n; If we don't have the phase boots unlocked, we prioritise chests furthest away from the exit.\n; If we do have the phase boots, we grab the last chest that's closest to our entrance so that\n; the furthest chest requires the minimum ammount of deviation\n;\n;\n; The key idea is to have a target room that we're trying to reach.\n; If we're at room 127, 127 and want to reach room 150, 90. We'd want to go diagonally until\n; we reached 150, 104 and then go down until we've reached 150, 90. Important to note is that\n; I'll prioritize moving on the x axis over moving on the y axis unless moving on the x axis\n; will cause us to enter an already cleared room and moving on the y axis will not.\n;\n; Picking rooms via a targetting system as apposed to a distance from center system helps\n; add full map completion to the script while also removing user interraction. If we cannot\n; survive the destination, we don't make it our target.\n;\n;\n; Every room will be encoded using a string after they're cleared of elites and enemies.\n; at this moment in time, kill enemies remains unchanged.\n; This encoding string will use the characters EWDRC to mean\n; Empty Wall Door Rock and Chest respectively\n; Each of the exits will also be encoded with the numbers 1234 for UDLR\n; And the Player will be called \"P\"\n;\n;\n; Target difficulty is calculated to guarantee that the player doesn't lose hp\n; This means that we use the player stats to determine the maximum difficulty we can reach\n;\n; We must fulfill one of 2 conditions\n; playerAttack >= enemyHealth + enemyArmor\n; Which is, at its base, floor((attack - 1) / (0.38 + 0.08)) + offset\n; where the offset is added because of the round() of both enemy health and enemy armor\n; this offset is a 23 array of the numbers 11120111210111210121201 that's indexed by attack % 23\n;\n; playerArmor >= enemyAttack\n; Which is floor(armor / 0.39)\n{lua(\\\n  local throw_error = false;\\\n  local function ceil(value)\\\n    local val = math.floor(value * 100);\\\n    return math.ceil(val / 100);\\\n  end\\\n  local player = {};\\\n  player.att = ceil(50 * 1.1);\\\n  player.arm = 39;\\\n  player.str = {};\\\n  local i = 0;\\\n  for word in string.gmatch(\"11120111210111210121201\", \"%d\") do\\\n    player.str[i] = tonumber(word);\\\n    i = i + 1;\\\n  end\\\n  local err_msg = table.pack(\\\n    \"\\n\",\\\n    \"\\nAtt = \", player.att, \" and Att diff = \", math.floor((player.att - 1.0) / 0.46) +\\\n    player.str[player.att % 23],\\\n    \\\n    \"\\nArm = \", player.arm, \" and Arm diff = \", math.floor(player.arm / 0.39)\\\n  );\\\n  if throw_error then\\\n    error(table.concat(err_msg), 0);\\\n  end\\\n)}\n"],["Main",":import Adventure lib\n:name {package(Main)}\n\n:local bool has_mastered\n\n:local double max_diff\n:local double player_attack\n\n:local int i\n:local int jump_target\n\n:local string target_dir\n;\n:local vector cur_pos\n:local vector target_pos\n\n; Impulses\n\nkey.{start}()\nkey.{kill}()\n\n; Conditions\n\n;\n; Only start the AI if we're in an active game of adventure\nadventure.playerHealth() > 0\n\n; Actions\n\n;\n; Toggle the script on/off. Shut down the script if we're triggered by key.kill\n{status.set(not({status.get}) && impulse() != \"key.{kill}\")}\n; This also starts a hiding block\n\n{path.set({path.get})} ; Do not overrite the value of path\n{target.set({target.get})} ; Do not overrite the value of our target positions\n\n;\n; End our hiding block.\n; This is used to encode the room we're in, so its value always changes\n; If we're here because of key.kill, we'll change our value to display \"Killing Enemies\" in red\n; Otherwise, if we're shutting down, we write \"Shutting Down...\" in white and if we're starting\n; up, we write \"Starting Up...\" in blue\n; The color block gets broken once we're running and have the room encoded\n{room.set(concat(\\\n  if(impulse() == \"key.{kill}\", \"red\", if({status.get}, \"#0DF\", \"#FFF\")) . \">\",\\\n  \"</size>\" . if(\\\n    impulse() == \"key.{kill}\",\\\n    \"Killing Enemies\",\\\n    if({status.get}, \"Starting Up\", \"Shutting Down\") . \"...\"\\\n  ) . \"</color>\"\\\n))}\n\ngoto(if({status.get}, top, if(impulse() == \"key.{start}\", end, 99)))\n\n; --- Start Loop ---\n\ntop:\n; Sets the player attack.\n; Used to determine how much damage is actually dealt\nplayer_attack = ceil(i2d(adventure.playerAttack()) * if(adventure.hasItem(\"impaler\"), 1.1, 1.0))\n\n; Determine if we have a master item\nhas_mastered = has_mastered || adventure.hasItem(\"masterSword\") || adventure.hasItem(\"masterArmor\")\n\n; Get the maximum difficulty we can reach\n; Important to note that this is not always our target difficulty\n#offsets 11120111210111210121201\nmax_diff = if(\\\n  has_mastered,\\\n  255.0,\\\n  floor(max(\\\n    i2d(adventure.playerArmor()) / 0.39,\\\n    (player_attack - 1.0) / 0.46 + s2d(sub(\"{offsets}\", d2i(player_attack % 23.0), 1), 0.0)\\\n  ))\\\n)\n\n\n\nbuild_target:\n; Determine what our target room is and build towards it\n; \n\nloop:\n\ngotoif(top, {status.get} && adventure.playerHealth() > 0)\n\n{status.set(false)} ; deactivate the script if adventure is no longer active\n\nend:\n{room.set(\"red></size></color>\")}"]]}}
```

