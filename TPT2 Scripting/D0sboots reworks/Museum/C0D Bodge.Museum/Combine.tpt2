:import museum_macros
:name {script(Combine)}

; This script is responsible for actually combining gems.
;
; That's true in two senses: It both has the actual call to Combine(), and
; also the logic immediately surrounding it that runs the combines and checks
; to see if the loop is done.

:global int museum_tier
:global int target_tier
:global int museum_pos

:global double end_time

:local int buy_amount


buy_amount = max(1, (target_tier - museum_tier - 5) * 3)
end_time = if(now() <= end_time, end_time, now() + 10000000.0 / 5.0)

combine:
museum.buyTier(element("inventory", 0), museum_tier, buy_amount)
combine(50)
combine(50)
combine(50)
goto(if(\
  tier("inventory", 0) >= target_tier || tier("inventory", 27) == -1,\
  done,\
  if(\
    now() >= end_time,\
    waitframe,\
    if(budget() < 400, trampoline, combine)\
  )\
))

waitframe:
waitframe()

trampoline:
execute("{script(Buy)}")
goto(end)

done:
; Now that we're done, move the finished stone back to "equipped". This also
; moves partial/original stones back, if we cancelled via {start}.
;
; Even though this happens after signalling, we get one extra cycle as a
; "delay slot" before we're stopped by Main.
museum.moveTo("inventory", 0, "loadout", museum_pos)
gotoif(done, tier("inventory", 0) != -1)

; This is the signal for Main that it should continue.
museum_tier = -5

end: