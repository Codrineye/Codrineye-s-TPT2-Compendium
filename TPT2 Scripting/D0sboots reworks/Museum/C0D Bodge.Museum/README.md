# C0D Bodge.Museum

A temporary fix of D0S.Museum for up until d0s releases D0S.Museum v5.

Import code:
```
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
```

Source Import:
```
{"workspaces":{"museum2":[["museum_macros","; Standardized (package) naming across all the scripts\n#script(name) C0D Bodge.Museum:{name}\n:budget_cap max\n\n; Keybindings. You can edit these here, or edit them in the scripts directly\n; (but it will be much more error-prone).\n#up w\n#down s\n#start m\n\n; Name of the budget variable, which begins the script-hiding block.\n#budget \"<size=0>mb**\"\n\n; Turn an element string into an index. For our purpose, all the indexes\n; need to be multiplied by two, so we look for the index of the first two\n; characters of the element.\n; The \"offset\" string allows us to concatenate on a string and thus add a\n; constant to the result.\n#element_to_index_base(ele, offset) index({offset} . \"lielfidanaaiwaeaun\", sub({ele}, 0, 2), 0)\n\n; Macro for determining the number of tiers we can boost, given our budget and\n; stones of \"in_tier\".\n; We allocate 1% of budget to each stone. Based on the tier of the stones we\n; can buy, they cost 2000 * 18^in_tier / 18 each. (We ignore the extra cost\n; of universal stones.) This determines how many stones we can buy, and thus,\n; the max tier.\n; There is an extra division by 9 and a floor. This means that if the level can't\n; be raised by at least 2 levels, the quantity in the log will be rounded down to 0,\n; and thus the log will result in -infinity. We add back the 2 levels on the outside.\n#up_tiers(in_tier) floor(gdg({budget}) / (100. * 2000. * 9. / 18.) / (18. ^ ({in_tier}))) // 3. + 2.\n\n; The top tier that can be achieved, given input stones of \"in_tier\". Capped\n; either at +11 levels, or by the budget function of up_tiers.\n; If we can't reach +2 levels, up_tiers returns -inf, which will result in -1.\n; from this function.\n#top_tier(in_tier) max(-1., min(50., min(11., {up_tiers({in_tier})}) + ({in_tier})))\n"],["Buy",":import museum_macros\n:name {script(Buy)}\n\n; This isn't included in this subdirectory, but comes from the factory/ directory.\n:import worker_storage_lib\n\n; This script is responsible for buying all stones.\n;\n; It also contains initialization logic for variables. They must be set in the\n; proper order, so that the remain hidden inside our <size=0> block. This also\n; reads/writes the budget from worker storage, and increment/decrements it\n; if the right keys are pressed.\n\nkey.{up}()\nkey.{down}()\n\nisopen(\"museum\")\n\n:global string museum_status\n:global string offer_tiers\n:global int museum_tier\n:global int target_tier\n:global int museum_pos\n\n:local double worker_val\n\n; If we're being called from Combine, we're a buyer.\n; Otherwise, if we're being invoked due to key-impulse, but the combiner is\n; currently running, abort. We don't want to change the budget in the middle\n; of things.\ngoto(if(\\\n  impulse() == \"{script(Combining)}\",\\\n  trampoline,\\\n  if(contains(museum_status, \"Combining\") && contains(impulse(), \"key.\"), 99, init)\\\n))\n\ntrampoline:\nstop(\"{script(Combining)}\")\nexecute(\"{script(Combining)}\")\nstop(\"{script(Buy)}\")\n\ninit:\n\n; We do *not* direct-start turbo, because we want to detect broken turbo installs.\n; In particular, if someone has turbo v2.1 still installed, that would break, but in a way\n; that's not easy to programatically detect if we direct-start at this point.\n\n; Use worker_storage_lib to find a worker_slot to use for permanent storage.\n#prefix [museum]\n:local int worker_slot\n{worker_lib_line_1({prefix})}\n{worker_lib_line_2}\n\n; Fetch the budget from the chosen worker. The s2d fallback handles the case\n; where we're allocating new storage, as well.\nworker_val = s2d(sub(worker.name(worker_slot), {len({prefix})}, 99), 1e11)\n\n; Ensure this value is set before we start hiding variables.\n; If we're launching on wakeup(), the other turbo variables will get set\n; in time, but this one might not.\n\n; If we're incrementing or decrementing the budget, round it to a fixed\n; amount. This allows users to set it to a specific amount by modifying the\n; worker if they wish, but we'll always get clean set-points when changing\n; via the UI.\n; The lower bound is 1e5, since at that point you can't buy any stones\n; (according to our budget).\n; Also, set budget to -1 if there are no worker slots available. This is our\n; signal to Main, so that it can display an appropriate error message.\ngds({budget}, if(\\\n  worker_slot == 200,\\\n  -1.,\\\n  if(\\\n    contains(impulse(), \"key.\"),\\\n    (10. ^ 0.5) ^ max(10., min(560.,\\\n      round(worker_val // (10. ^ 0.5)) +\\\n      if(contains(impulse(), \"key.{up}\"), 1., -1.)\\\n    )),\\\n    worker_val\\\n  )\\\n))\n; Save the budget back. There's always enough room for the full value.\nworker.setName(\\\n  worker_slot - if(worker_slot < 100, 0, 100),\\\n  \"{prefix}\" . gdg({budget})\\\n)\n\n\n; Set other variables that need to happen before we close the script block.\n\n; If target_tier is -2, we're being invoked because start was pressed: Either\n; during the timer countdown, or to abort a running combine. Either way,\n; museum_tier needs to be set to 0 to signal no countdown.\n;\n; Otherwise, we leave it unchanged, which will usually mean the countdown remains\n; in effect.\nmuseum_tier = if(target_tier == -2, 0, museum_tier)\nmuseum_pos = -1\n\n; Signal Main to wake up. We only want to override target_tier if it's idle,\n; i.e. set to 0 - other situations show that it's in use, and notifying about\n; changing budget is the lowest priority.\ntarget_tier = if(target_tier == 0, -3, target_tier)\n\n; Time for more ugly math! When we set preferred tier to \"pref\", we get stones in\n; the range [pref-10, pref], at uniform. We want our best stone to be in that\n; range - the one that we can *just* afford to do +11 levels from. Stones smaller\n; than that fall off at a rate of 1 tier/level, and stones higher fall off at a\n; rate of (18 log 3 - 1), or ~1.63 tiers/level. To maximize the potential of the\n; range, we want the top and bottom of the range to have equally high max_tiers,\n; so max_tier(pref - 10.5) = max_tier(pref + .5). (The halves make the range of\n; size 11, which is needed to properly match the actual integer-sized range.)\n;\n; Substituting gives pref - 10.5 + 11 = log_3(budget / (2000*100/18) / 18^(pref+.5)) + pref+.5,\n; 0 = log_3(budget / K) - (pref + .5) * log_3(18),\n; pref + .5 = log_3(budget / K) / log_3(18),\n; pref = log_18(budget / K) - .5,\n; pref = log_18(budget / (2000*100/18) / 18^.5),\n; pref = log_18(budget / (2000*100/18^.5))\n;\n; The result ends up being intuitive - since the range of stones spans 11 tiers, and\n; our uptiers is also +11 tiers, we want to match the preferred tier to the point where\n; we can just barely afford to buy the stone.\nmuseum.setPreferredTier(max(1, min(50, d2i((gdg({budget}) / (2000. * 100. / (18. ^ 0.5))) // 18.))))\n"],["Combine",":import museum_macros\n:name {script(Combine)}\n\n; This script is responsible for actually combining gems.\n;\n; That's true in two senses: It both has the actual call to Combine(), and\n; also the logic immediately surrounding it that runs the combines and checks\n; to see if the loop is done.\n\n:global int museum_tier\n:global int target_tier\n:global int museum_pos\n\n:local double end_time\n:local int buy_amount\n\nrestart_loop:\n; Calculate a time to end the loop at. This is 1/5 of a second in the future,\n; so it should reliably be 5 FPS.\nend_time = now() + 10000000. / 5.\nbuy_amount = max(1, (target_tier - museum_tier - 5) * 3)\n\ncombine:\nmuseum.buyTier(element(\"inventory\", 0), museum_tier, buy_amount)\ncombine(50)\ncombine(50)\ncombine(50)\ngotoif(combine, tier(\"inventory\", 0) < target_tier && now() < end_time)\n\ngotoif(done, tier(\"inventory\", 0) >= target_tier || tier(\"inventory\", 27) == museum_tier)\n\nexecute(\"{script(Buy)}\")\nwaitframe()\n\ndone:\n; Now that we're done, move the finished stone back to \"equipped\". This also\n; moves partial/original stones back, if we cancelled via {start}.\n;\n; Even though this happens after signalling, we get one extra cycle as a\n; \"delay slot\" before we're stopped by Main.\nmuseum.moveTo(\"inventory\", 0, \"loadout\", museum_pos)\n\n\n; This is the signal for Main that it should continue.\nmuseum_tier = -5\n\nend:"],["Calculate",":import museum_macros\n:name {script(Calculate)}\n\n; This script contains (stub) logic for handling key.{start}. This would be part\n; of Main normally, but there can only be 2 impulses per script at the\n; resource-cost-levels we're targeting.\n;\n; The final (bulk) of the logic deals with buying test stones from the\n; offshore market and doing calculations/preparations for the actual\n; combining, which is handled by Combine. This script sets museum_tier\n; and target_tier, which directly drive the combining process.\n\nkey.{start}()\n\n:global int museum_tier\n:global int target_tier\n:global int museum_pos\n:global double budget\n:global string offer_tiers\n\n:local int offer_idx\n\n; If we're called from key.{start}, then check if the museum\n; is open. If it is, signal Main, otherwise exit. We can't just set a\n; condition on the script, because that would possibly mess up scripts\n; that execute us, on exiting the museum.\n; This will overwrite target_tier if we are currently combining,\n; causing an early exit and leading to main resuming - which is what we\n; want.\n; If we're called from Main, then we need to set museum_tier to 0, because it\n; serves as a signal variable. Main waits on it for BuyOffshore/Combine to be done.\n;\n; It's ugly to fold this up into a single conditional set, but between the fact that\n; we need museum_tier reset on the first instruction, and some of the other conditions\n; involved, it wouldn't be less complicated to do it as two instructions.\nglobal.int.set(\\\n  if(contains(\"key.{start}\", impulse()), \"target_tier\", \"museum_tier\"),\\\n  if(contains(\"key.{start}\", impulse()),\\\n    if(isopen(\"museum\"), -2, target_tier),\\\n    0\\\n  )\\\n)\n; If we're called from key.{start}, we're done now. Otherwise, if offer_tiers is\n; the default, calculate it now, but don't bother re-doing work if we don't have to.\n; (This would be easier to do at the top, but there's no room in Main.)\ngoto(if(\\\n  contains(\"key.{start}\", impulse()),\\\n  end,\\\n  if(\\\n    contains(offer_tiers, \"0101010101010101-1\"),\\\n    get_offers,\\\n    skip_offers\\\n  )\\\n))\n\n; This loop calculates the best stone to buy, for each element.\nget_offers:\n\n; Turn an element string into an index. The base version is defined in museum_macros.\n#element_to_index(offset) {element_to_index_base(museum.slotElement(offer_idx), {offset})}\n\n; This monstrousity updates the value of the best tier to use for an element.\n; The element is the element in slot [offer_idx], and we're assessing whether\n; that offer will be an improvement.\n; The base logic relies on the top_tier formula.\noffer_tiers = if(\\\n  museum.slotElement(offer_idx) == \"\" ||\\\n    {top_tier(i2d(museum.slotTier(offer_idx)))} <=\\\n      {top_tier(s2d(sub(offer_tiers, {element_to_index(\"\")}, 2), -1.))},\\\n  offer_tiers,\\\n  sub(offer_tiers, 0, {element_to_index(\"\")}) .\\\n    sub(i2s(100 + museum.slotTier(offer_idx)), 1, 2) .\\\n    sub(offer_tiers, {element_to_index(\"  \")}, 99)\\\n)\n; There are max 10 offer slots, numbered 0 through 9. We'll exit after #9.\noffer_idx = offer_idx + 1\ngotoif(get_offers, offer_idx < 10)\n\nskip_offers:\nclear(\"inventory\")\n\n; Load the pre-calculated tier of stone we are buying.\nmuseum_tier = s2i(sub(\\\n  offer_tiers,\\\n  {element_to_index_base(element(\"loadout\", museum_pos), \"\")},\\\n  2\\\n), -1)\n\n; Determine \"target_tier\", the level we are trying to upgrade to. In the\n; best case, we can upgrade 11 levels past the tier of the stones we can\n; buy from the museum. (Which may only be tier 1.)\ntarget_tier = if(min(tier(\"loadout\", museum_pos), museum_tier) < 0,\\\n  -1,\\\n  d2i({top_tier(i2d(museum_tier))})\\\n)\n; If tier(museum_pos) < museum_tier, buy one of the target stone.\n; In this case, we're about to move our stone into the 0th slot, and\n; if it's below the base level it will never get combined with, so\n; the combine loop will never end.\n; It's OK to still move it, because there's enough room in the inventory\n; for an extra stone.\n; If we can't afford the stone, or for some other reason are unable to buy\n; it, then we'll also fall through in Combine and move the original stone\n; back when we're done. In this way, we can always avoid eating stones,\n; no matter what happens.\nmuseum.buyTier(\\\n  element(\"loadout\", museum_pos),\\\n  museum_tier,\\\n  if(tier(\"loadout\", museum_pos) < museum_tier, 1, 0)\\\n)\nmove(\"loadout\", museum_pos, \"inventory\")\n\n; Extend turbo for a little longer. There's a race condition where we might\n; run out of cycles and start a new frame, but even if we do that on this\n; line, the new frame will start in time for the Combiners to loop properly,\n; and for the max-setting line in Combine to set the max to its proper value.\n;\n; Otherwise, this ensures that we stay in the current loop until the line\n; in Combine sets cycles.max to its full value.\n; This is a small enough extension so that if we never enter the main loop\n; of Combine, we'll still eventually hit turbo.cycles.max and start a new frame.\n; (I.e. we can't loop indefinitely with this extension alone.)\n\n; executesync() is used here to pause us until our child Combine stops us.\n; If we jump from the top, we have to be prepared to loop back to this instruction.\n; in that case, this needs to be a no-op.\nexecute(if(contains(\"key.{start}\", impulse()),\\\n  \"%%museum-nop%%\",\\\n  \"{script(Combine)}\"\\\n))\n\nend:"],["Main",":import museum_macros\n:name {script(Main)}\n\n; The \"main\" script of the combiner. It starts on wakeup/entry into the\n; museum, and keeps running until the user leaves the museum. This is because\n; it is responsible for maintaining the UI global \"museum_status\", which\n; both conveys information to the user and also ends a <size=0> block that\n; hides our internal global variables. When we leave the museum, this is\n; set to \"</size>\" to blank the display and leave no clutter.\n;\n; This script also runs the outer part of the loop, which updates the\n; position of the combiner. It is well-suited to this, because it is the\n; only script that doesn't get stop()'ed at some point.\n\n:global int max_craft_tier\n:global int museum_pos\n\n:global string museum_status\n:global string offer_tiers\n:global int museum_tier\n:global int target_tier\n\nwakeup()\nopen.museum()\n\nisopen(\"museum\")\n\ntop:\n; Launch Buy to initialize the global variables in the proper order.\n; We re-do this after every run, because it resets museum_pos for us.\nexecutesync(\"{script(Buy)}\")\n\n; Two characters per tier. Universal is last. These are initialized to what can\n; be bought from the store.\n; This logically belongs in \"Buy\", but is moved out of there to make space.\noffer_tiers = \"0101010101010101-1\"\n\n; Macro-substitution for the museum timer, allows mocking it out easily for\n; testing.\n#timer museum.timer()\n\n; No-offshore-market fix: If we get here with museum_tier == -2 (which is the\n; waiting-to-start state), but the timer is *exactly* 1 hour, this means the user\n; doesn't have the offshore market and is getting the default value. In this case,\n; reset museum tier so that the script stops properly.\nmuseum_tier = if(\\\n  museum_tier == -2 && {timer} == 60. * 60.,\\\n  0,\\\n  museum_tier\\\n)\n\n; This loop usually runs without turbo, although it can have lingering\n; turbo from other scripts without bad effects. It keeps the status line\n; up-to-date while the museum is not running.\nstatus_loop:\n; We use target_tier to receive signals from other scripts. 0 means nothing\n; is hapenning, so we always reset to 0 at the top.\ntarget_tier = 0\n\n; This is a useful sub-expression when displaying numbers in rounded\n; scientific notation. We want to extract the exponent, but for numbers like\n; .9996, we know they'll round up to 1.00 (when rounded to 3 places), so we\n; have to consider them as an exponent higher already.\n; The parameter is to allow for the injection of a constant for constant\n; folding in later expressions.\n#adjusted_exp(x) floor(gdg({budget}) // 10. - (0.9995 // 10. + {x}))\n\n; Stringify the budget in rounded-scientific notation, rounded to 3 digits\n; (2 after the decimal place). This is an awkwardly large expression, but\n; it's really the best we can do with the tools we have.\n; The \"2\" passed to adjusted_exp subtracts 2 from the exponent, so the\n; overall effect is to multiply by 100 (before rounding).\n#rounded_budget round(gdg({budget}) / (10. ^ {adjusted_exp(2.)})) / 100. .\\\n  \"e\". {adjusted_exp(0.)}\n\n; Normally we would take the ceiling of the time remaining, because that's\n; how timers work. (You show 1 second left until the time hits 0.)\n; However, the display timer in the museum uses floor, and we want to match\n; that, so we use floor too.\n; The parameter is a divisor, to make dealing with minutes easier.\n#time_floor(x) floor({timer}/ {x})\n\n; Set the status. There's a lot of cases to this:\n; * Error for no workers available.\n;   - We don't have direct visibilty to worker_slot, but Buy will signal the\n;     error by setting budget to negative, which will never happen otherwise.\n; * Error for a bad Turbo install. This is disturbingly frequent.\n; * Show our current budget, with green highlighting to prompt that this\n;   can be adjusted.\n; * Show a brief help line, also with green highlighting to link the keys\n;   to the budget.\n; * If we've pressed {start}, show the Combining message instead. This is\n;   important because certain things key off of it. target_tier = -2 is the\n;   signal for this.\n;\n; We don't bother doing anything special when the museum isn't open, since\n; we'll handle that at the bottom of the script.\nmuseum_status = if(\\\n  gdg({budget}) < 0.,\\\n  \"</size>error=<color=#fb3>No available workers!</color>\",\\\n  \"</size>museum=<color=#2f4>\" . {rounded_budget} .\\\n    \"</color> <color=#fff>budget</color><br>\\\n<color=#0df><color=#2f4>{up}</color>/<color=#2f4>{down}</color> changes, <color=#2f4>{start}</color> \" .\\\n  if(\\\n    museum_tier != -2,\\\n    \"begins</color>\",\\\n    \"stops</color><br><color=#fff>Waiting \" .\\\n    {time_floor(60.)} . \":\" . sub(d2s({time_floor(1.)} % 60. + 100.), 1, 2) .\\\n    \"</color>\"\\\n  )\\\n)\n; The s2i()/sub() expression is a jump-table, where the string values are\n; line numbers.\n; The values that target_tier can have when we get here are 0\n; (if it hasn't been set to anything since it was cleared at the top of\n; status_loop), -2 (set when key.{start} is pressed), and -3 (set when\n; budget is adjusted via key.{up}/key.{down}).\n;\n; -2 finishes the loop. -3 should reset target_tier and update status by\n; jumping two lines back. 0 *could* repeat the same line, except sometimes\n; we have to update status, so we jump one back, to set status.\n; We can't merge the -3 and 0 cases, because setting target_tier over-frequently\n; makes keystrokes flaky.\n;\n; We use a modified jump table when museum_tier is -2, which indicates that\n; we are synced to the refresh timer. In that case, we abort when the timer is\n; 59:59 (meaning the refresh just hapenned), and when start is pressed (-2 for\n; target_tier) we jump back to executing Buy, which will reset museum_tier\n; (and also do other things, which we don't care about) in that case.\ngoto(if(\\\n  isopen(\"museum\"),\\\n  if(\\\n    museum_tier == -2 && {timer} >= 59. * 60. + 59.,\\\n    start_museum,\\\n    wait_frame\\\n  ),\\\n  end\\\n))\n\nwait_frame:\nwaitframe()\ngoto(if(\\\n  target_tier == -2,\\\n  if(museum_tier == -2, top, start_museum),\\\n  if(\\\n    target_tier == -3,\\\n    status_loop,\\\n    if(target_tier == 0, status_loop + 1, last_end)\\\n  )\\\n))\n\nstart_museum:\n; Now that we're in the active part of the script, start turbo. We want\n; minimal overhead, so don't execute an extra script, just increment\n; the variable.\n\nupgrade_loop:\n; Go to the next script to perform the actual upgrade.\n; We run this even when museum_pos is -1, in order to set all the variables\n; properly. Combine will exit immediately in that case, without a frame break,\n; so we will fall down below and set the status correctly within the frame\n; that it starts.\nexecute(\"{script(Calculate)}\")\n\n; Combine (which gets run from Calculate) will signal us when it's done.\n; It must be stopped for proper cleanup.\nwaituntil(museum_tier == -5)\nstop(\"{script(Combine)}\")\n\nskip:\nmuseum_tier = -2\nmuseum_pos += 1\n; While running, we have fewer conditions to check, since the errors were\n; already signaled at the top. (There's nothing actually stopping the user\n; from starting the script anyway, but that's on them at that point.)\n;\n; The condition for displaying Combining is reversed, since it's usual\n; here, and if {start} is pressed it means we should exit.\nmuseum_status = \"</size>museum=<color=#2f4>\" .\\\n  {rounded_budget} .\\\n  \"</color> <color=#fff>budget</color><br>\" .\\\n  if(\\\n    target_tier != -2,\\\n    \"<color=#ff0>Combining... [\" . museum_pos . \"] <color=#2f4>{start}</color> stops</color>\",\\\n    \"<color=#0df><color=#2f4>{up}</color>/<color=#2f4>{down}</color> changes, <color=#2f4>{start}</color> begins</color>\"\\\n  )\n\nstop_turbo:\n; Most of the time, we do not want to stop turbo. We only want to do it in\n; the specific cases where we'll be ending the loop. So, this duplicates a lot\n; of the logic in the loop below, all for the benefit of saving a line.\n;\n; Note that if we jumped to stop_turbo directly, museum_status can never\n; contain \"Combining\".\nexecute(if(\\\n  isopen(\"museum\") && museum_pos < 130 && contains(museum_status, \"Combining\"),\\\n  \"%%museum-nop%%\",\\\n  \"TE2.2:stop\"\\\n))\n\n; This very complicated gotoif consolidates the ends of lots of loops into\n; one statement.\n; If the museum is closed, fall through to exit the script.\n; If we're through all the positions, or if we're no longer \"Combining\"\n; (which means {start} was pressed), go to the top to reset our state.\n;\n; Otherwise, continue the loop: Either normally, or via a shortcut if this\n; part of the grid is empty, to avoid executing the sub-scripts.\ngotoif(\\\n  if(\\\n    museum_pos < 15 * 9 && contains(museum_status, \"Combining\"),\\\n    if(tier(\"loadout\", museum_pos) == -1, skip, upgrade_loop),\\\n    top\\\n  ),\\\n  isopen(\"museum\")\\\n)\n\nend:\n; Before we exit, blank the status so that there isn't clutter on the screen.\n; This is safe to do in the last slot because turbo shouldn't be running by\n; this point. Even if it is, we're the only ones who set museum_status, so\n; it's still safe.\nmuseum_status = \"</size>\"\nlast_end:"],["New 1","open.museum()\nwakeup()\n:budget_cap -1\nisopen(\"museum\")\n\nclear(\"loadout\")\nclear(\"inventory\")\n\nloop:\nmuseum.buyTier(\"light\", 1, 1)\nmove(\"inventory\", 1, \"loadout\")\ngotoif(loop, freeSlots(\"loadout\") > 0)"]]}}
```
