# C0D.DustManager

A rework of D0S.DustManager.


This is an ore crushing/dust up-tiering combo. It works stand-alone, but pairs nicely with other factory automation that expects dust to beavailable. It tries to crush any un-crushed ores, and up-tiers dust while trying to make the dust distribution match its built-in target ratios.

`C0D.DustManager 2 1 13`

```
7VxPb9s2FP8qnjB0wOKpkuw4Q9AgwVZgp20fYC4MSqIdohIpkNScru21u63n3trrMGy9bbcC1hcb9C9RZNKmZFmWU6GIbNAi+d7v/eUj2ZcacygKONPOf3mpAYcjguPv2jQ0DNPwiAM83SWh7UGdQT61HYIZB5jHvxvjKSYUzuxwPoe09NsoeRqy59Xq7ZU2vDcN4xThhXCa5C03ZHzmhx5HgYcgZeW3dHNgDgx9Yp0ODD3+M86+PbPiz8nITD7N24dhmaXZC0zGo00cgh0gpMSYZAwnbCKLJV8goIhf+5AjR0fZ6+U2mk6FMNcXYi4NE4mbH5earZT2r+4hK+x5IuppmBLBjJjlTjkL7VQaAvlIKBfIp1kIRj5xVUCQCiOjH2EX3vw8vyflXbgUsjCQNR8GE+GQ33SCmC1+In1G/0WfYnstECdxEzFxDZveiXDA+uYYf9gcUgzoizvtdIgfAIoYwZs0tmkt7YIGpH2ti4ty1+hT+k/owGS6ouKHe3ewU5zokjfJorgBFxBDihx9QThBcyEvMldTtr0dfMWT8sSr96s3RSDlWUd5vLlDQ3YN6YyjqslV+vyynGBtyuOSyWYc+TDpYRbkmHarQ4GiNxTN1iwR5vhKPP/XdUb8STKYlJm9QFeR9MHqrwr6kLwVkCWkgQcwn9mEsPJbapH746Vi4D5lHHBYzYc3k3NnM6vn3YZdV0gVu4uTBXMyBw4n9IXuA+caYajHC7dfxRycZW5k95FOfXSz5onkwViVcSFdZsElFzzCKCcXcegz3SHhWiaWRQ9Cy0xYU6wIu/XkYooz4/ARFpiMSJOKS+FKtI7jHEKJ2Pag4scElYjY9qBSNeZOQHVYA0z80THBJSO4XcgmxwaZiOB2ITs9NshEBLcL2fjYIBMR3C5kogy405DJUvb2IBPli52GTJbgtgeZagmmM5DJ9ha6uPqoB7iqLqu6CVUPrBrcVPMG1ZRMJctVWTSor8FE5T9nvW9e0TDz8t8SIL68RqnxGfOCTdqEeEmjsNS+8Ii9pUwAM22dcUBl71hfrFWxFVU06//qlZTw3c0lm+PRo8rD5VWEpJaT93MomEt8gxf6QQra9m0T9RqzeCdGte2wlaD18rpqV2ElXLbmhbmPvQtBFaygUcRkFXxlzBoypt3tpnrFVlIILofn7bXik9XvKQ/Ru+iP6N/on0tZoXFDIb1iTFe1W9Vcrrfb6oW1UUCWZV2IPvyWiHO8+vuH6EP05+UmmTfSvCfF6R3+/hQnx0wQB1Rcfi+udsUlOPagiHm9oKRu0bcp3FksER/cVFrrqeiVahzv9aqGG0gTgvX1f9jE4cY+G2hZmsnpmm4E717ORxW8e3H1wXsfwbtPCh9S8O6luUdpPp5uiNK9kB+GkJs8/DmQnlbtc/qHpDE1VCN6f5kfeZ/n2UBAiRs6WZqYp45397c+h1K/YPO8nAmpXbk5XlgOTL6qS+mDUDMuJdxhnXhEWl3cMbv9Dm6mTdQ9EqfRQXyyak/1szvNZB/RR8keY9XLOg9JGA0U0w7NSNmnqdUg7KsaUlde6wgI3XrvaNuOd+1KizjrTnZid2Jq002+WyVr0lBl64Q1/1G49Vd95bp/6FNG4iWL20mLqi21msW8Pr86UH71eS2mbq8MCglPDkipXruWIGtanCyxvkTYJUsdMRJALCYlMxLt2VBzCHbR/f+gps4wyA9Cj8FkkCV4DsNAG2pxT73wEgY+1M61742n+tOQ8R8BBouE6wA4z8Ei/k0banboLiDXzkeGYQy1kMHvsgZOQ/j62ev/AQ==
```

Source code can be found at [C0D.DustManager](C0D.DustManager.tpt2), with a dependency on [Editor_actions lib](../../Editor%20Actions%20lib/README.md).

## Details

Edit the first line which sets the variable `ore_buffer`. The default of 1000 means that 1000 of each ore tier will be kept, although initially it will be crushed so that you have dust to work with. This buffer amount is so that you can scan it with the Crafter. If you've already scanned all the ore tiers, or don't have access to the crafter, you can set `ore_buffer` to 0.

You can edit the second line which sets the variable "dust_multipliers" to customize the ratios, this sets the shape of the target distriburions as a space-separated list. Each number is a multiple of the previous tier dust amount. The default of "1 1 0.625 0.5 0.07872 0.06312 0.01 0.01 0.0021" is based on making high-level producers and should be reasonable for everything.

The newest addition to the editable lines are actions 6, 7 and 8. Together, they determine how much ore to crush based on a defined `crush_time`, which means that your crusher will never be occupied for more than `crush_time` ammount of time.<br>
Line 6 defines the crusher tier, it's assumed that you have a T10 crusher by default.<br>
Line 7 is the crush time. This is a `second + minute + hour` calculation with the default value of 5 minutes.<br>
Line 8 holds your powerplant boost. It's set to 1.0 by default, but you can increase it to your boost if the crusher isn't being used for as long as you'd like.

This version also fixes a newly introduced bug in the original D0S.DustManager where the script would no longer uptier dust if you only have 1 of it.

There's now also a budget_cap of `3000` so that every tier is processed in 1 frame.

## Source

The source of the script is imported in the [external editor](https://d0sboots.github.io/perfect-tower/).

```
{"workspaces":{"C0D.DustManager":[["C0D.DustManager","; Add a budget_cap for the script\n; We have 3 non-atomic actions, and there are 10 tiers\n; This means we'd need a budget of 10 * 3 * 100 for all tiers to be checked in 1 frame\n:budget_cap 3000\n:name C0D.DustManager\n\n:local double crusher_tier\n:local double crush_time\n:local double ore_buffer\n:local double powerplant_boost\n;\n:global int factory_target\n:local int i\n:local int state\n;\n:local string dust_multipliers\n\nwakeup()\nopen.factory()\n\nisopen(\"factory\")\n\n; Amount of ore to save at each tier. Ore will only be saved if there is\n; more dust than ore, otherwise it will be crushed anyway (so that saving\n; ore doesn't prevent you from progressing.) This function exists to allow\n; for scanning ore with the Crafter.\nore_buffer = 1000.0\n\n; Initialize multipliers from a string.\n; This used to be much worse, but is easy now that there is native s2d().\n\ndust_multipliers = \"1 1 0.625 0.5 0.07872 0.06312 0.01 0.01 0.0021\"\n;\n; \"i\" combines the position in the string with the tier currently being\n; initialized. The encoding is pos + tier * 10000.\n; (I.e. the string can only be 10000 long.)\n#pos (i % 10000)\n#tier (i / 10000)\n#next_space index(dust_multipliers . \" \", \" \", {pos})\n\n#buffer(tier) \"buffer\" . ({tier})\n#buffer.get(tier) local.double.get({buffer({tier})})\n#buffer.set(tier, ammount) local.double.set({buffer({tier})}, {ammount})\n\n; This is a simple loop: Each iteration converts one number and advances\n; both the read position \"pos\" and the \"tier\" appropriately. The only subtle\n; wrinkle is that once it gets to the end of the list, it will keep reading\n; the same entry to fill in the remaining tiers.\ninit_multipliers:\n{buffer.set({tier} + 1, s2d(sub(dust_multipliers, {pos}, {next_space} - {pos}), 0.0 / 0.0))}\ni += 10 ^ 4 + if(index(dust_multipliers, \" \", {pos}) == -1, 0, {next_space} + 1 - {pos})\n\n; loop until we've got a buffer for every tier\ngotoif(init_multipliers, i < 10 * 10 ^ 4)\n\n; Mark the maximum amount of time you want the crusher to be occupied for\n; and the crusher tier\ncrusher_tier = 10.0\ncrush_time = 0.0 + (arithmetic.double(5.0, \"*\", 60.0) + arithmetic.double(0.0, \"*\", 60.0 * 60.0))\npowerplant_boost = 1.0\n\n; The overall plan is to count down through the ores, so that the best ones\n; (with the least count) get processed first, and to count down through\n; the lumps as well. We process lumps in \"packets\" that are based on a\n; power of the stack size, which ensures that uptiering\n; doesn't consume too much dust while processing but also allows\n; for the chunks to process for a considerable time.\n; This also makes for a simple expression that equals 0 when the size\n; is 1 (so that we don't use the last dust), and 1 when the size is 2\n; (so that we do start immediately after that point.)\n\n; The tier variable is a local, so the process can be restarted from\n; the top if it's taking too long.\n\ntop:\n\n; Calculate the tier of ore to crush.\n; Since this is computation, import Editor_actions lib to build the operations in lua macros\n:import Editor_actions lib\n{lua(\\\n  DustManager = {};\\\n  --[[/*\\\n    * global table that everything in the global field is appended ontop of\\\n    *\\\n    * Then, create the names of the variables we can work with\\\n  */]]\\\n  \\\n  local ore_buffer = [[ore_buffer]];\\\n  local dust = [[\"dust\"]];\\\n  local ore = [[\"ore\"]];\\\n  local ingot = [[\"ingot\"]];\\\n  \\\n  local active = function(machine) return Editor_isMachineActive(machine); end\\\n  local mixer = [[\"mixer\"]];\\\n  local crusher = [[\"crusher\"]];\\\n  \\\n  local function ore_count_cond(tier)\\\n    --[[This determines if we have enough ore of this tier to crush it]]\\\n    local dust_count = Editor_factoryCountItems(dust, tier);\\\n    local ore_count = Editor_factoryCountItems(ore, tier);\\\n    \\\n    --[[/*\\\n      * We have enough ore if the max count between ore or ingot is bigger than or equal to\\\n      * the minimum between the dust count and the ore buffer\\\n    */]]\\\n    local min_count = Editor_min(ore_buffer, dust_count);\\\n    return Editor_math(ore_count, \"<=\", min_count);\\\n  end\\\n  \\\n  function DustManager.ore_state()\\\n    --[[/*\\\n      * The main state calculation. We first calculate whether ore needs to be crushed,\\\n      * and if it does not, we possibly increment the current dust that is being mixed.\\\n      *\\\n      * This is composed of multiple statements, so we're building it from end to the start\\\n      *\\\n      * Additionally, since this is a nest, I will make all Editor_actions return a table\\\n      * instead of a string, and then concatenate it all at the end.\\\n    */]]\\\n    Editor.output_table = true;\\\n    \\\n    local dust_inc = Editor_if(active(mixer), 0, 11);\\\n    local acc = dust_inc;\\\n    for i = 1, 10 do\\\n      local cond = ore_count_cond(i);\\\n      acc = Editor_if(cond, acc, i);\\\n    end\\\n    \\\n    acc = Editor_if(active(crusher), dust_inc, acc);\\\n    --[[Set back to false after we're done]]\\\n    if Editor.output_table then\\\n      Editor.output_table = false;\\\n      return table.concat(acc);\\\n    end\\\n    return acc;\\\n  end\\\n)}\n\n#ore_state {lua(return DustManager.ore_state())}\n\n; The dust_tier for mixing and ore_tier for crushing are stored together in state.\n; Mixing will only occur if ore_tier is 0, since crushing takes priority.\n; (Generally the mixing will happen in the next iteration.)\n\n#raw_dust_tier (state / 11)\n;\n#dust_tier ({raw_dust_tier} + 8) % 9\n#dust_tier.current 1 + {dust_tier}\n#dust_tier.next 2 + {dust_tier}\n\n\n#ore_tier (state % 11)\n#has_ore (state % 11 != 0)\n\nstate = ({raw_dust_tier} * 11 + {ore_state}) % 99\n\n; These expressions calculate how much dust to uptier. It used to be a more\n; complicated expression that calculated everything in T1-equivilant units,\n; (i.e. if you down-converted it all), but that isn't actually needed: Everything\n; works (better actually) if you just make local decisions based on the ratios\n; between the current and next tier.\n; In both cases, Ore Lumps are also counted as dust, so that unmixed lumps don't\n; throw off the calculations. We know that currently processing lumps won't be\n; an issue, because we only craft when the mixer is empty.\n\n#count_dust_and_lumps(count_tier) (count(\"dust\", {count_tier}) + if(\\\n  {count_tier} == 1,\\\n  0.0,\\\n  count(\"lump\", max(1, -1 + {count_tier}))\\\n))\n\n; Use arithmetic.double to separate the 2 operations\n; Removes most parentheses and helps (slightly) make the code flow easier\n#needed_by_ratio(ratio_tier) arithmetic.double(\\\n  {count_dust_and_lumps({ratio_tier})} * {buffer.get(1 + {ratio_tier})} -\\\n  {count_dust_and_lumps(1 + {ratio_tier})} * {buffer.get({ratio_tier})},\\\n  \"/\",\\\n  {buffer.get({ratio_tier})} + 8.0 * {buffer.get(1 + {ratio_tier})}\\\n)\n\n; We always save one dust on the producing side, so that dust ordering doesn't\n; get messed up in the inventory.\n; We produce lumps in chunks. We consume up to 5% of the destination;\n; this allows for large-ish mixing regardless of stack size, and\n; dynamically adjusts well.\n; Not adding more to the mixer when it's running greatly reduces\n; complications. We just move on to the next tier when it's done,\n; and come back around soon enough.\n; The \"+ 0.5\" on the consuming side is to adjust for Chemical Lumps.\n; That way, in the terminal case it'll hit the safety target exactly. If you\n; don't have lumps, you'll be up to 3 under the target. However, we always\n; ensure that you'll leave one leftover no matter what.\n\n;\n; Wait for D0S.Factory to stop if it's running.\n; Or if \nwaitwhile(factory_target != 0 || (active(\"mixer\") && active(\"crusher\")))\n\ncraft(\\\n  \"lump\",\\\n  {dust_tier.current},\\\n  if(\\\n    {has_ore} || active(\"mixer\"),\\\n    0.0,\\\n    min(\\\n      0.999 * count(\"dust\", {dust_tier.next}) ^ 0.84,\\\n      {needed_by_ratio({dust_tier.current})}\\\n    ) + 0.5\\\n  )\\\n)\n\n; try to crush the ammount of ore that'd occupy the crusher for crush_time ammount of seconds\n; This calculation is made with the machine speed, which is 2 ^ (crushter_tier - 1)\n; and ore crushing speed, which is (2t - 1) seconds, where t is the ore tier\n; We mark as `x` the ammount of ore we'll need to crush to achieve this goal\n; x(2t - 1) = crush_time * 2 ^ (crusher_tier - 1)\n; x = (crush_time / (2t - 1)) * 2 ^ (crusher_tier - 1)\n\nproduce(\\\n  if({has_ore}, \"ore\", \"lump\"),\\\n  if({has_ore}, {ore_tier}, {dust_tier.current}),\\\n  if(\\\n    {has_ore},\\\n    min(\\\n      max(\\\n        count(\"ore\", {ore_tier}) - ore_buffer,\\\n        1.0 + (count(\"ore\", {ore_tier}) - count(\"dust\", {ore_tier})) / 3.0\\\n      ),\\\n      powerplant_boost * (2.0 ^ (crusher_tier - 1.0)) * crush_time / (2.0 * i2d({ore_tier}) - 1.0)\\\n    ),\\\n    count(\"lump\", {dust_tier.current})\\\n  ),\\\n  if({has_ore}, \"crusher\", \"mixer\")\\\n)\n\ngotoif(top, isopen(\"factory\"))"]]}}
```

### Versioning

#### 1.1

Fixed a bug where the script wouldn't crush ore your ore ammount was <= ore_buffer but you had less dust.<br>
Changed the macro `has_ore` to no longer check if you have ingots of the tier. The script doesn't crush ingots, so I have no clue why I did that.

#### 1.0

Made the scripts modifications and pushed the version.