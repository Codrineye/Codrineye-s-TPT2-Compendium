# Source Export

```
{"workspaces":{"C0D.Factory":[["Factory assembly hdr","; Header for the factory assembly\n; Used to define the macros I'll be interacting with to make my life easier\n;\n; Since this is assembling data internally, everything is done within lua macros\n{lua(\\\n  Factory = {}; --[[Global table for C0D.Factory]]\\\n  --[[/*\\\n    * Stub function that'll be re-defined in the assembly file\\\n    * method is used to determine what functionality we're interacting with\\\n  */]]\\\n  function Factory.macro_body(method, arg1, arg2, arg3, arg4, craft_type)\\\n  end\\\n)}\n\n; Defines a factory item.\n; Helper macro used to make more definitions\n#item(name, tiers, cost, game_name, craft_type) {lua(\\\n  Factory.macro_body(\"define\", \"{name}\", {tiers}, \"{cost}\", {game_name}, {craft_type});\\\n)}\n;\n; Define an item obtained through craft()\n#craft(name, tiers, cost, game_name) {item({name}, {tiers}, {cost}, {game_name}, \"craft\")}\n;\n; Define an item obtained through produce()\n#produce(name, tiers, game_name) {item({name}, {tiers}, 0.0, {game_name}, \"produce\")}\n;\n; Define a special item that Facility AI can't obtain through Factory specific functions alone\n#special(name, tiers, game_name) {item({name}, {tiers}, 0.0, {game_name}, \"special\")}\n\n;\n; Define a category to place items inside of\n#category(name, default, first, last) {lua(\\\n  Factory.macro_body(\"category\", \"{name}\", \"{default}\", \"{first}\", \"{last}\");\\\n)}\n\n;\n; Define a group of items that'll be made at once\n#group(name, tiers) {lua(Factory.macro_body(\"group\", \"{name}\", {tiers}))}\n\n;\n; Specify the item whose recipe we're defining\n#recipe(name) {lua(Factory.macro_body(\"recipe\", {name}))}\n;\n; Specify a component of its crafting recipe\n#component(name, tiers, count) {lua(Factory.macro_body(\"recipe\", {name}, \"{tiers}\", \"{count}\"))}\n;\n; Specify how the produce()'d item is made\n#make(item, source, mult, machine) {lua(\\\n  Factory.macro_body(\"recipe\", {item}, {source}, {mult}, {machine});\\\n)}\n\n;\n; Get the item queue ID\n; Needed because the {item(name, tiers, cost, game_name, craft_type)} macro doesn't return\n; a :const anymore. This const is what originally reprezented the items id\n#queue(item, tier) {lua(return Factory.macro_body(\"queue\", \"{item}\", {tier}))}\n"],["Factory assembly",":import Factory assembly hdr\n\n{lua(\\\n  Factory.items = {};\\\n  Factory.item_names = {};\\\n  \\\n  function Factory.add_item(item_name, item_tiers, item_cost, game_name, craft_type)\\\n    local item = {};\\\n    item.id = #Factory.items + 1;\\\n    \\\n    local input = table.pack(item_name, item_tiers, item_cost, game_name, craft_type);\\\n    local params = \"item_name item_tiers item_cost game_name craft_type\";\\\n    local inc = 1;\\\n    for param in params:gmatch(\"[%w_]+\") do\\\n      if input[inc] == nil then\\\n        error(\"Parameter \" .. param .. \" is empty!\");\\\n      end\\\n      item[param] = input[inc];\\\n      inc = inc + 1;\\\n    end\\\n    Factory.items[item.id] = item;\\\n    Factory.item_names[item_name] = item;\\\n  end\\\n  \\\n  Factory.categories = {};\\\n  function Factory.add_category(name, default, first, last)\\\n    local category = {};\\\n    category.name = name;\\\n    local names = table.pack(\"default\", \"first\", \"last\");\\\n    local params = table.pack(default, first, last);\\\n    for i = 1, 3 do\\\n      local trimmed = params[i]:gsub(\"^ +\", \"\");\\\n      local item = Factory.item_names[trimmed];\\\n      if not item then\\\n        error(\"Can't find item '\" .. trimmed .. \"'\");\\\n      end\\\n      category[names[i]] = item.id;\\\n    end\\\n    Factory.categories[#Factory.categories + 1] = category;\\\n  end\\\n  \\\n  Factory.recipes = {};\\\n  function Factory.define_recipe(recipe_table)\\\n    local recipe_target = recipe_table[1];\\\n    if Factory.recipes[recipe_target] then\\\n      error(\"Duplicate recipe of item \" .. recipe_target);\\\n    end\\\n  end\\\n)}\n"],["Factory items",":import Factory assembly hdr\n; Define all items in the factory using the following macros:\n;\n; this item is obtained through craft()\n{craft(name, max_tier, list of cost in recources, \"name of item used ingame\")}\n;\n; This item is obtained through produce()\n{produce(name, max_tier, \"name used ingame\")}\n;\n; This item can't be obtained through craft() nor produce()\n{special(name, max_tier, \"name used ingame\")}\n;\n; This places items in categories\n{category(category_name, default_item_in_category, first_item_in_category, last_item_in_category)}\n;\n; And this defines a group of items\n; Item groups can use a category if you want to make all the items in that category\n{group(group_name, max_tier)}\n; Keep in mind that you're defining the maximum tier that's allowed in this group\n; If you had\n{craft(test, 5, 1.0, \"test\")}\n{group(tester, 2)}\n; If group tester contained the item test, you wouldn't be able to make tiers 3 4 and 5 of test\n; using this group\n;\n; If you were to make\n{group(tester, 7)}\n; and test is part of the group. Making tester of tiers 6 or 7 would only make test of tier 5\n\n:import Factory assembly\n; import the Factory assembly so that the macros can actually define our items\n; \n; Define producers\n; Keep them in alphabetical order\n{craft(town_producer,              5,    0   25   150  3350   2e4, \"producer.town\")}\n{craft(factory_producer,           5,    0  100   225   5e3  35e3, \"producer.factory\")}\n{craft(mine_producer,              5,    0   75   300   4e3   3e4, \"producer.mine\")}\n{craft(workshop_producer,          5,    0   80   200  7500   2e5, \"producer.workshop\")}\n{craft(construction_firm_producer, 5,    0  150  2500   1e3   1e5, \"producer.constructionFirm\")}\n{craft(laboratory_producer,        5,   20  150   9e3 125e3  25e5, \"producer.laboratory\")}\n{craft(headquarters_producer,      5,   20  250 12500 175e3   5e6, \"producer.headquarters\")}\n{craft(powerplant_producer,        5,   20  300 17500 275e3  75e5, \"producer.powerplant\")}\n{craft(arcade_producer,            5,  120  3e3  25e3   3e5   1e7, \"producer.arcade\")}\n{craft(tradingpost_producer,       5,  120 3150 27500 315e3 115e5, \"producer.tradingpost\")}\n{craft(shipyard_producer,          5,  500  5e3   5e4   5e5   5e7, \"producer.shipyard\")}\n{craft(museum_producer,            5,  500  5e3   5e4   5e5   5e7, \"producer.museum\")}\n{craft(statue_of_cubos_producer,   5,  500  5e3   5e4   5e5   5e7, \"producer.statueofcubos\")}\n{craft(gem_producer,               1, 2e11                       , \"producer.gems\")}\n{craft(exotic_producer,            1, 1e14                       , \"producer.exoticgems\")}\n{craft(pumpkin_producer,           1,    0                       , \"pumpkin.producer\")}\n\n; Boosters\n{craft(production_booster,         3, 5e10 1e40 1e50, \"pumpkin.producer\")}\n"],["Factory Recipes",":import Factory assembly hdr\n; Define the recipe for all items\n;\n; For items obtained via {craft(item, tier, cost, \"game_name\")}\n; You start by specifying the item whose recipe you're defining\n{recipe(item_name)}\n; Then, you add its components as follows:\n{component(comp1, list_of_counts, list_of_tiers)}\n;\n; For instance, the crafting recipe for a town producer is as follows:\n; t1 = \n; screw(2) plate(2)\n; plate(2) screw(2)\n; t2 =\n; screw(3) plate(3) screw(3)\n; chip(1) town_prod(1) chip(1)\n; screw(3) plate(3) screw(3)\n;\n; To define this, you'd have\n{craft(town_producer, 2, 0 25, \"producer.town\")}\n{recipe(town_producer)}\n{component(screw, 2 4, 2 3)}\n{component(plate, 2 4, 2 2)} ; which you can simplify to {component(plate, 2 4, 2)}\n{component(chip, 0 2, 0 1)} ; which you can simplify to {component(chip, 2, 0 1)}\n{component(town_producer, 0 1, 0 1)} ; which is simplified to {component(town_producer, 1, -1)}\n; having list_of_tier be -1 means that the recipe of tier x will have count x of tier x - 1\n;\n; For items obtained via {produce(item, tier, \"game_name\")}\n; You use {make(item_you_obtain, item_you_use, outputed_ammount, required_machine)}\n; So, to get screws, you put 1 rod into the cutter and get 4 in return\n; `screw` requires `rod` and you get `4` by using the cutter\n{make(screw, rod, 4, cutter)}\n\n:import Factory items\n; import Factory items to get access to the defined items\n; "],["C0D.Factory lib",""]]}}
```
