# Clicker
A project originally made by discord user [megahakerek](https://github.com/Megahackerboss36/tpt-2-clicker/blob/main/README.md)

Clicker is an incremental game created inside of The Perfect Tower 2 that features:
- Manual and Idle points gain
- 3 pages worth of upgrades
- A pointer system that highlights the sellected upgrade

**These are all features that were present in the original package**

This package features a shop system written in lua that gives the programmer a user friendly workspace for tweaking any and all upgrades<br>
Featuring dynamically updating limits, making this my first lua project where user intervention for tweaking is not needed<br>
All items are then concatenated into a string which can be used with ease without the need of any manual intervention

## Import codes
The source code is imported inside of [the external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) in order to look at the implemented code, featuring comments (***Mostly added***), macros and lua code
```
{"workspaces":{"clicker":[["Shop Contents",":import Shop Creation\n; \n; \n; This is a configuration script\n; you have at your disposal 2 functions:\n; \n; <add_item> will register a new item\n; it has 5 fields you need to fill out\n; in order to define an item\n; * the name of the item\n; * the amount it adds to points per click\n; * the amount it adds to points per second\n; * a description for the item\n; * a price for the item\n; \n; if the items description needs to have `,`\n; you will have to use `;`\n; we use e notation for the input to be read as a number\n; the implemented system does cannot read\n; numbers in notations other than scientific or full\n; \n; <add_page> will register a new page\n; to define a page, you need to give it a number\n; this function determines how many items can be shown at once\n; \n; at this time, I recommend you keep all pages the same size\n; the method in which items are displayed does not\n; update the items it cannot reach\n; this means that if a page has 5 items and the next has 6 items\n; going from a page to another does not hide the 6th item\n; \n; development in the future will likely find a fix to this\n; \n\n{add_item(noob clicker, 1, 0, you start with this clicker!, 50)}\n{add_item(cylindro clicker, 3, 0, the easiest boss!, 350)}\n{add_item(chaos complete, 0, 5, this is hardest region!, 1e3)}\n{add_item(first era, 7, 0, WOW! MT8!, 3e3)}\n{add_item(this long story..., 10, 15, MT10.. this not final, 10e3)}\n{add_page(1)}\n\n{add_item(pyramido, 25, 0, this is easy!, 25e3)}\n{add_item(maxing out the lab, 0, 50, youre maxing laboratory, 40e3)}\n{add_item(infinity board, 80, 0, what is it... you have MT11, 85e3)}\n{add_item(cubos jr., 60, 60, hmm new boss, 120e3)}\n{add_item(facility ai, 100, 100, required to win!, 250e3)}\n{add_page(2)}\n\n{add_item(first infinity..., 300, 0, wow; infinity... is this the end?, 1e6)}\n{add_item(challanger, 500, 500, huh; challenge tutorial time!, 4e6)}\n{add_item(INF anvil, 3.5e3, 0, you upgrade afk in anvil, 13e6)}\n{add_item(tower customization, 9e3, 0, flex multiply your click, 25e6)}\n{add_item(gem farm, 10e3, 10e3, shipyard; trading post..., 100e6)}\n{add_page(3)}\n\n; we now define our constants\n; first, string constants for an items string and a pages string\n; the pages string is likely the cause of the firstly mentioned issue\n:const string items '{lua(return shop.concat_items())}'\n:const string pages '{lua(return shop.concat_pages())}'\n\n; now, we have the count of items and our page recordings\n:const int items_count {lua(return #shop.item)}\n:const int page_count {lua(return #shop.page)}\n\n; 2 displacemant constants, for the name and description\n:const int name_displace {lua(return shop.text.max_name_size)}\n:const int description_displace {lua(return shop.text.max_description_size)}\n\n; the character that determines the end of our name/desc\n:const string text_separator '{lua(return shop.text.text_ending_marker)}'\n\n; 2 displacement constants for the price and effect\n:const int price_displace {lua(return shop.precision.price)}\n:const int effect_displace {lua(return shop.precision.effect)}\n\n; max page size is a number that determines how long a page is\n; if the biggest page is 12, this const makes it read 05\n:const int max_page_size {lua(return shop.max_page_size)}\n:const int segment_length {lua(return shop.max_length)}\n"],["Shop Creation","; \n; Package made to create an\n; item and page registering system\n; 1 lua macro to perform all actions\n; \n; initialisation of all variables present in this script\n; create the root table `shop`\n; all items are stored in the table shop.item\n; shop.max_length updates dynamically to mark the\n; maximum length of all inputs read\n; \n; the shop.text table is used for text inputs\n; max_name_size and max_description_size update\n; as the inputs are being recorded\n; .text_ending_marker is a character added to the\n; end of a text to make the retrieving of text easier\n; \n; shop.precision stores variables used to\n; format the numbers as best as possible\n; .price has the maximum value between itsself and\n; the number of digits the inputed price has\n; .effect has the maximum value between itself and\n; the number of digits of\n; the maximum between click/idle effects\n; \n; the system is not made to support negative numbers\n; but with some tweeking, it likely could\n; \n; .contents_saver is a dummy variable\n; it is used in calculating page sizes, by having\n; the count of recordings that had been made since\n; the last time this function got called\n; .max_page_size has the maximum between its value and\n; the number of digits of the count of item recordings made\n; since the previous page creation\n; \n; \n; local functions cannot be accessed outside of this lua macro\n; these functions are used for simple tasks not worth repeating\n; \n; local function x_digit_precision(digits, input)\n; This function is an edited version of what's used in my clicks compactor\n; it creates a local number, and gives it the value of the input\n; with the removed spaces afterwards, the fuction\n; returns a formatted string, that has <digits> amount of 0's infront\n; the value of digits uses shop.precision.<input type>\n; \n; time for the local functions\n; x_digit_precision(digits, input)\n; we create a local `number` that converts the\n; input into a string with none of the spaces\n; the function then returns the formatted string\n; such that the number has as many 0's infront of it\n; as the number of digits we want\n; \n; text_formatting() taken in a text input\n; we create a local `input` that replaces all instances\n; of ';' with a ',' and then\n; return the `input` to no longer have whitespace\n; before and after the text input and adds the ending\n; character at the end\n; As an example\n;   text_formatting('  yah;oo  ow ')\n;   will return 'yah,oo  ow|'\n; everything inbetween ''\n; \n; time for the global functions\n; add_item() takes in:\n;  * the price\n;  * the effect given per second\n;  * the effect given per click\n;  * the item name\n;  * the item description\n; we take our shop_index and create a table `new_item`\n; new_item.price is given the tonumber() value of price\n; tonumber() converts its input into a number, or empty string\n; if the input is not a number\n; we then compare .precision.price with the number of\n; characters inside of new_item.price, but converted to a string\n; create a new table new_item.effect() and add .idle and .click to it\n; perform the same dance with .precision.effect like with precision.price\n; Format the names accordingly and update max_name/description_size\n; update max_length to the absolute values, add the new item to shop.item\n; create an item_name that replaces all spaces inside of name with `_` and\n; return :local int item_name shop_index\n; \n; shop.concat_items() \n; \n; \n{lua(\\\n  shop = {};\\\n  shop.item = {};\\\n  shop.max_length = 0;\\\n  shop.text = {};\\\n  shop.text.max_name_size = 0;\\\n  shop.text.max_description_size = 0;\\\n  shop.text.text_ending_marker = [[|]];\\\n  shop.precision = {};\\\n  shop.precision.price = 0;\\\n  shop.precision.effect = 0;\\\n  shop.page = {};\\\n  shop.max_page_size = 0;\\\n  shop.contents_saver = 0;\\\n\\\n  local function x_digit_precision(digits, input)\\\n    local number = tostring(input):gsub(\" \", \"\");\\\n    return string.sub(\\\n      string.format(\"%0\" .. digits .. \"f\", number),\\\n      1,\\\n      digits + 2\\\n    );\\\n  end\\\n  local function text_formatting(text)\\\n    local input = text:gsub(\";\", \",\");\\\n    return input:gsub(\"^ +\", \"\"):gsub(\" +$\", \"\") .. shop.text.text_ending_marker;\\\n  end\\\n\\\n  function shop.add_item(price, effect_idle, effect_click, name, description)\\\n    local shop_index = 1 + #shop.item;\\\n    local new_item = {};\\\n    new_item.price = math.tointeger(price);\\\n    shop.precision.price = math.max(\\\n      #tostring(new_item.price) - 1,\\\n      shop.precision.price\\\n    );\\\n    new_item.effect = {};\\\n    new_item.effect.idle = math.tointeger(effect_idle);\\\n    new_item.effect.click = math.tointeger(effect_click);\\\n    shop.precision.effect = math.max(\\\n      #tostring(math.max(new_item.effect.idle, new_item.effect.click)) - 1,\\\n      shop.precision.effect\\\n    );\\\n    new_item.name = text_formatting(name);\\\n    new_item.description = text_formatting(description);\\\n    shop.text.max_name_size = math.max(\\\n      shop.text.max_name_size,\\\n      #new_item.name\\\n    );\\\n    shop.text.max_description_size = math.max(\\\n      shop.text.max_description_size,\\\n      #new_item.description\\\n    );\\\n    shop.max_length = shop.precision.price \\\n      + shop.precision.effect + shop.precision.effect\\\n      + shop.text.max_name_size + shop.text.max_description_size;\\\n    shop.item[shop_index] = new_item;\\\n    local item_name = name:gsub(\"^ +\", \"\"):gsub(\" +$\", \"\"):gsub(\" \", \"_\");\\\n    return [[:const int ]] .. item_name .. [[ ]] .. shop_index;\\\n  end\\\n\\\n  function shop.concat_items()\\\n    local function repetition_string(big, small)\\\n      local space = big - small;\\\n      return string.rep('.', space);\\\n    end\\\n    local shop_items = #shop.item;\\\n    local items_concat = {};\\\n    for i = 1, shop_items do\\\n      items_concat[1 + #items_concat] = x_digit_precision(\\\n        shop.precision.effect,\\\n        shop.item[i].effect.click\\\n      );\\\n      items_concat[1 + #items_concat] = x_digit_precision(\\\n        shop.precision.effect,\\\n        shop.item[i].effect.idle\\\n      );\\\n      items_concat[1 + #items_concat] = x_digit_precision(\\\n        shop.precision.price,\\\n        shop.item[i].price\\\n      );\\\n      items_concat[1 + #items_concat] = shop.item[i].name;\\\n      items_concat[1 + #items_concat] = repetition_string(\\\n        shop.text.max_name_size,\\\n        #shop.item[i].name\\\n      );\\\n      items_concat[1 + #items_concat] = shop.item[i].description;\\\n      items_concat[1 + #items_concat] = repetition_string(\\\n        shop.text.max_description_size,\\\n        #shop.item[i].description\\\n      );\\\n    end\\\n    return table.concat(items_concat);\\\n  end\\\n\\\n  function shop.add_page()\\\n    local page_index = 1 + #shop.page;\\\n    local new_page = {};\\\n    new_page.count = #shop.item - shop.contents_saver;\\\n    new_page.size = #tostring(new_page.count);\\\n    shop.max_page_size = math.max(\\\n      shop.max_page_size,\\\n      new_page.size\\\n    );\\\n    shop.page[page_index] = new_page;\\\n    shop.contents_saver = #shop.item;\\\n    return [[:const int page]] .. page_index .. [[ ]] .. page_index;\\\n  end\\\n\\\n  function shop.concat_pages()\\\n    local page_count = #shop.page;\\\n    local page_fitter = shop.max_page_size;\\\n    local pages_concat = {};\\\n    for i = 1, page_count do\\\n      pages_concat[1 + #pages_concat] = x_digit_precision(\\\n        shop.max_page_size,\\\n        shop.page[i].count\\\n      );\\\n    end\\\n    return table.concat(pages_concat);\\\n  end\\\n)}\n\n#add_item(name, effect_click, effect_idle, description, price) {lua(return shop.add_item(\\\n  [[{price}]],\\\n  [[{effect_idle}]],\\\n  [[{effect_click}]],\\\n  [[{name}]],\\\n  [[{description}]]\\\n))}\n#add_page(page) {lua(return shop.add_page())}\n\n\n"],["clicker lib",":import Shop Contents\n\n; Macro for names in the script\n#package(name) clicker:{name}\n#garbage_requested {package(##%GARBAGE REQUESTED%##)}\n; Macro to call general garbage package\n; for invalid execute/executesync\n\n\n; Impulse macros\n; makes it easy to change impulses\n; and hopefully makes the scripts easier\n; to understand\n; \n#click 0\n#clicker_start c\n#buy_at_pointer f\n#buy_best b\n#page_increase d\n#page_decrease a\n#pointer_increase s\n#pointer_decrease w\n; \n; Internal name for global variables\n; Reduces change of being modified by external sources\n#identifier \"clicker\"\n\n; Macro to handle a complex UI element\n; To prevent clutter, these are kept hidden until needed\n; \n#item(name) \"<size=0>\" . {identifier} . ({name})\n#item.get(name) global.string.get({item({name})})\n#item.set(name, value) global.string.set({item({name})}, \"</size>\" . {value})\n\n; Macro to more easily and consistely express int\n; It just makes the source easier to look at\n#stats.get(name) global.int.get({name})\n#stats.set(name, value) global.int.set({name}, {value})\n#stats.add(name, value) {stats.set({name}, {stats.get({name})} + ({value}))}\n\n; read the size of the page\n; we're working with page - 1 for the starting index to be 0\n#page_size s2i(sub(pages, {stats.get(\"shop page\")} - 1, max_page_size), -1)\n\n; color of our pointer\n; we set the color of the selected item\n#pointer \"<color=#0AF>\"\n; \n; macros to handle the position of our internal pointer\n; the pointer has the same naming scheme as an item, but\n; its hiding block isn't ended inside\n; this makes it the only stat with characteristics of items\n; \n#pointer.internal {item(\"internal pointer\")}\n#pointer.get {stats.get({pointer.internal})}\n#pointer.set(value) {stats.set({pointer.internal}, {value})}\n\n; Macros to get data out of our registered items\n; for clarity this is how the data is stored\n; \n; click->idle->price->name->description\n; \n; calculate the offset from our root\n; this is a compressed formula, that takes in\n; our curent position, the number of `effect displace` present\n; and other displacements\n; \n; this turns getting the discription from\n;  * effect_displace + effect_displace + price_displace + name_displace\n; into\n;  * 2, price_displace + name_displace\n; \n; the displace function gets us the corect offset by\n; multiplying the internal page size with the current page size\n; adding the position to this value, and then multiplying everything\n; by the segment length\n; this calculation will fail if page_size has varying values\n; \n#items.displace(position, effect_count, other_displace) {other_displace} \\\n  + ({effect_count} * effect_displace) + (\\\n    (({stats.get(\"shop page\")} - 1) * {page_size}) + {position}\\\n  ) * segment_length\n; \n; Macros to easily get the wanted substring and index\n; the offset needs to be removed to get the text length\n; additionally, we've already declaired our character to\n; mark the end of text, so the only change needed to make is\n; inside of Shop Creation, if you want a different character\n#items.substring(position, effect_count, other_displace, length) sub(\\\n  items, \\\n  {items.displace({position}, {effect_count}, {other_displace})},\\\n  {length}\\\n)\n#items.index(position, effect_count, other_displace) index(\\\n  items, \\\n  text_separator, \\\n  {items.displace({position}, {effect_count}, {other_displace})}\\\n) - ({items.displace({position}, {effect_count}, {other_displace})})\n\n"],["init",":import clicker lib\n:name {package(init)}\n\nkey.{clicker_start}()\n\n; the starter program\n; all scripts with a triggered impulse\n; make sure this script is triggered\n; \n; initialise the 3 core stats of an incremental game\n{stats.set(\"points\", 0)}\n{stats.set(\"points per click\", 1)}\n{stats.set(\"points per second\", 0)}\n\n; start our pointer\n; since it has a hiding block that doesn't end\n; we end it in the shop\n{pointer.set(0)}\n{item.set(\"shop\", \"</size>\" . \"=======shop=======\")}\n\n; initialise the shop page\n{stats.set(\"shop page\", 1)}\n\n; and finally, create the hidden UI variables\n{item.set(\"description\", \"\")}\n{item.set(\"effect per click\", \"\")}\n{item.set(\"effect per second\", \"\")}\n{item.set(\"cost\", \"\")}\n\n; we want to have our store created before our points\nexecutesync(\"{package(page system)}\")\nexecute(\"{package(points)}\")\n"],["page system",":import clicker lib\n:name {package(page system)}\n\nkey.{page_increase}()\nkey.{page_decrease}()\n\n; our page system\n; this block ensures we are initialised\n; since we're called by init, we can safely quit\n; \n; We can remove the initialised bool to clear an action\n; but since we're well in our limit, we can safely keep it\n; for guaranteed stability\n\n:local bool initialised\ninitialised = contains({item.get(\"shop\")}, \"</size>\")\n\nexecute(if(\\\n  initialised, \\\n  \"{garbage_requested}\", \\\n  \"{package(init)}\"\\\n))\ngotoif(99, initialised == false)\n\n; Update our shop page in accordance to the impulse\n; the macro names of the impulse should be clear enough\n; additionally, we set pointer to 0 if the page changes\n; we would not want the pointer at position 5 to stay there\n; on a new page\n{stats.set(\"shop page\", if(\\\n  contains(impulse(), \"{package()}\"), \\\n  {stats.get(\"shop page\")}, \\\n  if(\\\n    contains(impulse(), \"key.{page_increase}\"), \\\n    min({stats.get(\"shop page\")} + 1, page_count), \\\n    max({stats.get(\"shop page\")} - 1, 1)\\\n  )\\\n))}\n{pointer.set(if(contains(impulse(), \"key.\"), 0, {pointer.get}))}\n; the item loop\n; setting the name of all items on this page\n; \n:local int i\n\nitem_loop:\n{item.set(\"item\" . i, {items.substring(\\\n  i, \\\n  2, \\\n  price_displace, \\\n  {items.index(i, 2, price_displace)}\\\n)})}\n\n; look at clicker lib to understand this items.substring better\n; it's essentially just a sub() that takes less space\n; \n; we increment until i is the length of our page size\n; \ni += 1\ngotoif(item_loop, i < {page_size})\n; \n; check if the pointer system called us\n; if it didn't, we wake it up to add the pointer\n; we want the pointer to be active so that the user\n; instantly has a sellection\n; \n; tho it's not needed, since the system built\n; permits the pointer to be absent, I personally prefer this\n; \nexecute(if(\\\n  contains(impulse(), \"{package(pointer system)}\"), \\\n  \"{garbage_requested}\", \\\n  \"{package(pointer system)}\"\\\n))\n; We are not a turbo script, so there's no need for a no-op setup\n; \n"],["pointer system",":import clicker lib\n:name {package(pointer system)}\n\nkey.{pointer_increase}()\nkey.{pointer_decrease}()\n\n; \n; we repeat the same first start block as in page system\n; we end the process since we're woken up by page system\n; \n:local bool initialised\ninitialised = contains({item.get(\"shop\")}, \"</size>\")\n\nexecute(if(\\\n  initialised, \\\n  \"{garbage_requested}\", \\\n  \"{package(init)}\"\\\n))\ngotoif(99, initialised == false)\n\n; we execute page system to not have more than 1 sellection\n; a check on the impulse is not needed\n; since we're usually always going to execute page system\nexecutesync(\"{package(page system)}\")\n\n; update our pointer according to our impulse\n; we have a min value of 0, and a max of {page_size} - 1\n{pointer.set(if(\\\n  contains(impulse(), \"{package()}\"), \\\n  {pointer.get}, \\\n  if(\\\n    contains(impulse(), \"key.{pointer_increase}\"), \\\n    min({pointer.get} + 1, {page_size} - 1), \\\n    max({pointer.get} - 1, 0)\\\n  )\\\n))}\n\n; set up the store for the user to be able to see\n; since we always refresh the shop to remove the color\n; we can easily call for the item directly, instead of \n; getting a substring of the item\n; \n; we convert the input from a string to an int\n; and then back to a string so that the player\n; sees `cost = 50` instead of `cost = 00000050`\n{item.set(\"item\" . {pointer.get}, {pointer} . {item.get(\"item\" . {pointer.get})} . \"</color>\")}\n{item.set(\"description\", {items.substring(\\\n  {pointer.get}, \\\n  2, \\\n  price_displace + name_displace, \\\n  {items.index({pointer.get}, 2, price_displace + name_displace)}\\\n)})}\n{item.set(\"effect per click\", \"points per click + \" . i2s(\\\n  s2i({items.substring({pointer.get}, 0, 0, effect_displace)}, 0)\\\n))}\n{item.set(\"effect per second\", \"points per second + \" . i2s(\\\n  s2i({items.substring({pointer.get}, 1, 0, effect_displace)}, \\\n  0)\\\n))}\n{item.set(\"cost\", \"cost = \" . i2s(\\\n  s2i({items.substring({pointer.get}, 2, 0, price_displace)}, 0)\\\n))}\n\n"],["shop",":import clicker lib\n:name {package(shop)}\n\nkey.{buy_at_pointer}()\nkey.{buy_best}()\n\n:local int shopper\n:local bool initialised\n:local int price\n\n; \n; Setup sequence seen inside of page system\n; we quit on line 3\n; even tho the script self exits \ninitialised = contains({item.get(\"shop\")}, \"</size>\")\n\nexecute(if(\\\n  initialised, \\\n  \"{garbage_requested}\", \\\n  \"{package(init)}\"\\\n))\ngotoif(99, initialised == false)\n\nshopper = if(\\\n  contains(impulse(), \"key.{buy_best}\"), \\\n  1 + {page_size}, \\\n  1 + {pointer.get}\\\n)\n\n; we enter this sequence no matter the impulse\n; we pre-increment shopper for this setup to\n; always give a valid value\nbuy_best_loop:\n\nshopper = shopper - 1\nprice = s2i(\\\n  {items.substring(shopper, 2, 0, price_displace)}, \\\n  d2i(99 ^ price_displace)\\\n)\n\n; this condition will only proceed if\n; * we're buying max\n; * shopper is positive (since we cannot have item -1)\n; * price is bigger than our amount of points, since we cannot have \n;   a negative amount of points\n; \ngotoif(buy_best_loop, \\\n  contains(impulse(), \"key.{buy_best}\") && \\\n  shopper >= 0 && {stats.get(\"points\")} < price\\\n)\n; this gotoif stops us from trying to buy something\n; we cannot afford\n; this condition does not serve the same purpose as in\n; the previous gotoif even tho they both look the same\n; this condition exits the script if we're buying at the pointer\n; or if we're buying the first item in buy max, and we cannot afford it\n; the previous condition is to exit once we can afford an item\n; \ngotoif(99, {stats.get(\"points\")} < price)\n\n; we can now safely add the items to our stats\n; if the conversion fails, we return 0 just so that the player doesn't\n; lose progress because of a mistake I made\n{stats.add(\"points per click\", s2i({items.substring(shopper, 0, 0, effect_displace)}, 0))}\n{stats.add(\"points per second\", s2i({items.substring(shopper, 1, 0, effect_displace)}, 0))}\n{stats.set(\"points\", {stats.get(\"points\")} - price)}\n\n"],["points",":import clicker lib\n:name {package(points)}\n\nmouse.{click}.down()\nkey.{click}()\n\n; we perform the same check as in page system\n:local bool initialised\ninitialised = contains({item.get(\"shop\")}, \"</size>\")\n\nexecute(if(\\\n  initialised, \\\n  \"{garbage_requested}\", \\\n  \"{package(init)}\"\\\n))\ngotoif(99, initialised == false)\n\n; increment if we have a click\n; exit the script\nincrement:\nglobal.int.set(\\\n  \"points\", \\\n  global.int.get(\"points\") + global.int.get(\"points per click\")\\\n)\ngotoif(99, contains(\"mouse.{click}.down|key.{click}\", impulse()))\n\n; we have a clicks per second loop here\n; we wait 1 second so that we don't have\n; a clicks per frame loop\nclicks_per_second:\nwait(1.0)\nglobal.int.set(\\\n  \"points\", \\\n  global.int.get(\"points\") + global.int.get(\"points per second\")\\\n)\ngoto(clicks_per_second)\n"],["DEBUGGING",":import clicker lib\n:name {package(DEBUGGING)}\n\n#deb.displace(position, effect_count, other_displace) {other_displace} \\\n  + ({effect_count} * effect_displace) + (({position} + (page  * s2i(sub(pages, page, 1), 1))) * segment_length)\n\n#deb.substring(position, effect_count, other_displace, length) sub(\\\n  data, \\\n  {deb.displace({position}, {effect_count}, {other_displace})},\\\n  {length}\\\n)\n#deb.index(position, effect_count, other_displace) index(\\\n  data, \\\n  text_separator, \\\n  {deb.displace({position}, {effect_count}, {other_displace})}\\\n) - ({deb.displace({position}, {effect_count}, {other_displace})})\n\n\nkey.x()\n\nfalse == true\n\n:global string effect_click\n:global string effect_idle\n:global string price\n:global string name\n:global string description\n:local string data\n\ndata = items\n\n:global int pointer\n:global int page\n\npage = page % page_count\npointer = pointer % s2i(sub(pages, page, 1), 1)\n\neffect_click = {deb.substring(pointer, 0, 0, effect_displace)}\neffect_idle = {deb.substring(pointer, 1, 0, effect_displace)}\nprice = {deb.substring(pointer, 2, 0, price_displace)}\nname = {deb.substring(\\\n  pointer, \\\n  2, \\\n  price_displace, \\\n  {deb.index(pointer, 2, price_displace)}\\\n)}\ndescription = {deb.substring(\\\n  pointer, \\\n  2, \\\n  price_displace + name_displace, \\\n  {deb.index(pointer, 2, price_displace + name_displace)}\\\n)}\n\npointer = pointer + 1\npage = (page + pointer / s2i(sub(pages, page, 1), 1)) % page_count\n"]]}}
```

The ingame code is imported inside of the game and is what's used to interact with the system
```
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
```

### Import requirements
The AI requires space for
- 6 scripts
- 2 impulses
- 1 condition
- 12 actions

# Changelog
There is no version control yet, just assume these are all v0.0 until I add a version<br>
Added mostly all comments<br>
Fixed the issue where my pointer system would be static<br>
first push of project Clicker
