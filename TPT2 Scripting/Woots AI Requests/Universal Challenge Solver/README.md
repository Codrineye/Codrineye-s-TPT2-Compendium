# Universal Challenge Solver

v 1.0.1

A single package that can use all the blueprints in the [challenges github link](https://github.com/bluecats-Perfect-Tower-2/bluecats-PerfectTower2-comp./blob/main/Challenges/Hardmode/Pre%20Era/README.md).

# Development

This section is specifically for the development side of this AI, if you want the import, you [already passed it](#ai-import).<br>
Source code to be imported in [the external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/).

To be able to work with it, you will need to import the [blueprint compactor](../../Codrineye's%20Compactors/Codrineye's%20Blueprint%20Compactor/README.md)

```
{"workspaces":{"Universal Challenge Solver":[["Uni Solver Software Config",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(3)}\n{wave_streaming(3)}\n{wave_surge(2)}\n{critical_wave_jump(1)}\n{wave_momentum(1)}\n{wave_storm(1)}\n{wave_persistence(1)}\n{wave_instability(1)}\n{wave_vortex(1)}\n{wave_catalyst(1)}\n{wave_endurance(1)}\n{new_bounds(1)}\n{wave_marathon(1)}\n{wave_compression(1)}\n{era_surge(1)}\n{era_burst(1)}\n{era_swirl(1)}\n{wave_horizon(1)}\n{no_bounds(1)}\n{era_tunneling(1)}\n{wave_breach(1)}\n{wave_floor(1)}\n{era_floor(1)}\n{era_horizon(1)}\n{wave_restart(1)}\n{infinity_horizon(1)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {software.concat(software_len)}\n\n:local int watercat\n#watercat_index_reset watercat = 0\n\n#watercat_sub(list) sub(\\\n  {list}, \\\n  watercat, \\\n  index({list}, \"|\", watercat) - watercat\\\n)\n\n#watercat_line1(secure_level) \\\nsoftware_toggle_loop:\\\nsoftware.toggle(\\\n  {watercat_sub(software_list)},\\\n  {secure_level} <= s2i({watercat_sub(software_secure)}, -1)\\\n)\n#watercat_line2 watercat = 1 + index(software_list, \"|\", watercat)\n#watercat_line3 gotoif(software_toggle_loop, watercat < software_len)\n"],["Uni Solver Spell Config",":import Cods Blueprint Compactor\n:name Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; Please read the compactor manual on the repo for a better\n; understanding of how to use it\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; timer_modulo(modulo)\n; Should be used before you use recorded_blueprint to define a\n; blueprint that can loop\n; \n; this modulo value is used to \n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n; bp 1-1\n; bp 1-2\n; bp 1-3\n; bp 1-4\n{add_spell.grounded(spell.toxicivy, 0.0, 0.0, 0.0)}\n{recorded_blueprint(c1_5, true)}\n; bp 1-6\n\n{add_spell.grounded(spell.firestorm, 0.0, 0.0, 0.0)}\n{recorded_blueprint(c2_1, true)}\n; bp 2-2\n; bp 2-3\n; bp 2-4\n{add_spell.grounded(spell.toxicivy, 0.0, 0.0, 0.0)}\n{add_spell.instant(spell.desperado, 5.0)}\n{timer_modulo(30.0)}\n{recorded_blueprint(c2_5, true)}\n; bp 2-6\n\n; bp 3-1\n{add_spell.instant(focus.fire, 0.0)}\n{timer_modulo(1e-5)}\n{recorded_blueprint(c3_2, true)}\n; bp 3-3\n; bp 3-4\n{add_spell.grounded(spell.toxicivy, 0.0, 0.0, 0.6)}\n{timer_modulo(25.0)}\n{recorded_blueprint(c3_5, true)}\n; bp 3-6\n\n; bp 4-1\n; bp 4-2\n; bp 4-3\n; bp 4-4\n; bp 4-5\n{add_spell.instant(spell.recharge, 45.0)}\n{recorded_blueprint(c4_6, false)}\n\n; bp 5-1\n{add_spell.instant(focus.water, 0.0)}\n{timer_modulo(90.0)}\n{recorded_blueprint(c5_2, true)}\n\n{add_spell.grounded(spell.something, 0.0, 25.0, 25.0)}\n{recorded_blueprint(c5_3S, false)}\n{add_spell.grounded(spell.something, 0.0, 5.0, 5.0)}\n{add_spell.grounded(spell.something, 0.0, -5.0, 5.0)}\n{add_spell.grounded(spell.something, 0.0, 5.0, -5.0)}\n{add_spell.grounded(spell.something, 0.0, 0.0, 0.0)}\n{recorded_blueprint(c5_3L, true)}\n; open the modules menu\n; {pos.relative(0.0, 250.0 / 450.0, 0.0, 0.5)}\n; click on buy x1 button\n; {pos.relative(180.0/1280.0, 42.0/720.0, 0, 0)}\n; \n; buy granite foundation\n; {pos.relative(160.0 / 1280.0, 580.0 / 720.0, 0, 1)}\n; loop until granite foundation bought\n; \n; {pos.relative(160.0 / 1280.0, 480.0 / 720.0, 0.0, 1.0)}\n; buy adaptive regen\n; {pos.relative(160.0 / 1280.0, 380.0 / 720.0, 0.0, 1.0)}\n; buy ocean gift\n; \n; must activate wave surge if wave() > 250\n\n{add_spell.grounded(spell.toxicivy, 0.0, 0.0, 0.0)}\n{recorded_blueprint(c5_4, true)}\n\n\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {recorded_actives}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the concat operation one more time, which\n; can get very expensive if you have a big recording sequence\n\n:const int recoring_size {recording_size}\n"],["Challenge_lib",":import Uni Solver Software Config\n:import Uni Solver Spell Config\n:import Blueprint Compactor resources\n\n#package(name) Challenge Solver:{name}\n#identify Challenge Solver\n#identifier \"Challenge Solver\"\n\n#up w\n#down s\n#left a\n#right d\n#start t\n\n:const string instructions \"<size=0>{identify}instructions\"\n#instructions \"<size=0>\" . {identifier} . \"instructions\"\n#status \"<size=0>\" . {identifier} . \"status\"\n#visual {identifier} . \"visual\"\n#output {visual} . \"</size>\" . \"Challenge\"\n#get_visual(x) global.int.get({visual} . ({x}))\n\n\n; simple lua macro for recording coordinates\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.diff = {};\\\n  TowerTest.max_digits = 0;\\\n)}\n#set_difficulty(coord_y) {lua(\\\n  TowerTest.diff[1 + #TowerTest.diff] = [[{coord_y}]];\\\n  TowerTest.max_digits = math.max(\\\n    TowerTest.max_digits,\\\n    #[[{coord_y}]]\\\n  )\\\n)}\n\n{set_difficulty(290.0)}\n{set_difficulty(256.0)}\n{set_difficulty(217.0)}\n{set_difficulty(182.0)}\n{set_difficulty(145.0)}\n{set_difficulty(112.0)}\n\n; click on the button to switch challenges to hard mode\n{set_difficulty(77.0)}\n\n; const variables to make the difficulty logic easier to follow\n:const int challenge_length {lua(return TowerTest.max_digits)}\n\n:const string challenges \"{lua(\\\n  local diff_list = {};\\\n  for _, diff in ipairs(TowerTest.diff) do\\\n    diff_list[1 + #diff_list] = diff;\\\n  end\\\n  return table.concat(diff_list)\\\n)}\"\n"],["init",":import Challenge_lib\n:name {package(init)}\n\nwakeup()\nkey.{start}()\nkey.{up}()\nkey.{down}()\nkey.{right}()\nkey.{left}()\n\n\n#target(selection) \"<color=#00A0F0>\" . ({selection}) . \"</color>\"\nglobal.int.set({status}, if(\\\n  contains(impulse(), \"key.\"), \\\n  2, \\\n  global.int.get({status})\\\n))\n\nglobal.int.set({visual} . \"0\", {get_visual(0)})\nglobal.int.set({visual} . \"1\", {get_visual(1)})\nglobal.string.set({output}, if(\\\n  global.int.get({status}) == 0, \\\n  \"C\" . {target(sub(i2s(101 + {get_visual(0)}), 1, 2))} . \"-\" . i2s(1 + {get_visual(1)}), \\\n  if(\\\n    global.int.get({status}) == 1, \\\n    \"C\" . sub(i2s(101 + {get_visual(0)}), 1, 2) . \"-\" . {target(1 + {get_visual(1)})}, \\\n    \"C\" . sub(i2s(101 + {get_visual(0)}), 1, 2) . \"-\" . i2s(1 + {get_visual(1)})\\\n  )\\\n))\n\nglobal.string.set({instructions}, if(\\\n  contains(impulse(), \"key.\"), \\\n  \"</size>\", \\\n  \"</size>\" . \"Challenge=C<region>-<challenge>\" . \"<br>\" \\\n  . \"<color=#00A0F0>\" . \"{up}{left}{down}{right} moves, {start} begins the challenge\" . \"</color>\"\\\n))\n\ngoto(if(\\\n  contains(impulse(), \"{package()}\") || contains(impulse(), \"wakeup\"), \\\n  99, \\\n  if(anyopen() || isTowerTesting() || isBossFight(), warn, skip)\\\n))\nwarn:\nglobal.string.set(\\\n  \"<color=#F00>\" . \"<b>\" . \"warning\", \\\n  \"Exit All Buildings and/or active games\" . \"</b>\" . \"</color>\"\\\n)\n\nwaitwhile(anyopen() || isTowerTesting() || isBossFight())\nglobal.unset(\"<color=#F00>\" . \"<b>\" . \"warning\")\n\nskip:\nshow(\"towertesting\", true)\nexecutesync(\"{package(TowerTesting)}\")\nexecute(\"{package(init)}\")\n\n"],["TowerTesting",":import Challenge_lib\n:name {package(TowerTesting)}\n\nkey.{left}()\nkey.{right}()\n\n:local int region\n\nexecutesync(if(\\\n  contains(impulse(), \"key.\"), \\\n  \"{package(init)}\", \\\n  \"{package(N/A)}\"\\\n))\ngotoif(change, contains(impulse(), \"key.\"))\n; enter challenge mode\n{click.relative(615.0/800.0, 380.0/450.0, 0.7, 1.0)}\n\nregion = {get_visual(0)}\nloop:\n; move regions\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\nregion = region - 1\ngotoif(loop, region > 0)\n\n#curent_challenge s2d(sub(challenges, {get_visual(1)} * challenge_length, challenge_length), 290.0)\n; Sellect the challenge\n{click.relative(395.0/800.0, {curent_challenge}/450.0, 0.0, 1.0)}\n\n; launch tower testing\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\nexecutesync(\"{package(ui)}\")\ngoto(99)\nchange:\nglobal.int.set({status}, if(\\\n  contains(impulse(), \"key.{left}\"), \\\n  0, \\\n  1\\\n))\nexecute(\"{package(init)}\")\n"],["ui",":import Challenge_lib\n:name {package(ui)}\n\n:local int limit\n:local int region\n\nkey.{up}()\nkey.{down}()\n\nexecutesync(if(\\\n  contains(impulse(), \"key.\"), \\\n  \"{package(init)}\", \\\n  \"{package(N/A)}\"\\\n))\ngotoif(change, contains(impulse(), \"key.\"))\nwaitwhile(isTowerTesting())\n\nshow(\"towertesting\", true)\nregion = 14 - {get_visual(0)}\nloop:\n; move regions\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\nregion = region - 1\ngotoif(loop, region > 0)\nshow(\"towertesting\", false)\ngoto(99)\n\nchange:\nlimit = if(global.int.get({status}) == 0, 14, 5)\nglobal.int.set({visual} . i2s(global.int.get({status})), max(\\\n  0, \\\n  min(limit, if(\\\n    contains(impulse(), \"key.{up}\"),\\\n    {get_visual(global.int.get({status}))} + 1, \\\n    {get_visual(global.int.get({status}))} - 1\\\n  ))\\\n))\nexecute(\"{package(init)}\")\n"]]}}
```

## To be done

needs better variable names<br>
figure out the formula to make Check Coordinates work as expected<br>
figure out the UI scale breakpoint for module shifts<br>
find the old document which had the needed data for this AI<br>
add comments to every document, no matter how redundant

## versions

### version 1.0.1

- Replaced old compactor with new one.
- Cleaned up whatever junk was in the workspace.

### version 1.0.0

- AI published
- Added movement system to change regions and challenges
- Implemented a primitive library
- Decided on a formal release schematic
