# winAMD

This is a blueprint script made by WootImNoob that works to automate its connected blueprint

## Import Codes

This is the scripts blueprint:

```
bVIxjtwwDPxKsA/QA05VkLSHNNcFKWiJtomTKYOi1rcJ8vdQ9trQAak8HFI0Z8g/tyFVXIVYy+3ly8/bRvz19c0rRXQpbx4ZZXq4AQqFMxCcGgKlzCc3dsWC4RES8eTLiim1eAaZ0EcckQu6oaYN5P2KQ+ZYg2Z5PigM64/xOxYlfviJRnWMVQWSLzNhio6WJYtCIn2cVKQ7lTaRYKGiwAEdDMXP1ToqGUF18farO0qrc2veUDyIdbIRR2KM1qv9fyTBJ9xArejACKLzEwOdLIPWqzzRNOsTR5PIWMr5OmFQodBG7kbcrTRvd5VjtoweOGJBsV7rjILusPbUCvHeHsfTL1rWhDM2f3bizHdUpPb12dSnDGbX4X0/yulxR1WmZpeR+GFL5Om/1KX0Ypo9V3B42HXd/b3SvTFjrhz3w3ILyJA+zWeFC7JtvS+LBIudT08R2zL3yzjOD97LtyqmdW7LZvqN4trZB1A/5Fy00xSE+vBIH1vdUzu8/fr7Dw==
```

And this is AI
```
{"workspaces":{"winAMT":[["winAMT lib","#package(name) winAMT:{name}\n; consistent naming accross scripts\n\n\n; Using lua here so you can easily edit what elements get prioritised\n; elements stores the era elements in the order you want them in\n; element_cost is just the pre-computed disable.cost(element) function call\n; par is just to create a set of parenthesies I can use all arround\n; par[1] = `(` and par[2] = `)`\n{lua(\\\n  elements = {};\\\n  element_cost = {};\\\n  par = table.pack(\\\n    \"(\", \\\n    \")\"\\\n  );\\\n  --[[disable.cost and if() require parenthesies]]\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[]] no parse blocks are recommended here\n; Use this to create the priority listing\n#set_priority(element_name) {lua(\\\n  local name = [[{element_name}]];\\\n  local index = 1 + #elements;\\\n  elements[index] = table.concat(table.pack('\"', name, '\"'));\\\n  element_cost[index] = table.concat(table.pack(\\\n    \"disable.cost\", par[1], \\\n      elements[index], \\\n    par[2]\\\n  ));\\\n)}\n\n; Use this to get the big ol if() else if() statement\n#disable.era {lua(\\\n    local idx = #elements;\\\n    local printer = {};\\\n    for i, name in ipairs(elements) do\\\n      --[[/*\\\n          * Concat printer so the previous text isn't lost\\\n          * Create the if(disable.cost != -1.0, element, if()) statement\\\n         */]]\\\n      printer = table.pack(\\\n        table.concat(printer),\\\n        \"if\", par[1], \\\n        element_cost[i], \" != \", -1.0,\\\n        \", \", name, \", \"\\\n      );\\\n    end\\\n    --[[/*\\\n        * We've now made an if statement for every element\\\n        * remove the last if statement because that one's the\\\n        * result if all other costs are -1\\\n        * add the last element name and slap on\\\n        * the ending parenthesies :par[2]\\\n       */]]\\\n    printer = table.pack(\\\n      printer[1], \\\n      elements[idx], \\\n      string.rep(par[2], idx - 1)\\\n    );\\\n    return table.concat(printer);\\\n)}\n\n; helper macro to get the sum of all costs\n#element_costs {lua(\\\n  local costs = {}\\\n  for _, cost in ipairs(element_cost) do\\\n    --[[We just do disable.cost(element) + disable.cost(element)]]\\\n    costs = table.pack(table.concat(costs), cost, \" + \");\\\n  end\\\n  --[[We remove the last + and return the concat values]]\\\n  return table.concat(table.pack(costs[1], costs[2]));\\\n)}\n"],["main",":import winAMT lib\n:name {package(main)}\n\n; Use these macros to determine the order in which\n; the era abilities get disabled\n\n:global bool waves_lock\n:global double tm\n\ngame.newround()\n\nstop(\"{package(waves)}\")\nstop(\"{package(rak)}\")\nstop(\"{package(wootclock)}\")\nstop(\"{package(wootsync)}\")\n; stop(\"{package(wootSpam)}\")\n\nwaves_lock = true\nexecute(\"{package(wootclock)}\")\nexecute(\"{package(waves)}\")\n\ngotoif(99, software.enabled(\"software.wavehorizon\"))\nwaitwhile(waveAcceleration() >= 10.0)\nexecutesync(\"{package(rak)}\")\nwaves_lock = false\n\nwaituntil(waves_lock || health(false) <= 0.0)\ngotoif(99, health(false) <= 0.0)\n\nexecute(\"{package(wootsync)}\")\n; execute(\"{package(wootSpam)}\")\n\nwaitwhile(tm > 0.1 && health(false) > 0.0)\nwaitwhile(tm <= 0.1 && health(false) > 0.0)\ngotoif(99, health(false) <= 0.0)\n\nuseinstant(active.index(\"sphere.energy\"))\n"],["waves",":import winAMT lib\n:name {package(waves)}\n\n:local double restart_detect\n:global bool waves_lock\n\nwaves_lock = waves_lock\n; initializes waves_lock if it's used stand-alone\n\ngotoif(disabled, not(software.enabled(\"software.wavehorizon\")))\nsoftware.toggle(\"software.criticalWavejump\", false)\nsoftware.toggle(\"software.wavemomentum\", false)\nsoftware.toggle(\"software.wavestorm\", false)\nsoftware.toggle(\"software.wavepersistence\", false)\nsoftware.toggle(\"software.waveinstability\", false)\nsoftware.toggle(\"software.wavevortex\", false)\nsoftware.toggle(\"software.wavecatalyst\", false)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.newbounds\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.wavecompression\", false)\nsoftware.toggle(\"software.nobounds\", false)\nsoftware.toggle(\"software.wavehorizon\", false)\nsoftware.toggle(\"software.wavebreach\", false)\nsoftware.toggle(\"software.erafloor\", false)\nsoftware.toggle(\"software.waverestart\", false)\nsoftware.toggle(\"software.infinityhorizon\", false)\n\n; disables a lot of things, I can easily convert it into\n; a gotoif() loop to only happen in about 3 actions\n\n\nrestart_detect = fixedWavesPerInterval()\n; restart detection, if we've restarted, the\n; snapshot of fixedWavesPerInterval should be\n; bigger than the curent value\n\nrestart:\nrestart()\ngoto(if(\\\n  fixedWavesPerInterval() >= restart_detect, \\\n  restart, \\\n  99\\\n))\n\ndisabled:\nwaituntil(not(waves_lock))\n; lock for everything to finish\n\nsoftware.toggle(\"software.wavefloor\", true)\nsoftware.toggle(\"software.wavevortex\", true)\nsoftware.toggle(\"software.waveendurance\", true)\nsoftware.toggle(\"software.wavemarathon\", true)\nsoftware.toggle(\"software.wavecompression\", true)\nsoftware.toggle(\"software.wavehorizon\", true)\nsoftware.toggle(\"software.wavebreach\", true)\nsoftware.toggle(\"software.infinityhorizon\", true)\n\nwaituntil(fixedWavesPerInterval() >= 3.9999e16)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.waveendurance\", true)\nsoftware.toggle(\"software.wavemarathon\", true)\n\nwaituntil(fixedWavesPerInterval() >= 3.99999999e16)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.wavehorizon\", false)\n\n; signal that we've finished\nwaves_lock = true\n"],["rak",":import winAMT lib\n:name {package(rak)}\n\n:global double raxtax\n:local double stax\n:local double hp\n\nhp = health.max()\nuseinstant(active.index(\"spell.raksCurse\"))\ngotoif(99, health(false) == 0.0)\nstax = if((health.max() / hp) < 9.0, stax, stax + 1.0)\nraxtax = stax\n\ngotoif(0, stax < 5.0)\n"],["wootclock",":import winAMT lib\n:name {package(wootclock)}\n\n:budget_cap 1\n\n:global double t\n:global double tm\n:global double skips\n\ngotoif(start_infty, contains(impulse(), \"{package(main)}\"))\nt = time.delta() * 2.0\n\nloop:\nwaitframe()\n; waitframe needed because we're using atomic actions\nt = t + time.delta()\ntm = t % 24.5\nskips = fixedWavesPerInterval()\ngoto(loop)\n\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(fire)}\n{set_priority(water)}\n{set_priority(earth)}\n{set_priority(electricity)}\n{set_priority(nature)}\n{set_priority(air)}\n\nstart_infty:\nexecute(\"{package(wootclock)}\")\n\ninfty:\ndisable.era({disable.era})\n\ndisable.inf(\"gift.neutral\")\ndisable.inf(\"resistance.abs\")\ndisable.inf(\"shield.immortality\")\n\ngoto(infty)\n"],["wootsync",":import winAMT lib\n:name {package(wootsync)}\n\n:global double tm\n:global bool spam\n\nspam = not(spam)\n\nloop:\nwaitwhile(tm <= 0.1)\n\nspam_chunk_1:\nuseinstant(active.index(\"spell.recharge\"))\nuseinstant(active.index(\"shield.immortality\"))\ngotoif(spam_chunk_1, cooldown(active.index(\"shield.immortality\")) <= 5.0)\n\nspam = not(spam)\n\nwaitwhile(tm < 4.6)\nspam = not(spam)\nwaitwhile(tm < 4.8)\n\nspam_titanium:\nuseinstant(active.index(\"hull.titanium\"))\n\ngotoif(spam_titanium, cooldown(active.index(\"hull.titanium\")) <= 20.0)\n\nspam = not(spam)\nwaitwhile(tm < 14.8)\n\ngotoif(skip_snap, fixedWavesPerInterval() < 1e16)\nuseinstant(active.index(\"spell.snapOfDestiny\"))\n\nskip_snap:\nwaitwhile(tm < 24.3)\n\nspam = not(spam)\n\nwaitwhile(tm > 0.1)\ngoto(loop)\n"],["wootSpam",":import winAMT lib\n:name {package(wootSpam)}\n\n:global bool spam\n\ngotoif(multishot, contains(impulse(), \"{package(wootSpam)}\"))\nexecute(\"{package(wootSpam)}\")\n\nwootspam:\nwaituntil(spam)\nuseinstant(active.index(\"spell.simpleheal\"))\nuseinstant(active.index(\"spell.advancedheal\"))\nuseinstant(active.index(\"spell.dispel\"))\n\ngoto(wootspam)\n\nmultishot:\nuseinstant(active.index(\"spell.multishot\"))\nuseinstant(active.index(\"spell.superbounce\"))\ngoto(multishot)\n"]]}}
```

