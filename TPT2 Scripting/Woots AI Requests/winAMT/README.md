# winAMD

This is a blueprint script made by WootImNoob that works to automate its connected blueprint

## Import Codes

This is the scripts blueprint:

```
bVIxjtwwDPxKsA/QA05VkLSHNNcFKWiJtomTKYOi1rcJ8vdQ9trQAak8HFI0Z8g/tyFVXIVYy+3ly8/bRvz19c0rRXQpbx4ZZXq4AQqFMxCcGgKlzCc3dsWC4RES8eTLiim1eAaZ0EcckQu6oaYN5P2KQ+ZYg2Z5PigM64/xOxYlfviJRnWMVQWSLzNhio6WJYtCIn2cVKQ7lTaRYKGiwAEdDMXP1ToqGUF18farO0qrc2veUDyIdbIRR2KM1qv9fyTBJ9xArejACKLzEwOdLIPWqzzRNOsTR5PIWMr5OmFQodBG7kbcrTRvd5VjtoweOGJBsV7rjILusPbUCvHeHsfTL1rWhDM2f3bizHdUpPb12dSnDGbX4X0/yulxR1WmZpeR+GFL5Om/1KX0Ypo9V3B42HXd/b3SvTFjrhz3w3ILyJA+zWeFC7JtvS+LBIudT08R2zL3yzjOD97LtyqmdW7LZvqN4trZB1A/5Fy00xSE+vBIH1vdUzu8/fr7Dw==
```

And this is AI
```
{"workspaces":{"winAMT":[["winAMT lib",":import Editor_actions lib\n#package(name) winAMT:{name}\n; consistent naming accross scripts\n\n{lua(\\\n  elements = {};\\\n  element_cost = {};\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[]] no parse blocks are recommended here\n; Use this to create the priority listing\n#set_priority(element_name) {lua(\\\n  local name = [[{element_name}]];\\\n  local index = 1 + #elements;\\\n  elements[index] = string.format('\"%s\"', name);\\\n  element_cost[index] = editor_disableCost(elements[index]);\\\n)}\n\n#disable.era {lua(\\\n  local last_element = elements[#elements];\\\n  local function element_ternary(index, last)\\\n    if index == #elements then\\\n      return last;\\\n    end\\\n    local cost = element_cost[index];\\\n    local condition = editor_math(cost, \"!=\", -1.0);\\\n    local caseTrue = elements[index];\\\n    local caseFalse = element_ternary(index + 1, last);\\\n    return editor_if(condition, caseTrue, caseFalse);\\\n  end\\\n  return element_ternary(1, last_element);\\\n)}\n"],["main",":import winAMT lib\n:name {package(main)}\n\n; Use these macros to determine the order in which\n; the era abilities get disabled\n\n:global bool waves_lock\n:global double tm\n\ngame.newround()\n\nstop(\"{package(waves)}\")\nstop(\"{package(rak)}\")\nstop(\"{package(wootclock)}\")\nstop(\"{package(wootsync)}\")\n; stop(\"{package(wootSpam)}\")\n\nwaves_lock = true\nexecute(\"{package(wootclock)}\")\nexecute(\"{package(waves)}\")\n\ngotoif(99, software.enabled(\"software.wavehorizon\"))\nwaitwhile(waveAcceleration() >= 10.0)\nexecutesync(\"{package(rak)}\")\nwaves_lock = false\n\nwaituntil(waves_lock || health(false) <= 0.0)\ngotoif(99, health(false) <= 0.0)\n\nexecute(\"{package(wootsync)}\")\n; execute(\"{package(wootSpam)}\")\n\nwaitwhile(tm > 0.1 && health(false) > 0.0)\nwaitwhile(tm <= 0.1 && health(false) > 0.0)\ngotoif(99, health(false) <= 0.0)\n\nuseinstant(active.index(\"sphere.energy\"))\n"],["waves",":import winAMT lib\n:name {package(waves)}\n\n:local double restart_detect\n:global bool waves_lock\n\nwaves_lock = waves_lock\n; initializes waves_lock so it's initialized first, even\n; if it's used stand-alone, to prevent messy globals\n\ngotoif(disabled, not(software.enabled(\"software.wavehorizon\")))\nsoftware.toggle(\"software.criticalWavejump\", false)\nsoftware.toggle(\"software.wavemomentum\", false)\nsoftware.toggle(\"software.wavestorm\", false)\nsoftware.toggle(\"software.wavepersistence\", false)\nsoftware.toggle(\"software.waveinstability\", false)\nsoftware.toggle(\"software.wavevortex\", false)\nsoftware.toggle(\"software.wavecatalyst\", false)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.newbounds\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.wavecompression\", false)\nsoftware.toggle(\"software.nobounds\", false)\nsoftware.toggle(\"software.wavehorizon\", false)\nsoftware.toggle(\"software.wavebreach\", false)\nsoftware.toggle(\"software.erafloor\", false)\nsoftware.toggle(\"software.waverestart\", false)\nsoftware.toggle(\"software.infinityhorizon\", false)\n\n; disables a lot of things, I can easily convert it into\n; a gotoif() loop to only happen in about 3 actions\n\nrestart_detect = fixedWavesPerInterval()\n; restart detection, if we've restarted, the\n; snapshot of fixedWavesPerInterval should be\n; bigger than the curent value\n\nrestart:\nrestart()\ngoto(if(\\\n  fixedWavesPerInterval() >= restart_detect, \\\n  restart, \\\n  99\\\n))\n\ndisabled:\nwaituntil(not(waves_lock))\n; lock for everything to finish\n\nsoftware.toggle(\"software.wavefloor\", true)\nsoftware.toggle(\"software.wavevortex\", true)\nsoftware.toggle(\"software.waveendurance\", true)\nsoftware.toggle(\"software.wavemarathon\", true)\nsoftware.toggle(\"software.wavecompression\", true)\nsoftware.toggle(\"software.wavehorizon\", true)\nsoftware.toggle(\"software.wavebreach\", true)\nsoftware.toggle(\"software.infinityhorizon\", true)\n\nwaituntil(fixedWavesPerInterval() >= 3.9999e16)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.waveendurance\", true)\nsoftware.toggle(\"software.wavemarathon\", true)\n\nwaituntil(fixedWavesPerInterval() >= 3.99999999e16)\nsoftware.toggle(\"software.waveendurance\", false)\nsoftware.toggle(\"software.wavemarathon\", false)\nsoftware.toggle(\"software.wavehorizon\", false)\n\n; signal that we've finished\nwaves_lock = true\n"],["rak",":import winAMT lib\n:name {package(rak)}\n\n:global double raxtax\n:local double stax\n:local double hp\n\nhp = health.max()\nuseinstant(active.index(\"spell.raksCurse\"))\ngotoif(99, health(false) == 0.0)\nstax = if((health.max() / hp) < 9.0, stax, stax + 1.0)\nraxtax = stax\n\ngotoif(0, stax < 5.0)\n"],["wootclock",":import winAMT lib\n:name {package(wootclock)}\n\n:budget_cap 1\n\n:global double t\n:global double tm\n:global double skips\n\n:local bool ended_era\n\ngotoif(era, contains(impulse(), \"{package(wootclock)}\"))\nt = time.delta() * 2.0\nexecute(\"{package(wootclock)}\")\n\nloop:\nwaitframe()\n; waitframe needed because we're using atomic actions\nt = t + time.delta()\ntm = t % 24.5\nskips = fixedWavesPerInterval()\ngoto(loop)\n\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(fire)}\n{set_priority(water)}\n{set_priority(earth)}\n{set_priority(electricity)}\n{set_priority(nature)}\n{set_priority(air)}\n\nera:\ndisable.era({disable.era})\n\nended_era = -10 == {element_cost}\n\ninfty:\n\ndisable.inf(\"gift.neutral\")\ndisable.inf(\"resistance.abs\")\ndisable.inf(\"shield.immortality\")\n\ngoto(infty)\n"],["wootsync",":import winAMT lib\n:name {package(wootsync)}\n\n:global double tm\n:global bool spam\n\nspam = not(spam)\n\nloop:\nwaitwhile(tm <= 0.1)\n\nspam_chunk_1:\nuseinstant(active.index(\"spell.recharge\"))\nuseinstant(active.index(\"shield.immortality\"))\ngotoif(spam_chunk_1, cooldown(active.index(\"shield.immortality\")) <= 5.0)\n\nspam = not(spam)\n\nwaitwhile(tm < 4.6)\nspam = not(spam)\nwaitwhile(tm < 4.8)\n\nspam_titanium:\nuseinstant(active.index(\"hull.titanium\"))\n\ngotoif(spam_titanium, cooldown(active.index(\"hull.titanium\")) <= 20.0)\n\nspam = not(spam)\nwaitwhile(tm < 14.8)\n\ngotoif(skip_snap, fixedWavesPerInterval() < 1e16)\nuseinstant(active.index(\"spell.snapOfDestiny\"))\n\nskip_snap:\nwaitwhile(tm < 24.3)\n\nspam = not(spam)\n\nwaitwhile(tm > 0.1)\ngoto(loop)\n"],["wootSpam",":import winAMT lib\n:name {package(wootSpam)}\n\n:global bool spam\n\ngotoif(multishot, contains(impulse(), \"{package(wootSpam)}\"))\nexecute(\"{package(wootSpam)}\")\n\nwootspam:\nwaituntil(spam)\nuseinstant(active.index(\"spell.simpleheal\"))\nuseinstant(active.index(\"spell.advancedheal\"))\nuseinstant(active.index(\"spell.dispel\"))\n\ngoto(wootspam)\n\nmultishot:\nuseinstant(active.index(\"spell.multishot\"))\nuseinstant(active.index(\"spell.superbounce\"))\ngoto(multishot)\n"]]}}
```

