# Source Export
This is the source export

```
{"workspaces":{"Inf ?? BP":[["INF ?? Software Config",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(0)}\n{wave_streaming(0)}\n{wave_surge(0)}\n{critical_wave_jump(0)}\n{wave_momentum(0)}\n{wave_storm(0)}\n{wave_persistence(0)}\n{wave_instability(0)}\n{wave_vortex(0)}\n{wave_catalyst(0)}\n{wave_endurance(0)}\n{new_bounds(0)}\n{wave_marathon(0)}\n{wave_compression(0)}\n{era_surge(0)}\n{era_burst(0)}\n{era_swirl(0)}\n{wave_horizon(0)}\n{no_bounds(0)}\n{era_tunneling(0)}\n{wave_breach(0)}\n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n{wave_restart(0)}\n{infinity_horizon(0)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {software.concat(software_len)}\n\n:local int watercat\n"],["INF ?? lib",":import INF ?? Software Config\n#package(name) INF ?? BP:{name}\n\n; Library file of the script that would typically hold more macros.\n; This blueprint doesn't require much interaction, so the macros are just defined when needed.\n"],["init",":import INF ?? lib\n:name {package(init)}\n; init script used to summon the other scripts.\n\n:budget_cap 400\n; Budget cap of 400 so that the framebreak only happens after the scripts are executed\n\n:local int instance ; local helper variable for restart detection\n\nwakeup()\ngame.newround()\nisTowerTesting()\n\n; Hidden script status variable used for restart detection.\n; It's hidden to prevent global variable clutter\n; ?I%p? is the variables identifier, used to protect it against accidental use by other scripts\n\n:const string status \"<size=0>?I%p?\"\n#status.get global.string.get(status)\n#status.set(status) global.string.set(status, {status})\n; getter and setter macros\n\n\ninstance = 1 + s2i(sub({status.get}, 0, 1), 0) ; determine what instance we have\nloop:\n; status holds the instance count 0 1 or 2\n; 0 means nothing, 1 is the main running loop, 2 means a restart was detected\n{status.set(i2s(instance) . \"</size>\")}\n\n; Stop our running scripts. This does nothing in the main loop, but a restart should\n; stop the entire process instantly\nstop(\"{package(bluecat)}\")\nstop(\"{package(modules)}\")\n\n; Terminate the script instance if it was made made by a restart or if the tower died\ngotoif(end, instance > 1 || health(false) == 0.0)\n\nexecute(\"{package(bluecat)}\") ; Start our scripts. These contain infinite loops;\nexecute(\"{package(modules)}\")\n\n; This waitwhile condition lets the budget_cap be 400 instead of 500\n; Since restart cannot happen in the first few frames of towertesting starting up, it's\n; ok for the frame-break to happen after we execute the script called `modules`, because\n; we can guarantee that by the next frame, we won't have detected a restart, and that\n; the tower hasn't died. Even if the tower does die before this waitwhile, it's fine to wait\n; for a frame to pass.\nwaitwhile(contains({status.get}, i2s(instance)) && health(false) > 0.0)\n\n; Wait while our tower is alive and a restart hasn't been detected.\n; Go back to the top of the loop. We're here either because a restart happened or we died.\ngoto(loop)\nend:\n{status.set(i2s(instance - if(instance == 1, 1, 0)) . \"</size>\")}\n; Decrement the status ONLY if we're the main running status.\n; This needs to be like this because of how the execution stack works.\n;\n; The script summoned because of a restart will be put after the main instance of init\n; If we were to decrement the instance here, we wouldn't know that a restart even happened.\n"],["bluecat",":import INF ?? lib\n:name {package(bluecat)}\n; Script that handles all fundemental actions perfected by bluecat\n;\n:budget_cap 3200\n; Budget_cap of 3200 since there are\n; 4 era elements to disable + 26 software to toggle + 2 era dividor upgrades\n; The budget_cap can go higher than 3200, but 3200 is the absolute minimum needed for everything\n; in this script to happen in 1 frame\n;\n:global double t ; global ticker variable\n\nisTowerTesting()\n\ngotoif(software_toggle_loop, impulse() == \"{package(bluecat)}\")\nexecute(\"{package(bluecat)}\") ; create a new instance that actually executes this script\n; This first instance is in charge of running the ticker.\nt = 0.0 ; because of the execution budget, we no longer need 2 tickers running at a time\n; so this can just be set to 0.0, instead of time.delta() * 2.0\n\ntick:\nt += time.delta()\nwaitframe() ; Simple ticker loop. Count the time that's passed, wait a frame, return to tick\ngoto(tick)\n\n; This is where things get confusing, but without it here, things would become even more confusing.\n; watercat lines 1 2 and 3 are macros defined in The Blueprint Compactor that's imported in\n; INF ?? Software Config, which we import through INF ?? lib\n; These 3 lines are in charge of turning all the softwares on/off, given the security level\n; In this case, the security level is 0.\n{watercat_line1(0)}\n{watercat_line2}\n{watercat_line3}\n\n\n{set_priority(earth)} {set_priority(nature)} {set_priority(neutral)} {set_priority(fire)}\n\n; Then, the `set_priority` macro sets the priority in which era element ability we want to\n; disable. In this case, earth will be disabled before nature, which itself is disabled before\n; neutral, which is disabled before fire. No other elements will be disabled.\nearth_cat:\ndisable.era({disable.era})\n; These 2 lines use macros that abstract what's actually going on.\n; If you want to see what they're doing, put a character like `|` at the start of the respective\n; line.\n; disable.era is a long if chain that checks if this element isn't disabled, disable it, otherwise\n; try to disable the next.\n; disable_era is a sumation operation that's used to check if all our elements have been disabled\ngotoif(earth_cat, {disable_era})\n\n; Lastly, the upgrade.era loop. This is a continuous loop that upgrades the\n; damage and health dividors for enemies.\nupgrade.era:\nupgrade.era(\"damage\", 50)\nupgrade.era(\"health\", 50)\ngoto(upgrade.era)\n"],["modules",":import INF ?? lib\n:name {package(modules)}\n; Script that handles everything that partains to module usage.\n\n:budget_cap 1400\n; Budget_cap for 1400 to handle every action in 1 frame\n\n:local string modules\n:local int spell\n:global double t\n; variables `modules` and `spell` are used for activation encoding\n; global t is the ticker variable used for spell execution\n\nisTowerTesting()\n\ngotoif(multibounce, impulse() == \"{package(modules)}\")\nexecute(\"{package(modules)}\") ; execute self to activate multibounce sequence\n\nloop:\n; Massive assignment used to remove actions and minimise execution stress, if you believe it XD\n; this script works in 2 phases, phase 1 involves encoding our spells, phase 2 means using spells\n;\n; We check for which phase we're in by looking at the value of `spell`\n; If spell == 0 and modules is empty, that means we're in phase 1, where we encode the active index\n; of the spells we're going to be using.\n; Then, for as long as `modules` isn't empty, and spell is less than 9, we move to the next\n; active module to encode. This is accomplished with index(), since each module name ends with the\n; character `|`.\n;\n; Then, if we finish phase 1, phase 2 will encode the spells we want to use\n; if(t % 44.0 <= 1.0) use focus.fire and focus.neutral\n; if(t % 19.0 <= 1.0) use spell.fracture\n; if health is less than 0.48%, use advanceheal\n; if health is higher than 0.69%, use dark sacrifice\nmodules = if(\\\n  modules != \"\",\\\n  sub(modules, if(spell < 9, index(modules, \"|\", 0), 0) + 1, 99),\\\n  if(\\\n    spell == 0,\\\n    \"focus.fire|focus.neutral|spell.fracture|spell.advancedheal|sacrifice.dark|\",\\\n    if(t % 44.0 <= 1.0, \"01\", \"\") . if(t % 19.0 <= 1.0, \"2\", \"\") .\\\n    if(health(true) < 0.48, \"3\", if(health(true) >= 0.69, \"4\", \"\"))\\\n  )\\\n)\n\n\nlocal.int.set(\"spell\" . spell, active.index(sub(modules, 0, index(modules, \"|\", 0))))\n; create a variable that holds the active index of our spell, and give it an encoding based on spell\n; This creates the local int called `spell0` hold the active index of `focus.fire`\n;\n; Then, the incrementation of spell. Because integers have a limit to how big of a value it can hold\n; we stop our counting once spell is bigger than 99, otherwise, if spell < 5, we have to encode\n; more modules, so we increment by 1, and finally, if spell == 5, we increment by 99\nspell += if(spell > 99, 0, if(spell < 5, 1, 99))\n\n; And here, we use our spells given our encoding.\n; there is 1 edge case here which makes \"spell\" . sub(modules, 0, 1) return \"spell\",\n; and local.int.get(\"spell\") just retrieves the value of spell, so, to prevent that index\n; from actually existing, we set spell to be at 104, which is far above the maximum number of active\n; spells a tower can have.\nuseinstant(local.int.get(\"spell\" . sub(modules, 0, 1)))\ngotoif(loop, modules != \"\" || disable.inf.cost() > 1e13 || xp() < disable.inf.cost())\n; Then, we loop things over here.\n; If our modules string is empty and we haven't secured 4 infinity modules and we can afford\n; securing the next module, we enter this block, which tries to secure as many modules it can\n;\n; To prevent wasting execution budget, we don't bother with entering this block after we've reached\n; 4 secured modules.\ndisable.inf(\"burst.infinity\")\ndisable.inf(\"attack.infinity\")\ndisable.inf(\"energy.basic\")\ndisable.inf(\"resistance.abs\")\ngoto(loop)\n\nmultibounce:\nuseinstant(active.index(\"spell.multishot\"))\nuseinstant(active.index(\"spell.superbounce\"))\n; multibounce loop. This loop just spams multishot and superbounce continually\nwaitframe() ; to reduce even further the minimal lag this block causes, this waitframe\n; will make it only run 1 time in a frame, since the cooldown of these modules\n; is higher than 1 frame \ngoto(multibounce)\n"]]}}
```

Do note that this scripts source has [The Bluepring Compactor](../../../Codrineye's%20Compactors/Codrineye's%20Blueprint%20Compactor/README.md) as a dependency.