# Extreme Frags

It's extreme.

Just the source import because anything else would be broken.

Progress should stop until I make the compactor better... again ;-;.

```
{"workspaces":{"Extreme Frags":[["Extreme Config",":import Cods Spell Compactor\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n; This is the borf blueprint\n{add_spell.instant(spell.multishot, 0.0)}\n{add_spell.instant(spell.superbounce, 0.0)}\n{recorded_blueprint(borf, true)}\n; \n\n; This is the blue frags blueprint\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n{add_spell.instant(spell.cooling, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 19.99)}\n{add_spell.instant(spell.refresh, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 39.89)}\n{add_spell.instant(spell.cooling, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{add_spell.instant(spell.glacier.spikes, 59.0)}\n{recorded_blueprint(blue, false)}\n; 432\n\n; This is the red frags blueprint\n{synchronize(3)}\n{add_spell.instant(google.influence, 0.0)}\n{add_spell.instant(boost.shoreline, 0.0)}\n{add_spell.instant(sacrifice.dark, 0.0)}\n; \n{add_spell.instant(focus.nature, 14.99)}\n{add_spell.instant(focus.light, 59.99)}\n; \n{add_spell.instant(focus.nature, 104.99)}\n{add_spell.instant(focus.light, 149.99)}\n{recorded_blueprint(red, false)}\n; 659\n\n; This is the purple frags blueprint\n{synchronize(3)}\n{add_spell.instant(air.hurricate, 0.0)}\n{add_spell.instant(tower.super.1, 0.0)}\n{add_spell.instant(tower.super.2, 0.0)}\n; \n{add_spell.instant(spell.radar, 19.99)}\n{add_spell.instant(spell.radar, 39.99)}\n; \n{add_spell.instant(air.hurricane, 49.99)}\n{recorded_blueprint(purple, false)}\n; 847\n\n; Notice how all the inner synchronizations\n; have a timer of 0.0 This is to ensure that they all\n; get executed simultaneously. Even tho the timer doesn't get\n; updated while synchronization takes place. This is an extra\n; safety procedure\n\n; This is the yellow frags blueprint\n{synchronize(3)}\n{add_spell.instant(spell.awareness, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n{add_spell.instant(spell.refresh, 1.0)}\n{recorded_blueprint(yellow, true)}\n; 940\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return Spell.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n; \n:const int recoring_size {lua(return Spell.active.space)}\n"],["Extreme lib",":import Extreme Config\n:import Spell Compactor resources\n\n; Here we import Spell Compactor resources so that\n; we can communicate with the compactor\n; \n\n#package(name) ExtremeAI:{name}\n; Consistent naming for scripts\n; \n#identifier Extreme Frags\n; A script identifier to create global variables that decreases\n; the likelyhood it gets modified by other scripts\n; \n\n:const string script_signal \"{identifier} Signal\"\n#signal.get global.string.get(script_signal)\n#signal.set(value) global.string.set(script_signal, {value} . \"</size>\")\n\n; active.id(1)\n; Blue   = google.influence\n; Red    = boost.shoreline\n; Purple = tower.super.3\n; Yellow = spell.superbounce\n\n; This lua macro makes an index table holding all our sizes.\n; Every size obtains an offset to it such that the next size\n; is reprezented by the index of the first spell.\n{lua(\\\n  --[[/*\\\n      * Define what string active.id(1) returns for the blueprint\\\n      * \\\n      * Ordered blue, red, purple, yellow\\\n     */]]\\\n  local first_active = table.pack(\\\n    \"google.influence\",\\\n    \"boost.shoreline\",\\\n    \"tower.super.3\",\\\n    \"spell.superbounce\"\\\n  );\\\n  --[[/*\\\n      * Define which blueprints have an extra timer\\\n     */]]\\\n  local timmed_blueprints = table.pack(\\\n    \"blue\", \"purple\"\\\n  );\\\n  --[[Define the value t should have when these blueprints end]]\\\n  local timers = table.pack(60.0, 79.99)\\\n  --[[/*\\\n      * Define what modules you want to get secured\\\n      * and the order in which they get secured\\\n      * \\\n      * If you've changed the name of a blueprint/added a new blueprint,\\\n      * then you must have the name in single quotemarks ' and the\\\n      * spell in double quotemarks \"\\\n      * It's important that, after you've defined a blueprint, you use a\\\n      * `;` to mark the end\\\n      * \\\n      * Note that this addition is temporary, as the compactor will\\\n      * have module securing capabilities too.\\\n      * If you're adding a blueprint to this, you'll have\\\n      * to update the secures made at the top of Main\\\n     */]]\\\n  local blueprint_secures = [==[\\\n  'blue' \"defense.bulwark\" \"spell.glacier.spikes\"\\\n         \"impact.gravity\" \"gift.universe\";\\\n  'red' \"shield.division\" \"infinity.range\" \"gift.universe\"\\\n        \"multishot.focused\";\\\n  'purple' \"energy.basic\" \"aura.checkerboard\"\\\n           \"nature.daybloom\" \"synergy.void\";\\\n  'yellow' \"defense.bulwark\" \"shield.division\" \"impact.gravity\"\\\n           \"gift.universe\" \"synergy.void\";\\\n  ]==];\\\n  --[[Past this point, everything is for internal processing]]\\\n  \\\n  blueprint_secures = blueprint_secures:gsub(\" \", \"\");\\\n  local bp_sec = {};\\\n  for security in blueprint_secures:gmatch(\"([^;]+)\") do\\\n    local secures = {};\\\n    local index = 1;\\\n    for spell in security:gmatch('%b\"\"') do\\\n      local spell_name = spell:sub(2, -2);\\\n      secures[index] = string.format(\"%s|\", spell_name);\\\n      index = index + 1;\\\n    end\\\n    local bp_name = security:match(\"%b''\"):sub(2, -2);\\\n    bp_sec[bp_name] = secures;\\\n  end\\\n  function Secure_blueprint(bp_name)\\\n    local blueprint = bp_sec[bp_name];\\\n    local const = [[:const string secure_%s \"%s\"]];\\\n    return const:format(bp_name, table.concat(blueprint));\\\n  end\\\n  local colors = {};\\\n  local blueprints = table.pack(\\\n    \"borf\", \\\n    \"blue\", \"red\", \\\n    \"purple\", \"yellow\",\\\n    \\\n    --[[Final blueprint that's made when calling Spell.comp.concat_actives]]\\\n    \"Spell.comp.Define_entire_blueprint\"\\\n  );\\\n  local sizes = {};\\\n  for i, bp in ipairs(blueprints) do\\\n    sizes[i] = Spell.comp.blueprint[bp];\\\n  end\\\n  local recordings = table.pack(\"borf\", \"blue\", \"red\", \"purple\");\\\n  local timed_colors = {};\\\n  timed_colors.blue = {};\\\n  timed_colors.purple = {};\\\n  local first_actives = \"\";\\\n  local non_borf_bp = \"\";\\\n  local offsets = \"\";\\\n  local sizes = \"\";\\\n  local timed_actives = \"\";\\\n  local non_timed_actives = \"\";\\\n  for i, color in ipairs(colors) do\\\n    local active_1 = first_active[i];\\\n    if not timed_colors[color] then\\\n      non_timed_actives = non_timed_actives .. active_1;\\\n    else\\\n      timed_actives = timed_actives .. active_1;\\\n    end\\\n    if i < 4 then\\\n      non_borf_bp = non_borf_bp .. active_1;\\\n    end\\\n    first_actives = first_actives .. active_1;\\\n    local bp_size = blueprints[color];\\\n    sizes = sizes .. tostring(bp_size);\\\n    \\\n    local excess = #first_actives - #sizes;\\\n    sizes = sizes .. string.rep(\" \", excess);\\\n    --[[Adds the spacer needed for the index to match the size]]\\\n    local recording = recordings[i];\\\n    local bp_offset = blueprints[recording];\\\n    offsets = offsets .. tostring(bp_offset);\\\n    \\\n    excess = #first_actives - #offsets\\\n    offsets = offsets .. string.rep(\" \", excess);\\\n  end\\\n  local stringify = [[\"%s\"]]\\\n  Blueprint_first_actives = stringify:format(first_actives);\\\n  Blueprint_offsets = stringify:format(offsets);\\\n  Blueprint_sizes = stringify:format(sizes);\\\n  Blueprint_non_borf = stringify:format(non_borf_bp);\\\n  Blueprint_timed_blueprints = stringify:format(timed_actives);\\\n  Blueprint_non_timed_blueprints = stringify:format(non_timed_actives);\\\n)}\n\n:const string first_actives {lua(return Blueprint_first_actives)}\n:const string offsets {lua(return Blueprint_offsets)}\n:const string sizes {lua(return Blueprint_sizes)}\n\n:const string non_borf_bp {lua(return Blueprint_non_borf)}\n:const string timed_bp {lua(return Blueprint_timed_blueprints)}\n:const string non_timed_bp {lua(return Blueprint_non_timed_blueprints)}\n\n; This lua macro creates a string that consists of\n; the module secure sequence needed of the blueprint\n; \n; The lua macro creates const strings called secure_<blueprint color>\n; \n\n#secure_bp(name) {lua(return Secure_blueprint([[{name}]]))}\n"],["Main",":import Extreme lib\n:name {package(Main)}\n:budget_cap -1\n\n{secure_bp(blue)}\n{secure_bp(red)}\n{secure_bp(purple)}\n{secure_bp(yellow)}\n; Defines const strings\n\n:local double clock\n\n:local int blueprint_offset\n:local int blueprint_size\n\n:local string first_active\n:local string compactor\n\ngame.newround()\n\nisTowerTesting()\n\nfirst_active = active.id(1)\n\ngotoif(\\\n  if(contains({signal.get}, \"security\"), secures, lag_saver),\\\n  contains(impulse(), \"{package(Main)}\")\\\n)\n\n; unsets the timer variable so that it's back to 0.0 without\n; pottentially messing up the UI interface\nglobal.unset(timer_var)\n\n{pointer.set(0)}\n{compactor.set(recorded_actives)}\n{signal.set(\"security\")}\n\nexecute(\"{package(Main)}\")\n; Re-Execute the script to start securing modules\n\n; Skip activating borf if we aren't using the yellow blueprint\ngotoif(no_borf, contains(non_borf_bp, first_active))\nexecute(\"{spell_compactor}\")\n; wait a frame for the compactor to use multishot\nwaitframe()\nexecute(\"{spell_compactor}\")\nno_borf:\n\nblueprint_offset = s2i(\\\n  sub(offsets, index(first_actives, first_active, 0), 3), \\\n  0\\\n)\n\nblueprint_size = s2i(\\\n  sub(sizes, index(first_actives, first_active, 0), 3),\\\n  0\\\n)\n\ncompactor = sub(\\\n  recorded_actives, \\\n  blueprint_offset, \\\n  blueprint_size - blueprint_offset\\\n)\n{compactor.set(compactor)}\n\nexit:\nexit()\n\nrestart:\nrestart()\n\nend:\nstop(\"{spell_compactor}\")\ngoto(99)\n\nsecures:\n\ngoto(99)\nlag_saver:\n"],["Software",":import Extreme lib\n:name {package(Software)}\n\n:local vector Index\n:local string softwareList\n:local string securityList\n:local int security\n\nwakeup()\n\nsecurity = 1\nsecurityList = \"2;2;2;0;0;1;0;0;1;2;2;2;1;0;0;0;0;1;2;0;1;0;0;0;2;1;\"\nsoftwareList = \"software.autoskip;software.wavestreaming;software.wavesurge;software.criticalWavejump;software.wavemomentum;software.wavestorm;software.wavepersistence;software.waveinstability;software.wavevortex;software.wavecatalyst;software.waveendurance;software.newbounds;software.wavemarathon;software.wavecompression;software.erasurge;software.eraburst;software.eraswirl;software.wavehorizon;software.nobounds;software.eratunneling;software.wavebreach;software.wavefloor;software.erafloor;software.erahorizon;software.waverestart;software.infinityhorizon;\"\nsoftware.toggle(sub(softwareList, d2i(y(Index)), index(softwareList, \";\", d2i(y(Index))) - d2i(y(Index))), security <= s2i(sub(securityList, d2i(x(Index)), index(securityList, \";\", d2i(x(Index))) - d2i(x(Index))), 0))\nIndex = vec(i2d(index(securityList, \";\", d2i(x(Index))) + 1), i2d(index(softwareList, \";\", d2i(y(Index))) + 1))\ngotoif(4, sub(softwareList, d2i(y(Index)), 1) != \"\")"],["Era",":import Extreme lib\n:name {package(Era)}\n\ngame.newround()\n\ndisable.era(\"electricity\")\ndisable.era(\"light\")\ndisable.era(\"universal\")\ndisable.era(\"darkness\")\ndisable.era(\"earth\")\ndisable.era(\"neutral\")\ndisable.era(\"fire\")\ndisable.era(\"nature\")\ndisable.era(\"water\")\ndisable.era(\"air\")"],["ExtremeAI:Borf","useinstant(active.index(\"spell.multishot\"))\nuseinstant(active.index(\"spell.superbounce\"))\ngoto(1)"],["ExtremeAI:RedSecures","disable.inf(\"shield.division\")\nwaituntil(xp() >= 1000000.0)\ndisable.inf(\"infinity.range\")\nwaituntil(xp() >= 1000000000.0)\ndisable.inf(\"gift.universe\")\nwaituntil(xp() >= 1000000000000.0)\ndisable.inf(\"multishot.focused\")\n"],["ExtremeAI:RedMain",":global double t\n\nstop(\"ExtremeAI:RedSecures\")\nexecute(\"ExtremeAI:RedSecures\")\nstop(\"ExtremeAI:LagSaver120\")\nexecute(\"ExtremeAI:LagSaver120\")\nuseinstant(active.index(\"google.influence\"))\nuseinstant(active.index(\"boost.shoreline\"))\nuseinstant(active.index(\"sacrifice.dark\"))\nwaituntil(t >= 14.99)\nuseinstant(active.index(\"focus.nature\"))\nwaituntil(t >= 59.99)\nuseinstant(active.index(\"focus.light\"))\nwaituntil(t >= 104.99)\nuseinstant(active.index(\"focus.nature\"))\nwaituntil(t >= 149.99)\nuseinstant(active.index(\"focus.light\"))\nstop(\"ExtremeAI:tick\")\n"],["ExtremeAI:LagSaver120","\n; Red, Purple and Blue use this lagSaver\n#lag_detector 1.0 / time.unscaled()\n\n; Unpauses the game once it's executed\npause.set(false)\n\ndetect_lag:\nwaituntil({lag_detector} < 120.0)\npause.set(true)\nwaitframe()\nwaituntil({lag_detector} >= 120.0)\npause.set(false)\ngoto(detect_lag)\n"],["ExtremeAI:YellowMain","stop(\"ExtremeAI:YellowSecures\")\nexecute(\"ExtremeAI:YellowSecures\")\nstop(\"ExtremeAI:LagSaver55\")\nexecute(\"ExtremeAI:LagSaver55\")\nstop(\"ExtremeAI:Borf\")\nexecute(\"ExtremeAI:Borf\")\nexecute(\"ExtremeAI:Borf\")\nexecute(\"ExtremeAI:Borf\")\nstop(\"ExtremeAI:tick\")\n\nuseinstant(active.index(\"spell.awareness\"))\nuseinstant(active.index(\"spell.floof\"))\nuseinstant(active.index(\"spell.refresh\"))\nwait(1.0)\ngoto(10)\n"],["ExtremeAI:YellowSecures","disable.inf(\"defense.bulwark\")\nwaituntil(xp() >= 1000000.0)\ndisable.inf(\"shield.division\")\nwaituntil(xp() >= 1000000000.0)\ndisable.inf(\"impact.gravity\")\nwaituntil(xp() >= 1000000000000.0)\ndisable.inf(\"gift.universe\")\nwaituntil(xp() >= 1000000000000000.0)\ndisable.inf(\"synergy.void\")\nstop(\"ExtremeAI:YellowMain\")\n"],["ExtremeAI:PurpleMain",":global double t\n\nstop(\"ExtremeAI:PurpleSecures\")\nexecute(\"ExtremeAI:PurpleSecures\")\nstop(\"ExtremeAI:LagSaver120\")\nexecute(\"ExtremeAI:LagSaver120\")\n\nuseinstant(active.index(\"air.hurricane\"))\nuseinstant(active.index(\"tower.super.1\"))\nuseinstant(active.index(\"tower.super.2\"))\nwaituntil(t >= 19.99)\nuseinstant(active.index(\"spell.radar\"))\nwaituntil(t >= 39.99)\nuseinstant(active.index(\"spell.radar\"))\nwaituntil(t >= 49.99)\nuseinstant(active.index(\"air.hurricane\"))\nwaituntil(t >= 79.99)\nstop(\"ExtremeAI:tick\")\nrestart()"],["ExtremeAI:PurpleSecures","disable.inf(\"energy.basic\")\nwaituntil(xp() >= 1000000.0)\ndisable.inf(\"aura.checkerboard\")\nwaituntil(xp() >= 1000000000.0)\ndisable.inf(\"nature.daybloom\")\nwaituntil(xp() >= 1000000000000.0)\ndisable.inf(\"synergy.void\")\n"],["ExtremeAI:LagSaver55","\n#lag_detector 1.0 / time.unscaled()\n\ngotoif(detect_lag, time.scale() != 0.0)\npause.set(false)\n; unpauses the game if the time scale is 0.0\n; aka, if we're paused\n\ndetect_lag:\nwaituntil({lag_detector} < 55.0)\npause.set(true)\nwait(0.1)\nwaituntil({lag_detector} >= 55.0)\npause.set(false)\ngoto(detect_lag)"],["ExtremeAI:BlueSecures","disable.inf(\"defense.bulwark\")\nwaituntil(xp() >= 1000000.0)\ndisable.inf(\"spell.glacier.spikes\")\nwaituntil(xp() >= 1000000000.0)\ndisable.inf(\"impact.gravity\")\nwaituntil(xp() >= 1000000000000.0)\ndisable.inf(\"gift.universe\")\n"],["ExtremeAI:BlueMain",":global double t\n\nwaituntil(t >= 0.1)\nstop(\"ExtremeAI:BlueSecures\")\nexecute(\"ExtremeAI:BlueSecures\")\nstop(\"ExtremeAI:LagSaver120\")\nexecute(\"ExtremeAI:LagSaver120\")\nuseinstant(active.index(\"spell.glacier.spikes\"))\nuseinstant(active.index(\"spell.cooling\"))\nuseinstant(active.index(\"spell.glacier.spikes\"))\nwaituntil(t >= 19.99)\nuseinstant(active.index(\"spell.glacier.spikes\"))\nuseinstant(active.index(\"spell.refresh\"))\nuseinstant(active.index(\"spell.glacier.spikes\"))\nwaituntil(t >= 39.89)\nuseinstant(active.index(\"spell.glacier.spikes\"))\nuseinstant(active.index(\"spell.cooling\"))\nuseinstant(active.index(\"spell.glacier.spikes\"))\nwaituntil(t >= 59.0)\nuseinstant(active.index(\"spell.glacier.spikes\"))\nwaituntil(t >= 60.0)\nexit()\n\n"]]}}
```

