# Extreme Frags

It's extreme.

Compacted version of Extreme Frags that's under construction.<br>
I lack the stats needed to fully test it out, so I don't know how good it is.

```
{"workspaces":{"Extreme Frags":[["Extreme Software Config",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(2)}\n{wave_streaming(2)}\n{wave_surge(2)}\n; \n{critical_wave_jump(0)}\n{wave_momentum(0)}\n; \n{wave_storm(1)}\n; \n{wave_persistence(0)}\n{wave_instability(0)}\n; \n{wave_vortex(1)}\n{wave_catalyst(2)}\n{wave_endurance(2)}\n{new_bounds(2)}\n{wave_marathon(1)}\n; \n{wave_compression(0)}\n{era_surge(0)}\n{era_burst(0)}\n{era_swirl(0)}\n; \n{wave_horizon(1)}\n{no_bounds(2)}\n; \n{era_tunneling(0)}\n; \n{wave_breach(1)}\n; \n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n; \n{wave_restart(2)}\n{infinity_horizon(1)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {software.concat(software_len)}\n\n:const string Wcat \"w#|\"\n\n#watercat_line1(secure_level) \\\nsoftware_toggle_loop:\\\nsoftware.toggle(\\\n  sub(\\\n    software_list, \\\n    lig(Wcat), \\\n    index(software_list, \"|\", lig(Wcat)) - lig(Wcat)\\\n  ),\\\n  {secure_level} <= s2i(\\\n    sub(\\\n      software_secure, \\\n      lig(Wcat), \\\n      index(software_secure, \"|\", lig(Wcat)) - lig(Wcat)\\\n    ),\\\n    0\\\n  )\\\n)\n; sub = 3\n; lig = 1\n; a.i = 3\n; index = 3\n; c.i = 3\n; s2i = 2\n; software.toggle = 2\n; sub + lig + a.i + index + lig + lig = 3 + 1 + 3 + 3 + 1 + 1 = 12\n; c.i + lig + s2i + sub + lig + a.i + index + lig + lig \n; = 3 + 1 + 2 + 3 + 1 + 3 + 3 + 1 + 1\n; = 4 + 5 + 4 + 4 + 1 = 9 + 8 + 1 = 18\n; \n; 2 + 12 + 18 = 32\n\n#watercat_line2 lis(Wcat, 1 + index(software_list, \"|\", lig(Wcat)))\n; lis + c.i + index + lig = 2 + 3 + 3 + 1 = 9\n\n#watercat_line3 gotoif(software_toggle_loop, lig(Wcat) < software_len)\n; gotoif + c.i + lig = 2 + 3 + 1 = 6\n; \n; 31 + 9 + 6 = 46\n\n#watercat_index_reset lis(Wcat, 0)\n"],["Extreme Secure Config",":import Cods Blueprint Compactor\n:name Security Config\n\n; \n; Welcome to security config, where you define\n; what modules you want to secure and in what order\n; \n; Since securing isn't very complicated, logging and halting\n; has not been added, as there's not much for you to keep track of\n; \n; You have 2 macros at your disposal\n; add_secure(secure_name) is the name ID that you want to be secured\n; recorded_secures(secures_name) will return a const int called\n; secures_<secures_name> which holds the ammount of space your secures\n; have taken up\n; \n; your compacted secures are in the const string recorded_secures\n; and the total size of your recorded_secures is in the\n; const int secures_space\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{add_secure(defense.bulwark)}\n{add_secure(spell.glacier.spikes)}\n{add_secure(impact.gravity)}\n{add_secure(gift.universe)}\n{recorded_security(blue)}\n\n{add_secure(shield.division)}\n{add_secure(infinity.range)}\n{add_secure(gift.universe)}\n{add_secure(multishot.focused)}\n{recorded_security(red)}\n\n{add_secure(energy.basic)}\n{add_secure(aura.checkerboard)}\n{add_secure(nature.daybloom)}\n{add_secure(synergy.void)}\n{recorded_security(purple)}\n\n{add_secure(defense.bulwark)}\n{add_secure(shield.division)}\n{add_secure(impact.gravity)}\n{add_secure(gift.universe)}\n{add_secure(synergy.void)}\n{recorded_security(yellow)}\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n:const string recorded_secures {recorded_secures}\n:const int secures_space {secures_space}\n"],["Extreme Spell Config",":import Cods Blueprint Compactor\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n; This is the blue frags blueprint\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n{add_spell.instant(spell.cooling, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 19.99)}\n{add_spell.instant(spell.refresh, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{synchronize(3)}\n{add_spell.instant(spell.glacier.spikes, 39.89)}\n{add_spell.instant(spell.cooling, 0.0)}\n{add_spell.instant(spell.glacier.spikes, 0.0)}\n\n{add_spell.instant(spell.glacier.spikes, 59.0)}\n{recorded_blueprint(blue, false)}\n; 432\n\n; This is the red frags blueprint\n{synchronize(3)}\n{add_spell.instant(google.influence, 0.0)}\n{add_spell.instant(boost.shoreline, 0.0)}\n{add_spell.instant(sacrifice.dark, 0.0)}\n; \n{add_spell.instant(focus.nature, 14.99)}\n{add_spell.instant(focus.light, 59.99)}\n; \n{add_spell.instant(focus.nature, 104.99)}\n{add_spell.instant(focus.light, 149.99)}\n{recorded_blueprint(red, false)}\n; 659\n\n; This is the purple frags blueprint\n{synchronize(3)}\n{add_spell.instant(air.hurricate, 0.0)}\n{add_spell.instant(tower.super.1, 0.0)}\n{add_spell.instant(tower.super.2, 0.0)}\n; \n{add_spell.instant(spell.radar, 19.99)}\n{add_spell.instant(spell.radar, 39.99)}\n; \n{add_spell.instant(air.hurricane, 49.99)}\n{recorded_blueprint(purple, false)}\n; 847\n\n; Notice how all the inner synchronizations\n; have a timer of 0.0 This is to ensure that they all\n; get executed simultaneously. Even tho the timer doesn't get\n; updated while synchronization takes place. This is an extra\n; safety procedure\n\n; This is the yellow frags blueprint\n{synchronize(3)}\n{add_spell.instant(spell.awareness, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n{add_spell.instant(spell.refresh, 0.0)}\n{timer_modulo(1.1)}\n{recorded_blueprint(yellow, true)}\n; 940\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {recorded_actives}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n; \n:const int recoring_size {recording_size}\n"],["Extreme lib",":import Extreme Secure Config\n:import Extreme Spell Config\n:import Blueprint Compactor resources\n\n; Here we import Blueprint Compactor resources so that\n; we can communicate with the compactor\n; \n\n#package(name) ExtremeAI:{name}\n; Consistent naming for scripts\n; \n\n#identifier Extreme Frags\n; A script identifier to create global variables that decreases\n; the likelyhood it gets modified by other scripts\n; \n\n:const string script_signal \"{identifier} Signal\"\n#signal.get global.string.get(script_signal)\n#signal.set(value) global.string.set(script_signal, {value} . \"</size>\")\n\n{lua(\\\n  BP.extreme = {};\\\n  BP.extreme_actives = {};\\\n  BP.extreme_sizes = {};\\\n)}\n\n; Use this macro to give the lua macro the module active.id(1)\n#first_active(bp_name, active) {lua(\\\n  local active = string.gsub(\"{active}\", \" \", \"\");\\\n  local bp_name = \"{bp_name}\";\\\n  if active == \"\" then\\\n    error(\"Module ID cannot be empty\");\\\n  elseif BP.comp.blueprint[bp_name] == nil then\\\n    error(\"Unrecognized blueprint name\");\\\n  elseif BP.extreme[active] then\\\n    error(\"The first active of every blueprint should be unique\");\\\n  end\\\n  BP.extreme_actives[1 + #BP.extreme_actives] = active;\\\n  BP.extreme_sizes[1 + #BP.extreme_sizes] = BP.comp.blueprint[bp_name];\\\n  BP.extreme[active] = bp_name;\\\n)}\n\n{first_active(blue, google.influence)}\n\n{first_active(red, boost.shoreline)}\n{first_active(purple, tower.super.3)}\n{first_active(yellow, spell.superbounce)}\n\n; make a list of all our first actives\n:const string first_actives \"{lua(return table.concat(BP.extreme_actives))}\"\n\n; because yellow is the only borf blueprint, this const\n; will cycle through all non_borf blueprints\n:const string non_borf_bp {lua(\\\n  local non_borf = \"\";\\\n  for _, active in ipairs(BP.extreme_actives) do\\\n    if BP.extreme[active] ~= \"yellow\" then\\\n      non_borf = non_borf .. active;\\\n    end\\\n  end\\\n  return string.format([[\"%s\"]], non_borf)\\\n)}\n\n; We make an offsets string such that we can use the first_active\n; as an index. We must add the same ammount of space as the module ID\n; takes up.\n:const string offset_list {lua(\\\n  local offsets = \"\";\\\n  local bps = {};\\\n  bps[1] = \"borf\";\\\n  for i = 1, #BP.extreme_actives - 1 do\\\n    local active = BP.extreme_actives[i];\\\n    bps[1 + #bps] = BP.extreme[active];\\\n  end\\\n  for i, active in ipairs(BP.extreme_actives) do\\\n    local fmt = string.format(\"%%s%%-%ss\", #active);\\\n    local offset = tostring(BP.comp.blueprint[bps[i]]);\\\n    offsets = fmt:format(offsets, offset);\\\n  end\\\n  return string.format([[\"%s\"]], offsets);\\\n)}\n\n:const string offsets {lua(\\\n  local offsets = \"\";\\\n  local sizes = {};\\\n  for _, active in ipairs(BP.extreme_actives) do\\\n    local name = BP.extreme[active];\\\n    sizes[1 + #sizes] = tostring(BP.comp.secure[name]);\\\n  end\\\n  for i, actives in ipairs(BP.extreme_actives) do\\\n    local fmt = string.format(\"%%s%%-%ss\", #actives);\\\n    local offset = sizes[i - 1] or \"\";\\\n    offsets = fmt:format(offsets, offset);\\\n  end\\\n  return string.format([[\"%s\"]], offsets)\\\n)}\n\n; We make a sizes string, in the same idea as the offsets string\n:const string size_list {lua(\\\n  local sizes = \"\";\\\n  for i, active in ipairs(BP.extreme_actives) do\\\n    local fmt = string.format(\"%%s%%-%ss\", #active);\\\n    local size = tostring(BP.extreme_sizes[i]);\\\n    sizes = fmt:format(sizes, size);\\\n  end\\\n  return string.format([[\"%s\"]], sizes);\\\n)}\n\n:const string sizes {lua(\\\n  local list = \"\";\\\n  local sizes = BP.comp.secure;\\\n  for i, actives in ipairs(BP.extreme_actives) do\\\n    local fmt = string.format(\"%%s%%-%ss\", #actives);\\\n    local name = BP.extreme[actives];\\\n    local size = tostring(sizes[name]);\\\n    list = fmt:format(list, size);\\\n  end\\\n  return string.format([[\"%s\"]], list)\\\n)}\n\n:const string lagsaver_times {lua(\\\n  local lag = \"\";\\\n  for _, active in ipairs(BP.extreme_actives) do\\\n    local fmt = string.format(\"%%s%%-%ss\", #active);\\\n    local time = \"\"\\\n    if BP.extreme[active] == \"yellow\" then\\\n      time = \"55.0\";\\\n    else\\\n      time = \"120.0\";\\\n    end\\\n    lag = fmt:format(lag, time);\\\n  end\\\n  return string.format([[\"%s\"]], lag);\\\n)}\n\n:const string end_times {lua(\\\n  local end_time = \"\";\\\n  local times = table.pack(\"60.0\", \"\", \"80.0\", \"\")\\\n  for i, active in ipairs(BP.extreme_actives) do\\\n    local time = times[i];\\\n    local fmt = string.format(\"%%s%%-%ss\", #active)\\\n    end_time = fmt:format(end_time, time);\\\n  end\\\n  return string.format([[\"%s\"]], end_time);\\\n)}\n"],["Main",":import Extreme lib\n:name {package(Main)}\n:budget_cap -1\n\n:local double lag\n:local double clock\n\n:local int blueprint_offset\n:local int blueprint_size\n\n:local int secure_offset\n:local int secure_size\n\n:local string first_active\n\n:local string spells\n:local string secures\n\ngame.newround()\n\nisTowerTesting()\n\nfirst_active = active.id(1)\n\n{timer.set(utcnow())}\nwaitframe()\n\n; unsets the timer variable so that it's back to 0.0 without\n; pottentially messing up the UI interface\nglobal.unset(timer_var)\n\n{pointer.set(0)}\n{comp_active.set(recorded_actives)}\n{comp_secure.set(\"\")}\n\n; Skip activating borf if we aren't using the yellow blueprint\ngotoif(no_borf, contains(non_borf_bp, first_active))\n\nexecute(\"{package(Borf)}\")\nwaitframe()\nexecute(\"{package(Borf)}\")\nwaitframe()\nexecute(\"{package(Borf)}\")\nno_borf:\n\nblueprint_offset = s2i(\\\n  sub(offset_list, index(first_actives, first_active, 0), 3), \\\n  0\\\n)\nsecure_offset = s2i(\\\n  sub(offsets, index(first_actives, first_active, 0), 3),\\\n  0\\\n)\n\nblueprint_size = s2i(\\\n  sub(size_list, index(first_actives, first_active, 0), 3),\\\n  0\\\n)\nsecure_size = s2i(\\\n  sub(sizes, index(first_actives, first_active, 0), 3),\\\n  0\\\n)\n\nspells = sub(\\\n  recorded_actives, \\\n  blueprint_offset, \\\n  blueprint_size - blueprint_offset\\\n)\nsecures = sub(\\\n  recorded_secures,\\\n  secure_offset,\\\n  secure_size - secure_offset\\\n)\n{comp_active.set(spells)}\n{comp_secure.set(secures)}\n\nexecute(\"{blueprint_compactor}\")\nwaitframe()\nclock = s2d(\\\n  sub(end_times, index(first_actives, first_active, 0), 3),\\\n  utcnow()\\\n)\n\nwaitwhile({timer.get} < clock && health(false) > 0.0)\ngotoif(if(clock > 80.0, end, restart), clock > 60.0)\n\nexit:\nexit()\n\nrestart:\nrestart()\n\nend:\nstop(\"{blueprint_compactor}\")\nstop(\"{package(Borf)}\")\n"],["Disables",":import Extreme Software Config\n:import Extreme lib\n:name {package(Disables)}\n\n:local int secure\n\nwakeup()\ngame.newround()\n\nsecure = 1\ngotoif(software_toggle_loop, contains(impulse(), \"wakeup\"))\nstop(impulse())\n\n{set_priority(electricity)}\n{set_priority(light)}\n{set_priority(universal)}\n{set_priority(darkness)}\n{set_priority(earth)}\n{set_priority(neutral)}\n{set_priority(fire)}\n{set_priority(nature)}\n{set_priority(water)}\n{set_priority(air)}\n\nera:\ndisable.era({disable.era})\ngoto(if({disable_era}, era, 99))\n\n{watercat_line1(secure)}\n{watercat_line2}\n{watercat_line3}"],["Borf",":import Extreme lib\n\n:name {package(Borf)}\n\nuseinstant(active.index(\"spell.multishot\"))\nuseinstant(active.index(\"spell.superbounce\"))\ngoto(0)"]]}}
```

