# Codrineye's TowerTesting
My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 versions in this repo, [Codrineye's TowerTesting](#codrineyes-towertesting-v-10) and [Cod TT](#cod-tt)

# Source Code
The source code is a code you import into the [external AI editor](https://d0sboots.github.io/perfect-tower/) by [d0sboots](https://github.com/d0sboots/perfect-tower)
```
{"workspaces":{"Cods TowerTesting":[["TowerTesting_lib","#version v1.3.1\n#package(name) Cods TowerTesting {version}:{name}\n\n; the identifier of this script\n#identifier \"Condineye's TowerTesting\"\n\n; the global variable hider\n#hider concat(\"<size=0>\", \"Variable_Hider\") . {identifier}\n\n; the variable name for the scripts state\n#state \"<size=0>\" . {identifier} . \"</size>\" . \"active\"\n#state_get global.bool.get({state})\n#state_toggle global.bool.set({state}, false == {state_get})\n\n; the variable name for counting, a hidden global variable used internally\n#counting \"<size=0>\" . {identifier} . \"counting\"\n#counting_get global.int.get({counting})\n#counting_set(value) global.int.set({counting}, ({value}))\n#counting_increment {counting_set({counting_get} + 1)}\n\n; The variable name for change_difficulty, a hidden global variable used internally\n#change_difficulty \"<size=0>\" . {identifier} . \"</size>\" . \"change_difficulty\"\n#change_difficulty_get global.bool.get({change_difficulty})\n#change_difficulty_set(value) global.bool.set({change_difficulty}, {value})\n\n; The variable name for Region_Cycling\n#Region_Cycling {identifier} . \"</size>\" . \"Region_Cycling\" . \"(W)\"\n#Region_Cycling_get global.bool.get({Region_Cycling})\n\n; The variable name for CurentMode\n#CurentMode \"<size=0>\" . {identifier} . \"</size>\" . \"CurentMode\" . \"(Q)\"\n#CurentMode_get global.string.get({CurentMode})\n\n; The two different modes, so it's easy to edit\n#mode1 \"Difficulty>Region\" . \"</size>\"\n#mode2 \"Region>Difficulty\" . \"</size>\"\n\n; const variable to make the difficulty logic easier to find\n:const int difficulty_spacing 5\n\n; const string variables that represents the coordinates of\n; each respective difficulty\n:const string difficulty1 '290.0'\n:const string difficulty2 '256.0'\n:const string difficulty3 '217.0'\n:const string difficulty4 '182.0'\n:const string difficulty5 '145.0'\n:const string difficulty6 '112.0'\n\n; const variable to make the difficulty logic easier to find\n:const int difficulty_count 6\n\n; the two lists used for the comment in `Stats Exit Diff_Change`\n#difficulty_list difficulty1 . difficulty2 . difficulty3 . difficulty4 . difficulty5 . difficulty6\n#inversed_difficulty_list difficulty6 . difficulty5 . difficulty4 . difficulty3 . difficulty2 . difficulty1\n\n"],["Stats Exit Diff_Change",":import TowerTesting_lib\n:name {package(Stats Exit Diff_Change)}\n\n:global double Curent_Diff\n:local int increment\n\nkey.t()\nkey.e()\n\n; helper condition so the user can easily chose which list to use\nconcat(\"Easy -> Impossible\", {difficulty_list}) != \\\nconcat(\"Impossible -> Easy\", {inversed_difficulty_list})\n\n; if called by Initialiser, go to loop\n; if called by an impulse, check if in towertesting\n; if in towertesting, if impulse key.t, goto stats, else goto exit\n; if not in towertesting quit the call\n; if not called by a key impulse, we're called by winAI4 to stop towertesting at 60 ingame seconds\ngoto(if(\\\n  contains(impulse(), \"{package()}\"), \\\n  loop, \\\n  if(\\\n    contains(impulse(), \"key.\"), \\\n    if(\\\n      isTowerTesting(), \\\n      if(contains(impulse(), \"key.t\"), stats, exit), \\\n      99\\\n    ), \\\n    wait_for_exit\\\n  )\\\n))\nwait_for_exit:\nwaitwhile(global.double.get(\"t\") % 60.0 > 0.5 || global.double.get(\"t\") < 0.5)\nexit:\nexit()\n\nstats:\nwait(global.double.get(\"screen_delay\"))\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\ngoto(99)\n\n; most important loop, it determines which difficulty is sellected\nloop:\nCurent_Diff = s2d(sub({difficulty_list}, increment * difficulty_spacing, difficulty_spacing), 290.0)\n\n; we increment because we've changed difficulty\nincrement = (increment + 1) % difficulty_count\n\n; prevent unwanted actions by waiting for set delay\n; wait to get a signal from either Movement Manager or Initialiser\nwait(global.double.get(\"screen_delay\"))\nwaituntil({change_difficulty_get} || {state_get} == false)\n; signal to Movement Manager that it may continue running\n{change_difficulty_set(false)}\n; loop if we got a signal from Movement Manager\ngotoif(loop, {state_get})\n"],["Toggles",":import TowerTesting_lib\n:name {package(Toggles)}\n\nkey.q()\nkey.w()\n\n; Ensure the global hider is active, this also means that q and w activate the AI\ngotoif(initialized, {state_get})\nexecutesync(\"{package(Initialiser)}\")\ngoto(99)\n\n; we've passed the initialization sequence, set Region_Cycling and CurentMode appropiately\ninitialized:\nglobal.bool.set(\\\n  {Region_Cycling}, \\\n  contains(\"key.q|{package(Initialiser)}\", impulse()) || {Region_Cycling_get} == false\\\n)\n\ngotoif(99, contains(impulse(), \"key.w\"))\nglobal.string.set({CurentMode}, if(\\\n  contains({CurentMode_get}, {mode1}) && false == contains(impulse(), \"{package()}\"), \\\n  {mode2}, \\\n  {mode1}\\\n))\n"],["Enter Region",":import TowerTesting_lib\n:name {package(Enter Region)}\n\n:global double Curent_Diff\n\n; Conditions set in accordance to CurentMode\n; counting starts from 0\n; mode2 means we advance to the next difficulty after 15 cycles\n; mode1 means we advance to the next region after 6 cycles\n#condition1 contains({CurentMode_get}, {mode2}) && {counting_get} == 14\n#condition2 contains({CurentMode_get}, {mode1}) && {counting_get} < 6\n\ngame.newround()\n\n; if either condition is true, check if AI is active\n; if so enter difficulty, else quit process\n; if neither condition is true, check if we're starting the timer, else we proceed\ngoto(if(\\\n  {condition1} || {condition2}, \\\n  if({state_get}, enter_difficulty, 99), \\\n  if(contains(impulse(), \"game.newround\"), timer, skip)\\\n))\nskip:\n; if Region_Cycling is not permitted, default to enter difficulty\ngotoif(enter_difficulty, false == {Region_Cycling_get})\n\n; prevent the AI from performing actions when it cannot\nwaitwhile(isTowerTesting() || anyopen())\n\n; cycle through region\nshow(\"towertesting\", true)\nwait(global.double.get(\"screen_delay\"))\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\nwait(global.double.get(\"screen_delay\"))\n\n; enter the difficulty\nenter_difficulty:\nshow(\"towertesting\", true)\nwait(global.double.get(\"screen_delay\"))\n{click.relative(395.0/800.0, Curent_Diff/450.0, 0.0, 1.0)}\n\n; launch the new round\nwait(global.double.get(\"screen_delay\"))\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\n; timer cannot interact with Restart At Will unless we're called for the timer\ntimer:\nstop(if(\\\n  contains(impulse(), \"game.newround\"), \\\n  \"{package(Restart At Will)}\", \\\n  \"{package(Null Package)}\"\\\n))\nexecute(if(\\\n  contains(impulse(), \"game.newround\"), \\\n  \"{package(Restart At Will)}\", \\\n  \"{package(Null Package)}\"\\\n))\n"],["Movement Manager",":import TowerTesting_lib\n:name {package(Movement Manager)}\n\n; Reset counting and change_difficulty condition\n{counting_set(0)}\n{change_difficulty_set(false)}\n\nloop:\n; wait while AI cannot interact with game as wanted\n; execute Enter Region and wait until we may proceed\nwaitwhile({state_get} && (anyopen() || isTowerTesting() || {CurentMode_get} == \"\"))\nexecutesync(\"{package(Enter Region)}\")\n\n; increment counting and see if difficulty can be changed\n{counting_increment}\n{change_difficulty_set(contains({CurentMode_get}, {mode1}))}\n\n; wait for a response from Diff_Change if one can be returned\n; wait while outside of towertesting\n; quit if AI is shut down, else loop if we cannot proceed\nwaitwhile({change_difficulty_get} && {state_get})\nwaituntil(anyopen() || isTowerTesting() || {state_get} == false)\ngotoif(\\\n  if({state_get}, loop, 99), \\\n  contains({CurentMode_get}, {mode1}) && {counting_get} < 6 || \\\n  contains({CurentMode_get}, {mode2}) && {counting_get} < 15\\\n)\n; wait so we can proceed, executesync Enter Region, same reason as above\nwaitwhile({state_get} && (anyopen() || isTowerTesting()))\nexecutesync(\"{package(Enter Region)}\")\n\n; Reset counting, check if we can change proceed, and loop AI is active\n{counting_set(0)}\n{change_difficulty_set(contains({CurentMode_get}, {mode2}))}\ngotoif(loop, {state_get})\n"],["Initialiser",":import TowerTesting_lib\n:name {package(Initialiser)}\n\nkey.x()\n\n:local bool additional_cond\n\n; hide content if AI should turn off, else stop hiding\nglobal.string.set({hider}, if(\\\n  {state_get}, \\\n  \"Codrineye's TowerTesting Is Shutdown\", \\\n  concat(\"Stop Hiding\", \"</size>\")\\\n))\n\n; toggle the state, and exit if AI is shutdown\n{state_toggle}\ngoto(if({state_get}, skip, 99))\n\nskip:\nexecute(\"{package(Restart At Will)}\")\nexecute(\"{package(Stats Exit Diff_Change)}\")\nexecute(\"{package(Movement Manager)}\")\nexecutesync(\"{package(Toggles)}\")\nwaitwhile({state_get} && (anyopen() || isTowerTesting()))\n; initiate needed scripts and include the global variables within the hider\n; Toggles needs to be last execution, as modes end the hider on shutdown\n; wait until we can perform actions\n\n; start the loop which permits the condition to update\n; if tower health reaches 0, enter exit loop\n; this keeps telling the game to exit until it fulfills the task\n; End the timer\n; Once we're no longer TowerTesting we may continue the loop if the AI isn't shutdown\nloop:\nadditional_cond = false\ngotoif(\\\n  loop, \\\n  {state_get} && health(false) > 0.0 && \\\n  (additional_cond == false)\\\n)\n\nexit_loop:\nexit()\nstop(\"{package(Restart At Will)}\")\ngotoif(if(isTowerTesting(), exit_loop, loop), {state_get})\n"],["Restart At Will",":import TowerTesting_lib\n:name {package(Restart At Will)}\n\nkey.r()\n\n; Adjustable screen delay\n; if called by pressing r, restart, otherwise\n; only have a timer if we've not reached era >= 1.0 and if the script is active\nglobal.double.set(\"screen_delay\", 0.5)\ngoto(if(\\\n  contains(impulse(), \"key.\"), \\\n  restart, \\\n  if(era() >= 1.0 || ({state_get} == false), 99, timer)\\\n))\ntimer:\nwait(30.0)\n\nrestart:\nrestart()\n"]]}}
```
# Cods TowerTesting v 1.3.1
Fixed timer in `Restart At Will` by stopping and starting the script in Enter Region<br>
Renamed variables to remove the miniature guide<br>
Added comments to each section

# Cods TowerTesting v 1.3.0
Updated the click coordinates of the `QOL` feature linked to impulse `key.t` to click the button more accurately<br>
Fixed the timer of `Restart At Will` not being activated after first restart<br>
Modified the timer to only get activated if the wave record for the entered difficulty is below era 1<br>
Re-structured the logic behind [additional_cond](#cods-towertesting-v-125) so that the inputed condition gets updated<br>
Relocated `additional_cond` to line 9 to support the afformentioned restructuring<br>
Added an execution of `Restart At Will` within [Initialiser](Initialiser.tpt2) so that `screen_delay` now gets hidden as well
Added a miniature guide that describes how to use the [Toggles](Toggles.tpt2)

# Cods TowerTesting v 1.2.7
This reintroduces `Restart At Will` as a separate script, as the way it functions doesn't permit it being merged in other scripts<br>
Added a loop to the exit so that the game can properly exit towertesting if the condition in `aditional_cond` returns true faster than the exut function can be used<br>
Added new global variable `screen_delay` that can be edited at the top of [Restart At Will](Restart%20At%20Will.tpt2)

# Cods TowerTesting v 1.2.5
This fixes the bug I missed when merging `Restart At Will` with `Initialiser`<br>
timer is now found in `Enter Region`<br>
Added local bool variable `additional_cond` to make aditional exit conditions easier to implement<br>
Imagine you want to implement an exit condition so that once you reach inf 1 you just need to make additional_cond = comparison.double game.infinity == 0

# Codrineye's TowerTesting v 1.2.2
This marks a rebranding as Cods TowerTesting<br>
Codrineye is too long, so from now on `Codrineye` will be shortened to `Cods`

# Codrineye's TowerTesting v 1.2.1
This version adds a couple bug fixes, removes the unnecessary shutdown message, implements unfinished assets and merges Restart At Will with Initialiser

# Codrineye's TowerTesting v 1.1.0
This version makes a slight difference to [Stats Exit Diff_Change](Stats%20Exit%20Diff_Change.tpt2) that supports it being used by [winAI4](/TPT2%20Scripting/Codrineye's%20Compact%20Spell-Caster/tick.tpt2) to exit towertesting once the round has lasted for 60 ingame seconds

# Codrineye's TowerTesting v 1.0.0
Codrineye's TowerTesting is a fully automated AI which will cycle through every single Region and Difficulty in accordance to both its Mode and wether or not its cycling mechanic is toggled on.


# Cod TT
Thank you bluecat for making an attempt to rework this mess

Cod TT is a version of Codrineye's TowerTesting made by bluecat, who tried to take my original idea and condense it into a more compact AI.<br>
While the attempt was great, and it lead to a functional product, it still has the same shortcomings my original AI had

```
{"workspaces":{"Cod TT":[["Tower_Automation lib","\n#package Codrineye's TowerTesting\n\n\n#init Init\n#logic Core\n#difficulty Difficulty Cycle\n#region Region Cycle\n#toggles QOL\n"],["init","\n:import Tower_Automation lib\n:name {package}:{init}\n\n:global bool CdTTRunning\n:global bool RegionCycle\n:global double ClickPos\n:global string difficultyClickPositions\n\n\n\nkey.x()\n\nstart:\ngss(\"OnName\", \"<color=#FF0000><b>PLEASE INPUT CUSTOM NAME IN HERE</b></color>\")\ngss(\"<size=0>\", \"##--STARTHIDING--##\")\nCdTTRunning = CdTTRunning == false ;starts true, if called again goes false and ends script\nRegionCycle = RegionCycle\nClickPos = ClickPos\ndifficultyClickPositions = \"112.0;145.0;182.0;217.0;256.0;290.0;</size><color=\" . if(CdTTRunning, \"#00FF00\", \"#FF0000\") . \">\" \ngss(gsg(\"OnName\") . if(false, \"\", \"<size=0>\"), \"</size></color><color=\" . if(RegionCycle, \"#FF0000\", \"#00FF00\"))\ngss(\"Cycle Region<size=0>\", \"</size>\")\nloop:\nexecutesync(\"{package}:{logic}\")\nwaituntil((tower.health(false) == 0.0) && isTowerTesting())\nexit()\ngotoif(loop, CdTTRunning)\ngu(gsg(\"OnName\"))"],["Instant Restart || Stats Button","\n:import Tower_Automation lib\n:name {package}:{toggles}\n\nkey.r() ;restart\nkey.t() ;stats\n\nisTowerTesting()\n\ngotoif(stats, impulse() == \"key.t\")\n\nrestart:\nrestart()\n\nstats:\n{click.relative(230.0/800.0, 275.0/450.0, 0.5, 0.5)}"],["Region Cycle Toggle || Region Move","\n:import Tower_Automation lib\n:name {package}:{region}\n\n:global bool CdTTRunning\n:global bool RegionCycle\n\nkey.w() ; toggle cycle\n\n\ngotoif(toggleCycle, contains(impulse(), \"key.\") || CdTTRunning == false)\n\nmoveRegion:\nwaitwhile(isTowerTesting() && RegionCycle)\ngotoif(99, RegionCycle == false)\nshow(\"towertesting\", true)\nwait(0.2)\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\nwait(0.2)\nshow(\"towertesting\", false)\ngoto(99)\n\ntoggleCycle:\nRegionCycle = (RegionCycle == false)\n"],["Difficulty Move || Auto Exit","\n:import Tower_Automation lib\n:name {package}:{difficulty}\n\n:global double ClickPos\n\ngame.newround()\nkey.e()\n\ngotoif(changeDiff, contains(impulse(), \"{package}\"))\n\nexit:\nwait(if(impulse() == \"game.newround\", 10.0, 0.0))\nexit()\ngoto(99)\n\nchangeDiff:\nshow(\"towertesting\", true)\nwait(0.2)\n{click.relative(395.0/800.0, ClickPos/450.0, 0.0, 1.0)}\nwait(0.2)\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n"],["Movement Logic","\n:import Tower_Automation lib\n:name {package}:{logic}\n\n#subList sub(difficultyClickPositions, index, index(difficultyClickPositions, \";\", index) - index)\n\n:global double ClickPos\n:local int index\n:global string difficultyClickPositions\n\n\n\ngotoif(99, false)\nloop:\nwaitwhile(isTowerTesting()) \n; waits until the restart triggers from auto restart\n\nClickPos = s2d({subList}, 290.0) \n; sets the new position to go to diff\n    \nexecutesync(\"{package}:{difficulty}\") \n; runs position\n    \nindex = (index(difficultyClickPositions, \";\", index) + 1) \n; updates index to set up next click\n    \nwaituntil(isTowerTesting()) \n; run waituntil to make sure we get in TT before updating region if needed\n\nrepeat:\ngotoif(loop, {subList} != \"\") ; if next click is blank, list is over so lets restart\nexecutesync(\"{package}:{region}\") ; when there's no diffs start the region move\nlu(\"index\") ; remove this once I fix index\ngoto(loop)\n\n\n\n\n"]]}}
```
