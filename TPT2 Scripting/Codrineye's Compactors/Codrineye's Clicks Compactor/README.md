# IronClicker
IronClicker is a script created by [discord user Eisenefaust](<https://discord.com/channels/488444879836413975/1291450323214274611/1291451637633650719>)

Its purpose is to automate activities inside of both [Construction firm](<https://www.perfecttower2.com/wiki/Construction_Firm>) and [Era essence research](https://www.perfecttower2.com/wiki/Era#Era_Powers)

```
{"workspaces":{"Codrineye's Clicks Compactor":[["Clicks Config",":import Codrineye's Clicks Compactor\n; This AI is made to\n\n\n{add_click(287.0, 332.0, 1.0, 1.0)}\n{add_click(437.0, 30.0, 0.0, 0.0)}\n\n:const int increment {lua(return click.max_length)}\n:const int clicks_count {lua(return #click.recording)}\n:const int coord_displace {lua(return 2 + click.precision.coord)}\n:const int anchor_displace {lua(return 2 + click.precision.anchor)}\n"],["Codrineye's Clicks Compactor",":name LUA MADNESS\n\n#anchor_warning \"Recording a relative vector should not have anchor values bellow 0 or above 1\"\n\n{lua(\\\n  click = {};\\\n  click.recording = {};\\\n  click.max_length = 1;\\\n  click.precision = {};\\\n  click.precision.coord = 3;\\\n  click.precision.anchor = 2;\\\n\\\n  local function x_digit_precision(digits, input)\\\n    local number = string.gsub(input, \" \", \"\");\\\n    return string.sub(string.format(\"%.\" .. digits .. \"f\", number), 1, digits + 2);\\\n  end\\\n\\\n  function click.add_click(coord_x, coord_y, anchor_x, anchor_y)\\\n    local click_index = 1 + #click.recording;\\\n    local click_recording = {};\\\n    click_recording.coord_x = x_digit_precision(click.precision.coord, coord_x);\\\n    click_recording.coord_y = x_digit_precision(click.precision.coord, coord_y);\\\n    click_recording.anchor_x = x_digit_precision(click.precision.anchor, anchor_x);\\\n    click_recording.anchor_y = x_digit_precision(click.precision.anchor, anchor_y);\\\n    local anchor_max = math.max(\\\n      tonumber(click_recording.anchor_x), \\\n      tonumber(click_recording.anchor_y)\\\n    );\\\n    local anchor_min = math.min(\\\n      tonumber(click_recording.anchor_x), \\\n      tonumber(click_recording.anchor_y)\\\n    );\\\n    if 1 < anchor_max or anchor_min < 0 then\\\n      return {anchor_warning};\\\n    end\\\n  \\\n    local click_string = click_recording.coord_x .. click_recording.coord_y\\\n      .. click_recording.anchor_x .. click_recording.anchor_y;\\\n    click.max_length = math.max(click.max_length, #click_string);\\\n  \\\n    click.recording[click_index] = click_recording;\\\n    return [[:const string click]] .. click_index .. [[ ']] .. click_string .. [[']];\\\n  end\\\n\\\n  function click.concatinate_click_recordings()\\\n    local clicks_recorded = #click.recording;\\\n    local clicks_concat = {};\\\n    for i = 1, clicks_recorded - 1 do\\\n      clicks_concat[1 + #clicks_concat] = \"click\" .. i;\\\n      clicks_concat[1 + #clicks_concat] = [[ . ]];\\\n    end\\\n    clicks_concat[1 + #clicks_concat] = \"click\" .. clicks_recorded;\\\n    return table.concat(clicks_concat);\\\n  end\\\n)}\n\n#add_click(coord_x, coord_y, anchor_x, anchor_y) {lua(\\\n  return click.add_click(\\\n    [[{coord_x}]], \\\n    [[{coord_y}]], \\\n    [[{anchor_x}]], \\\n    [[{anchor_y}]]\\\n  );\\\n)}\n\n#clicks_concat {lua(return click.concatinate_click_recordings())}\n"],["IronClick_lib",":import Clicks Config\n#package(name) IronClick:{name}\n\n#identifier \"IronClick\"\n#pointer \"<size=0>\" . {identifier} . \"pointer\"\n#pointer.get global.int.get({pointer})\n#pointer.advance global.int.set({pointer}, ({pointer.get} + 1) % clicks_count)\n"],["Main",":import IronClick_lib\n:name {package(Main)}\n\n#root_click(distance, length) sub({clicks_concat}, {distance}, {length})\n#string_read {pos.relative(\\\n  s2d({root_click({pointer.get} * increment, coord_displace)}, 0.0) / 800.0, \\\n  s2d({root_click({pointer.get} * increment + coord_displace, coord_displace)}, 0.0) / 450.0, \\\n  s2d({root_click({pointer.get} * increment + coord_displace + coord_displace, anchor_displace)}, 0.0), \\\n  s2d({root_click({pointer.get} * increment + coord_displace + coord_displace + anchor_displace, anchor_displace)}, 0.0)\\\n)}\n\nkey.p()\nkey.l()\n\ngotoif(points, contains(impulse(), \"key.l\"))\n\n; enter a modification of D0S.Superclick\n; D0S.Superclick link\n; https://github.com/d0sboots/PerfectTower/blob/main/D0S.Crates_Idler_v2\n:global int click_instances\n:local vector Point\n\nclick_instances += 1\nexecute(if(click_instances < 54, \"{package(Main)}\", \"{package(Null)}\"))\nexecute(if(click_instances < 54, \"{package(Main)}\", \"{package(Null)}\"))\n\nloop:\nPoint = {string_read}\nclick(position())\nclick(Point)\ngotoif(loop, click_instances <= 54)\n\nclick_instances += 1\nglobal.unset(if(\\\n  click_instances > 109, \\\n  \"click_instances\", \\\n  \"{package(NULL)}\"\\\n))\ngoto(99)\n\npoints:\n{pointer.advance}"]]}}
```

## Requirements
- 2 impulses
- 0 conditions
- 12 actions
- 1 script in use

## In action
The script works by copying itself to perform the click-spamming of [D0S.Superclick](<https://github.com/d0sboots/PerfectTower/blob/main/D0S.Crates_Idler_v2>)

use the impulse P to activate the clicker, and the impulse L to change between the different modes<br>
the clicker will initialise the point if it has no value

## Thoughts
This project was not created by me, however it shows to be interesting as a project<br>
Tho this is a script for a simple task, I believe it shows that there's room in the world of scripts for a tool such as [Codrineye's Compact Spell-Caster](/Codrineye's%20Compact%20Spell-Caster/) that, instead of compacting spells for use in towertesting, permits compacting the coordinates for relative vectors inside of a string, like I do in [Cods TowerTesting](/Cods%20TowerTesting/Stats%20Exit%20Diff_Change.tpt2) to determine the difficulty my AI enters

