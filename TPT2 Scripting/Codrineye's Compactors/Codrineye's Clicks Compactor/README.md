# Codrineye's Clicks Compactor
Original project that gave me the idea for a new compactor was [Iron Click by Eisenefaust](https://discord.com/channels/488444879836413975/1291450323214274611/1291450323214274611)

The clicks compactor, similar to its brother [Cordineye's Spells Compactor](/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Spells%20Compactor/README.md), is a workspace with the purpose of compressing all given clicks into one string which is then cycled through and read to store a relative vector inside of the internal global vector Position

## Import scripts
The source import, used to get the workspace in the [external editor by d0sboots](https://d0sboots.github.io/perfect-tower/) contains all documentation for what the compactor actually does, found in the script [Cordineye's Clicks Compactor](Codrineye's%20Clicks%20Compactor.tpt2)
```
{"workspaces":{"Codrineye's Clicks Compactor":[["Clicks Config",":import Codrineye's Clicks Compactor\n; This configuration is made to stack relative vectors together in 1 single string\n; You use the macro add_click and specify the parameters as you would with a pos.relative macro call\n; * the x coordinate\n; * the y coordinate\n; * the x anchor\n; * the y anchor\n; the relevant division is done internally within the root_click macro in Main\n; The final parameter is a name you can assign to the click, usefull for visual feedback\n; \n; You should check the values in Codineye's Clicks Compactor under click.maintenance\n; Modify them accordingly, to represent what you're working with\n; Ensure the resolution values are equivalent to the ingame resolution\n\n{add_click(287.0, 332.0, 1.0, 1.0, Era)}\n{add_click(437.0, 30.0, 0.0, 0.0, Ship)}\n\n; These constant values are used for internal calculations\n; 2 double constants representing the x and y values of the games resolution\n; they are used when calculating relative vectors\n\n:const double resolution_x {lua(return click.maintenance.resolution_x)}\n:const double resolution_y {lua(return click.maintenance.resolution_y)}\n\n; 4 int constants representing\n; * the size of a recorded chunk\n; * the number of recorded clicks\n; * the size a coordinate is saved as\n; * the size an anchor is saved as\n; look in Main to see how they are being used\n\n:const int increment {lua(return click.max_length)}\n:const int clicks_count {lua(return #click.recording)}\n:const int coord_displace {lua(return 2 + click.precision.coord)}\n:const int anchor_displace {lua(return 2 + click.precision.anchor)}\n\n"],["Codrineye's Clicks Compactor",":name LUA MADNESS\n; \n; Package found on discord or on my github repo\n; discord: To Be Done\n; github: https://github.com/Codrineye/Codrineye-s-TPT2-Compendium/blob/main/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Clicks%20Compactor/Codrineye's%20Clicks%20Compactor.tpt2\n; \n; 2 lua macros made to perform all actions\n; The way this works is by creating a string value\n; :const string click[click number] 'data given for the click'\n; For information on what 'data given for click' means, look at Clicks Config\n; The comments bellow explain what you're looking at\n; \n; Macro 1 will initialise all global variables used in the functions\n; Additionally, it supports user interaction to for additional configuration\n; \n; We declair the root table [click], which differentiates lua macros from the rest\n; \n; click.debugging represents a boolean that if set to true will permit us to\n; read debugging information in the developer console accessed with ctrl+shift+i\n; \n; click.maintenance is the field that supports user interraction\n; * .resolution_x = the x resolution value found in the debugging interface accessed with f2\n; * .resolution_y = the y resolution found alongside .resolution_y\n; * .name_separator = the separation character that's used for getting the name of a click\n; Modify these values as you see fit, if one of them is not permitted, you will get an error message\n; \n; click.recording is the field used to record, this is what's used for <add_click>\n; click.precision is the field used to determine how large or small a variable can be\n; you, the user, can configure these as you see fit\n; * .coord is the size in which a coordinate can be recorded\n; * .anchor is the size in which an anchor can be recorded\n; You can modify them, tho I recommend not to unless you have a reason\n; \n; click.max_name stores the max length of all the names we've read\n; click.max_length stores the max length of the outputed 'data given for the click'\n; \n\n{lua(\\\n  click = {};\\\n  click.debugging = false;\\\n  click.maintenance = {};\\\n  click.maintenance.resolution_x = 800.0;\\\n  click.maintenance.resolution_y = 450.0;\\\n  click.maintenance.name_separator = [[;]];\\\n  click.recording = {};\\\n  click.precision = {};\\\n  click.precision.coord = 3;\\\n  click.precision.anchor = 2;\\\n  click.max_name = 0;\\\n  click.max_length = 0;\\\n)}\n\n; \n; this marks the end of Macro 1 \n; /=================================================================\\\n; |WARNING: IT IS NOT ADVISED THAT USERS MODIFY THE FOLLOWING FIELDS|\n; |WARNING: IT IS NOT ADVISED THAT USERS MODIFY THE FOLLOWING FIELDS|\n; |WARNING: IT IS NOT ADVISED THAT USERS MODIFY THE FOLLOWING FIELDS|\n; \\=================================================================/\n; \n; Macro 2 holds the function declarations\n; local functions cannot be accessed outside of this lua macro\n; these functions are used for simple tasks not worth repeating\n; \n; local function x_digit_precision(digits, input)\n; This function is an edited version of what's used in my spells compactor\n; it creates a local number, and gives it the value of the input with the removed spaces\n; afterwards, the fuction returns a formatted string, that has <digits> amount of digits\n; the value of digits uses click.precision.<input type>\n; \n; local function debugging()\n; This function too can be found in my spells compactor\n; its purpose is to print out relevant debugging values to the developer console\n; \n; global functions can be accessed globally, as long as the originating library is imported\n; these functions are used to perform all kinds of tasks\n; \n; function add_clicks(coord_x, coord_y, anchor_x, anchor_y, name)\n; this is the function you write to when calling for <add_click>\n; we create a local integer 'click_index' that's used for the returning click[click number]\n; we create a local table 'new_click' that gets added to clicks.recording\n; we assign the given values as follows\n; * .coord_x calls for x_digit_precision with precision.coord\n; * .coord_y calls for x_digit_precision with precision.coord\n; we check if .coord_x or .coord_y are values larger than the resolution they were recorded with\n; if they are, we return an error and prevent compilation\n; \n; otherwise, we continue\n; * .anchor_x calls for x_digit_precision with precision.anchor\n; * .anchor_y calls for x_digit_precision with precision.anchor\n; we then take the max and min of the two anchors and\n; check if the max is larger than 1.0 or if the min is smaller than 0\n; if they are, we return an error and prevent compilation\n; \n; otherwise, we can continue\n; we create a local string 'click_string' that\n; contains the data which will be outputed for the string\n; we then update click.max_name to hold either\n; * the length of the curent name\n; * the value it already has\n; we do a similar thing with click.max_length but with the whole click_string\n; after that, we insert the new click inside of our table click.record\n; check if we're permitted to call for 'local function debugging()'\n; and return the :const string\n; \n; function clicks.concatinate_click_recordings()\n; this is the function that concatenates all the const strings into one string\n; we start by storing the number of recorded clicks inside of 'local clicks_count'\n; then, create the table 'local clicks_concat'\n; entering a loop, we count in i from 1 to clicks_count\n; create a dummy variable 'local space' that has the subtraction\n; between .max_name and the stored name of click[i]\n; then, assign string concaining [.] that repeat as many times as space says to 'local spacer'\n; insert into clicks_concat the const click[i] and the linking concatination [[ . \"]] \n; insert into clicks_concat the spacing value of spacer and the linking concatination [[\" . ]]\n; loop until we run out of recordings\n; insert into clicks_concat the ending value of [[\".\"]]\n; and finally, return the table concatination of 'clicks_concat'\n; \n; function click.data_validation()\n; this is a function that verifies whether or not the user is recording valid data\n; valid data is defined as click coordinates obtained at a screen resolution of 16/9\n; we start by creating local copies of click.maintenance.resolution_x and .resolution_y\n; then, check if resolution_x is smaller or equal to resolution_y\n; throw an error if it's the case and prevent compilation\n; otherwise, we continue onward\n; \n; we assign the division of 16/9 to 'local resolution'\n; we assign the division of our given resolution to 'local given_resolution'\n; \n; then, create a 'local divisor' element that'll be used in getting the resolution factor\n; we enter a while loop, that only stops once resolution_y == 0\n; inside of the loop\n; * give divisor the value of resolution_x\n; * give resolution_x the value of resolution_y\n; * give resolution_y the value of divisor % resolution_y\n; once the loop ends, finish by assigning divisor the value of resolution_x\n; we then create the 2 'local root_resolution_x' _y respectively and\n; assign them the division between the respective click.maintenance.resolution and our divisor\n; finally, we check if resolution - given_resolution is different than 0\n; if it is, then our given resolution is not 16/9 which means we return an error and prevent compilation\n; \n; click.data_validation() is run at the bottom of this file\n; so you can check the errors by modifying the values under .maintenance.resolution_x/y\n\n{lua(\\\n  local function x_digit_precision(digits, input)\\\n    local number = string.gsub(input, \" \", \"\");\\\n    return string.sub(string.format(\"%.\" .. digits .. \"f\", number), 1, digits + 2);\\\n  end\\\n\\\n  local function debugging()\\\n    print([[Debugging enabled: ]] .. click.debugging);\\\n    print([[Click Index: ]] .. #click.recording);\\\n    print([[Click ID: ]] .. click.recording[#click.recording].click_name);\\\n    print([[Click Coord_x: ]] .. click.recording[#click.recording].coord_x);\\\n    print([[Click Coord_y: ]] .. click.recording[#click.recording].coord_y);\\\n    print([[Click Anchor_x: ]] .. click.recording[#click.recording].anchor_x);\\\n    print([[Click Anchor_y: ]] .. click.recording[#click.recording].anchor_y);\\\n    print([[Click Max Name Length: ]] .. click.max_name);\\\n    print([[Click Max Formation Length: ]] .. click.max_length);\\\n    print([[Debugging Log]] .. #click.recording .. [[ End]]);\\\n  end\\\n\\\n  function click.add_click(coord_x, coord_y, anchor_x, anchor_y, name)\\\n    local click_index = 1 + #click.recording;\\\n    local click_recording = {};\\\n    click_recording.coord_x = x_digit_precision(click.precision.coord, coord_x);\\\n    click_recording.coord_y = x_digit_precision(click.precision.coord, coord_y);\\\n    if tonumber(click_recording.coord_x) > click.maintenance.resolution_x or tonumber(click_recording.coord_y) > click.maintenance.resolution_y then\\\n      return [[Try not to give values larger than your screen resolution]] .. \\\n        \"\\ncoord_x[\" .. click_recording.coord_x .. \"] should be smaller than \" .. click.maintenance.resolution_x ..\\\n        \"\\ncoord_y[\" .. click_recording.coord_y .. \"] should be smaller than \" .. click.maintenance.resolution_y;\\\n    end\\\n    click_recording.anchor_x = x_digit_precision(click.precision.anchor, anchor_x);\\\n    click_recording.anchor_y = x_digit_precision(click.precision.anchor, anchor_y);\\\n    click_recording.click_name = string.gsub(name, \" \", \"\") .. click.maintenance.name_separator;\\\n    local anchor_max = math.max(\\\n      tonumber(click_recording.anchor_x), \\\n      tonumber(click_recording.anchor_y)\\\n    );\\\n    local anchor_min = math.min(\\\n      tonumber(click_recording.anchor_x), \\\n      tonumber(click_recording.anchor_y)\\\n    );\\\n    if 1 < anchor_max or anchor_min < 0 then\\\n      return [[Recording a relative vector should not have anchor values bellow 0 or above 1]];\\\n    end\\\n  \\\n    local click_string = click_recording.coord_x .. click_recording.coord_y .. \\\n        click_recording.anchor_x .. click_recording.anchor_y .. \\\n        click_recording.click_name;\\\n  \\\n    click.max_name = math.max(click.max_name, #click_recording.click_name);\\\n    click.max_length = math.max(click.max_length, #click_string);\\\n  \\\n    table.insert(click.recording, click_recording);\\\n    if click.debugging then\\\n      debugging();\\\n    end\\\n    return [[:const string click]] .. click_index .. [[ ']] .. click_string .. [[']];\\\n  end\\\n\\\n  function click.concatinate_click_recordings()\\\n    local clicks_recorded = #click.recording;\\\n    local clicks_concat = {};\\\n    for i = 1, clicks_recorded do\\\n      local space = click.max_name - #click.recording[i].click_name;\\\n      local spacer = string.rep([[.]], space);\\\n      table.insert(clicks_concat, [[click]] .. i .. [[ . \"]]);\\\n      table.insert(clicks_concat, spacer .. [[\" . ]]);\\\n    end\\\n    table.insert(clicks_concat, [[\".\"]]);\\\n    return table.concat(clicks_concat);\\\n  end\\\n\\\n  function click.data_validation()\\\n    local resolution_x = click.maintenance.resolution_x;\\\n    local resolution_y = click.maintenance.resolution_y;\\\n    if resolution_x <= resolution_y then\\\n      return [[Recording coordinates should be done on a resolution of 16/9 ]] .. \\\n        \"resolution_x[\" .. resolution_x .. \"]\" \\\n        .. [[ should always be bigger than ]] ..\\\n        \"resolution_y[\" .. resolution_y .. \"]\";\\\n    end\\\n    local resolution = 16/9;\\\n    local given_resolution = resolution_x / resolution_y;\\\n    local divisor = 0;\\\n    while resolution_y ~= 0 do\\\n      divisor = resolution_x;\\\n      resolution_x = resolution_y;\\\n      resolution_y = divisor % resolution_x;\\\n    end\\\n    divisor = resolution_x;\\\n    local root_resolution_x = click.maintenance.resolution_x / divisor;\\\n    local root_resolution_y = click.maintenance.resolution_y / divisor;\\\n    if resolution - given_resolution ~= 0 then\\\n      return \"Resolution provided has a factor of \" .. \\\n        root_resolution_x .. \"/\" .. root_resolution_y .. \\\n        \"\\nExpected resolution was 16/9\" .. \\\n        \"\\nRecommended resolution for recording clicks is 800x450\";\\\n    end\\\n  end\\\n)}\n\n; this marks the end of Macro 2\n; the following 2 ordinairy macros are for the user\n; to communicate with the scripts more easily\n\n; <add_click> communicates with click.add_click()\n#add_click(coord_x, coord_y, anchor_x, anchor_y, identifier) {lua(\\\n  return click.add_click(\\\n    [[{coord_x}]], \\\n    [[{coord_y}]], \\\n    [[{anchor_x}]], \\\n    [[{anchor_y}]], \\\n    [[{identifier}]]\\\n  );\\\n)}\n\n; <clicks_concat> returns the concatinated table from click.concatinate_click_recordings\n#clicks_concat {lua(return click.concatinate_click_recordings())}\n\n; this final lua call ensures that all data entered by the user is valid\n{lua(return click.data_validation())}\n"],["IronClick_lib",":import Clicks Config\n#package(name) IronClick:{name}\n\n#identifier \"IronClick\"\n\n#pointer \"<size=0>\" . {identifier} . \"pointer\"\n#pointer.get global.int.get({pointer})\n#pointer.set(value) global.int.set({pointer}, {value})\n#pointer.advance {pointer.set(({pointer.get} + 1) % clicks_count)}\n\n#position {identifier} . \"clicker position\"\n#position.get global.vec2.get({position})\n#position.set(value) global.vec2.set({position}, {value})\n#position.vector_set(coord_x, coord_y, anchor_x, anchor_y) {position.set({pos.relative(\\\n  {coord_x} / 800.0, \\\n  {coord_y} / 450.0, \\\n  {anchor_x}, \\\n  {anchor_y}\\\n)})}\n\n#status {identifier} . \"</size>\" . \"Status\"\n#status.get global.string.get({status})\n#status.set(value) global.string.set({status}, {value})\n\n#root_click(distance, length) sub({clicks_concat}, {distance}, {length})\n#root_index(char, spacing) index(\\\n  {clicks_concat}, \\\n  {char}, \\\n  {spacing}\\\n) - ({spacing})\n"],["Main",":import IronClick_lib\n:name {package(Main)}\n\n#string_read {pos.relative(\\\n  s2d({root_click(root_pointer, coord_displace)}, 0.0) / resolution_x, \\\n  s2d({root_click(root_pointer + coord_displace, coord_displace)}, 0.0) / resolution_y, \\\n  s2d({root_click(root_pointer + coord_displace + coord_displace, anchor_displace)}, 0.0), \\\n  s2d({root_click(root_pointer + coord_displace + coord_displace + anchor_displace, anchor_displace)}, 0.0)\\\n)}\n\nkey.p()\nkey.l()\n\ngoto(if(\\\n  contains(impulse(), \"key.l\"), \\\n  points, \\\n  if(contains(impulse(), \"{package(Main)}\"), superclick, start)\\\n))\n\nstart:\n; enter a modification of D0S.Superclick\n; D0S.Superclick link\n; https://github.com/d0sboots/PerfectTower/blob/main/D0S.Crates_Idler_v2\n\n:global int click_instances\n:local int root_pointer\n\nroot_pointer = if(\\\n  contains(impulse(), \"key.p\") && click_instances > 0, \\\n  clicks_count * increment, \\\n  {pointer.get} * increment\\\n)\n\n{position.set({string_read})}\n\nsuperclick:\nclick_instances += 1\nexecute(if(click_instances < 54, \"{package(Main)}\", \"{package(Null)}\"))\nexecute(if(click_instances < 54, \"{package(Main)}\", \"{package(Null)}\"))\n\nloop:\nclick(position())\nclick({position.get})\ngotoif(loop, click_instances <= 54)\n\nclick_instances += 1\nglobal.unset(if(\\\n  click_instances > 109, \\\n  \"click_instances\", \\\n  \"{package(NULL)}\"\\\n))\ngoto(99)\n\npoints:\n{pointer.advance}\n{position.set({position.get})}\n{status.set({root_click(\\\n  {pointer.get} * increment + coord_displace + coord_displace + anchor_displace + anchor_displace, \\\n  {root_index(\\\n    \";\", \\\n    {pointer.get} * increment + coord_displace + coord_displace + anchor_displace + anchor_displace\\\n  )}\\\n)})}\n\n"],["Debug",":import IronClick_lib\n:name {package(Debug)}\n\nkey.d()\n\n:local double coord_x\n:local double coord_y\n:local double anchor_x\n:local double anchor_y\n:local string identifier\n\n:local bool debuging\n\ndebuging = false\ngoto(if(debuging, debug, 99))\ndebug:\n{pointer.advance}\ncoord_x = s2d({root_click({pointer.get} * increment, coord_displace)}, -1.0)\ncoord_y = s2d({root_click({pointer.get} * increment + coord_displace, coord_displace)}, -1.0)\nanchor_x = s2d({root_click({pointer.get} * increment + coord_displace + coord_displace, anchor_displace)}, 0.0)\nanchor_y = s2d({root_click({pointer.get} * increment + coord_displace + coord_displace + anchor_displace, anchor_displace)}, 0.0)\n\nidentifier = {root_click(\\\n  {pointer.get} * increment + coord_displace + coord_displace + anchor_displace + anchor_displace, \\\n  {root_index(\\\n    \";\", \\\n    {pointer.get} * increment + coord_displace + coord_displace + anchor_displace + anchor_displace\\\n  )}\\\n)}\n\n{position.vector_set(\\\n  coord_x, \\\n  coord_y, \\\n  anchor_x, \\\n  anchor_y\\\n)}\n\n{status.set(if(\\\n  contains(d2s(coord_x) . d2s(coord_y) . d2s(anchor_x) . d2s(anchor_y), \"-1\"), \\\n  \"relative.pos(\" . d2s(coord_x) . \", \" . d2s(coord_y) . \", \" . d2s(anchor_x) . \", \" . d2s(anchor_y) . \")\", \\\n  identifier\\\n))}\n"]]}}
```

## Import requirements
- 2 impulses
- 0 conditions
- 15 actions
- 2 scripts

The ingame import script provides a visual state "Status" which displays which click is selected
```
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
```

It has 2 scripts, but uses only 1<br>
[Main](Main.tpt2) is the script that acts like the original IronClick, it holds 2 impulses
- key.l is used to cycle between the stored clicks
- key.p is used to initiate the modified d0s.superclick script

[Debug](Debug.tpt2) is a script used for debugging<br>
If you want to make sure all your clicks are stored correctly, you can use it for that<br>
It has 2 layers of protection, to ensure you do not modify the clicking position while the superclick is engaged<br>
The script is activated with key.d, and to read the debug information you need to enable the boolean `debugging`

It advances the pointer, assigns the values to 5 local variables, updates the internal position vector, and then it will display the name of the click, or it will show the string "relative.pos(" followed by the given parameters, ending with ")" if one of the values failed to change

# I do not really know what to write in my readme, so this is for all intents and purposes purely a draft