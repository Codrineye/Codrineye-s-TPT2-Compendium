# winAI

winAI is a blueprint AI made by WootImNoob for the blueprint of the same name.<br>
It was originally 8 scripts long, but now that it uses the stand alone compactor, it's only 2 scripts big.

## Source import

winAI was not made as a source program, but I've reworked it so that anyone can look at it for a practical example.<br>
To remove any 

```
{"workspaces":{"unofficial winAI4":[["Secure Config winAI",":import Cods Blueprint Compactor\n\n; \n; Welcome to security config, where you define\n; what modules you want to secure and in what order\n; \n; Since securing isn't very complicated, logging and halting\n; has not been added, as there's not much for you to keep track of\n; \n; You have 2 macros at your disposal\n; add_secure(secure_name) is the name ID that you want to be secured\n; recorded_secures(secures_name) will return a const int called\n; secures_<secures_name> which holds the ammount of space your secures\n; have taken up\n; \n; your compacted secures are in the const string recorded_secures\n; and the total size of your recorded_secures is in the\n; const int secures_space\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{add_secure(barrier.temporal)}\n{add_secure(spell.void)}\n{add_secure(spell.snapOfDestiny)}\n{add_secure(spell.response.neutral)}\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n:const string recorded_secures \"{lua(\\\n  return table.concat(BP.comp.secure);\\\n)}\"\n:const int secures_space {lua(return BP.used_space.secure)}\n"],["Spell Config winAI",":import Cods Blueprint Compactor\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; Please read the compactor manual on the repo for a better\n; understanding of how to use it\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; timer_modulo(modulo)\n; Should be used before you use recorded_blueprint to define a\n; blueprint that can loop\n; \n; this modulo value is used to \n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{synchronize(2)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n{add_spell.instant(crate.rex, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{synchronize(2)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n; Because woot activates a spamming script that executes\n; spell.response.neutral every 0.2 seconds, I will write a reusable\n; lua macro here that does this exact thing\n#spam_SRN(start, end) {lua(\\\n  for i = {start} + 0.2, {end}, 0.2 do\\\n    BP.sync_ammount = 1;\\\n    BP.comp.add_spell([[\"spell.response.neutral\"]], i, 0.0, 0.0);\\\n  end\\\n)}\n\n{spam_SRN(2.0, 3.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{spam_SRN(3.0, 28.0)}\n\n{synchronize(2)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n\n{add_spell.instant(spell.recharge, 28.0)}\n\n{synchronize(3)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{add_spell.instant(spell.cooling, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n\n{spam_SRN(28.0, 30.0)}\n{add_spell.grounded(spell.void, 30.0, 0.0, 0.0)}\n\n{spam_SRN(30.0, 30.5)}\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{spam_SRN(30.4, 31.0)}\n{synchronize(2)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n\n{add_spell.instant(spell.refresh, 31.0)}\n\n{synchronize(2)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{spam_SRN(31.0, 33.0)}\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{spam_SRN(33.0, 57.0)}\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n{spam_SRN(57.0, 60.0)}\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return BP.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the concat operation one more time, which\n; can get very expensive if you have a big recording sequence\n\n:const int recoring_size {lua(return BP.used_space.active)}\n"],["winAI_lib",":import Secure Config winAI\n:import Spell Config winAI\n:import Blueprint Compactor resources\n\n; Consistent naming across scripts\n#package(name) Unofficial winAI4:{name}\n"],["init",":import winAI_lib\n:name {package(init)}\n:budget_cap 301\ngame.newround()\n\nglobal.unset(timer_var)\n\n{pointer.set(0)}\n{comp_active.set(recorded_actives)}\n{comp_secure.set(recorded_secures)}\nexecute(\"{blueprint_compactor}\")\n\nwaituntil(health(false) <= 0.0)\n\nstop(\"{package(disables)}\")\nstop(\"{blueprint_compactor}\")\n"],["disables",":import winAI_lib\n:name {package(disables)}\n\n:budget_cap 200\ngame.newround()\n\n:local bool disabled_era\n\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(nature)}\n{set_priority(electricity)}\n{set_priority(universal)}\n{set_priority(fire)}\n{set_priority(neutral)}\n{set_priority(water)}\n{set_priority(earth)}\n\nera:\ndisable.era({disable.era})\ndisabled_era = {disabled_era}\n\ndivider:\nupgrade.era(\"health\", 25)\n\ngoto(if(disabled_era, era, divider))\n"]]}}
```

If you do encounter issues with it, please contact me on the compactors discord post, in the ai-help channel or by giving me a message directly.

# DO NOT CONTACT WOOTIMNOOB ABOUT ANY ISSUES THAT ACCOUR WHILE USING THE COMPACTOR

Woot does not know how to use the compactor and cannot provide assistance.
