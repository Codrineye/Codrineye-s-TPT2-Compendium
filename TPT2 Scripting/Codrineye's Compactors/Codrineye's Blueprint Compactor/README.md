# Codrineye's Blueprint Compactor

The blueprint compactor is a library for the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) that helps you define what you want your blueprint AI to do.

To better understand how to use the compactor, head over to the [Compactor Manual](Compactor%20manual.md) for an explanation of each function.

## The source import

This is the import you need to be able to use the configuration scripts.<br>
As this is the source, you must use this code in the [external editor](https://d0sboots.github.io/perfect-tower/).

If you want to look through this import, the library file will return an import error if you haven't imported [Editor_actions lib](../../Editor%20Actions%20lib/README.md).

```
{"workspaces":{"Codrineye's Blueprint Compactor":[["Cods Blueprint Compactor","\n{lua(\\\n  BP = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  BP.debug = {};\\\n  BP.debug.can_log = false;\\\n  BP.debug.can_halt = false;\\\n  BP.debug.halt_limit = 0;\\\n  BP.debug.can_display = false;\\\n  BP.debug.concat_format = \"\";\\\n  \\\n  --[[Table that has data needed in compacting data]]\\\n  BP.used_space = {};\\\n  BP.used_space.secure = 0;\\\n  BP.used_space.blueprint = 0;\\\n  \\\n  BP.sync_ammount = 0;\\\n  \\\n  --[[Table that has compactor specific data]]\\\n  BP.comp = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  BP.comp.software = {}\\\n  \\\n  --[[Store the modules we want to secure]]\\\n  BP.comp.module = {};\\\n  BP.comp.secure = {};\\\n  \\\n  --[[Blueprint activation]]\\\n  BP.comp.spell = {};\\\n  BP.comp.blueprint = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(BP.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  BP.debug.can_display = true;\\\n  BP.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(BP.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  BP.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  BP.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  BP.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  BP.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local bp_debug_stop = false;\\\n  \\\n  --[[/*\\\n      * Empty table that replaces the need\\\n      * for repetitive assert sequences\\\n      * \\\n      * Adding to a table and concatenating it is more efficient\\\n      * than ordinairy string concatenation\\\n     */]]\\\n  local err_msg = {};\\\n  \\\n  --[[Function to more easily handle error messages]]\\\n  function BP.debug.detect_error()\\\n    --[[Check if there's an error message to send]]\\\n    if err_msg[1] ~= nil then\\\n      error(table.concat(err_msg, 0));\\\n      --[[/*\\\n          * If there is send just the message,\\\n          * the 0 ignores the call context since this context is\\\n          * just illegible lua code\\\n         */]]\\\n    end\\\n  end\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  for _, soft in ipairs(software_list) do\\\n    BP.comp.software[soft] = -50;\\\n  end\\\n  \\\n  function BP.comp.add_software(software, level)\\\n    --[[get direct access to the software we recognize]]\\\n    local soft = BP.comp.software;\\\n    \\\n    --[[get the security level from the macro call]]\\\n    local sec = level:match([[%b\"\"]]):sub(2, -2):gsub(\" \", \"\");\\\n    \\\n    if soft[software] == nil then\\\n      err_msg = table.pack(\\\n        \"Attempt to assign a security level to \",\\\n        \"an unrecognized software\\n\",\\\n        \"If this is a new software, an update to the compactor \",\\\n        \"should be released soon\"\\\n      );\\\n    elseif soft[software] ~= -50 then\\\n      --[[/*\\\n          * Smallest security level I've seen is -1, \\\n          * so -50 should never be assigned naturally\\\n         */]]\\\n      err_msg = table.pack(\\\n        \"Trying to assign a security level to an \",\\\n        \"already set software\"\\\n      );\\\n    elseif tonumber(sec) == nil then\\\n      err_msg[1] = \"Trying to assing a non-numeric security level\";\\\n    elseif math.type(tonumber(sec)) ~= \"integer\" then\\\n      err_msg[1] = \"Trying to assign a non-integer security level\";\\\n    end\\\n    \\\n    --[[Detect if we have an error and send it if we do]]\\\n    BP.debug.detect_error();\\\n    \\\n    --[[create the software ID]]\\\n    local software_name = string.format(\"software.%s\", software);\\\n    \\\n    --[[/*\\\n        * get the extra space we need to fill out\\\n        * such that the string in sec has as many characters\\\n        * as the software ID does\\\n       */]]\\\n    local lvl = string.format(\"%%-%ss\", #software_name);\\\n    BP.comp.software[software] = lvl:format(sec);\\\n  end\\\n  \\\n  function BP.comp.concat_software(concat_mode)\\\n    local modes = {};\\\n    modes.software_list = true;\\\n    modes.software_secure = true;\\\n    modes.software_len = true;\\\n    \\\n    if not modes[concat_mode] then\\\n      err_msg = table.pack(\\\n        \"Invalid concat_mode.\\n\",\\\n        \"If you're seeing this:\\n\",\\\n        \"- You're either a user that messed with something \",\\\n        \"you shouldn't have\\n\",\\\n        \"- Or you're a user that did nothing wrong and \",\\\n        \"I messed something up and didn't propperly bug test\"\\\n      );\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local software = {};\\\n    local software_len = 0;\\\n    \\\n    for _, soft in ipairs(software_list) do\\\n      local concat_val = {};\\\n      if concat_mode == [[software_len]] then\\\n        software_len = software_len + 9 + #soft;\\\n      else\\\n        if concat_mode == [[software_list]] then\\\n          concat_val[1] = \"software.\";\\\n          concat_val[2] = soft;\\\n        else\\\n          concat_val[1] = BP.comp.software[soft];\\\n        end\\\n        software[1 + #software] = table.concat(concat_val);\\\n        software[1 + #software] = \"|\"\\\n      end\\\n    end\\\n    if software_len > 0 then\\\n      return software_len - 5;\\\n    end\\\n    return string.format([[\"%s\"]], table.concat(software));\\\n  end\\\n  \\\n  function BP.comp.recorded_secures(blueprint_name)\\\n    if #BP.comp.module == 0 then\\\n      --[[Check if there are any modules to secure]]\\\n      err_msg = table.pack(\\\n        \"Cannot define a recorded security sequence if you haven't \",\\\n        \"added modules to secure\"\\\n      );\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local space = BP.used_space.secure;\\\n    BP.comp.secure[blueprint_name] = space;\\\n    --[[give the user access to the updated data]]\\\n    \\\n    local const = table.pack(\\\n      \":const int secures_\",\\\n      blueprint_name, \" \", space\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.add_secure(module_name)\\\n    local secures_idx = 1 + #BP.comp.module;\\\n    local secure_name = table.pack(module_name:gsub(\" \", \"\"), \"|\");\\\n    \\\n    BP.comp.module[secures_idx] = table.concat(secure_name);\\\n    local space = #table.concat(secure_name);\\\n    BP.used_space.secure = space + BP.used_space.secure;\\\n    \\\n    local const = table.pack(\\\n      \":const in secure_module.\",\\\n      secures_idx, \" \", BP.used_space.secure\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local spell_index = #BP.comp.spell;\\\n      BP.comp.spell[spell_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that\\\n          * the compactor knows to loop\\\n         */]]\\\n    end\\\n    \\\n    local space = BP.used_space.blueprint;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    \\\n    local bp_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    \\\n    BP.comp.blueprint[bp_name] = space;\\\n    --[[/*\\\n        * add an instance to the table so that this value\\\n        * can be accessed in lua\\\n       */]]\\\n    \\\n    local const = table.pack(\\\n      \":const int blueprint_\",\\\n      bp_name, \" \", space\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local spell = BP.comp.spell[#BP.comp.spell];\\\n    if spell == nil then\\\n      err_msg[1] = table.pack(\"Trying to add a timer_base\", \\\n        \"without any recorded spells\");\\\n    elseif tonumber(defined_base) == nil then\\\n      err_msg[1] = \"Trying to define a timer_base as a non number\";\\\n    elseif math.type(tonumber(defined_base)) ~= \"float\" then\\\n      err_msg[1] = \"Trying to define a timer_base as a non double\";\\\n    end\\\n    BP.debug.detect_error()\\\n    \\\n    local base_val = tonumber(defined_base);\\\n    local base_fmt = table.pack(base_val, \"|\");\\\n    spell.timer_base = table.concat(base_fmt);\\\n    \\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    BP.used_space.blueprint = BP.used_space.blueprint - space;\\\n    --[[We also have to update the total ammount of space being used]]\\\n    \\\n    space = -1 + space + #spell.timer_base;\\\n    --[[/*\\\n        * Since spell.timer_base originally had a value of `|`\\\n        * space already includes this 1 character. To get an\\\n        * accurate reading, we must subtract this 1.\\\n       */]]\\\n    \\\n    local used_space = space;\\\n    local prev_space = -1;\\\n    while used_space ~= prev_space do\\\n      prev_space = used_space;\\\n      local value = table.pack(used_space, \"|\");\\\n      spell.space = table.concat(value);\\\n      used_space = space + #spell.space;\\\n      --[[We loop until we're not adding any extra space]]\\\n    end\\\n    --[[And we can end by adding the new used space to the total]]\\\n    BP.used_space.blueprint = BP.used_space.blueprint + used_space;\\\n  end\\\n  \\\n  function BP.comp.sync(spell_ammount)\\\n    --[[Perform basic error handling on the parameter]]\\\n    if tonumber(spell_ammount) == nil then\\\n      err_msg[1] = \"Trying to add a non-number as a sync ammount\";\\\n    elseif tonumber(spell_ammount) <= 0 then\\\n      err_msg[1] = \"Trying to add a sync ammount that's less than 1\";\\\n    end\\\n    BP.debug.detect_error();\\\n    --[[/*\\\n        * The sync system prevents the compactor from refreshing its\\\n        * execution budget until all synchronized modules have been used\\\n        * \\\n        * We subtract the ammount of spells that are synchronized by 1\\\n        * so that the final synchronized spell refreshes the budget\\\n       */]]\\\n    BP.sync_ammount = tonumber(spell_ammount) - 1;\\\n    --[[sync_ammount always gets overwritten]]\\\n  end\\\n  \\\n  function BP.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local halt_limit = BP.debug.halt_limit == 0 and BP.debug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our \"halt limit\" has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or bp_debug_stop then BP.debug.halt() end\\\n    \\\n    local active_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    if active_name == \"\" then\\\n      error(\"Trying to add a spell with an empty ID\", 0);\\\n    end\\\n    local actives_index = 1 + #BP.comp.spell;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * so that we loop the activation sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    if BP.sync_ammount > 0 then\\\n      new_spell.sync = \"s\";\\\n      BP.sync_ammount = BP.sync_ammount - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the execution budget]]\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      if value == nil then\\\n        err_msg = table.pack(\"Trying to add a non-number \", variable);\\\n      elseif math.type(value) ~= \"float\" then\\\n        err_msg = table.pack(\"Trying to add a non-double \", variable);\\\n      end\\\n      BP.debug.detect_error();\\\n      \\\n      new_spell[variable] = value;\\\n    end\\\n    new_spell.name = active_name\\\n    spell_values[4] = \"name\";\\\n    \\\n    for _, variable in ipairs(spell_values) do\\\n      local value = table.pack(new_spell[variable], \"|\");\\\n      new_spell[variable] = table.concat(value);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * We use spell_fmt to include the ending character\\\n          * This ending character is used in an editor index()\\\n          * in order to isolate the value we need\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      local value = table.pack(used_space, \"|\");\\\n      new_spell.space = table.concat(value);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[Add the extra space taken up by our space size marker]]\\\n    \\\n    BP.comp.spell[actives_index] = new_spell;\\\n    BP.used_space.blueprint = BP.used_space.blueprint + used_space;\\\n    \\\n    \\\n    --[[Check if we have to log the added data]]\\\n    local logging_check = BP.debug.can_halt or BP.debug.can_log;\\\n    if logging_check then BP.debug.log() end\\\n    \\\n    --[[If we can halt, decrement our halting limit by 1]]\\\n    if BP.debug.can_halt then\\\n      BP.debug.halt_limit = BP.debug.halt_limit - 1;\\\n    end\\\n    \\\n    local const = table.pack(\\\n      \":const int spell_\", \\\n      actives_index, \" \", BP.used_space.blueprint\\\n    );\\\n    return table.concat(const);\\\n    --[[/*\\\n        * Return a const int that has\\\n        * the ammount of space it took to add this spell\\\n       */]]\\\n  end\\\n  \\\n  function BP.comp.concat_actives()\\\n    local actives = {};\\\n    \\\n    local spells = BP.comp.spell;\\\n    --[[table holding the compacted data]]\\\n    local spells_count = #spells;\\\n    --[[number of spells recorded]]\\\n    \\\n    local concat_debug = {};\\\n    if BP.debug.can_display then\\\n      local fmt = BP.debug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    else\\\n      concat_debug.format = \"\";\\\n      concat_debug.separation = \"\";\\\n      concat_debug.bit_format = \"%s\";\\\n      concat_debug.spell_data = \"%s\";\\\n    end\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    for i = 1, spells_count do\\\n      --[[/*\\\n          * spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data = spells[i];\\\n      local data_pack = {};\\\n      local data_names = table.pack(\\\n        \"loop_bit\", \"sync_bit\",\\\n        \"base\", \"space\", \"timer\",\\\n        \"coord_x\", \"coord_y\",\\\n        \"name\"\\\n      );\\\n      local data_set = {};\\\n      local idx = 1;\\\n      if BP.debug.can_display then\\\n        --[[Sets the data_set for the case where we can display]]\\\n        data_set = table.pack(\"loop_sign\", \"sync\");\\\n        for _, set in ipairs(data_set) do\\\n          local name = data_names[idx];\\\n          data_pack[name] = table.pack(\\\n            name:gsub(\"_bit\"),\\\n            --[[removes the _bit from the name]]\\\n            data[set]\\\n          );\\\n          idx = idx + 1;\\\n        end\\\n        data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        \\\n        data_set = table.pack(\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      else\\\n        --[[Sets the data_set for the case where we can't display]]\\\n        data_pack.chunk_end = \"\";\\\n        data_set = table.pack(\\\n          \"loop_sign\", \"sync\",\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      end\\\n      for _, set in ipairs(data_set) do\\\n        local name = data_names[idx];\\\n        data_pack[name] = table.pack(\\\n          data[set], set, \\\n          #data[set]\\\n        );\\\n        idx = idx + 1;\\\n      end\\\n      \\\n      actives[1 + #actives] = concat_debug.format;\\\n      for _, name in ipairs(data_names) do\\\n        local spell_data = data_pack[name];\\\n        local fmt = \"\";\\\n        --[[Determine the format we're using]]\\\n        if name:match(\"_bit\") == \"_bit\" then\\\n          fmt = concat_debug.bit_format;\\\n        else\\\n          fmt = concat_debug.spell_data;\\\n        end\\\n        actives[1 + #actives] = fmt:format(table.unpack(spell_data));\\\n      end\\\n      actives[1 + #actives] = concat_debug.format;\\\n      actives[1 + #actives] = data_pack.chunk_end;\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(actives));\\\n  end\\\n  \\\n  \\\n  function BP.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from BP.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local spell_index = #BP.comp.spell;\\\n    local spell = BP.comp.spell[spell_index];\\\n    local logging_text = table.pack(\\\n      \"%s| BP has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"timer_base\",\\\n      \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 8;\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value];\\\n      if spell_value == nil then\\\n        err_msg = \"Cannot log nil value \" .. value;\\\n        error(err_msg);\\\n      end\\\n      local fmt = table.pack(log, value, spell_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, spell_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function BP.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * BP.comp.add_spell\\\n        * * BP Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local should_halt = BP.debug.can_halt or BP.debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #BP.comp.spell,\\\n        \" \"\\\n      );\\\n      if #BP.comp.spell == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = BP.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n#recorded_security(secure_name) {lua(\\\n  return BP.comp.recorded_secures([[{secure_name}]])\\\n)}\n; \n#add_secure(secure_name) {lua(BP.comp.add_secure([[{secure_name}]]))}\n; \n; \n#recorded_secures \"{lua(return table.concat(BP.comp.module))}\"\n#secures_space {lua(return BP.used_space.secure)}\n\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return BP.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; \n#timer_modulo(modulo) {lua(BP.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(BP.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return BP.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0.0, \\\n  0.0\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n\n#recorded_actives {lua(return BP.comp.concat_actives())}\n#recording_size {lua(return BP.used_space.blueprint)}\n\n#software.concat(concat_mode) {lua(\\\n  return BP.comp.concat_software([[{concat_mode}]])\\\n)}\n\n#software.secure(software_name, level) {lua(\\\n  BP.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}\n"],["Blueprint Compactor resources","\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#blueprint_compactor Blueprint Compactor\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{blueprint_compactor} Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string compactor_actives \"{blueprint_compactor}access actives str\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{blueprint_compactor}access secures str\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_secures, {str})\n; \n:const string caller_ID \"{hider.close}{blueprint_compactor} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n\n#idle_mode_str {hider.start}{blueprint_compactor}{hider.close}\n; \n; this is a special string that makes it highly unlikely\n; that the caller_ID has this value naturally.\n; \n:const string idle_mode \"{idle_mode_str}idle mode\"\n; \n; This string is used by the compactor to detect if entered idle mode\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n\n; \n; Adds era securing capabilities\n; \n\n{lua(\\\n  Era = {};\\\n  Era.elements = {};\\\n  Era.element_cost = {};\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[no parse blocks]] are recommended here to\n; ensuse our input is a string\n; \n; Use this to create the priority listing\n; The macro doesn't check if it's a valid element since\n; the editor checks for us :D\n#set_priority(element_name) {lua(\\\n  local elems = Era.elements;\\\n  local name = [[\"{element_name}\"]];\\\n  --[[/*\\\n      * Prevent recording the same element multiple times\\\n      * by checking if its name has already been read\\\n      * if it has, return to prevent another entry\\\n     */]]\\\n  if elems[name] ~= nil then\\\n    return;\\\n  end\\\n  local index = 1 + #elems;\\\n  elems[index] = name;\\\n  \\\n  local disable_era = [[disable.cost(%s)]]\\\n  Era.element_cost[index] = disable_era:format(elems[index]);\\\n  elems[name] = index;\\\n)}\n\n; important thing to know about disable.cost(element)\n; if we input an element we can't disable, disable.cost returns -1.0\n; \n; Here we use this fact to create an if statement\n; if(disable.cost(\"element\"), \"element\", if(next_element))\n; and we repeat this until our last recorded element\n; that if statement is\n; if(disable.cost(\"element\"), \"element\", \"last_element\")\n#disable.era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.element_cost;\\\n  \\\n  local condition_fmt = [[%s != -1.0]]\\\n  local if_fmt = [[if(%s, %s, %s)]];\\\n  \\\n  local last_element = elems[#elems];\\\n  for i = #elems - 1, 1, -1 do\\\n    local cost = elem_costs[i];\\\n    local condition = condition_fmt:format(cost);\\\n    local caseTrue = elems[i];\\\n    last_element = if_fmt:format(condition, caseTrue, last_element);\\\n  end\\\n  return last_element;\\\n)}\n\n; Here we construct the condition for the bool ended_era\n; ended_era = -<number_of_elements> == <sum_of_elements_cost>\n#disable_era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.element_cost;\\\n  \\\n  local sum_fmt = [[%s + %s]];\\\n  \\\n  local last_cost = elem_costs[#elems];\\\n  for i = #elems - 1, 1, -1 do\\\n    last_cost = sum_fmt:format(last_cost, elem_costs[i]);\\\n  end\\\n  local negative_costs = 0.0 - #elems;\\\n  local not_equal = [[%s != %s]]\\\n  return not_equal:format(negative_costs, last_cost);\\\n)}\n\n"],["Blueprint Compactor lib",":import Blueprint Compactor resources\n\n:local int pointer\n:local string actives\n:local string secures\n; \n:local bool det_timer_base\n:local double timer_base\n:local double clock\n; \n:local string spell_ID\n; \n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[actives]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, pointer, 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  contains({get_bits}, \"#\"), \\\n  0, \\\n  pointer + {get_space}\\\n)\n\n; \n#modulo_timer {timer.get} % timer_base\n"],["Blueprint Compactor",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n\n:budget_cap max\n\ngotoif(\\\n  if({timer.get} == 0.0, start_timer, start_secures), \\\n  contains(impulse(), \"{blueprint_compactor}\")\\\n)\n; The compactor will have at most 3 instances running at once\n; The first instance will be in charge of executing actives.\n; It also executes a second instance of itself.\n; If the timer is set to 0, this second instance will be the timer.\n; If this second instance is the timer, it will create a third instance.\n; \n; This third instance will always be in charge of securing modules.\n; \n; If the timer is not set to 0 when the second instance is created, this\n; means that there's already an instance that's running the timer, so\n; this second instance becomes in charge of securing modules\n\npointer = {pointer.get}\nactives = {comp_active.get}\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{blueprint_compactor}\")\n; We now make a copy of ourselves.\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; get_base returns utcnow() if s2d fails.\n; since we're doing this check in the same frame thanks to the budget\n; the value returned by the utcnow() function does not update\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; If we start to execute a recording sequence or we're looping over\n; we have to make sure that execution is done starting from tm = 0.0\n\nclock = if(\\\n  pointer == 0 && det_timer_base, \\\n  1.0 + floor({timer.get} / timer_base), \\\n  0.0\\\n)\n\nwaitwhile(timer_base * clock > {timer.get})\n\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\nwaitwhile({modulo_timer} < clock)\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell or set it to 0 if\n; we must loop over. \n\n#end_of_compactor contains(\"\", sub(actives, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n\n; Skip waiting a frame if we have enough xp to secure another module\ngotoif(secures_no_frame, disable.inf.cost() <= xp())\nwaitframe()\n\nsecures_no_frame:\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngotoif(timer, {caller.get} != idle_mode)\n; The timer will be incremented until one of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(idle_mode)}\n\nend_instance:\n"],["Blueprint Compactor with Debugger",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n; \n; This script is a version of the ordinairy compactor, and as such\n; is intended to make every script that uses the compactor think\n; this is their target. This way, you don't have to change much\n; of your blueprint AI\n; \n\n; \n; The debugger adds a layer of complexity to the compactor\n; and makes everything a little bit more computationally intense\n; (so your game will likely be laggier when you\n; run the compactor like this)\n; \n; This is used to tell you what the compactor sees at any 1 time\n; if durring run-time you get undesirable spell execution\n; \n; While the primary goal here is to diagnose issues,\n; you can also use this as a spell compactor to test\n; any changes you've made.\n; This debugger isn't just for uncovering bugs in the compactor\n; —though if you find any, please let me know!\n; Instead, it's meant to help you, the end user, understand:\n; * What you're instructing the compactor to do\n; * How the substring used to compute the\n;   activation sequence changed the recording string\n; \n\n:budget_cap max\n\nkey.x()\n; You have the impulse that lets you cycle through your spells\n; \n:local bool debugging\n\ndebugging = true\n; This debugging_bool is set to true if you want\n; to search for what's going wrong\n; \n; By default I've set this to true so you have to manually disable\n; debugging if you don't want it\ngotoif(\\\n  if(debugging, debug, if(\\\n    {timer.get} == 0.0, \\\n    start_timer, \\\n    start_secures\\\n  )), \\\n  contains(impulse(), \"{blueprint_compactor}\") || debugging\\\n)\n\npointer = {pointer.get}\nactives = {comp_active.get}\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{blueprint_compactor}\")\n; We now make a copy of ourselves.\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; get_base returns utcnow() if s2d fails.\n; since we're doing this check in the same frame thanks to the budget\n; the value returned by the utcnow() function does not update\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; If we start to execute a recording sequence or we're looping over\n; we have to make sure that execution is done starting from tm = 0.0\n\nclock = if(pointer == 0 && det_timer_base, 1.0, {timer.get})\nwaitwhile(clock < {modulo_timer})\n\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\nwaitwhile({modulo_timer} < clock)\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell or set it to 0 if\n; we must loop over. \n\n#end_of_compactor contains(\"\", sub(actives, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n\n; Skip waiting a frame if we've successfully secured a module\n; this is done in hopes that, maybe, we have enough xp to disable\n; the next module as well\ngotoif(secures_no_frame, disable.inf.cost() < xp())\nwaitframe()\n\nsecures_no_frame:\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(contains({caller.get}, idle_mode), end, end_instance))\n; The timer will be incremented until any of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\ndebug:\n; It sets the caller to idle_mode so that when you\n; force your blueprint AI to send the string over, there's\n; a concrete spot that tells it that it can shut down\n; \n\npointer = {pointer.get}\nactives = {comp_active.get}\n{caller.set(\"debug\")}\n\nglobal.string.set(\"spell_chunk\", sub(\\\n  actives,\\\n  pointer,\\\n  {get_space}\\\n))\n; The chunk shows you how the spell is stored\n; the order is as shown bellow:\n; * `loop_signal bit` that is / to move to the next spell and # to loop\n; * `sync bit` that is / to refresh budget and `s`\n;    to skip refreshing budget\n\nglobal.int.set(\"pointer\", pointer)\n; We also have a pointer and next_pointer that shows what value\n; this pointer has at that state\n\nglobal.string.set(\"timer_base\", {lua(return Compactor.timer_base)})\nglobal.string.set(\"spell space\", {lua(return Compactor.space)})\n; space value which is the ammount of space\n; the spell takes up in the recording\n\nglobal.string.set(\"spell_timer\", {lua(return Compactor.timer)})\n; timer value which is the timer\n; you set when adding a spell\n\nglobal.string.set(\"coord_x\", {lua(return Compactor.coord_x)})\n; coord_x which is the coordinate you add\n; if you added a grounded spell\nglobal.string.set(\"coord_y\", {lua(return Compactor.coord_y)})\n; coord_y which is the same idea as coord_x\n; \n; Remember that add_spell.instant is the same\n; as add_spell.grounded with 0, 0 as coordinates\n; \nglobal.string.set(\"spell_name\", {get_name})\n; name which is the spells identifier so we can\n; take an active index of it\n\n{pointer.increment}\n; We finally increment our pointer and add the next pointer state\n{pointer.set(pointer)}\n\ngoto(end_instance)\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(idle_mode)}\n\nend_instance:"]]}}
```

## Blueprint Compactor with Debugger

This is a version of the blueprint compactor that has a debugger attatched to it.<br>
It is used to show you what the data you send to the compactor gets translated into. But this is usually just for internal use.

You have a local boolean called "debugging" set to true by default. This lets you see the data string obtained from your blueprint AI. You use key.x() to go through your spells.

Requirements:

- impulse: 1
- conditions: 0
- lines: 48
- scripts: 1

```
7V3dbpw4FH6VCdX2YpPQYdJuulHSRu3e7NX2vhNFHuMhVgAjbJpkmz7Dvsq+QaX2xSowJAzYM5jMZAY4qkQT4Pjzz3d+bHycrxbHMY0Et04+f7UQFpSF6c/WNBmPx8RnGPn2jDHf5kRMZ5iFXKBQZE9fT4VLZonn0dCrPHLk1TrIy/FISGKKbY8JRufZvZkgcYjiO5vmMmUwzwRsspf9N65dqxCOg1kQoZhyFtouS2Y+kbc9n82Qn99SgmfNUd+enJ1V7h9p6qO/VhqU1Qo3fO+1ptR5qbFpp8qbXMQ09GzMQoFoyGXPSw7YNIgSnxNVK52jD35CopiGYvQxLRcLFqu74/7ecDhTlsTybRoKJdHS63HEaChInDNKDlkqoCj9xSmn/5Kz8TtFrUefZDk5OZ2xhM47Roue6sYXwhcIk8soKvCbAhhhTDgf5QWNuHioQqU8RR32Tl+lLVK2ByPfL7qlYLws6UlDPnZOpoIns1JRy6UmS0lO8mrQ0CW3/8xNamEGs1BkYYHmhQUitwQnojnHKyzJTYSKJaGgAYkvZ4gTaQX4xK10YIVrOkNT5tqYoJiKq4AIijM7VtIUrXyhKcr+3Ff2p65Xq/CaoTRtmbJm99tusFL8cNu1yro3JRcXKIjsROCQ3Ty41hUuOnvHJeJykZ06V7hIc1XLyjRX2v+9s6U1bqBJ6fUN9hm+XjRqj/VUOzdSurmOMap7dr3tUcq/fNnIFarGqEVE8fP/91OjcObR/eTG8QZRcXNF/SdSpDR+SuBTWXxJo9YWjB0FzDUncvNQYMYj4vuXf/+1Acv+/KYVEPuBuG0XqRZ3QLx23T5XABEQwcoMTFw9hxkCaQERTMFAxVtPuDe0cgWK0SPF2I3uHgLiYCgFkQuMe+Olzh/f261e7tCq47LFUZNF1qIjjgW7IbEdMDfxiZ1wQh8FnLceCkjxTLJR8rghix8WPgu0t1W0iHGabh9YL5xUjS8E2/OYBR8Zi10ZXUCQ0iHEgdoyiKoAEXRgHeLDDQOBqN0gauO4Vb4N0QsgggpCuAWIvUEEpYX4EBBBs3oibroQW8vyUcA6ug20tSSFp8XG7QljyAyuXIWexyggbdJaaklRXe2XF0pxHY02oO+JnGTRXkyyumP/dqO/YIQ6Gj51tRsnP7/Lf6nRn5f9YEOzrqrNeIvGPlzdZFV+qqqxqi+xc/nx8IogX1xVCnaWDNDkdO25troXjfOTk5VZPJOpWF0fOS7198x2czm0XTT33jArlhOcxOvIis0LKmfFTsrfkOXzlhpR1NJEIzZgEItqaAzik43foUkRJlH7n2rC6PZYHNcHzsaMa5h6OhWRj+5IbN9Gm42m11Pfd1PNPhIjhTv/8d+5svyjiN0oFF27I4UqmfrEGePuEN2c0c0tZNbKenJpf2mi2/3UuIxGQZNRsmpT6KaBVdNDLxp4qwZnLlQk9pccO5EXRl2fjALmapKni8MzKpnMu6OPylrX86SLeLhJ0KjyOH/U36selrFKv4WO8dkWPNslvkBqyd/bx5jnaztwQu0Cn6cD9lU4y/PI20x6dlANJ69WE1TBYTjCZi1H2Khq/SY7J6g5jOSe3D6Kr5Lw+hln0QksOi6JC2DRcbAjBIuOG+jGhUXHqkdZ6YJaTKwaGN9yegOcfdV5am777KtWbn/EI4Q3Qb/hjT/44P6MEPjgdXRju4lI5hV7YZGAGrAbufOIg6HUTtt8GPdNn/zS0Ekd4zSt+vIWHFRHEIfCY/CogAg6ACFApxGBqBuMWe4gZgFEUDwIsgCxH4igtBAVAiJoVlfFTfZKyG9DIQr68bEaEPuBCIaiC+K7wRVABESwMgMTh3kCIIIpGJg4HGdUE68HZOqwDI4z6qq+70Z/wQh1NEDpajeaZhY1yVU1TThaTCiu1E+TgmuWHb142/ggoU1mvppkMFsXBxZmoZv98RVunXy+OLBoECU+J+lv1jW5s2/Tl9KFRuvEUuecRwhfIy99bh1Ys8T1iLBODp0DK+HkQ/6riBPy7eLbLw==
```

# Changelog

## version 2.7.6

Potentially made the compactor a lot more precise.

Replaced string concatenation with table.concat operations.<br>
Added an error handling function that detects if there's an error and displays it.<br>
Reduced the length of the compactors lines to fit in the guide for size.

## version 2.7.5

Watercat is no longer an infinite loop.<br>
Const values are now done through macros defined in the compactor.<br>
Remade the entire compactor manual.

Macro `recorded_secures` is now called `recorded_security`.<br>
Macro `disabled_era` is now called `disable_era`.<br>
`BP.used_space.active` is now called `BP.used_space.blueprint`.<br>
`BP.comp.active` is now called `BP.comp.spell`.

Added `BP.comp.module` which holds the module ID's you want to secure.<br>
`BP.comp.secure` now holds the space in the recording when you call `recorded_security`.<br>
Overhauled error handling system to now be done via the string when large assert() sequences are used.<br>
Added basic error handling to the entirety of the compactor.<br>
Added timer_base to the list of logged values.<br>
`BP.comp.concat_actives` has been modified to be easier to update and maintain.

## version 2.7.4

Moved the ingame compactor to the root README.<br>
Made the unofficial winAI4 script work.<br>
Re-worked this README.md to be easier to understand.<br>
Discord post is on hold until I get feedback on this README.md

## version 2.7.3

Made the last tweeks to the compactor.<br>
The user can now soft-stop the compactor by directly changing the caller_ID to the const string idle_mode.<br>
Replaced the Spell Compactor discord post with the Blueprint Compactors.<br>
Fixed typos in the watercat and easy eracat macros.<br>
Updated and fixed all warnings from the lua version of the compactor.

## version 2.7.2

Removed To Be Done<br>
The user can now define a base for their timer.<br>
The compactor can now also secure modules durring towertesting.<be>
Added watercat and easy eracat macros.

## version 2.6.0

Added a To Be Done<br>
At this stage, I'm never going to be able to get any work done with it.

Modified recorded_blueprint to also save the ammount of space used in the recording to a global table Spell.comp.blueprint. This way, the user can retrieve this value dynamically in lua code, and, as shuch, does not need to manually change the value after modifying the blueprint.

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
