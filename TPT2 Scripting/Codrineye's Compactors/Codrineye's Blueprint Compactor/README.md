# Codrineye's Blueprint Compactor

The blueprint compactor is a library for the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) that helps you define what you want your blueprint AI to do.

To better understand how to use the compactor, head over to the [Compactor Manual](Compactor%20manual.md) for an explanation of each function.

## The source import

This is the import you need to be able to use the configuration scripts.<br>
As this is the source, you must use this code in the [external editor](https://d0sboots.github.io/perfect-tower/).

If you want to look through this import, the library file will return an import error if you haven't imported [Editor_actions lib](../../Editor%20Actions%20lib/README.md).

```
{"workspaces":{"Codrineye's Blueprint Compactor":[["Cods Blueprint Compactor","\n{lua(\\\n  BP = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  BP.debug = {};\\\n  BP.debug.can_log = false;\\\n  BP.debug.can_halt = false;\\\n  BP.debug.halt_limit = 0;\\\n  BP.debug.can_display = false;\\\n  BP.debug.concat_format = \"\";\\\n  \\\n  --[[Table keeping track of how much space we're using up]]\\\n  BP.used_space = {};\\\n  BP.used_space.secure = 0;\\\n  BP.used_space.blueprint = 0;\\\n  \\\n  --[[Keep track of how many modules we have left to synchronize]]\\\n  BP.sync_ammount = 0;\\\n  \\\n  --[[Table that has compactor specific data]]\\\n  BP.comp = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  BP.comp.software = {};\\\n  --[[Store the era elements priority order]]\\\n  BP.comp.era = {};\\\n  \\\n  --[[Store the modules we want to secure]]\\\n  BP.comp.module = {};\\\n  BP.comp.secure = {};\\\n  \\\n  --[[Blueprint activation]]\\\n  BP.comp.spell = {};\\\n  BP.comp.blueprint = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(BP.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  BP.debug.can_display = true;\\\n  BP.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(BP.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  BP.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  BP.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  BP.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  BP.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local bp_debug_stop = false;\\\n  \\\n  --[[/*\\\n      * Empty table that replaces the need\\\n      * for repetitive assert sequences\\\n      * \\\n      * Adding to a table and concatenating it is more efficient\\\n      * than ordinairy string concatenation\\\n     */]]\\\n  local err_msg = {};\\\n  \\\n  --[[Function to more easily handle error messages]]\\\n  function BP.debug.detect_error()\\\n    --[[Check if there's an error message to send]]\\\n    if err_msg[1] ~= nil then\\\n      error(table.concat(err_msg, 0));\\\n      --[[/*\\\n          * If there is send just the message,\\\n          * the 0 ignores the call context since this context is\\\n          * just illegible lua code\\\n         */]]\\\n    end\\\n  end\\\n  \\\n  --[[/*\\\n      * WaterCat implementation\\\n      * Set a list of software names and then\\\n      * a security level to each software.\\\n      * \\\n      * If the security level decided by the user\\\n      * is smaller or = to the level given to the software\\\n      * that software gets toggled on, othwerise, it's off\\\n     */]]\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  for _, soft in ipairs(software_list) do\\\n    BP.comp.software[soft] = -50;\\\n  end\\\n  \\\n  function BP.comp.add_software(software, level)\\\n    --[[get direct access to the software we recognize]]\\\n    local soft = BP.comp.software;\\\n    \\\n    --[[get the security level from the macro call]]\\\n    local sec = level:match([[%b\"\"]]):sub(2, -2):gsub(\" \", \"\");\\\n    \\\n    if soft[software] == nil then\\\n      err_msg = table.pack(\\\n        \"Attempt to assign a security level to \",\\\n        \"an unrecognized software\\n\",\\\n        \"If this is a new software, an update to the compactor \",\\\n        \"should be released soon\"\\\n      );\\\n    elseif soft[software] ~= -50 then\\\n      --[[/*\\\n          * Smallest security level I've seen is -1, \\\n          * so -50 should never be assigned naturally\\\n         */]]\\\n      err_msg = table.pack(\\\n        \"Trying to assign a security level to an \",\\\n        \"already set software\"\\\n      );\\\n    elseif tonumber(sec) == nil then\\\n      err_msg[1] = \"Trying to assing a non-numeric security level\";\\\n    elseif math.type(tonumber(sec)) ~= \"integer\" then\\\n      err_msg[1] = \"Trying to assign a non-integer security level\";\\\n    end\\\n    \\\n    --[[Detect if we have an error and send it if we do]]\\\n    BP.debug.detect_error();\\\n    \\\n    --[[create the software ID]]\\\n    local software_name = string.format(\"software.%s\", software);\\\n    \\\n    --[[/*\\\n        * get the extra space we need to fill out\\\n        * such that the string in sec has as many characters\\\n        * as the software ID does\\\n       */]]\\\n    local lvl = string.format(\"%%-%ss\", #software_name);\\\n    BP.comp.software[software] = lvl:format(sec);\\\n  end\\\n  \\\n  function BP.comp.concat_software(concat_mode)\\\n    local modes = {};\\\n    modes.software_list = true;\\\n    modes.software_secure = true;\\\n    modes.software_len = true;\\\n    \\\n    if not modes[concat_mode] then\\\n      err_msg = table.pack(\\\n        \"Invalid concat_mode.\\n\",\\\n        \"If you're seeing this:\\n\",\\\n        \"- You're either a user that messed with something \",\\\n        \"you shouldn't have\\n\",\\\n        \"- Or you're a user that did nothing wrong and \",\\\n        \"I messed something up and didn't propperly bug test\"\\\n      );\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local software = {};\\\n    local software_len = 0;\\\n    \\\n    for _, soft in ipairs(software_list) do\\\n      local concat_val = {};\\\n      if concat_mode == [[software_len]] then\\\n        software_len = software_len + 9 + #soft;\\\n      else\\\n        if concat_mode == [[software_list]] then\\\n          concat_val[1] = \"software.\";\\\n          concat_val[2] = soft;\\\n        else\\\n          concat_val[1] = BP.comp.software[soft];\\\n        end\\\n        software[1 + #software] = table.concat(concat_val);\\\n        software[1 + #software] = \"|\"\\\n      end\\\n    end\\\n    if software_len > 0 then\\\n      return software_len - 5;\\\n    end\\\n    return string.format([[\"%s\"]], table.concat(software));\\\n  end\\\n  \\\n  --[[/*\\\n      * Easy Era cat\\\n      * Set a priority level for all the era elements\\\n      * you want to disable.\\\n      * Create a ternary string that makes sure the\\\n      * element of priority 1 gets disabled before priority 2\\\n      * and so on...\\\n      * Create an arithmetic.double that checks if the sum\\\n      * of disabling all those elements is == -#BP.comp.era\\\n     */]]\\\n  \\\n  function BP.comp.set_priority(element_name)\\\n    local elems = BP.comp.era;\\\n    local name = tostring(element_name);\\\n    --[[don't overwrite the priority level of elements]]\\\n    if elems[name] then return; end\\\n    \\\n    elems[1 + #elems] = string.format([[\"%s\"]], name);\\\n    elems[name] = #elems;\\\n  end\\\n  \\\n  function BP.comp.disable_era()\\\n    assert(\\\n      BP.comp.era[1], \\\n      \"Cannot call disable.era without using set_priority macro first\"\\\n    );\\\n    local elems = BP.comp.era;\\\n    local era = table.pack(elems[#elems]);\\\n    for i = #elems - 1, 1, -1 do\\\n      era = table.pack(\"if(\", \\\n        \"disable.cost(\", elems[i], \") != -1.0, \",\\\n        elems[i], \", \",\\\n        table.concat(era),\\\n      \")\");\\\n    end\\\n    return table.concat(era);\\\n  end\\\n  \\\n  function BP.comp.era_to_disable()\\\n    local elems = BP.comp.era;\\\n    local negative_elems = 0.0 - #elems;\\\n    local era = table.pack(\"disable.cost(\", elems[#elems], \")\");\\\n    for i = #elems - 1, 1, -1 do\\\n      era = table.pack(\\\n        \"disable.cost(\", elems[i], \")\",\\\n        \" + \",\\\n        table.concat(era)\\\n      );\\\n    end\\\n    era = table.pack(negative_elems, \" != \", table.concat(era));\\\n    return table.concat(era);\\\n  end\\\n  \\\n  function BP.comp.recorded_secures(blueprint_name)\\\n    if #BP.comp.module == 0 then\\\n      --[[Check if there are any modules to secure]]\\\n      err_msg = table.pack(\\\n        \"Cannot define a recorded security sequence if you haven't \",\\\n        \"added modules to secure\"\\\n      );\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local space = BP.used_space.secure;\\\n    BP.comp.secure[blueprint_name] = space;\\\n    --[[give the user access to the updated data]]\\\n    \\\n    local const = table.pack(\\\n      \":const int secures_\",\\\n      blueprint_name, \" \", space\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.add_secure(module_name)\\\n    local secures_idx = 1 + #BP.comp.module;\\\n    local secure_name = table.pack(module_name:gsub(\" \", \"\"), \"|\");\\\n    \\\n    BP.comp.module[secures_idx] = table.concat(secure_name);\\\n    local space = #table.concat(secure_name);\\\n    BP.used_space.secure = space + BP.used_space.secure;\\\n    \\\n    local const = table.pack(\\\n      \":const in secure_module.\",\\\n      secures_idx, \" \", BP.used_space.secure\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local spell_index = #BP.comp.spell;\\\n      BP.comp.spell[spell_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that\\\n          * the compactor knows to loop\\\n         */]]\\\n    end\\\n    \\\n    local space = BP.used_space.blueprint;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    \\\n    local bp_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    \\\n    BP.comp.blueprint[bp_name] = space;\\\n    --[[/*\\\n        * add an instance to the table so that this value\\\n        * can be accessed in lua\\\n       */]]\\\n    \\\n    local const = table.pack(\\\n      \":const int blueprint_\",\\\n      bp_name, \" \", space\\\n    );\\\n    return table.concat(const);\\\n  end\\\n  \\\n  function BP.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local spell = BP.comp.spell[#BP.comp.spell];\\\n    if spell == nil then\\\n      err_msg[1] = table.pack(\"Trying to add a timer_base\", \\\n        \"without any recorded spells\");\\\n    elseif tonumber(defined_base) == nil then\\\n      err_msg[1] = \"Trying to define a timer_base as a non number\";\\\n    elseif math.type(tonumber(defined_base)) ~= \"float\" then\\\n      err_msg[1] = \"Trying to define a timer_base as a non double\";\\\n    end\\\n    BP.debug.detect_error()\\\n    \\\n    local base_val = tonumber(defined_base);\\\n    local base_fmt = table.pack(base_val, \"|\");\\\n    spell.timer_base = table.concat(base_fmt);\\\n    \\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    BP.used_space.blueprint = BP.used_space.blueprint - space;\\\n    --[[We also have to update the total ammount of space being used]]\\\n    \\\n    space = space + #spell.timer_base - 1 - #spell.space;\\\n    --[[/*\\\n        * Since spell.timer_base originally had a value of `|`\\\n        * space already includes this 1 character. To get an\\\n        * accurate reading, we must subtract this 1.\\\n       */]]\\\n    \\\n    local used_space = space;\\\n    local prev_space = -1;\\\n    while used_space ~= prev_space do\\\n      prev_space = used_space;\\\n      local value = table.pack(used_space, \"|\");\\\n      spell.space = table.concat(value);\\\n      used_space = space + #spell.space;\\\n      --[[We loop until we're not adding any extra space]]\\\n    end\\\n    --[[And we can end by adding the new used space to the total]]\\\n    BP.used_space.blueprint = BP.used_space.blueprint + used_space;\\\n  end\\\n  \\\n  function BP.comp.sync(spell_ammount)\\\n    --[[Perform basic error handling on the parameter]]\\\n    if tonumber(spell_ammount) == nil then\\\n      err_msg[1] = \"Trying to add a non-number as a sync ammount\";\\\n    elseif tonumber(spell_ammount) <= 0 then\\\n      err_msg[1] = \"Trying to add a sync ammount that's less than 1\";\\\n    end\\\n    BP.debug.detect_error();\\\n    --[[/*\\\n        * The sync system prevents the compactor from refreshing its\\\n        * execution budget until all synchronized modules have been used\\\n        * \\\n        * We subtract the ammount of spells that are synchronized by 1\\\n        * so that the final synchronized spell refreshes the budget\\\n       */]]\\\n    BP.sync_ammount = tonumber(spell_ammount) - 1;\\\n    --[[sync_ammount always gets overwritten]]\\\n  end\\\n  \\\n  function BP.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local halt_limit = BP.debug.halt_limit == 0 and BP.debug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our \"halt limit\" has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or bp_debug_stop then BP.debug.halt() end\\\n    \\\n    local active_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    if active_name == \"\" then\\\n      error(\"Trying to add a spell with an empty ID\", 0);\\\n    end\\\n    local actives_index = 1 + #BP.comp.spell;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * so that we loop the activation sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    if BP.sync_ammount > 0 then\\\n      new_spell.sync = \"s\";\\\n      BP.sync_ammount = BP.sync_ammount - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the execution budget]]\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      if value == nil then\\\n        err_msg = table.pack(\"Trying to add a non-number \", variable);\\\n      elseif math.type(value) ~= \"float\" then\\\n        err_msg = table.pack(\"Trying to add a non-double \", variable);\\\n      end\\\n      BP.debug.detect_error();\\\n      \\\n      new_spell[variable] = value;\\\n    end\\\n    new_spell.name = active_name\\\n    spell_values[4] = \"name\";\\\n    \\\n    for _, variable in ipairs(spell_values) do\\\n      local value = table.pack(new_spell[variable], \"|\");\\\n      new_spell[variable] = table.concat(value);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * We use spell_fmt to include the ending character\\\n          * This ending character is used in an editor index()\\\n          * in order to isolate the value we need\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      local value = table.pack(used_space, \"|\");\\\n      new_spell.space = table.concat(value);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[Add the extra space taken up by our space size marker]]\\\n    \\\n    BP.comp.spell[actives_index] = new_spell;\\\n    BP.used_space.blueprint = BP.used_space.blueprint + used_space;\\\n    \\\n    \\\n    --[[Check if we have to log the added data]]\\\n    local logging_check = BP.debug.can_halt or BP.debug.can_log;\\\n    if logging_check then BP.debug.log() end\\\n    \\\n    --[[If we can halt, decrement our halting limit by 1]]\\\n    if BP.debug.can_halt then\\\n      BP.debug.halt_limit = BP.debug.halt_limit - 1;\\\n    end\\\n    \\\n    local const = table.pack(\\\n      \":const int spell_\", \\\n      actives_index, \" \", BP.used_space.blueprint\\\n    );\\\n    return table.concat(const);\\\n    --[[/*\\\n        * Return a const int that has\\\n        * the ammount of space it took to add this spell\\\n       */]]\\\n  end\\\n  \\\n  function BP.comp.concat_actives()\\\n    local actives = {};\\\n    \\\n    local spells = BP.comp.spell;\\\n    --[[table holding the compacted data]]\\\n    local spells_count = #spells;\\\n    --[[number of spells recorded]]\\\n    \\\n    local concat_debug = {};\\\n    if BP.debug.can_display then\\\n      local fmt = BP.debug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    else\\\n      concat_debug.format = \"\";\\\n      concat_debug.separation = \"\";\\\n      concat_debug.bit_format = \"%s\";\\\n      concat_debug.spell_data = \"%s\";\\\n    end\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    for i = 1, spells_count do\\\n      --[[/*\\\n          * spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data = spells[i];\\\n      local data_pack = {};\\\n      local data_names = table.pack(\\\n        \"loop_bit\", \"sync_bit\",\\\n        \"base\", \"space\", \"timer\",\\\n        \"coord_x\", \"coord_y\",\\\n        \"name\"\\\n      );\\\n      local data_set = {};\\\n      local idx = 1;\\\n      if BP.debug.can_display then\\\n        --[[Sets the data_set for the case where we can display]]\\\n        data_set = table.pack(\"loop_sign\", \"sync\");\\\n        for _, set in ipairs(data_set) do\\\n          local name = data_names[idx];\\\n          data_pack[name] = table.pack(\\\n            name:gsub(\"_bit\", \"\"),\\\n            --[[removes the _bit from the name]]\\\n            data[set]\\\n          );\\\n          idx = idx + 1;\\\n        end\\\n        data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        \\\n        data_set = table.pack(\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      else\\\n        --[[Sets the data_set for the case where we can't display]]\\\n        data_pack.chunk_end = \"\";\\\n        data_set = table.pack(\\\n          \"loop_sign\", \"sync\",\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      end\\\n      for _, set in ipairs(data_set) do\\\n        local name = data_names[idx];\\\n        data_pack[name] = table.pack(\\\n          data[set], set, \\\n          #data[set]\\\n        );\\\n        idx = idx + 1;\\\n      end\\\n      \\\n      actives[1 + #actives] = concat_debug.format;\\\n      for _, name in ipairs(data_names) do\\\n        local spell_data = data_pack[name];\\\n        local fmt = \"\";\\\n        --[[Determine the format we're using]]\\\n        if name:match(\"_bit\") == \"_bit\" then\\\n          fmt = concat_debug.bit_format;\\\n        else\\\n          fmt = concat_debug.spell_data;\\\n        end\\\n        actives[1 + #actives] = fmt:format(table.unpack(spell_data));\\\n      end\\\n      actives[1 + #actives] = concat_debug.format;\\\n      actives[1 + #actives] = data_pack.chunk_end;\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(actives));\\\n  end\\\n  \\\n  \\\n  function BP.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from BP.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local spell_index = #BP.comp.spell;\\\n    local spell = BP.comp.spell[spell_index];\\\n    local logging_text = table.pack(\\\n      \"%s| BP has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"timer_base\",\\\n      \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 8;\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value];\\\n      if spell_value == nil then\\\n        err_msg = \"Cannot log nil value \" .. value;\\\n        error(err_msg);\\\n      end\\\n      local fmt = table.pack(log, value, spell_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, spell_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function BP.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * BP.comp.add_spell\\\n        * * BP Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local should_halt = BP.debug.can_halt or BP.debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if BP.debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if BP.debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #BP.comp.spell,\\\n        \" \"\\\n      );\\\n      if #BP.comp.spell == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = BP.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; Separated in \"chapters\"\n; \n\n; The Spell Compactor\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return BP.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; Define a base for the timer\n#timer_modulo(modulo) {lua(BP.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(BP.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return BP.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n; Adds a useinstant() spell\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0.0, \\\n  0.0\\\n)}\n\n; Adds a useposition() spell\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n; Concatenates the actives and returns the total recording space\n#recorded_actives {lua(return BP.comp.concat_actives())}\n#recording_size {lua(return BP.used_space.blueprint)}\n\n; Secure Compactor\n; Defines a security sequence\n#recorded_security(secure_name) {lua(\\\n  return BP.comp.recorded_secures([[{secure_name}]])\\\n)}\n; Defines a module to secure\n#add_secure(secure_name) {lua(BP.comp.add_secure([[{secure_name}]]))}\n; \n; Concatenates the secures and returns the total recording space\n#recorded_secures \"{lua(return table.concat(BP.comp.module))}\"\n#secures_space {lua(return BP.used_space.secure)}\n\n; EasyEra cat\n; Assigns a priority to an element\n#set_priority(element) {lua(\\\n  return BP.comp.set_priority([[{element}]])\\\n)}\n; Returns a ternary: string to that's placed in disable.era\n#disable.era {lua(return BP.comp.disable_era())}\n; Returns a bool to know if all elements we wanted to disable\n; got disabled\n#disable_era {lua(return BP.comp.era_to_disable())}\n; \n; Watercat\n; Reset the watercat index\n#watercat_index_reset watercat = 0\n; \n; Generalized substring used in watercat\n#watercat_sub(list) sub(\\\n  {list}, \\\n  watercat, \\\n  index({list}, \"|\", watercat) - watercat\\\n)\n; Line 1 that toggles the software\n#watercat_line1(secure_level) software_toggle_loop:\\\nsoftware.toggle(\\\n  {watercat_sub(software_list)},\\\n  {secure_level} <= s2i({watercat_sub(software_secure)}, -1)\\\n)\n; line 2 that increments watercat\n#watercat_line2 watercat = 1 + index(software_list, \"|\", watercat)\n; line 3 that creates a while loops\n#watercat_line3 gotoif(software_toggle_loop, watercat < software_len)\n; \n; Concat the software levels\n#software.concat(concat_mode) {lua(\\\n  return BP.comp.concat_software([[{concat_mode}]])\\\n)}\n\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n#software.secure(software_name, level) {lua(\\\n  BP.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}\n"],["Blueprint Compactor resources","\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#bp_comp BP Comp\n#blueprint_package(name) {bp_comp}:{name}\n#tower_handler {blueprint_package(Tower Handler)}\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{bp_comp} Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string checkpoint_var \"{bp_comp} Pointer Checkpoint\"\n#checkpoint.get global.int.get(checkpoint_var)\n#checkpoint.set(value) global.int.set(checkpoint_var, {value})\n; \n:const string compactor_actives \"{bp_comp} access actives str\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{bp_comp} access secures str\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_secures, {str})\n; \n:const string caller_ID \"{hider.close}{bp_comp} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n\n#idle_mode_str {hider.start}:{hider.close}\n; \n; this is a special string that makes it impossible\n; for a caller script to trigger this value.\n; \n:const string idle_mode \"{idle_mode_str}idle mode\"\n; This string is used by the compactor to detect if entered idle mode\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n"],["Blueprint Compactor lib",":import Blueprint Compactor resources\n#package(name) {blueprint_package({name})}\n\n:local int pointer\n:local int checkpoint\n:local string actives\n:local string secures\n; \n:local bool det_timer_base\n:local double timer_base\n:local double clock\n; \n:local string spell_ID\n; \n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[actives]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, pointer, 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  contains({get_bits}, \"#\"), \\\n  checkpoint, \\\n  pointer + {get_space}\\\n)\n\n; \n#modulo_timer {timer.get} % timer_base\n"],["Time Stopper",":import Blueprint Compactor lib\n:name {package(Time Stopper)}\n:budget_cap 200\n\ngame.newround()\nkey.x()\n\n; advance a frame if the compactor is activated\ngotoif(advance_frame, contains(impulse(), \"key.x\"))\n\nmain:\n; Prevents a clunky user interface.\nglobal.unset(timer_var)\n\n; Since the sequences we send are empty, the pointer offset\n; is only used for the second instance run by game.newround()\n; to pause the game.\n{pointer.set(0)}\n{comp_active.set(\"\")}\n{comp_secure.set(\"\")}\n\n; start our compactor so we can configure our timings.\nexecute(\"{tower_handler}\")\n\nwaitwhile({timer.get} <= 0.0)\n; We must ensure that the compactor successfully initialized\n; otherwise, we'd be too fast and check if there's any enemies\n; before the game had time to spawn any in\n\npause()\n; we can now pause the game\n\nwaitwhile(health(false) > 0.0 && enemies() > 0)\n; Stop the compactor if we're dead.\n; \n; Usually, I'd prefer we do {caller.set(idle_mode)}, as\n; that safely terminates all instances of the tower handler,\n; but instead, we have to both mark the time of death but to also\n; ensure that, when we unset timer_var, there's not an actively\n; running ticker that makes {timer.get} != 0.0\nstop(\"{tower_handler}\")\n\nadvance_frame:\n; make sure that we don't pause the game before the timer is initialized\nwaitwhile({timer.get} <= 0.0)\n\n; unpause the game to let a frame go by\nunpause()\n\n; pause the game\n; this is how we do frame-by-frame advancing\npause()\n"],["Debugger",":import Blueprint Compactor lib\n:name {package(Debugger)}\n:budget_cap 101\n\n; The debugger attatchment to the\n; core blueprint compactor\n; \n; It's used to go through the data you sent\n; to the tower handler for execution\n\nkey.x()\n\n:global string spell_chunk\n; \n:global string loop_bit\n:global string sync_bit\n; \n:global string spell_size\n:global string spell_timer\n; \n:global string coord_x\n:global string coord_y\n; \n:global string spell_name\n\n#get_val(val) {lua(return Compactor.{val})}\n\nstop(\"{tower_handler}\")\n; Stop all instances of the tower handler\n\npointer = {pointer.get}\ncheckpoint = {checkpoint.get}\nactives = {comp_active.get}\nsecures = {comp_secure.get}\n; initialize our variables\n\n{pointer.set(pointer)}\n{checkpoint.set(checkpoint)}\n{comp_active.set(actives)}\n{comp_secure.set(secures)}\n{caller.set(\"debuging\")}\n; Start and end the block hider\n\nglobal.int.set(\"pointer\", pointer)\nglobal.int.set(\"loop checkpoint\", checkpoint)\n\nspell_chunk = sub(actives, pointer, {get_space})\n; Get the spell chunk, aka, the spell that\n; the pointer is pointing at\n; \nloop_bit = sub(actives, pointer, 1)\nsync_bit = sub(actives, pointer + 1, 1)\n; Show the bits so the user can know what they mean, this is\n; likely unnecesairy as they probably already know what it means\n; but for now, while nobody knows what the compactor even is,\n; this data stays visible\n; \nglobal.string.set(\"timer_base\", {get_val(timer_base)})\nspell_size = {get_val(space)}\n; \nspell_timer = {get_val(timer)}\ncoord_x = {get_val(coord_x)}\ncoord_y = {get_val(coord_y)}\nspell_name = {get_val(name)}\n; \n; Increment our pointer to point to the next spell\n{pointer.increment}\n; Save it to our global pointer\n{pointer.set(pointer)}\n; \nglobal.string.set(\"secures\", \"<br>\" . secures)\n; Show the secures as well, this should be a short string\n"],["Tower Handler",":import Blueprint Compactor lib\n:name {tower_handler}\n:budget_cap max\n\n; detect if the handler is in idle_mode\n#idle_mode contains(idle_mode, {caller.get})\n\nexecute(\"{package(Debugger)}\")\n; To support debugging, you enable the script called \"Debugger\"\n; once it executes, it will stop all instance of the tower handler\n; \ngotoif(\\\n  if({timer.get} == 0.0, start_timer, start_secures), \\\n  contains(impulse(), \"{tower_handler}\")\\\n)\n; The handler is in charge of spell activations and module secures\n; Because spell activations need a timer, there will always be 1 instance\n; running that is in charge of keeping the timer updated\n; \n; If we pass the gotoif(), we're in charge of casting spells\n; we are not the instance that's keeping the timer as doing so\n; would prevent people from using executesync(\"{tower_handler}\")\n; \n\n; We use local variables to prevent a messy interface\n; And to let the user have more instances running at once\n; \npointer = {pointer.get}\n; Potential offset when executing spells.\n\ncheckpoint = {checkpoint.get}\n; Point at which we return on looping spells\nactives = {comp_active.get}\n; Our list of spells to execute\n\n{comp_secure.set({comp_secure.get})}\n; makes sure that the secures string is included in the block hider\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We stop the block hider started by {pointer.set()}\n; by setting the caller. This is also used so that\n; the user knows who accessed the tower hander\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{tower_handler}\")\n; We now make a copy of ourselves.\n; This is how we start securing modules\n; If there is no timer yet, this will first\n; initialize the timer which starts securing modules\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; {get_base} returns utcnow() if we didn't find a base.\n; Thanks to the budget, the value returned by utcnow()\n; will be the same until we let a frame pass\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; We loop for as long as our actives still holds\n; at least 1 spell to activate\n; \n; If this is a loopable blueprint, we can be in\n; the loop when pointer == checkpoint more than once. If we've \n; looped over and have determined the timer base, we must\n; wait for our modulo_timer to reset back to 0.0\n\nclock = if(\\\n  pointer == checkpoint && det_timer_base, \\\n  1.0 + floor({timer.get} / timer_base), \\\n  0.0\\\n)\n\n; Here, we make sure that execution is halted until\n; {modulo_timer} is reset to 0.0 or until we enter idle_mode\nwaituntil({timer.get} >= timer_base * clock || {idle_mode})\n\n; Since the modules clock is used in the waitwhile,\n; we calculate the value here to save on processing\nclock = {get_timer}\n\n; we lock up the handler until it's time to use a spell\n; we stop waiting if we've entered idle mode to safely shut down\nwaituntil({modulo_timer} >= clock || {idle_mode})\n\n; Prevent activating a spell if we're in idle mode\nspell_ID = if({idle_mode}, \"\", {get_name})\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell or set it to 0 if\n; we must loop over. \n\n#end_of_compactor -1 == index(actives, \"|\", pointer)\n; if we can't find the separation character `|` in our string at\n; offset pointer, we've successfully cleared our activation sequence\n; and can safely exit.\n; If index can't find the character, it returns -1\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  end,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n{comp_secure.set(\"\")}\n; Clear the secure field to not over-populate the active scripts count.\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n; try to disable the module we're pointing at\n\n; Skip waiting a frame if we have enough xp to secure another module\ngotoif(secures_no_frame, disable.inf.cost() <= xp())\nwaitframe()\n\nsecures_no_frame:\n; increment our pointer only if we managed to secure a module\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\n; increment our disable.inf.cost() indicator only if\n; our indicator has become out of date\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n; or if we've entered idle_mode\n\nstart_timer:\n{timer.set(time.delta())}\nexecute(\"{tower_handler}\")\n; We must create another instance of ourselves\n; to start securing modules\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngotoif(timer, {caller.get} != idle_mode)\n; The timer will be incremented until one of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; This would make it so that the user never actually needs to start\n; their script with global.unset(timer_var), but I'm honnestly not sure\n; why it doesn't get set to 0.0\n\nidle:\n{caller.set(idle_mode)}\n\nend_instance:\n"]]}}
```

# Developer package

This package includes the [Debugger](Debugger.tpt2) and [Time Stopper](Time%20Stopper.tpt2) scripts along with the ordinairy [Tower Handler](Tower%20Handler.tpt2) that you can chose to import, but it's the same as in the non-developer package import.

## Requirements

- impulses: 2
- conditions: 0
- actions: 37
- scripts: 3
- min budget: 200

```
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
```

## Debugger

The debugger is activated by the tower handler, to enable debugging you just have to enable this script.<br>
This script will stop the tower handler and is used to analyze what it is you're sending to the compactor.

You go through your spells by pressing `key.x`.

You will be shown the following values through the medium of global strings:
- `pointer`: the value that's used to determine what spell is being processed.
- `loop checkpoint`: if your blueprint has the loop bit enabled, the `pointer` will get this value once it must loop.
- `spell chunk`: is the entire string that reprezents your spell.
- `loop bit`: the state of your loop bit, it can either be `/` for nothing happens or `#` for looping.
- `sync bit`: the state of your sync bit, it can either be `/` for nothing happens or `s` for synchronizing.
- `timer base`: what's the largest value the timer can have before it's considered 0 by the `spell timer`.
- `spell size`: the number that gets added to the `pointer` to move to the next spell
- `spell timer`: at what value t must be for your spell to be activated.
- `coord_x/y`: the x/y coordinates for your grounded spell.
- `spell name`: the spells ID used to determine the active index of your spell.
- `secures`: what modules you want to secure.

## Time Stopper

The time stopper is used to plan out your spell activations with a high ammount of precision by letting you go frame by frame through towertesting.

Once activated, it will execute an instance of the Tower Handler to start the timer and pause towertesting on the frame it gets initialized. You then use key.x to advance the game by 1 frame. You are also able to use this tool in conjunction with another compacted blueprint to better understand what is happening on a frame of spell execution.

# Changelog

## version 2.8.0

- Converted the compactor into a utility package.
- Included the Debugger and Time Stopper utility tools in the package
- Added checkpoint system to the compactor that lets you determine what value the pointer should be reset to once it reaches the end of a loopable blueprint.

## version 2.7.7

I can now confirm that the change did make the compactor a lot more precise.

- Added a helper script [Compactor timer](#time-stopper).

## version 2.7.6

Potentially made the compactor a lot more precise.

Replaced string concatenation with table.concat operations.<br>
Added an error handling function that detects if there's an error and displays it.<br>
Reduced the length of the compactors lines to fit in the guide for size.

## version 2.7.5

Watercat is no longer an infinite loop.<br>
Const values are now done through macros defined in the compactor.<br>
Remade the entire compactor manual.

Macro `recorded_secures` is now called `recorded_security`.<br>
Macro `disabled_era` is now called `disable_era`.<br>
`BP.used_space.active` is now called `BP.used_space.blueprint`.<br>
`BP.comp.active` is now called `BP.comp.spell`.

Added `BP.comp.module` which holds the module ID's you want to secure.<br>
`BP.comp.secure` now holds the space in the recording when you call `recorded_security`.<br>
Overhauled error handling system to now be done via the string when large assert() sequences are used.<br>
Added basic error handling to the entirety of the compactor.<br>
Added timer_base to the list of logged values.<br>
`BP.comp.concat_actives` has been modified to be easier to update and maintain.

## version 2.7.4

Moved the ingame compactor to the root README.<br>
Made the unofficial winAI4 script work.<br>
Re-worked this README.md to be easier to understand.<br>
Discord post is on hold until I get feedback on this README.md

## version 2.7.3

Made the last tweeks to the compactor.<br>
The user can now soft-stop the compactor by directly changing the caller_ID to the const string idle_mode.<br>
Replaced the Spell Compactor discord post with the Blueprint Compactors.<br>
Fixed typos in the watercat and easy eracat macros.<br>
Updated and fixed all warnings from the lua version of the compactor.

## version 2.7.2

Removed To Be Done<br>
The user can now define a base for their timer.<br>
The compactor can now also secure modules durring towertesting.<be>
Added watercat and easy eracat macros.

## version 2.6.0

Added a To Be Done<br>
At this stage, I'm never going to be able to get any work done with it.

Modified recorded_blueprint to also save the ammount of space used in the recording to a global table Spell.comp.blueprint. This way, the user can retrieve this value dynamically in lua code, and, as shuch, does not need to manually change the value after modifying the blueprint.

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
