# Codrineye's Blueprint Compactor

The blueprint compactor is a library of a multitude of macros that will simplify the creation of an AI for your specific blueprint.<br>
It capable of recording module activation sequences, recording a security sequence that prevents infinity enemies from copying them, software configuration and era disables.

## The import packages

The compactor has 2 types of imports, a source import and a game import

The game import will likely be moved to the [root TPT2 Scripting README](/TPT2%20Scripting/README.md), but for the time being, there's still work to be done.

## The source import

The source import is a code you import inside the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/). This import is required for the editor to use the compactor in the first place. If you get an error message when adding a Spell Config file, you likely have copies of the old spell compactors workspace, in which case I recommend deleting all workspaces and files that you have which are related to the spell compactor and re-importing the source.

This import contains the Compactor, its resource folder that's used to communicate with the game import of the compactor, the spell compactors library which uses [Editor_actions lib](/TPT2%20Scripting/Editor%20Actions%20lib/README.md) to create the substrings and 2 game compactor versions:

- [Blueprint Compactor](#blueprint-compactor)
- [Debugger Version](#spell-compactor-with-debugger)

You can get an explanation of how to use the compactor by heading over to its manual [Compactor manual](Compactor%20manual.md)

```
{"workspaces":{"Codrineye's Blueprint Compactor":[["Cods Blueprint Compactor","\n{lua(\\\n  BP = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  BP.debug = {};\\\n  BP.debug.can_log = false;\\\n  BP.debug.can_halt = false;\\\n  BP.debug.halt_limit = 0;\\\n  BP.debug.can_display = false;\\\n  BP.debug.concat_format = \"\";\\\n  \\\n  --[[Table that has data needed in compacting data]]\\\n  BP.used_space = {};\\\n  BP.used_space.secure = 0;\\\n  BP.used_space.active = 0;\\\n  \\\n  BP.sync_ammount = 0;\\\n  \\\n  --[[Table that has compactor specific data]]\\\n  BP.comp = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  \\\n  BP.comp.software = {}\\\n  --[[Store the module secures]]\\\n  BP.comp.secure = {};\\\n  \\\n  --[[Blueprint activation]]\\\n  BP.comp.active = {};\\\n  BP.comp.blueprint = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(BP.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  BP.debug.can_display = true;\\\n  BP.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(BP.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  BP.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  BP.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  BP.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  BP.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local bp_debug_stop = false;\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  for _, soft in ipairs(software_list) do\\\n    BP.comp.software[soft] = -50;\\\n  end\\\n  \\\n  function BP.comp.add_software(software, level)\\\n    local err_msg;\\\n    local soft = BP.comp.software;\\\n    local sec = level:match([[%b\"\"]]):sub(2, -2):gsub(\" \", \"\");\\\n    if soft[software] == nil then\\\n      err_msg = \"Attempt to assign a security level to an \"\\\n        .. \"unrecognized software\\n\" .. \"If this is a new \"\\\n        .. \"software, an update to the compactor should \"\\\n        .. \"be released soon\";\\\n    elseif soft[software] ~= -50 then\\\n      err_msg = \"Trying to assign a security level to \"\\\n        .. \"an already set software\";\\\n      --[[/*\\\n          * Smallest security level I've seen is -1, \\\n          * so -50 should never be assigned naturally\\\n         */]]\\\n    elseif tonumber(sec) == nil then\\\n      err_msg = \"Trying to assing an empty security level\";\\\n    elseif math.type(tonumber(sec)) ~= \"integer\" then\\\n      err_msg = \"Trying to assign a non-integer security level\";\\\n    end\\\n    \\\n    --[[Throw an error if we have an error message]]\\\n    if err_msg then error(err_msg, 0) end\\\n    \\\n    local software_name = string.format(\"software.%s\", software);\\\n    local lvl = string.rep(\" \", #software_name - #sec);\\\n    sec = string.format(\"%s%s\", sec, lvl);\\\n    BP.comp.software[software] = sec;\\\n  end\\\n  \\\n  function BP.comp.concat_software(concat_mode)\\\n    local modes = {};\\\n    modes.software_list = true;\\\n    modes.software_secure = true;\\\n    assert(\\\n      modes[concat_mode],\\\n      \"Invalid concat_mode.\\n\"\\\n      .. \"If you're seeing this, you're either a user that messed \"\\\n      .. \"with something you shouldn't have, or I messed up\"\\\n    );\\\n    local software = \"\";\\\n    \\\n    local secure_fmt = \"%s%s|\";\\\n    local software_fmt = \"software.%s\";\\\n    for _, soft in ipairs(software_list) do\\\n      local concat_val = \"\";\\\n      if concat_mode == [[software_list]] then\\\n        concat_val = software_fmt:format(soft);\\\n      else\\\n        concat_val = BP.comp.software[soft];\\\n      end\\\n      software = secure_fmt:format(software, concat_val);\\\n    end\\\n    return string.format([[\"%s\"]], software);\\\n  end\\\n  \\\n  function BP.comp.recorded_secures(blueprint_name)\\\n    assert(\\\n      #BP.comp.secure,\\\n      \"Attempt to define a security recording before \" ..\\\n      \"adding a module to secure\"\\\n    );\\\n    local space = BP.used_space.secure;\\\n    local const = [[:const int secures_%s %s]];\\\n    return const:format(blueprint_name, space);\\\n  end\\\n  function BP.comp.add_secure(module_name)\\\n    local secures_idx = 1 + #BP.comp.secure;\\\n    local secure_name = string.format(\"%s|\", module_name:gsub(\" \",  \"\"));\\\n    BP.comp.secure[secures_idx] = secure_name;\\\n    BP.used_space.secure = #secure_name + BP.used_space.secure;\\\n  end\\\n  \\\n  function BP.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local active_index = #BP.comp.active;\\\n      BP.comp.active[active_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that we can\\\n          * easily check it with a contains of the full spell\\\n         */]]\\\n    end\\\n    \\\n    local space = BP.used_space.active;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    local bp_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    BP.comp.blueprint[bp_name] = space;\\\n    --[[/*\\\n        * And create a blueprint that stores\\\n        * How much space we've used up thus far\\\n       */]]\\\n    bp_name = string.format(\"blueprint_%s\", bp_name);\\\n    --[[change the bp_name so we can output it as a const int]]\\\n    return string.format(\":const int %s %s\", bp_name, space)\\\n  end\\\n  \\\n  function BP.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local err_msg = \"\";\\\n    local spell = BP.comp.active[#BP.comp.active];\\\n    if spell == nil then\\\n      err_msg = \"Trying to add a timer_base without any recorded spells\";\\\n    elseif tonumber(defined_base) == nil then\\\n      err_msg = \"Trying to define a timer_base as a non number\";\\\n    elseif math.type(tonumber(defined_base)) ~= \"float\" then\\\n      err_msg = \"Trying to define a timer_base as a non double\";\\\n    end\\\n    if err_msg ~= \"\" then error(err_msg, 0) end\\\n    \\\n    local spell_fmt = \"%s|\"\\\n    spell.timer_base = spell_fmt:format(defined_base);\\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    BP.used_space.active = BP.used_space.active - space;\\\n    --[[We also have to update the total ammount of space being used]]\\\n    \\\n    space = -1 + space + #spell.timer_base;\\\n    --[[/*\\\n        * We substract by 1 since the space variable already has\\\n        * the space of 1 from the default state of `|`\\\n       */]]\\\n    local used_space = space;\\\n    local prev_space = -1;\\\n    while used_space ~= prev_space do\\\n      prev_space = used_space;\\\n      spell.space = spell_fmt:format(used_space);\\\n      used_space = space + #spell.space;\\\n      --[[We loop until we're not adding any extra space]]\\\n    end\\\n    --[[And we can end by adding the new used space to the total]]\\\n    BP.used_space.active = BP.used_space.active + used_space;\\\n  end\\\n  \\\n  function BP.comp.sync(spell_ammount)\\\n    --[[/*\\\n        * The synchronization system prevents the\\\n        * script from refreshing the budget untill\\\n        * all synchronized spells have been used.\\\n       */]]\\\n    \\\n    local sync = tonumber(spell_ammount);\\\n    assert(sync >= 0, \"Trying to add a negative sync_ammount\");\\\n    --[[Synchronizing less than 1 spell is meaningless]]\\\n    \\\n    sync = sync - 1;\\\n    --[[/*\\\n        * We subtract 1 from the sync_ammount\\\n        * to cover the first spell\\\n        * \\\n        * Sync_ammount always gets overwritten\\\n       */]]\\\n    BP.sync_ammount = sync;\\\n  end\\\n  \\\n  function BP.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local dbug = BP.debug;\\\n    local halt_limit = dbug.halt_limit == 0 and dbug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our halt limit has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or bp_debug_stop then\\\n      BP.debug.halt();\\\n    end\\\n    \\\n    local active_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    \\\n    local actives_index = 1 + #BP.comp.active;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * to loop our sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because, sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    local sync = BP.sync_ammount;\\\n    if sync > 0 then\\\n      new_spell.sync = \"s\";\\\n      BP.sync_ammount = sync - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the budget.]]\\\n    new_spell.name = active_name;\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      new_spell[variable] = {};\\\n      new_spell[variable] = 0.0 + value\\\n      --[[/*\\\n          * the addition with 0.0 here is to guarantee \\\n          * the correct data type.\\\n          * timer, coord_x and coord_y need to be doubles \\\n          * for the actions waitwhile() and vec().\\\n          * float and double are the same type in this editor\\\n         */]]\\\n    end\\\n    spell_values[4] = \"name\";\\\n    for _, variable in ipairs(spell_values) do\\\n      new_spell[variable] = string.format(\"%s|\", new_spell[variable]);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * string.format converts the value in\\\n          * new_spell[variable] into a string. Meaning that\\\n          * I no longer have to convert the value to a string myself\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      new_spell.space = string.format(\"%s|\", used_space);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[/*\\\n        * Add the extra space taken up by our signal bits\\\n        * and space recording.  We add our space here so that\\\n        * we don't have to pass through the entire string an extra time\\\n       */]]\\\n    \\\n    BP.comp.active[actives_index] = new_spell;\\\n    BP.used_space.active = BP.used_space.active + used_space;\\\n    \\\n    local logging_check = dbug.can_halt or dbug.can_log;\\\n    if logging_check then BP.debug.log() end\\\n    \\\n    if dbug.can_halt then\\\n      BP.debug.halt_limit = dbug.halt_limit - 1;\\\n    end\\\n    --[[/*\\\n        * Check if we're logging or\\\n        * if compilation should be halted\\\n        * \\\n        * Remember that dbug is the same as BP.debug\\\n        * in this function\\\n       */]]\\\n    local spell_number = string.format(\"spell_%s\", actives_index);\\\n    local const_txt = \":const int %s %s\";\\\n    return const_txt:format(spell_number, BP.used_space.active);\\\n  end\\\n  \\\n  function BP.comp.concat_actives()\\\n    local spells = {};\\\n    --[[table holding the compacted data]]\\\n  \\\n    local actives = BP.comp.active;\\\n    local dbug = BP.debug;\\\n    --[[access our recordings]]\\\n    \\\n    local actives_count = #actives;\\\n    --[[nr of recordings]]\\\n    \\\n    do\\\n      local identifier = [[\"BP.comp.Define_entire_blueprint\"]]\\\n      BP.comp.recorded_blueprint(identifier, false);\\\n    end\\\n    --[[/*\\\n        * Record the final blueprint to the BP.comp.Blueprint table\\\n        * without forcing the blueprint to be in a loop\\\n        * \\\n        * I'm doing this in a do...end block so that the identifier\\\n        * doesn't linger in the rest of the code\\\n       */]]\\\n    \\\n    local concat_debug = {};\\\n    concat_debug.format = \"\";\\\n    concat_debug.separation = \"\";\\\n    concat_debug.bit_format = \"%s\";\\\n    concat_debug.spell_data = \"%s\";\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    if dbug.can_display then\\\n      local fmt = dbug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    end\\\n    \\\n    for i = 1, actives_count do\\\n      --[[/*\\\n          * spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data_pack = {};\\\n      do\\\n        local data = actives[i];\\\n        if dbug.can_display then\\\n          data_pack.loop_bit = table.pack(\"loop\", data.loop_sign);\\\n          data_pack.sync_bit = table.pack(\"sync\", data.sync);\\\n          \\\n          data_pack.base = table.pack(\\\n            data.timer_base, \"timer_base\",\\\n            #data.timer_base\\\n          );\\\n          data_pack.space = table.pack(\\\n            data.space, \"space\",\\\n            #data.space\\\n          );\\\n          data_pack.timer = table.pack(\\\n            data.timer, \"timer\",\\\n            #data.timer\\\n          );\\\n          \\\n          data_pack.coord_x = table.pack(\\\n            data.coord_x, \"coord_x\",\\\n            #data.coord_x\\\n          );\\\n          data_pack.coord_y = table.pack(\\\n            data.coord_y, \"coord_y\",\\\n            #data.coord_y\\\n          );\\\n          \\\n          data_pack.name = table.pack(\\\n            data.name, \"name\",\\\n            #data.name\\\n          );\\\n          data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        else\\\n          data_pack.loop_bit = table.pack(data.loop_sign);\\\n          data_pack.sync_bit = table.pack(data.sync);\\\n          \\\n          data_pack.base = table.pack(data.timer_base);\\\n          \\\n          data_pack.space = table.pack(data.space);\\\n          data_pack.timer = table.pack(data.timer);\\\n          \\\n          data_pack.coord_x = table.pack(data.coord_x);\\\n          data_pack.coord_y = table.pack(data.coord_y);\\\n          \\\n          data_pack.name = table.pack(data.name);\\\n          data_pack.chunk_end = \"\";\\\n        end\\\n      end\\\n      \\\n      local spell_data = table.pack(\\\n        concat_debug.format,\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.loop_bit)),\\\n        --[[Adds the loop_sign bit]]\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.sync_bit)),\\\n        --[[adds the sync signal bit]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.base)),\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.space)),\\\n        --[[Adds the space we take up]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.timer)),\\\n        --[[Adds the spell timer]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_x)),\\\n        --[[Adds the spells x coord]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_y)),\\\n        --[[Adds the spells y coord]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.name)),\\\n        --[[Adds the spells name]]\\\n        \\\n        concat_debug.format, data_pack.chunk_end\\\n      );\\\n      \\\n      for _, data in ipairs(spell_data) do\\\n        spells[1 + #spells] = data;\\\n      end\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(spells));\\\n  end\\\n  function BP.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from BP.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local active = BP.comp.active;\\\n    local spell_index = #active;\\\n    local spell = active[spell_index];\\\n    \\\n    local logging_text = table.pack(\\\n      \"%s| BP has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 7\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value] or \"nil\";\\\n      --[[/*\\\n          * Gets our spell_value\\\n          * If its respecitve value exists then \\\n          * * spell_value = spell[value]\\\n          * else\\\n          * * spell_value = \"nil\" to signal that\\\n          * * something has gone wrong\\\n          * \\\n        */]]\\\n      \\\n      local fmt = table.pack(log, value, spell_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, spell_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function BP.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * BP.comp.add_spell\\\n        * * BP Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local debug = BP.debug;\\\n    local should_halt = debug.can_halt or debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #BP.comp.active,\\\n        \" \"\\\n      );\\\n      if #BP.comp.active == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = BP.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n#recorded_secures(secure_name) {lua(\\\n  return BP.comp.recorded_secures([[{secure_name}]])\\\n)}\n#add_secure(secure_name) {lua(BP.comp.add_secure([[{secure_name}]]))}\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return BP.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; \n#timer_modulo(modulo) {lua(BP.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(BP.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return BP.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0, \\\n  0\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n\n#software.concat(concat_mode) {lua(\\\n  return BP.comp.concat_software([[{concat_mode}]])\\\n)}\n\n#software.secure(software_name, level) {lua(\\\n  BP.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}"],["Blueprint Compactor resources","\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#blueprint_compactor Blueprint Compactor\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{blueprint_compactor} Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string compactor_actives \"{blueprint_compactor}access actives str\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{blueprint_compactor}access secures str\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_secures, {str})\n; \n:const string caller_ID \"{hider.close}{blueprint_compactor} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n\n#idle_mode_str {hider.start}{blueprint_compactor}{hider.close}\n; \n; this is a special string that makes it highly unlikely\n; that the caller_ID has this value naturally.\n; \n:const string idle_mode \"{idle_mode_str}idle mode\"\n; \n; This string is used by the compactor to detect if entered idle mode\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n\n; \n; Adds era securing capabilities\n; \n\n{lua(\\\n  Era = {};\\\n  Era.elements = {};\\\n  Era.element_cost = {};\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[no parse blocks]] are recommended here to\n; ensuse our input is a string\n; \n; Use this to create the priority listing\n; The macro doesn't check if it's a valid element since\n; the editor checks for us :D\n#set_priority(element_name) {lua(\\\n  local elems = Era.elements;\\\n  local name = [[\"{element_name}\"]];\\\n  --[[/*\\\n      * Prevent recording the same element multiple times\\\n      * by checking if its name has already been read\\\n      * if it has, return to prevent another entry\\\n     */]]\\\n  if elems[name] ~= nil then\\\n    return;\\\n  end\\\n  local index = 1 + #elems;\\\n  elems[index] = name;\\\n  \\\n  local disable_era = [[disable.cost(%s)]]\\\n  Era.element_cost[index] = disable_era:format(elems[index]);\\\n  elems[name] = index;\\\n)}\n\n; important thing to know about disable.cost(element)\n; if we input an element we can't disable, disable.cost returns -1.0\n; \n; Here we use this fact to create an if statement\n; if(disable.cost(\"element\"), \"element\", if(next_element))\n; and we repeat this until our last recorded element\n; that if statement is\n; if(disable.cost(\"element\"), \"element\", \"last_element\")\n#disable.era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.element_cost;\\\n  \\\n  local condition_fmt = [[%s != -1.0]]\\\n  local if_fmt = [[if(%s, %s, %s)]];\\\n  \\\n  local last_element = elems[#elems];\\\n  for i = #elems - 1, 1, -1 do\\\n    local cost = elem_costs[i];\\\n    local condition = condition_fmt:format(cost);\\\n    local caseTrue = elems[i];\\\n    last_element = if_fmt:format(condition, caseTrue, last_element);\\\n  end\\\n  return last_element;\\\n)}\n\n; Here we construct the condition for the bool ended_era\n; ended_era = -<number_of_elements> == <sum_of_elements_cost>\n#disabled_era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.element_cost;\\\n  \\\n  local sum_fmt = [[%s + %s]];\\\n  \\\n  local last_cost = elem_costs[#elems];\\\n  for i = #elems - 1, 1, -1 do\\\n    last_cost = sum_fmt:format(last_cost, elem_costs[i]);\\\n  end\\\n  local negative_costs = 0.0 - #elems;\\\n  local not_equal = [[%s != %s]]\\\n  return not_equal:format(negative_costs, last_cost);\\\n)}\n\n"],["Blueprint Compactor lib",":import Blueprint Compactor resources\n\n:local int pointer\n:local string actives\n:local string secures\n; \n:local bool det_timer_base\n:local double timer_base\n:local double clock\n; \n:local string spell_ID\n; \n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[actives]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, pointer, 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  contains({get_bits}, \"#\"), \\\n  0, \\\n  pointer + {get_space}\\\n)\n\n; \n#modulo_timer {timer.get} % timer_base\n"],["Blueprint Compactor",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n\n:budget_cap max\n\ngotoif(\\\n  if({timer.get} == 0.0, start_timer, start_secures), \\\n  contains(impulse(), \"{blueprint_compactor}\")\\\n)\n; The compactor will have at most 3 instances running at once\n; The first instance will be in charge of executing actives.\n; It also executes a second instance of itself.\n; If the timer is set to 0, this second instance will be the timer.\n; If this second instance is the timer, it will create a third instance.\n; \n; This third instance will always be in charge of securing modules.\n; \n; If the timer is not set to 0 when the second instance is created, this\n; means that there's already an instance that's running the timer, so\n; this second instance becomes in charge of securing modules\n\npointer = {pointer.get}\nactives = {comp_active.get}\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{blueprint_compactor}\")\n; We now make a copy of ourselves.\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; get_base returns utcnow() if s2d fails.\n; since we're doing this check in the same frame thanks to the budget\n; the value returned by the utcnow() function does not update\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; If we must loop over, we'll have to wait until our modulo_timer is\n; of value 0\nclock = if(pointer == 0 && det_timer_base, 0.0, {timer.get})\nwaituntil({modulo_timer} <= clock)\n\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\nwaituntil(clock <= {modulo_timer} || contains({caller.get}, idle_mode))\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\"\", sub(actives, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n\n; Skip waiting a frame if we have enough xp to secure another module\ngotoif(secures_no_frame, disable.inf.cost() <= xp())\nwaitframe()\n\nsecures_no_frame:\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngotoif(timer, {caller.get} != idle_mode)\n; The timer will be incremented until one of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(idle_mode)}\n\nend_instance:\n"],["Blueprint Compactor with Debugger",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n; \n; This script is a version of the ordinairy compactor, and as such\n; is intended to make every script that uses the compactor think\n; this is their target. This way, you don't have to change much\n; of your blueprint AI\n; \n\n; \n; The debugger adds a layer of complexity to the compactor\n; and makes everything a little bit more computationally intense\n; (so your game will likely be laggier when you\n; run the compactor like this)\n; \n; This is used to tell you what the compactor sees at any 1 time\n; if durring run-time you get undesirable spell execution\n; \n; While the primary goal here is to diagnose issues,\n; you can also use this as a spell compactor to test\n; any changes you've made.\n; This debugger isn't just for uncovering bugs in the compactor\n; â€”though if you find any, please let me know!\n; Instead, it's meant to help you, the end user, understand:\n; * What you're instructing the compactor to do\n; * How the substring used to compute the\n;   activation sequence changed the recording string\n; \n\n:budget_cap max\n\nkey.x()\n; You have the impulse that lets you cycle through your spells\n; \n:local bool debugging\n\ndebugging = true\n; This debugging_bool is set to true if you want\n; to search for what's going wrong\n; \n; By default I've set this to true so you have to manually disable\n; debugging if you don't want it\ngotoif(\\\n  if(debugging, debug, if(\\\n    {timer.get} == 0.0, \\\n    start_timer, \\\n    start_secures\\\n  )), \\\n  contains(impulse(), \"{blueprint_compactor}\") || debugging\\\n)\n\npointer = {pointer.get}\nactives = {comp_active.get}\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{blueprint_compactor}\")\n; We now make a copy of ourselves.\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; get_base returns utcnow() if s2d fails.\n; since we're doing this check in the same frame thanks to the budget\n; the value returned by the utcnow() function does not update\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; If we must loop over, we'll have to wait until our modulo_timer is\n; of value 0\nclock = if(pointer == 0, 0.0, {timer.get})\nwaituntil({modulo_timer} <= clock)\n\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\nwaituntil(clock <= {modulo_timer} || contains({caller.get}, idle_mode))\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell or set it to 0 if\n; we must loop over\n\n#end_of_compactor contains(\"\", sub(actives, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n\n; Skip waiting a frame if we've successfully secured a module\n; this is done in hopes that, maybe, we have enough xp to disable\n; the next module as well\ngotoif(secures_no_frame, disable.inf.cost() < xp())\nwaitframe()\n\nsecures_no_frame:\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(contains({caller.get}, idle_mode), end, end_instance))\n; The timer will be incremented until any of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\ndebug:\n; It sets the caller to idle_mode so that when you\n; force your blueprint AI to send the string over, there's\n; a concrete spot that tells it that it can shut down\n; \n\npointer = {pointer.get}\nactives = {comp_active.get}\n{caller.set(\"debug\")}\n\nglobal.string.set(\"spell_chunk\", sub(\\\n  actives,\\\n  pointer,\\\n  {get_space}\\\n))\n; The chunk shows you how the spell is stored\n; the order is as shown bellow:\n; * `loop_signal bit` that is / to move to the next spell and # to loop\n; * `sync bit` that is / to refresh budget and `s`\n;    to skip refreshing budget\n\nglobal.int.set(\"pointer\", pointer)\n; We also have a pointer and next_pointer that shows what value\n; this pointer has at that state\n\nglobal.string.set(\"timer_base\", {lua(return Compactor.timer_base)})\nglobal.string.set(\"spell space\", {lua(return Compactor.space)})\n; space value which is the ammount of space\n; the spell takes up in the recording\n\nglobal.string.set(\"spell_timer\", {lua(return Compactor.timer)})\n; timer value which is the timer\n; you set when adding a spell\n\nglobal.string.set(\"coord_x\", {lua(return Compactor.coord_x)})\n; coord_x which is the coordinate you add\n; if you added a grounded spell\nglobal.string.set(\"coord_y\", {lua(return Compactor.coord_y)})\n; coord_y which is the same idea as coord_x\n; \n; Remember that add_spell.instant is the same\n; as add_spell.grounded with 0, 0 as coordinates\n; \nglobal.string.set(\"spell_name\", {get_name})\n; name which is the spells identifier so we can\n; take an active index of it\n\n{pointer.increment}\n; We finally increment our pointer and add the next pointer state\n{pointer.set(pointer)}\n\ngoto(end_instance)\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(idle_mode)}\n\nend_instance:"]]}}
```

## The game import

The game import is a code you import inside TPT2

### Blueprint Compactor

This is the program that will execute your spells durring towertesting.<br>
You can read its comments by importing the source version or by looking at [Blueprint Compactor](Blueprint%20Compactor.tpt2). The comments explain how it does things in more detail.

Using the compactor is strictly within the External Editor. While you could communicate with the compactor ingame, I highly advise against it as it uses hidden variables to prevent UI clutter.

Requirements:

- impulse: 0
- conditions: 0
- lines: 33
- scripts: 1

```
7Vxdbts4EL6Ko2L7sHG0ktNugiDuBu2+7NPu+zoIKGrsEKVEQaSadNueoVfZGxRoL1bIlGpZIhXKlus/IoAQU5ofDr8ZjkiOPjgcpyQR3Ln694ODsCAszv93JpnneTCDGFKC3RkTjEznbYGANEbpe5fEIm/wfcyiBKWEs9gNWRZQkM0zygJEiyZ3BmISYBZzgSSd92J+9dXNo/G41n4+v3odrsv0o7lWgeFzOmlTLlISz1zMYoFIzKWZpA1dEiUZ5aDqkH/+mmaQpCQWgze5vbBgqTN0JillGNHcmC7XmOgiYSQWkBZDIs2aEyhs+uyak/9g7L1SiBv8I/nkYnOVPCm66JFWeg6Kd8CXBrWgUSjwi0Iwwhg4HxSMBlz8UKHGT6HDyfVveY+U/cGI0tIsJSolp7XGyvOvJoJnQYVVO9WoFYhQqEHiEB7/nnbRopuYJZaFhb1p6cLwCDgT3cBZQUnhxiqUxIJEkN4FiIP0VD4KawasYU0XDKpY8wClRNxHIAiex5qKp2jpS09R2vNUaU+dVeviNUPZtWdKzT5uu8NK8rNtazU3bw4uLlCUuJnAMXsogQ1Sj4Axqo1dEIK4W0anbrpahrmqZ1WYK6esk3GrxgaelF9fYsrw2+WgttDTm1bUz/suH6w09jFGzdlXH3uU9M+fN8ZIp0h9jNad9TvlHot5qIiSD4iILBaEtmHFr7hEbxnPecTCvpB4PTbktACceVIQ8AQovfvrzw3E+J8fZK3Ew5C47clSTe5b8sZ1+1ixEq1EG2WOjFz9NnMMoLUSbSg4UvKVX703tIZlHeOAHGM3zH0MEo8GUjZzseNuuOj57f+vX9qXL5Vrxauvf2eLGbJt0XHnF0c/SqypdgcN9jcN9iNrFKctW7IFMxJSGEQsLHft/AvBHiB1IxZmFNyMA1lw9C9nKILynvQq6Y+G3vhjAbeUdlmXljBO8pMA/YqTLv4OsDtNWfSGsTSUWZJNtvZI4pHGZJsdWonWB/ogP9501gJ1P4BqnH/Lp232YiVaF7TplpV4MBKt09r80Eq0nnUg5F0XlBuFPwqxvm4Wbiysrpcbrw6YjsjgytX0aYoiWKVQp14ntbd2eaYk18FoA/6eyZcschAvWfsT/3bDXnaE9jR92lczjr59kX950J9W50HDsK7SxttisI+f7jLWuL9Jre9Ubh7eA6LivsbYbxmgfL94hSylrRsnht3ooS5pNDGsJPZ+bz7X7VSaT1bL5v7oWOfLAWdpH3W+BaNqne+ouocs76/oEaWWXTxiAwGxVEMTENcOfmddWHTJ2i/VgNEdC7loDpyLGdcU7V+PJyKh6D2k7mOy2XS6F4X9VxPNkZVOHnfz9fONkv95wh4Unq49/EKUUF3zlXF3kN4d0uYhct7LZr3s4cJEd9DKmIdR1mQ613QSbZpZqUqdd/LYljoaFgfN6sXZu+OPSq2bpd9lQmySNaqmnJfN5+rf/3jKv4UO8fPTfm4IVCA15a+rJ5k3vX1DQz0F/hwDnKrkPFkRb5RLhGrLLcXcSoa3CS+V2pzUMbvSoUvzsVjzvaXXr9+s0/HboYNZHJLyq0+3Q6f4fEzxK86heuWooZ0g/BbN8vvO0AmycAbCuTrzh07G4XXxU6QZfLr99B0=
```

### Blueprint Compactor with Debugger

This is the program, similar to the normal [Blueprint Compactor](#blueprint-compactor), that includes debugging functionality.<br>
You can read an explanation of what it does by looking at the comments in [Blueprint Compactor with Debugger](Blueprint%20Compactor%20with%20Debugger.tpt2).

You have a local boolean called "debugging" set to true by default. This lets you see the data string obtained from your blueprint AI. You use key.x() to go through your spells.

Requirements:

- impulse: 1
- conditions: 0
- lines: 48
- scripts: 1

```
7V3dcps4FH4Vh87ebBxqnHbTzSTdTLs3e7V7X2cyWMhEE0AMEk2yTZ+hr7Jv0Jn2xXZAkGA4YETs2JgznaEJIH1H0nd+kHSUL4YgEQulME4/fTFsIhkPkp+NWTyZTKjHie2Zc849U1A5mxMeCGkHMn36ZiYdOo9dlwVu6ZGlrsY4q8elAY0YMV0uOVuk9+aSRoEd3ZssK1MEc3XApgfpf5PKtQxhWYT7oR0xwQPT4fHco+q26/G57WW3QPC0OfDt6fl56f5xjTz111KDUqlIy/fe1NS6KDQ26VR1U8iIBa5JeCBtFgjV84oDJvPD2BMUaqV1/MGLaRixQI4+JvUSySO4Ox4eNIczYUmk3maBBImWXE9CzgJJo4xRasiSAkDtr84E+5eeT94DUo/+UfVk5LQmCjrrmFr0RDc+U7FEmKwMIMAvALBNCBVilFU0EvJRhFJ9gAwHZ6+TFoHtIbbn5d2SM17V9Kwhn1inMynieaGq5lLTRpLTTAwWOPTu74WOFHowS1XmFmiRWyB6R0ks23O8xJLMREAsCSTzaXQ1twVVVkBMnVIHlrhWZ2iKXJtQO2Ly2qeSkdSOFTSltnyuKWB/HoL9WderZfiaodRtGSjZw7YbDBY/2rZUafcm5BLS9kMzliTgt4+udYWLTt9xqLxaZmedK1ymOdSyIs1B+39w3ihxC01Krm+Jx8nNslF7knNCC+KvYziqTrzezDzX2WuFHE8uIjNgtzaTcSCZ1zSMVoGtawt0jn3urIskZ+cta3riQnt/PRch9byrv/7cgPl9efuHiPuBuG0/Bhe3sHjlun2uICIiopUZWHH4Q2MIpEVENAUDLd75q3hD00uoGHukGLvR3UNAHAylMHLBcW856fnzvx/fm6cvwTXK7lPT8ZOHbJp03PnJ0WwFFVq4a7H02GKpsFTisGG1NKuMOR4d+dzJF9SsE8lvaWT63Ik9asaCsqcarXeu7dP8mdIqpY8ttfFxAjdHe1dGC7lgyV6F9cIpFf9MibmIuP+R88hRURIGWz1CHKhNxugQEVEH1lF8uOEsErUfRG0df6u3MXpBRFRBDLcQcW8QUWkxPkRE1Kw9Ka47oVxJKQJgrbotvJWJ1efFxt0Jo8kMAc6mLyLbp11yaCoZWH3tl1dg8ToabUDfY/WRxfbiI6s/9m83+gtHqKfhU1+7cfrzu/qXGP1F0Q+2NOuQNJMtGvtgdZOhZFiosdDi8UItHl5T25PXpYqthgFK1os7RClNzah7UTsZOgbSusrdKlfLo8al+p7erjSLdYvm/tBMwRWUxNE6UnCzioopuNPiGrJ63lEjcil1NGIDBjEXo8YgPtv4HelUoRO1/w4Tpm5byEl14EzCRQ1Tz2Yy9Ox7Gpl34Waj6fXI+35Ws2NFS+Eufny7AOs/DvktoOi1e18YyNRnfjHuDtH1Gd3eQsZwJuv+0qRun1XrOloFTW1djRZ028Cq7QkbW9+1Bcc3+UkdpVzq3dFHUOpqpnYeD7cJGiGP81v1vfLJHKv0W9YxPt3sZzrUkzZc8tfuMebF2k63gF3gy3TAIYTTnBDf5aNnB9Vw+no1QQEO43k5azkvB5L6bXooUXsYxT21fZRcx8HNC35Fxzjp2BAX4KTjYEcIJx030I1Lk45lj7LSBXX4sGphfIuJFHjQVu+pue2Dtjq5/ZEIbbIJ+g1v/NEH788IoQ9eRzd2+xBJveJeWCSkBu5G7j3iYCi10zYfx33TJ9i0dFInJEmrvrpDB9UTxKHwGD0qIqIOYAjQa0Qk6gZjlnuMWRARFQ+DLETcD0RUWowKERE1q6/FdfZKqLWhwPb3Y7EaEfcDEQ1FH4rvBlcQERHRygysOH4nICKagoEVx+OMKsWrARkcluFxRn3V993oLxyhngYofe1G3cyiNrmquglHywnFJflqUnD1sqOXb2sfJLTJzFetP/9yOTYID5z0j68I4/TT5dhgfhh7gia/GTf03rxLXkomGo1TA845D21yY7vJc2NszGPHpdI4PbLGRizoh+xXGcX06+XX/wE=
```

# Changelog

## version 2.7.3

Made the last tweeks to the compactor.<br>
The user can now soft-stop the compactor by directly changing the caller_ID to the const string idle_mode.<br>
Replaced the Spell Compactor discord post with the Blueprint Compactors.<br>
Fixed typos in the watercat and easy eracat macros.<br>
Updated and fixed all warnings from the lua version of the compactor.

## version 2.7.2

Removed To Be Done<br>
The user can now define a base for their timer.<br>
The compactor can now also secure modules durring towertesting.<be>
Added watercat and easy eracat macros.

## version 2.6.0

Added a To Be Done<br>
At this stage, I'm never going to be able to get any work done with it.

Modified recorded_blueprint to also save the ammount of space used in the recording to a global table Spell.comp.blueprint. This way, the user can retrieve this value dynamically in lua code, and, as shuch, does not need to manually change the value after modifying the blueprint.

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
