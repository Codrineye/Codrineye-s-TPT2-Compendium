# Codrineye's Blueprint Compactor

The blueprint compactor is a library for the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) that helps you define what you want your blueprint AI to do.

To better understand how to use the compactor, head over to the [Compactor Manual](Compactor%20manual.md) for an explanation of each function.

## The source import

This is the import you need to be able to use the configuration scripts.<br>
As this is the source, you must use this code in the [external editor](https://d0sboots.github.io/perfect-tower/).

If you want to look through this import, the library file will return an import error if you haven't imported [Editor_actions lib](../../Editor%20Actions%20lib/README.md).

```
{"workspaces":{"Codrineye's Blueprint Compactor":[["Devbuild Software Config",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(0)}\n{wave_streaming(0)}\n{wave_surge(0)}\n{critical_wave_jump(0)}\n{wave_momentum(0)}\n{wave_storm(0)}\n{wave_persistence(0)}\n{wave_instability(0)}\n{wave_vortex(0)}\n{wave_catalyst(0)}\n{wave_endurance(0)}\n{new_bounds(0)}\n{wave_marathon(0)}\n{wave_compression(0)}\n{era_surge(0)}\n{era_burst(0)}\n{era_swirl(0)}\n{wave_horizon(0)}\n{no_bounds(0)}\n{era_tunneling(0)}\n{wave_breach(0)}\n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n{wave_restart(0)}\n{infinity_horizon(0)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {software.concat(software_len)}\n\n:local int watercat\n"],["Devbuild Secure Config",":import Cods Blueprint Compactor\n:name Security Config\n\n; \n; Welcome to security config, where you define\n; what modules you want to secure and in what order\n; \n; Since securing isn't very complicated, logging and halting\n; has not been added, as there's not much for you to keep track of\n; \n; You have 2 macros at your disposal\n; add_secure(secure_name) is the name ID that you want to be secured\n; recorded_secures(secures_name) will return a const int called\n; secures_<secures_name> which holds the ammount of space your secures\n; have taken up\n; \n; your compacted secures are in the const string recorded_secures\n; and the total size of your recorded_secures is in the\n; const int secures_space\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{add_secure(barrier.temporal)}\n; tells the compactor you want to secure barrier.temporal\n{add_secure(spell.void)}\n; means that you want to secure spell.void\n; after you've secured barrier.temporal\n\n{recorded_security(blue)}\n; Gets you the constant secures_blue, which you can use to\n; isolate this secures sequence by using\n; sub(recorded_secures, 0, secures_blue)\n; \n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n:const string recorded_secures {recorded_secures}\n:const int secures_space {secures_space}\n"],["Devbuild Spell Config",":import Cods Blueprint Compactor\n:name Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; Please read the compactor manual on the repo for a better\n; understanding of how to use it\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; timer_modulo(modulo)\n; Should be used before you use recorded_blueprint to define a\n; blueprint that can loop\n; \n; this modulo value is used when your loopable blueprint\n; has precice timings where the timer must be set back to 0.0 before\n; it can activate spells again.\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; You can make your timer be based off of the cooldown\n; of another module. You must set this cooldown to the module ID\n; of the spell you want as refference. This module ID must\n; be in \"double quotes\"\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n\n{add_spell.instant(barrier.temporal, 0.0)}\n; adds the instant spell `temporal barrier` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t >= 0.0\n\n{recorded_blueprint(start, false)}\n; defines the blueprint called \"blueprint_start\" that doesn't loop\n; the spell activation sequence when it executes the last spell\n\n{synchronize(2)}\n; makes the next 2 recordings happen on the same frame\n\n{add_spell.instant(spell.response.neutral, 0.0)}\n; adds the instant spell `neutral response` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, \"spell.response.neutral\", 0.0, 0.0)}\n; adds the grounded spell `void` to be used at position 0.0, 0.0\n; on the map when the spell `neutral response` has a cooldown of 0.0\n\n{timer_modulo(50.0)}\n{recorded_blueprint(loop, true)}\n; defines the blueprint called \"blueprint_loop\" that loops\n; once it reaches the end of the loop, it will wait until t becomes\n; a multiple of 50.0. Then it will activate neutral response again\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n; adds the instant spell `snap of destiny` to be used\n; when t is a multiple of 28.0\n\n; \n; If you just sent the sequence `recorded_actives` to the compactor\n; you'd execute\n; temporal barier, void, neutral response, void\n; and loop back to using temporal barrier\n; \n; Notice that, since blueprint_loop has the loop property\n; snap of destiny will never be executed\n\n; \n; To execute just blueprint_start, you can cut that sequence\n; by using sub(recorded_actives, 0, blueprint_start)\n; \n; If you want to isolate blueprint_loop, you cut it using\n; sub(recorded_actives, blueprint_start, blueprint_loop - blueprint_start)\n; \n; and if you want to use snap of destiny every 28 seconds you use\n; sub(recored_actives, blueprint_loop, recording_size)\n; The last spell always gets the looping tag\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {recorded_actives}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the concat operation one more time, which\n; can get very expensive if you have a big recording sequence\n\n:const int recording_size {recording_size}\n"],["Cods Blueprint Compactor","\n{lua(\\\n  BP = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  BP.debug = {};\\\n  BP.debug.can_log = false;\\\n  BP.debug.can_halt = false;\\\n  BP.debug.halt_limit = 0;\\\n  BP.debug.can_display = false;\\\n  BP.debug.concat_format = \"\";\\\n  \\\n  --[[Table keeping track of how much space we're using up]]\\\n  BP.used_space = {};\\\n  BP.used_space.secure = 0;\\\n  BP.used_space.blueprint = 0;\\\n  \\\n  --[[Keep track of how many modules we have left to synchronize]]\\\n  BP.sync_ammount = 0;\\\n  \\\n  --[[Table that has compactor specific data]]\\\n  BP.comp = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  BP.comp.software = {};\\\n  --[[Store the era elements priority order]]\\\n  BP.comp.era = {};\\\n  \\\n  --[[Store the modules we want to secure]]\\\n  BP.comp.module = {};\\\n  BP.comp.secure = {};\\\n  \\\n  --[[Blueprint activation]]\\\n  BP.comp.spell = {};\\\n  BP.comp.blueprint = {};\\\n  BP.comp.spell_names = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(BP.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  BP.debug.can_display = true;\\\n  BP.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(BP.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  BP.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  BP.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  BP.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  BP.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local bp_debug_stop = false;\\\n  --[[/*\\\n      * Empty table that replaces the need\\\n      * for repetitive assert sequences\\\n      * \\\n      * Adding to a table and concatenating it is more efficient\\\n      * than ordinairy string concatenation\\\n     */]]\\\n  local err_msg = {};\\\n  \\\n  --[[Function to more easily handle error messages]]\\\n  function BP.debug.detect_error()\\\n    if not err_msg[1] then return; end\\\n    --[[Exit function if there's no error]]\\\n    \\\n    error(table.concat(err_msg), 0);\\\n  --[[/*\\\n      * If there is an error, send just the message,\\\n      * the 0 ignores the call context since this \"context\" is\\\n      * just illegible lua code\\\n     */]]\\\n  end\\\n  \\\n  --[[/*\\\n      * WaterCat implementation\\\n      * Set a list of software names and then\\\n      * a security level to each software.\\\n      * \\\n      * If the security level decided by the user\\\n      * is smaller or = to the level given to the software\\\n      * that software gets toggled on, othwerise, it's off\\\n     */]]\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  local software_count = #software_list;\\\n  for i = 1, software_count do\\\n    BP.comp.software[software_list[i]] = -50;\\\n  end\\\n  \\\n  function BP.comp.add_software(software, level)\\\n    --[[get direct access to the software we recognize]]\\\n    local soft = BP.comp.software;\\\n    \\\n    --[[get the security level from the macro call]]\\\n    local sec = level:match([[%b\"\"]]):sub(2, -2):gsub(\" \", \"\");\\\n    \\\n    if soft[software] == nil then\\\n      err_msg[1] = \"Attempt to assign a security level to \";\\\n      err_msg[2] = \"an unrecognized software\\n\";\\\n      err_msg[3] = \"If this is a new software, an update to \";\\\n      err_msg[4] = \"the compactor should be released soon\";\\\n    \\\n    elseif soft[software] ~= -50 then\\\n      --[[/*\\\n          * Smallest security level I've seen is -1, \\\n          * so -50 should never be assigned naturally\\\n         */]]\\\n      err_msg[1] = \"Trying to assign a security level to an \";\\\n      err_msg[2] = \"already set software\";\\\n    elseif tonumber(sec) == nil then\\\n      err_msg[1] = \"Trying to assing a non-numeric security level\";\\\n    elseif math.type(tonumber(sec)) ~= \"integer\" then\\\n      err_msg[1] = \"Trying to assign a non-integer security level\";\\\n    end\\\n    \\\n    --[[Detect if we have an error and send it]]\\\n    BP.debug.detect_error();\\\n    --[[create the software ID]]\\\n    local software_name = \"software.\" .. software;\\\n    --[[/*\\\n        * get the extra space we need to fill out\\\n        * such that the string in sec has as many characters\\\n        * as the software ID does\\\n       */]]\\\n    local lvl = string.format(\"%%-%ss\", #software_name);\\\n    BP.comp.software[software] = lvl:format(sec);\\\n  end\\\n  \\\n  function BP.comp.concat_software(concat_mode)\\\n    local modes = {};\\\n    modes.software_list = true;\\\n    modes.software_secure = true;\\\n    modes.software_len = true;\\\n    \\\n    if not modes[concat_mode] then\\\n      err_msg[1] = \"Invalid concat_mode.\\n\";\\\n      err_msg[2] = \"If you're seeing this then:\\n\";\\\n      err_msg[3] = \"- You're either a user that messed \";\\\n      err_msg[4] = \"with something you shouldn't have.\\n\";\\\n      err_msg[5] = \"or\\n\";\\\n      err_msg[6] = \"- You're a user that did nothing wrong and I \";\\\n      err_msg[7] = \"messed something up and didn't propperly bug test\";\\\n      error(table.concat(err_msg), 0)\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local software = {};\\\n    local software_len = 0;\\\n    \\\n    for i = 1, software_count do\\\n      if concat_mode == \"software_len\" then\\\n        software_len = software_len + 9 + #software_list[i];\\\n      elseif concat_mode == \"software_list\" then\\\n        software[i] = \"software.\" .. software_list[i] .. \"|\";\\\n      else\\\n        software[i] = BP.comp.software[software_list[i]] .. \"|\"\\\n      end\\\n    end\\\n    if software_len > 0 then\\\n      return software_len - 1;\\\n    end\\\n    return [[\"]] .. table.concat(software) .. [[\"]];\\\n  end\\\n  \\\n  --[[/*\\\n      * Easy Era cat\\\n      * Set a priority level for all the era elements\\\n      * you want to disable.\\\n      * Create a ternary string that makes sure the\\\n      * element of priority 1 gets disabled before priority 2\\\n      * and so on...\\\n      * Create an arithmetic.double that checks if the sum\\\n      * of disabling all those elements is == -#BP.comp.era\\\n     */]]\\\n  \\\n  function BP.comp.set_priority(element_name)\\\n    local elems = BP.comp.era;\\\n    local name = tostring(element_name);\\\n    --[[don't overwrite the priority level of elements]]\\\n    if elems[name] then return; end\\\n    \\\n    elems[1 + #elems] = string.format([[\"%s\"]], name);\\\n    elems[name] = #elems;\\\n  end\\\n  \\\n  function BP.comp.disable_era()\\\n    assert(\\\n      BP.comp.era[1], \\\n      \"Cannot call disable.era without using set_priority macro first\"\\\n    );\\\n    local elems = BP.comp.era;\\\n    local era = table.pack(elems[#elems]);\\\n    for i = #elems - 1, 1, -1 do\\\n      era = table.pack(\"if(\", \\\n        \"disable.cost(\", elems[i], \") != -1.0, \",\\\n        elems[i], \", \",\\\n        table.concat(era),\\\n      \")\");\\\n    end\\\n    return table.concat(era);\\\n  end\\\n  \\\n  function BP.comp.era_to_disable()\\\n    local elems = BP.comp.era;\\\n    local negative_elems = 0.0 - #elems;\\\n    local era = table.pack(\"disable.cost(\", elems[#elems], \")\");\\\n    for i = #elems - 1, 1, -1 do\\\n      era = table.pack(\\\n        \"disable.cost(\", elems[i], \")\",\\\n        \" + \",\\\n        table.concat(era)\\\n      );\\\n    end\\\n    era = table.pack(negative_elems, \" != \", table.concat(era));\\\n    return table.concat(era);\\\n  end\\\n  \\\n  function BP.comp.recorded_secures(blueprint_name)\\\n    if #BP.comp.module == 0 then\\\n      --[[Check if there are any modules to secure]]\\\n      err_msg[1] = \"Cannot define a recorded security sequence if \";\\\n      err_msg[2] = \"you haven't added modules to secure\";\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    local space = BP.used_space.secure;\\\n    BP.comp.secure[blueprint_name] = space;\\\n    --[[give the user access to the updated data]]\\\n    \\\n    return \":const int secures_\" .. blueprint_name .. \" \" .. space;\\\n  end\\\n  \\\n  function BP.comp.add_secure(module_name)\\\n    local secures_idx = 1 + #BP.comp.module;\\\n    local secure_name = module_name:gsub(\" \", \"\") .. \"|\";\\\n    \\\n    BP.comp.module[secures_idx] = secure_name;\\\n    local space = #secure_name + BP.used_space.secure;\\\n    BP.used_space.secure = space;\\\n    return \":const int secure_module.\" .. secures_idx .. \" \" .. space;\\\n  end\\\n  \\\n  function BP.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if #BP.comp.spell_names == 0 then\\\n      err_msg[1] = \"Cannot record a blueprint with no recorded spells\";\\\n    elseif type(loopable) ~= \"boolean\" then\\\n      err_msg[1] = \"Loopable flag must be 'true' or 'false'\";\\\n    end\\\n    BP.debug.detect_error();\\\n    \\\n    if loopable then\\\n      local spell_index = #BP.comp.spell;\\\n      BP.comp.spell[spell_index].loop_sign = \"#\";\\\n      --[[`#` means loop, `/` means nothing]]\\\n    end\\\n    \\\n    local space = BP.used_space.blueprint;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    \\\n    local bp_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    \\\n    local blueprint = {};\\\n    blueprint.space = space;\\\n    for i = 1, #BP.comp.spell_names do\\\n      blueprint[i] = BP.comp.spell_names[i];\\\n      if blueprint[i]:match(\"nomatch\") == \"nomatch\" then\\\n        err_msg[1] = \"\\nFaulty blueprint definition\\n\";\\\n        err_msg[2] = \"Module timer is derived from a module \";\\\n        err_msg[3] = \"with ID '\" .. blueprint[i]:gsub(\"nomatch\", \"\");\\\n        err_msg[4] = \"' but this recording does not use this module\";\\\n        error(table.concat(err_msg), 0);\\\n      end\\\n      blueprint[blueprint[i]] = i;\\\n    end\\\n    \\\n    BP.comp.spell_names = {};\\\n    --[[Clear the spell names for the next blueprint]]\\\n    BP.comp.blueprint[bp_name] = blueprint;\\\n    --[[/*\\\n        * add an instance to the table so that this value\\\n        * can be accessed in lua\\\n       */]]\\\n    return \":const int blueprint_\" .. bp_name .. \" \" .. space;\\\n  end\\\n  \\\n  function BP.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local spell = BP.comp.spell[#BP.comp.spell];\\\n    if BP.comp.spell_names[1] == nil then\\\n      err_msg[1] = \"Trying to assign a timer_base \";\\\n      err_msg[2] = \"without any recorded spells\";\\\n    elseif tonumber(defined_base) == nil then\\\n      err_msg[1] = \"Trying to define a timer_base as a non number\";\\\n    elseif math.type(tonumber(defined_base)) ~= \"float\" then\\\n      err_msg[1] = \"Trying to define a timer_base as a non double\";\\\n    end\\\n    BP.debug.detect_error()\\\n    \\\n    local base_val = tonumber(defined_base);\\\n    spell.timer_base = base_val .. \"|\";\\\n    \\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    BP.used_space.blueprint = BP.used_space.blueprint - space;\\\n    --[[We also have to update the total ammount of space being used]]\\\n    \\\n    space = space + #spell.timer_base - 1 - #spell.space;\\\n    --[[/*\\\n        * Since spell.timer_base originally had a value of `|`\\\n        * space already includes this 1 character. To get an\\\n        * accurate reading, we must subtract this 1.\\\n       */]]\\\n    \\\n    local used_space = space;\\\n    local prev_space = -1;\\\n    while used_space ~= prev_space do\\\n      prev_space = used_space;\\\n      local value = table.pack(used_space, \"|\");\\\n      spell.space = table.concat(value);\\\n      used_space = space + #spell.space;\\\n      --[[We loop until we're not adding any extra space]]\\\n    end\\\n    --[[And we can end by adding the new used space to the total]]\\\n    BP.used_space.blueprint = BP.used_space.blueprint + used_space;\\\n  end\\\n  \\\n  function BP.comp.sync(spell_ammount)\\\n    --[[Perform basic error handling on the parameter]]\\\n    if tonumber(spell_ammount) == nil then\\\n      err_msg[1] = \"Trying to add a non-number as a sync ammount\";\\\n    elseif tonumber(spell_ammount) <= 0 then\\\n      err_msg[1] = \"Trying to add a sync ammount that's less than 1\";\\\n    elseif math.type(tonumber(spell_ammount)) ~= \"integer\" then\\\n      err_msg[1] = \"Trying to assign a non-integer as a sync ammount\";\\\n    end\\\n    BP.debug.detect_error();\\\n    --[[/*\\\n        * The sync system prevents the compactor from refreshing its\\\n        * execution budget until all synchronized modules have been used\\\n        * \\\n        * We subtract the ammount of spells that are synchronized by 1\\\n        * so that the final synchronized spell refreshes the budget\\\n       */]]\\\n    BP.sync_ammount = tonumber(spell_ammount) - 1;\\\n    --[[sync_ammount always gets overwritten]]\\\n  end\\\n  \\\n  function BP.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local halt_limit = BP.debug.halt_limit == 0 and BP.debug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our \"halt limit\" has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or bp_debug_stop then BP.debug.halt() end\\\n    \\\n    local spell_names = BP.comp.spell_names;\\\n    --[[Add to the spell names we've seen thus far]]\\\n    \\\n    local active_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    if active_name == \"\" then\\\n      error(\"Trying to add a spell with an empty ID\", 0);\\\n    end\\\n    spell_names[active_name] = spell_names[active_name] or (1 + #spell_names);\\\n    spell_names[spell_names[active_name]] = active_name;\\\n    \\\n    local actives_index = 1 + #BP.comp.spell;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * so that we loop the activation sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    if BP.sync_ammount > 0 then\\\n      new_spell.sync = \"s\";\\\n      BP.sync_ammount = BP.sync_ammount - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the execution budget]]\\\n    \\\n    local parameters = table.pack(coord_x, coord_y, timer);\\\n    local spell_values = table.pack(\"coord_x\", \"coord_y\", \"timer\");\\\n    if timer:match([[%b\"\"]]) ~= nil then\\\n      parameters = table.pack(coord_x, coord_y);\\\n      spell_values = table.pack(\"coord_x\", \"coord_y\");\\\n      \\\n      timer = timer:match([[%b\"\"]]):sub(2, -2);\\\n      --[[remove the quotemarks]]\\\n      spell_names[timer] = spell_names[timer] or (1 + #spell_names);\\\n      local idx = spell_names[timer];\\\n      spell_names[idx] = spell_names[idx] or timer .. \"nomatch\";\\\n      new_spell.timer = timer;\\\n    end\\\n    \\\n    for i = 1, #spell_values do\\\n      local variable = spell_values[i];\\\n      local param = tonumber(parameters[i]);\\\n      if param == nil then\\\n        error(\"Trying to add a non-number \" .. variable, 0);\\\n      elseif math.type(param) ~= \"float\" then\\\n        error(\"Trying to add a non-double \" .. variable);\\\n      end\\\n      new_spell[variable] = param;\\\n    end\\\n    new_spell.name = active_name;\\\n    spell_values[3] = \"timer\";\\\n    --[[no need to check if timer is already a spell value]]\\\n    spell_values[4] = \"name\";\\\n    \\\n    for i = 1, 4 do\\\n      local value = spell_values[i];\\\n      new_spell[value] = new_spell[value] .. \"|\";\\\n      used_space = used_space + #new_spell[value];\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      new_spell.space = used_space .. \"|\";\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[Add the extra space taken up by our space size marker]]\\\n    used_space = used_space + BP.used_space.blueprint;\\\n    \\\n    BP.comp.spell[actives_index] = new_spell;\\\n    BP.used_space.blueprint = used_space;\\\n    \\\n    --[[Check if we have to log the added data]]\\\n    local logging_check = BP.debug.can_halt or BP.debug.can_log;\\\n    if logging_check then BP.debug.log() end\\\n    \\\n    --[[If we can halt, decrement our halting limit by 1]]\\\n    if BP.debug.can_halt then\\\n      BP.debug.halt_limit = BP.debug.halt_limit - 1;\\\n    end\\\n    return \":const int spell_\" .. actives_index .. \" \" .. used_space;\\\n  end\\\n  \\\n  function BP.comp.concat_actives()\\\n    local actives = {};\\\n    \\\n    local spells = BP.comp.spell;\\\n    --[[table holding the compacted data]]\\\n    local spells_count = #spells;\\\n    --[[number of spells recorded]]\\\n    \\\n    BP.comp.recorded_blueprint([[\"concat_actives\"]], false);\\\n    --[[Make sure that the recorded blueprint is valid]]\\\n    \\\n    local concat_debug = {};\\\n    if BP.debug.can_display then\\\n      local fmt = BP.debug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    else\\\n      concat_debug.format = \"\";\\\n      concat_debug.separation = \"\";\\\n      concat_debug.bit_format = \"%s\";\\\n      concat_debug.spell_data = \"%s\";\\\n    end\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    for i = 1, spells_count do\\\n      --[[/*\\\n          * spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data = spells[i];\\\n      local data_pack = {};\\\n      local data_names = table.pack(\\\n        \"loop_bit\", \"sync_bit\",\\\n        \"base\", \"space\", \"timer\",\\\n        \"coord_x\", \"coord_y\",\\\n        \"name\"\\\n      );\\\n      local data_set = {};\\\n      local idx = 1;\\\n      if BP.debug.can_display then\\\n        --[[Sets the data_set for the case where we can display]]\\\n        data_set = table.pack(\"loop_sign\", \"sync\");\\\n        for _, set in ipairs(data_set) do\\\n          local name = data_names[idx];\\\n          data_pack[name] = table.pack(\\\n            name:gsub(\"_bit\", \"\"),\\\n            --[[removes the _bit from the name]]\\\n            data[set]\\\n          );\\\n          idx = idx + 1;\\\n        end\\\n        data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        \\\n        data_set = table.pack(\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      else\\\n        --[[Sets the data_set for the case where we can't display]]\\\n        data_pack.chunk_end = \"\";\\\n        data_set = table.pack(\\\n          \"loop_sign\", \"sync\",\\\n          \"timer_base\", \"space\", \"timer\",\\\n          \"coord_x\", \"coord_y\",\\\n          \"name\"\\\n        );\\\n      end\\\n      for _, set in ipairs(data_set) do\\\n        local name = data_names[idx];\\\n        data_pack[name] = table.pack(\\\n          data[set], set, \\\n          #data[set]\\\n        );\\\n        idx = idx + 1;\\\n      end\\\n      \\\n      actives[1 + #actives] = concat_debug.format;\\\n      for _, name in ipairs(data_names) do\\\n        local spell_data = data_pack[name];\\\n        local fmt = \"\";\\\n        --[[Determine the format we're using]]\\\n        if name:match(\"_bit\") == \"_bit\" then\\\n          fmt = concat_debug.bit_format;\\\n        else\\\n          fmt = concat_debug.spell_data;\\\n        end\\\n        actives[1 + #actives] = fmt:format(table.unpack(spell_data));\\\n      end\\\n      actives[1 + #actives] = concat_debug.format;\\\n      actives[1 + #actives] = data_pack.chunk_end;\\\n    end\\\n    \\\n    return table.concat(actives);\\\n  end\\\n  \\\n  \\\n  function BP.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from BP.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local spell_index = #BP.comp.spell;\\\n    local spell = BP.comp.spell[spell_index];\\\n    local logging_text = table.pack(\\\n      \"%s| BP has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"timer_base\",\\\n      \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 8;\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value];\\\n      if spell_value == nil then\\\n        err_msg = \"Cannot log nil value \" .. value;\\\n        error(err_msg);\\\n      end\\\n      local fmt = table.pack(log, value, spell_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, spell_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function BP.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * BP.comp.add_spell\\\n        * * BP Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local should_halt = BP.debug.can_halt or BP.debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if BP.debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if BP.debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #BP.comp.spell,\\\n        \" \"\\\n      );\\\n      if #BP.comp.spell == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = BP.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; Separated in \"chapters\"\n; \n\n; The Spell Compactor\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return BP.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; Define a base for the timer\n#timer_modulo(modulo) {lua(BP.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(BP.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return BP.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n; Adds a useinstant() spell\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0.0, \\\n  0.0\\\n)}\n\n; Adds a useposition() spell\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n; Concatenates the actives and returns the total recording space\n#recorded_actives \"{lua(return BP.comp.concat_actives())}\"\n#recording_size {lua(return BP.used_space.blueprint)}\n\n; Secure Compactor\n; Defines a security sequence\n#recorded_security(secure_name) {lua(\\\n  return BP.comp.recorded_secures([[{secure_name}]])\\\n)}\n; Defines a module to secure\n#add_secure(secure_name) {lua(BP.comp.add_secure([[{secure_name}]]))}\n; \n; Concatenates the secures and returns the total recording space\n#recorded_secures \"{lua(return table.concat(BP.comp.module))}\"\n#secures_space {lua(return BP.used_space.secure)}\n\n; EasyEra cat\n; Assigns a priority to an element\n#set_priority(element) {lua(\\\n  return BP.comp.set_priority([[{element}]])\\\n)}\n; Returns a ternary: string to that's placed in disable.era\n#disable.era {lua(return BP.comp.disable_era())}\n; Returns a bool to know if all elements we wanted to disable\n; got disabled\n#disable_era {lua(return BP.comp.era_to_disable())}\n; \n; Watercat\n; Reset the watercat index\n#watercat_index_reset watercat = 0\n; \n; Generalized substring used in watercat\n#watercat_sub(list) sub(\\\n  {list}, \\\n  watercat, \\\n  index({list}, \"|\", watercat) - watercat\\\n)\n; Line 1 that toggles the software\n#watercat_line1(secure_level) software_toggle_loop:\\\nsoftware.toggle(\\\n  {watercat_sub(software_list)},\\\n  {secure_level} <= s2i({watercat_sub(software_secure)}, -1)\\\n)\n; line 2 that increments watercat\n#watercat_line2 watercat = 1 + index(software_list, \"|\", watercat)\n; line 3 that creates a while loops\n#watercat_line3 gotoif(software_toggle_loop, watercat < software_len)\n; \n; Concat the software levels\n#software.concat(concat_mode) {lua(\\\n  return BP.comp.concat_software([[{concat_mode}]])\\\n)}\n\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n#software.secure(software_name, level) {lua(\\\n  BP.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}\n"],["Blueprint Compactor resources","\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#bp_comp BP Comp\n#blueprint_package(name) {bp_comp}:{name}\n#tower_handler {blueprint_package(Tower Handler)}\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{bp_comp} Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string checkpoint_var \"{bp_comp} Pointer Checkpoint\"\n#checkpoint.get global.int.get(checkpoint_var)\n#checkpoint.set(value) global.int.set(checkpoint_var, {value})\n; \n:const string compactor_actives \"{bp_comp} access actives str\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{bp_comp} access secures str\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_secures, {str})\n; \n:const string caller_ID \"{hider.close}{bp_comp} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n\n#idle_mode_str {hider.start}:{hider.close}\n; \n; this is a special string that makes it impossible\n; for a caller script to trigger this value.\n; \n:const string idle_mode \"{idle_mode_str}idle mode\"\n; This string is used by the compactor to detect if entered idle mode\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n"],["Blueprint Compactor lib",":import Blueprint Compactor resources\n#package(name) {blueprint_package({name})}\n\n:local int pointer\n:local int checkpoint\n:local string actives\n:local string secures\n; \n:local bool det_timer_base\n:local double timer_base\n:local double clock\n; \n:local string spell_ID\n; \n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[actives]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i = 1, #compactor_vals do\\\n    local value = compactor_vals[i];\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = value .. \"_value\";\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i == 3 then\\\n      local modulo_timer = [[{timer.get} % timer_base]];\\\n      local active_index = Editor_activeIndex(Compactor[value]);\\\n      local cooldown = Editor_moduleCooldown(active_index);\\\n      local fallback = Editor_math(cooldown, \"+\", modulo_timer);\\\n      local s2d = Editor_convertStringToDouble;\\\n      Compactor[val] = s2d(Compactor[value], fallback);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value])\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, pointer, 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  contains({get_bits}, \"#\"), \\\n  checkpoint, \\\n  pointer + {get_space}\\\n)\n\n; \n#modulo_timer {timer.get} % timer_base\n"],["Time Stopper",":import Blueprint Compactor lib\n:name {package(Time Stopper)}\n:budget_cap 200\n\ngame.newround()\nkey.x()\n\n; advance a frame if the compactor is activated\ngotoif(advance_frame, contains(impulse(), \"key.x\"))\n\nmain:\n; Prevents a clunky user interface.\nglobal.unset(timer_var)\n\n; Since the sequences we send are empty, the pointer offset\n; is only used for the second instance run by game.newround()\n; to pause the game.\n{pointer.set(0)}\n{comp_active.set(\"\")}\n{comp_secure.set(\"\")}\n\n; start our compactor so we can configure our timings.\nexecute(\"{tower_handler}\")\n\nwaitwhile({timer.get} <= 0.0)\n; We must ensure that the compactor successfully initialized\n; otherwise, we'd be too fast and check if there's any enemies\n; before the game had time to spawn any in\n\npause()\n; we can now pause the game\n\nwaitwhile(health(false) > 0.0 && enemies() > 0)\n; Stop the compactor if we're dead.\n; \n; Usually, I'd prefer we do {caller.set(idle_mode)}, as\n; that safely terminates all instances of the tower handler,\n; but instead, we have to both mark the time of death but to also\n; ensure that, when we unset timer_var, there's not an actively\n; running ticker that makes {timer.get} != 0.0\nstop(\"{tower_handler}\")\n\nadvance_frame:\n; make sure that we don't pause the game before the timer is initialized\nwaitwhile({timer.get} <= 0.0)\n\n; unpause the game to let a frame go by\nunpause()\n\n; pause the game\n; this is how we do frame-by-frame advancing\npause()\n"],["Debugger",":import Blueprint Compactor lib\n:name {package(Debugger)}\n:budget_cap 101\n\n; The debugger attatchment to the\n; core blueprint compactor\n; \n; It's used to go through the data you sent\n; to the tower handler for execution\n\nkey.x()\n\n:global string spell_chunk\n; \n:global string loop_bit\n:global string sync_bit\n; \n:global string spell_size\n:global string spell_timer\n; \n:global string coord_x\n:global string coord_y\n; \n:global string spell_name\n\n#get_val(val) {lua(return Compactor.{val})}\n\nstop(\"{tower_handler}\")\n; Stop all instances of the tower handler\n\npointer = {pointer.get}\ncheckpoint = {checkpoint.get}\nactives = {comp_active.get}\nsecures = {comp_secure.get}\n; initialize our variables\n\n{pointer.set(pointer)}\n{checkpoint.set(checkpoint)}\n{comp_active.set(actives)}\n{comp_secure.set(secures)}\n{caller.set(\"debuging\")}\n; Start and end the block hider\n\nglobal.int.set(\"pointer\", pointer)\nglobal.int.set(\"loop checkpoint\", checkpoint)\n\nspell_chunk = sub(actives, pointer, {get_space})\n; Get the spell chunk, aka, the spell that\n; the pointer is pointing at\n; \nloop_bit = sub(actives, pointer, 1)\nsync_bit = sub(actives, pointer + 1, 1)\n; Show the bits so the user can know what they mean, this is\n; likely unnecesairy as they probably already know what it means\n; but for now, while nobody knows what the compactor even is,\n; this data stays visible\n; \nglobal.string.set(\"timer_base\", {get_val(timer_base)})\nspell_size = {get_val(space)}\n; \nspell_timer = {get_val(timer)}\ncoord_x = {get_val(coord_x)}\ncoord_y = {get_val(coord_y)}\nspell_name = {get_val(name)}\n; \n; Increment our pointer to point to the next spell\n{pointer.increment}\n; Save it to our global pointer\n{pointer.set(pointer)}\n; \nglobal.string.set(\"secures\", \"<br>\" . secures)\n; Show the secures as well, this should be a short string\n"],["Tower Handler",":import Blueprint Compactor lib\n:name {tower_handler}\n:budget_cap max\n\n; detect if the handler is in idle_mode\n#idle_mode contains(idle_mode, {caller.get})\n\nexecute(\"{package(Debugger)}\")\n; To support debugging, you enable the script called \"Debugger\"\n; once it executes, it will stop all instance of the tower handler\n; \ngotoif(\\\n  if({timer.get} == 0.0, start_timer, start_secures), \\\n  contains(impulse(), \"{tower_handler}\")\\\n)\n; The handler is in charge of spell activations and module secures\n; Because spell activations need a timer, there will always be 1 instance\n; running that is in charge of keeping the timer updated\n; \n; If we pass the gotoif(), we're in charge of casting spells\n; we are not the instance that's keeping the timer as doing so\n; would prevent people from using executesync(\"{tower_handler}\")\n; \n\n; We use local variables to prevent a messy interface\n; And to let the user have more instances running at once\n; \npointer = {pointer.get}\n; Potential offset when executing spells.\n\ncheckpoint = {checkpoint.get}\n; Point at which we return on looping spells\nactives = {comp_active.get}\n; Our list of spells to execute\n\n{comp_secure.set({comp_secure.get})}\n; makes sure that the secures string is included in the block hider\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We stop the block hider started by {pointer.set()}\n; by setting the caller. This is also used so that\n; the user knows who accessed the tower hander\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nexecute(\"{tower_handler}\")\n; We now make a copy of ourselves.\n; This is how we start securing modules\n; If there is no timer yet, this will first\n; initialize the timer which starts securing modules\n\nassign_base:\n; We try to assign a base to ourselves.\n; Since the user could have set the base at any point\n; in the recording process it's not enough to try to assign a base\n; once the pointer is set to 0\n; \ntimer_base = {get_base}\n; \n; {get_base} returns utcnow() if we didn't find a base.\n; Thanks to the budget, the value returned by utcnow()\n; will be the same until we let a frame pass\ndet_timer_base = timer_base != utcnow()\n\nloop:\n; We loop for as long as our actives still holds\n; at least 1 spell to activate\n; \n; If this is a loopable blueprint, we can be in\n; the loop when pointer == checkpoint more than once. If we've \n; looped over and have determined the timer base, we must\n; wait for our modulo_timer to reset back to 0.0\n\nclock = if(\\\n  pointer == checkpoint && det_timer_base, \\\n  1.0 + floor({timer.get} / timer_base), \\\n  0.0\\\n)\n\n; Here, we make sure that execution is halted until\n; {modulo_timer} is reset to 0.0 or until we enter idle_mode\nwaituntil({timer.get} >= timer_base * clock || {idle_mode})\n\n; Since the modules clock is used in the waitwhile,\n; we calculate the value here to save on processing\nclock = {get_timer}\n\n; we lock up the handler until it's time to use a spell\n; we stop waiting if we've entered idle mode to safely shut down\nwaituntil({modulo_timer} >= clock || {idle_mode})\n\n; Prevent activating a spell if we're in idle mode\nspell_ID = if({idle_mode}, \"\", {get_name})\n\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell or set it to 0 if\n; we must loop over. \n\n#end_of_compactor -1 == index(actives, \"|\", pointer)\n; if we can't find the separation character `|` in our string at\n; offset pointer, we've successfully cleared our activation sequence\n; and can safely exit.\n; If index can't find the character, it returns -1\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  end,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would stop, de-synchronizing things\n\nstart_secures:\n:local double i\ni = 1.0\nsecures = {comp_secure.get}\n{comp_secure.set(\"\")}\n; Clear the secure field to not over-populate the active scripts count.\n\nloop_secures:\ndisable.inf(sub(secures, pointer, index(secures, \"|\", pointer) - pointer))\n; try to disable the module we're pointing at\n\n; Skip waiting a frame if we have enough xp to secure another module\ngotoif(secures_no_frame, disable.inf.cost() <= xp())\nwaitframe()\n\nsecures_no_frame:\n; increment our pointer only if we managed to secure a module\npointer = if(\\\n  disable.inf.cost() > 1000.0 ^ i, \\\n  1 + index(secures, \"|\", pointer), \\\n  pointer\\\n)\n; increment our disable.inf.cost() indicator only if\n; our indicator has become out of date\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\n\ngoto(if(\\\n  contains({caller.get}, idle_mode) \\\n  || index(secures, \"|\", pointer) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n; We end the instance if we've secured all the modules we had to\n; or if we've entered idle_mode\n\nstart_timer:\nexecute(\"{tower_handler}\")\n; We must create another instance of ourselves\n; to start securing modules.\n; \n; Thanks to the budget, we can save a line here\n; by using the waitframe() in the timer\n\ntimer:\n{timer.add(time.delta())}\nwaitframe()\ngotoif(timer, {caller.get} != idle_mode)\n; The timer will be incremented until one of these actions are performed\n; - call the compactor outside of towertesting\n; - stop all instances of the compactor\n; - set the caller_ID to the string called idle_mode\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; This would make it so that the user never actually needs to start\n; their script with global.unset(timer_var), but I'm honnestly not sure\n; why it doesn't get set to 0.0\n\nidle:\n{caller.set(idle_mode)}\n\nend_instance:\n"]]}}
```

# Developer package

This package includes the [Debugger](Debugger.tpt2) and [Time Stopper](Time%20Stopper.tpt2) scripts along with the ordinairy [Tower Handler](Tower%20Handler.tpt2) that you can chose to import, but it's the same as in the non-developer package import.

## Requirements

- impulses: 2
- conditions: 0
- actions: 36
- scripts: 3
- min budget: 200

```
7Vzbbts2GH4VTwV6sbmq5CZNGyRp0fZiu1qB9W4OAomibCISKUhUnaztM+xV9gYF2hcbdHJkmZR1siNZPwoYjU3yI/8zLf/fFyVAPvF4oJz//UUxECeMRv9X5qGmaXiBKfYJUheMM2LPTcRowA3K409n8asZv2pbr3bAfUIXKmKUG4QGyYIJmkpcL3QCXFjwJH49vcX36p0yVeb2wmGm4aghDTAXjtV5NC7ZajKWUK5KRutnFwH5B19qV+8+Tt4z15t8ZIRy7AvPtX0iLcXS9RQrPaEMzshgDIRwEEwi6X7GwSTgRcSTTtYPMAr9CutrdqZWfIdRyIVq0E/T1c8/sRX2J78b1HKw/7DFdImVQfhqSRycvI2Y6xk+CRhVLRaa2dvpgZK31IVUm8K3ZxeXhfdfyDRUpjm6MFysekYY4PJTaHbuFCZjjuxoNo9Eoy6x4fBlYYt6Ci8851Xb84jl9PRp4gq5nZJkhD6LD48pdgkOVMRCKlFBcWulzrA2pIAzbxxWZMeCDOnajvJmdT1VEKMWyaLo9VRJI10cU+ORFK98FlJLmSpJoLueKtRwsXKufCIunvzFmefFIvIMdGssog9SISpTxQytBebK+UzTpkoY4Hfp39wP8bfpZgRvox3fYag8mmpnXho9i+FXohhp+K2AR9ESo9sYsDKcUYCZvF+vkdmflqCWx1ntLA3coti8E3w79tcET6N6G/BcYugkXeaUJXPCzDjq4JUobBdkzj46TNLbWpIeN53WYQavAZ5Oqwl+evE80u9au8hwnK1a6GRuWtgMF4QuaqjyITbsx1Q022HMm6D924dmBh52nBu0DOntnAehmYxvYBt1ZJHkp2BGWkLG8jR8wpcu5gSp6/iZLkCohe/+tJssLUy9X4WIdQ4uXPY3YVEiKk1qTNcF0/shL9CQXEPC6c9AjK3EOPv5PflXIziaUQi+MQk/YFSseLo6pwjuKergFAe0hgrq7EAwlBMX+zemEeDhiEZ2WYXIII6Qh9tVHctLKq6oNoXqB6of0BBUPx2LsdkVME6IRxGRwDRqehiE0P4hjsakeh3zQe/70nvNJHWGGPOtmztIUANBHIsdQ0YFRPABKAEGjQiGusea5R5qFkAEx4MiCxCPAxGcFqpCQATPGur0+g+rox9wQxULiL1BhEAxhOn9sBVABESIMiObDvcEQIRQMLLpTTo7TY59avj3a7vaaux/3N//V7aQJzWaxPZl4iG0dT2Gy/dDXqChgdYoQxVjsa3r0F3flZ8D53rctZeIUWSIB55cmP5VHWVnndE7iBmKRAwfopbnxU4SBl3Td5IwhFX5VrSMiyEHniptk4RHlJT3RJlx2ZoyQ2S5ul1x3EvJqk2phYDv4jH5LjriROiMA6MlT0KslswNH0q55rxX+nmhKtwxS8rMI8uQVXdRD2ZjyQ4ZplJbTSPXrhbVMCmsLehVHX6589i9qol4I+MKuOF6asgRZat1Ok72EfGCSSMotjC/2bROWYbeNHPhtTS3kDBL/3JZuuMKnhS9niKHodvNsPawTyEn2hbTWFsdRQVHjUu6cImMBC2nJtlehGrKmV16/AYl0M//3siM0E71EFHY+DLI9rWb/ry1eTXiRwuLtG4h5cSRmtCeCteryzLJtvc5/deKC+U8S7jRr0kI3ioaRPnydVZPnqcVCbEcPHGZtSmyHYWRuJxpHCv2lHQPn/XGl2fhMffRIY7GpHr9fSHofZ+hRJbVTxM2XpdZoYNVxJhjsRWNP3oVM6+mnyTiTRQDmQvMDTJXHxBHY1KQuUDvuel7+wLghcusee3bbpdX+P6cqvRLgqO9xJc810gprf74kPhklccYhz6MUNQaFGyA2BvEseeuYUzvh60AIiBClBnZ9PFe6wARQsFIp2e3sLON76PDAJOH2SXfSFezoPUFLkN7VUTzWBD/3LVbuMQsP2Ok2j5z30f8TcmtCp4DDwgR4ghcHcaOCD4Ahe0gEMFQm0yv+DPNH9+T0VC9ACK4IJRbgHg0iOC0UB8CInjWkUyvXNDK+sYFsPqJZKGhcrwEwt8v2X7U1g/cN8B9M8IQ2A95gYYGWkENVYwb3Dd2PhWKI3uxlVmymnCTUdvyfjXTIlEgSUyoQiFjJw8Vl9hw+LKwsF6itdlF58QxTyoeo1Hjt8jEzN17mvPtMfUaaXXSrMp7U5PRJUewdHgClTJGF9Fu1zKc5Z9aJ7MaFg/Z+ev40R7ib7aNzr18nTTqk3RVuidIgojsp/9n24pTEQskzfoXl3PuOcY99tU7b78FfCcb1hMKsrZMEW9//PtWuP4Lj60EMUTaKUGEptryktofS2/AO1c5+IaakO3keM2kOSWGMF1JirTKHCl1oCsWckKiGhEpV/ftKWX9MMLIlzYOFWvP/vierNqtVh0La09Renm9Pa5DJrFCx5k0HHCZg8SdZKqFHW6UhMvqnW3lOa5CTp5USMe5Iqn7PqyIc6qeA9RXRssLRDcsfzUPWc4z+kAwWrTTMpbRZwKS0etv/wM=
```

## Debugger

The debugger is activated by the tower handler, to enable debugging you just have to enable this script.<br>
This script will stop the tower handler and is used to analyze what it is you're sending to the compactor.

You go through your spells by pressing `key.x`.

You will be shown the following values through the medium of global strings:
- `pointer`: the value that's used to determine what spell is being processed.
- `loop checkpoint`: if your blueprint has the loop bit enabled, the `pointer` will get this value once it must loop.
- `spell chunk`: is the entire string that reprezents your spell.
- `loop bit`: the state of your loop bit, it can either be `/` for nothing happens or `#` for looping.
- `sync bit`: the state of your sync bit, it can either be `/` for nothing happens or `s` for synchronizing.
- `timer base`: what's the largest value the timer can have before it's considered 0 by the `spell timer`.
- `spell size`: the number that gets added to the `pointer` to move to the next spell
- `spell timer`: at what value t must be for your spell to be activated.
- `coord_x/y`: the x/y coordinates for your grounded spell.
- `spell name`: the spells ID used to determine the active index of your spell.
- `secures`: what modules you want to secure.

## Time Stopper

The time stopper is used to plan out your spell activations with a high ammount of precision by letting you go frame by frame through towertesting.

Once activated, it will execute an instance of the Tower Handler to start the timer and pause towertesting on the frame it gets initialized. You then use key.x to advance the game by 1 frame. You are also able to use this tool in conjunction with another compacted blueprint to better understand what is happening on a frame of spell execution.

# Changelog

## version 2.8.2

- Blueprint Compactor timer can now be set to happen based on the cooldown of a module
- Defining `{recorded_blueprint}` will now throw an error if that module wasn't defined in this blueprint activation sequence.
- Changed a few `table.pack` operations made for concatenating 2 values together into simple string concatenation.
- `{concat_actives}` now uses `{recorded_blueprint}` internally to validate if the recorded sequence is valid.
- Inserted the devbuild changelog into this changelog.
- Removed the devbuild entirely as it was not useful.
- Added the 3 devbuild configuration scripts to this package.
- Removed the lua version folder, it's just 1 file and it can stay in here.

## version 2.8.0

- Converted the compactor into a utility package.
- Included the Debugger and Time Stopper utility tools in the package
- Added checkpoint system to the compactor that lets you determine what value the pointer should be reset to once it reaches the end of a loopable blueprint.

## version 2.7.7

I can now confirm that the change did make the compactor a lot more precise.

- Added a helper script [Compactor timer](#time-stopper).

## version 2.7.6

Potentially made the compactor a lot more precise.

Replaced string concatenation with table.concat operations.<br>
Added an error handling function that detects if there's an error and displays it.<br>
Reduced the length of the compactors lines to fit in the guide for size.

## version 2.7.5

Watercat is no longer an infinite loop.<br>
Const values are now done through macros defined in the compactor.<br>
Remade the entire compactor manual.

Macro `recorded_secures` is now called `recorded_security`.<br>
Macro `disabled_era` is now called `disable_era`.<br>
`BP.used_space.active` is now called `BP.used_space.blueprint`.<br>
`BP.comp.active` is now called `BP.comp.spell`.

Added `BP.comp.module` which holds the module ID's you want to secure.<br>
`BP.comp.secure` now holds the space in the recording when you call `recorded_security`.<br>
Overhauled error handling system to now be done via the string when large assert() sequences are used.<br>
Added basic error handling to the entirety of the compactor.<br>
Added timer_base to the list of logged values.<br>
`BP.comp.concat_actives` has been modified to be easier to update and maintain.

## version 2.7.4

Moved the ingame compactor to the root README.<br>
Made the unofficial winAI4 script work.<br>
Re-worked this README.md to be easier to understand.<br>
Discord post is on hold until I get feedback on this README.md

## version 2.7.3

Made the last tweeks to the compactor.<br>
The user can now soft-stop the compactor by directly changing the caller_ID to the const string idle_mode.<br>
Replaced the Spell Compactor discord post with the Blueprint Compactors.<br>
Fixed typos in the watercat and easy eracat macros.<br>
Updated and fixed all warnings from the lua version of the compactor.

## version 2.7.2

Removed To Be Done<br>
The user can now define a base for their timer.<br>
The compactor can now also secure modules durring towertesting.<be>
Added watercat and easy eracat macros.

## version 2.7.3

Synchronized the devbuild version with the updated made to the live version.<br>
Using {timer_modulo} now adds the extra space to the total space sum.<br>
The compactor uses the timer_base correctly, so that looping over does not cause instant execution.<br>
Replaced BP.misc.space and BP.misc.sync_ammount with BP.used_space and BP.sync_ammount.<br>
Added the watercat_index_reset macro that resets your index to 0.<br>
Fixed misspellings in the easy_era cat configuration macros.<br>
Fixed uninitialized local variables being used as apposed to their initialised counterparts.

## version 2.7.0

Added secures compatibility.<br>
Compactor Resources now has macros that let you set priorities for disabling era abilities.

## version 2.6.8

Renaming package to "Blueprint Compactor".<br>
Changed root lua table to "BP".<br>
Added the 2 new config files to the repo.

## version 2.6.7

Added 2 new config spaces. "Secures Config" and "Software Config".<br>
Sort of finished Software Config, just need to figure out the output format.

## version 2.6.4

Added a timer_base to the compactor. The user now defines the base used for their timer via the macro {timer_modulo(`base`)}

## version 2.6.0

Added a To Be Done<br>
At this stage, I'm never going to be able to get any work done with it.

Modified recorded_blueprint to also save the ammount of space used in the recording to a global table Spell.comp.blueprint. This way, the user can retrieve this value dynamically in lua code, and, as shuch, does not need to manually change the value after modifying the blueprint.

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
