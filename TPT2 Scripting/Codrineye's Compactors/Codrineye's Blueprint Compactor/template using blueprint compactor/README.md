This source import gives you a skeleton build of a blueprint AI that uses the compactor.<br>
There is no game import code because to communicate with the compactor you need to be in the external editor. Looking at a compactor output ingame is also just plain confusing.

If you want an example that also produces an export code, check out the [unofficial winAI](../Unofficial%20winAI4/README.md) that doesn't have as many comments, but does produce an example you can look at and use.

```
{"workspaces":{"blueprint AI using the compactor":[["Software Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(0)}\n{wave_streaming(0)}\n{wave_surge(0)}\n{critical_wave_jump(0)}\n{wave_momentum(0)}\n{wave_storm(0)}\n{wave_persistence(0)}\n{wave_instability(0)}\n{wave_vortex(0)}\n{wave_catalyst(0)}\n{wave_endurance(0)}\n{new_bounds(0)}\n{wave_marathon(0)}\n{wave_compression(0)}\n{era_surge(0)}\n{era_burst(0)}\n{era_swirl(0)}\n{wave_horizon(0)}\n{no_bounds(0)}\n{era_tunneling(0)}\n{wave_breach(0)}\n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n{wave_restart(0)}\n{infinity_horizon(0)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {len({software.concat(software_list)})}\n\n:const string Wcat \"w#|\"\n\n#watercat_line1(secure_level) \\\nsoftware_toggle_loop:\\\nsoftware.toggle(\\\n  sub(\\\n    software_list, \\\n    lig(Wcat), \\\n    index(software_list, \"|\", lig(Wcat)) - lig(Wcat)\\\n  ),\\\n  {secure_level} <= s2i(\\\n    sub(\\\n      software_secure, \\\n      lig(Wcat), \\\n      index(software_secure, \"|\", lig(Wcat)) - lig(Wcat)\\\n    ),\\\n    0\\\n  )\\\n)\n; sub = 3\n; lig = 1\n; a.i = 3\n; index = 3\n; c.i = 3\n; s2i = 2\n; software.toggle = 2\n; sub + lig + a.i + index + lig + lig = 3 + 1 + 3 + 3 + 1 + 1 = 12\n; c.i + lig + s2i + sub + lig + a.i + index + lig + lig \n; = 3 + 1 + 2 + 3 + 1 + 3 + 3 + 1 + 1\n; = 4 + 5 + 4 + 4 + 1 = 9 + 8 + 1 = 18\n; \n; 2 + 12 + 18 = 32\n\n#watercat_line2 lis(Wcat, 1 + index(software_list, \"|\", lig(Wcat)))\n; lis + c.i + index + lig = 2 + 3 + 3 + 1 = 9\n\n#watercat_line3 gotoif(software_toggle_loop, lig(Wcat) < software_len)\n; gotoif + c.i + lig = 2 + 3 + 1 = 6\n; \n; 31 + 9 + 6 = 46\n\n#watercat_index_reset lis(Wcat, 0)"],["Secure Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Security Config\n\n; \n; Welcome to security config, where you define\n; what modules you want to secure and in what order\n; \n; Since securing isn't very complicated, logging and halting\n; has not been added, as there's not much for you to keep track of\n; \n; You have 2 macros at your disposal\n; add_secure(secure_name) is the name ID that you want to be secured\n; recorded_secures(secures_name) will return a const int called\n; secures_<secures_name> which holds the ammount of space your secures\n; have taken up\n; \n; your compacted secures are in the const string recorded_secures\n; and the total size of your recorded_secures is in the\n; const int secures_space\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{add_secure(barrier.temporal)}\n; tells the compactor you want to secure barrier.temporal\n{add_secure(spell.void)}\n; means that you want to secure spell.void\n; after you've secured barrier.temporal\n\n{recorded_secures(blue)}\n; Gets you the constant secures_blue, which you can use to\n; isolate this secures sequence by using\n; sub(recorded_secures, 0, secures_blue)\n; \n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n:const string recorded_secures \"{lua(\\\n  return table.concat(BP.comp.secure);\\\n)}\"\n:const int secures_space {lua(return BP.used_space.secure)}\n"],["Spell Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; Please read the compactor manual on the repo for a better\n; understanding of how to use it\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; timer_modulo(modulo)\n; Should be used before you use recorded_blueprint to define a\n; blueprint that can loop\n; \n; this modulo value is used to \n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n\n{add_spell.instant(barrier.temporal, 0.0)}\n; adds the instant spell `temporal barrier` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t >= 0.0\n\n{recorded_blueprint(start, false)}\n; defines the blueprint called \"blueprint_start\" that doesn't loop\n; the spell activation sequence when it executes the last spell\n\n{synchronize(2)}\n; makes the next 2 recordings happen on the same game_tick\n\n{add_spell.instant(spell.response.neutral, 0.0)}\n; adds the instant spell `neutral response` to be used when t >= 0.0\n{add_spell.grounded(spell.void, 10.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t is a multiple of 10.0\n{timer_modulo(0.0)}\n{recorded_blueprint(loop, true)}\n; defines the blueprint called \"blueprint_loop\" that loops\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n; adds the instant spell `snap of destiny` to be used\n; when t is a multiple of 28.0\n\n; \n; If you just sent the sequence `recorded_actives` to the compactor\n; you'd execute\n; temporal barier, void, neutral response, void\n; and loop back to using temporal barrier\n; \n; Notice that, since blueprint_loop has the loop property\n; snap of destiny will never be executed\n\n; \n; To execute just blueprint_start, you can cut that sequence\n; by using sub(recorded_actives, 0, blueprint_start)\n; \n; If you want to isolate blueprint_loop, you cut it using\n; sub(recorded_actives, blueprint_start, blueprint_loop - blueprint_start)\n; \n; and if you want to use snap of destiny every 28 seconds you use\n; sub(recored_actives, blueprint_loop, recording_size)\n; The last spell always gets the looping tag\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return BP.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the concat operation one more time, which\n; can get very expensive if you have a big recording sequence\n\n:const int recoring_size {lua(return BP.used_space.active)}\n"],["example_text library",":import Secure Config_blueprint AI using the compactor\n:import Spell Config_blueprint AI using the compactor\n:import Blueprint Compactor resources\n\n; \n; A blueprint AI most of the time\n; has a library for convenience\n; \n; Here, we import the Spell and Secure Configs you just made\n; and the Blueprint Compactor resources\n; \n; if you get an error saying\n; 'Import failed: Script \"Blueprint Compactor resources\" does not exist!'\n; Please make sure you have Codrineye's Spell Compactor imported\n; \n\n#package(name) example_text:{name}\n\n; \n; this package macro is kept for use in the\n; :name function for consistent naming and\n; to easily detect if you were called by a\n; scrit of your own\n; \n; As of game update 0.49.0, you no longer\n; need to include the package name when executing\n; as it will automaticall execute the script of the\n; same name inside of your package\n; if none are found, it will try to execute a script\n; of that name, that is not included in a package\n; \n; My recommendation is that you keep the execute format\n; execute(\"package:name\")\n; so that it's easier to understand what you're looking at\n; when making a source project\n; \n\n#identifier \"example_text\"\n\n; \n; identifier is a string used when creating\n; global variables that ensures your variable\n; is unique to your AI\n; \n; This identifier should preferably\n; be the package name to ensure you're\n; the only one who can access it\n"],["blueprint AI caller",":import example_text library\n:name {package(blueprint AI caller)}\n\n; \n; this is a caller script, it\n; can be integrated into any\n; part of your script, but\n; so that you don't have to read\n; a novel, and so I don't have to write a novel\n; this is what you have to do for your blueprint\n; to be executed by the blueprint compactor\n; \n; the macro names you see here have been declaired inside\n; of Blueprint Compactor Resources, which you imported in your library\n; \n\n{pointer.set(0)}\n; \n; Set a hiding block for your script, this prevents\n; the recording string from being shown on the user interface\n; as this string is usually rather large\n; \n; You can also use the pointer to start your actives string at an offset\n; since every add_spell macro returns a spell.<number> constant\n; with the ammount of space in your recording. To start at the second\n; spell, you can set the pointer to spell_2\n\n; \n; To ensure that the compactor starts up the timer, you should unset\n; the global variable\nglobal.unset(timer_var)\n\n{comp_active.set(recorded_actives)}\n; this sends the entirety of your recorded_actives to the compactor\n; if you want to isolate a blueprint, you will have to use a substring\n; of the recorded_actives to successfully isolate it\n; \n; If you add an offset to your pointer, this is the value\n; your offset will be used on\n\n{comp_secure.set(recorded_secures)}\n; this sends the compactor a list of the modules you want to secure\n; the compactor will try to secure the module as soon as possible\n; \n\n; For the compactor to interract with your game, you'll have to execute it\nexecute(\"{blueprint_compactor}\")\n; This is the name for the compactor. It's going to stop the hiding blocker\n; by initializing the variable called caller_ID\n; \n; Once you run the compactor, it will start up a timer\n; if the value of {timer.get} is 0\n; \n; If you want the compactor to shut down, you can either use\nstop(\"{blueprint_compactor}\")\n; for an immediate stop, or you can use\n{caller.set(idle_mode)}\n; which is the internal flag to stop execution\n"],["blueprint handler",":import Software Config_blueprint AI using the compactor\n:import example_text library\n\n; This is how to use easy_era cat\n\n; We set a priority system\n; We will secure the elements fire, water, earth, air\n; and so on until neutral, in this exact order\n{set_priority(fire)}\n{set_priority(water)}\n{set_priority(earth)}\n{set_priority(air)}\n{set_priority(nature)}\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(electricity)}\n{set_priority(universal)}\n{set_priority(neutral)}\n\n; This macro creates the ternary string that ensures the elements\n; get disabled in the specified order\ndisable.era({disable.era})\n\n; This macro is a condition that's true as long as\n; we haven't disabled all our elements\ngotoif(0, {disabled_era})\n\n; Time to use watercat with a static security\n\n{watercat_line1(1)}\n; Only secures the softwares that have a security level of 1 or higher\n\n{watercat_line2}\n; makes our index point to the next software\n\n{watercat_line3}\n; makes us go back to watercat_line1 until we've set all our software"],["watercat with dynamic security",":import Software Config_blueprint AI using the compactor\n:import example_text library\n; We don't need anything from our library, but it's good practice\n; to include it in your scripts for naming\n\n:local int security\n; this is how we set the security level\n\nsecurity = 1\n{watercat_line1(security)}\n; makes our security level directly linked to the security variable\n{watercat_line2}\n{watercat_line3}\n\ngotoif(99, security == 2)\n; just to prevent this from being an infinite loop,\n; we have an exit condition\n\nwait(5.0)\n; after 5.0 seconds have passed, we reset our index\n{watercat_index_reset}\n\n; then, we set our security to 2\nsecurity = 2\n\n; and we use line3 again to return to line1\n{watercat_line3}\n\n; alternatively, we can also use\ngoto(software_toggle_loop)\n"]]}}
```

This workspace does not contain an integrated compactor, as having more than just 1 would be wasting script space and very computationally demanding.
