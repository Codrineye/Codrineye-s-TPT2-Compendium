# Codrineye's Compact Spell-Caster
This is a library to be used within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/) with the purpose of condensing all the programming behind the activation logic of a blueprint into one single script called 'sync'<br>
This tool comes with an indepth explanation for how it works within the source code, so you can simply import it, or use the provided `.tpt2` files which include these comments, [Cods Spell Compactor](Cods%20Spell%20Compactor.tpt2) [Spell Config](Spell%20Config.tpt2) and [winAI_lib](winAI_lib.tpt2) respectively.

## The import package
In order to showcase this package in action, I have adapted the AI for winAI4 to work within this compacted format<br>
The reason I chose winAI4 was also because it is one of the only blueprint AI's that could benifit from it.

## The downsides
I will admit that, as the creator of this package, this tool will hardly ever get used.<br>
I say this because of how rare it is for the activation logic of an AI to surpass the size of a single script, and because I made this tool specifically to streamline the programming of large blueprint activation sequences.

## Introducing Batches
Batches are a simple, yet powerful adition to the compactor.<br>
One of the major struggles of implementing multiple blueprints within the compactor is the clunky manner you get to a desired package of skills, well not anymore,<br>
Thanks to the introduction of batches, all the broken up sections are a dynamically defined length stored within the :const int variable `batch`, which works in tandumn with `increment` to get the full length of all our segments by multiplying them together.

# Source code
the source code is imported within the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/)
```
{"workspaces":{"Codrineye's Compact Spell-Caster":[["Spell Config",":import Cods Spell Compactor\n:name Spell Config\n\n; Welcome to the configuration\n; This is the only area you have to make changes to\n; Here you will configure the following properties\n; *  what active modules you want to be used\n; *  the order in which you want them to be used\n; *  the timings of the activation\n; *  and lastly\n; *  if the module is placed, you will have to specify the coordinates\n; \n; you have 4 functions at your disposal:\n; All of these macros generate :const <type> <token> 'contents'\n; \n; syncronize_module_activation()\n; This macro will create a token sync<sync count> containing the value 'module_count - 1'\n; You will need to specify the amount of modules you want to activate at this time and\n; a delay to the activation\n; This will make it so you have <module_count> sync scripts active at once\n; The excess scripts will remove themselves after spell activation\n; \n; add_batch()\n; This macro will declare the end of one batch and the start of another\n;   it's curently the only macro that returns a :const int, with the token being batch<batch count>\n; A 'batch' means a sellection of modules so that you may separate module sequences\n;   with only needing arithmetic operations\n; By default you're in batch1, if you call for this macro you will move to batch2\n;   by calling this macro, you change the string within sync created by <active_module_list> \n;   so that each batch has equal length\n; \n; add_active_module.type()\n; This macro will create a token spellname<spell count> containing the following values\n; 'spell_timer' . 'coord_x' . 'coord_y' . 'attribute' . 'spell_name' . ';'\n; \n; add_active_module.instant()\n; The first type of addition, where you need to specify the spell name and the timer\n; coord_x and coord_y are 0.0 and the attribute is 'instant '\n; the extra ' ' is there for consistent spacing\n; \n; add_active_module.grounded()\n; The second type of addition, where you need to specify everything field\n; The field meaning spell_name, spell_timer, coord_x and coord_y\n; the attribute for it is 'grounded'\n; \n; I do not recommend defining a ground module as an instant module nor vice versa\n; the system will accept your input, but you will not cast anything\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(barrier.temporal, 0.0)}\n{add_active_module.instant(spell.floof, 0.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 0.0)}\n{add_active_module.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 0.5, 12.0, 10.0)}\n{add_batch}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 1.0)}\n{add_active_module.instant(spell.recharge, 1.0)}\n{add_active_module.instant(spell.cooling, 1.0)}\n{add_active_module.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.response.neutral, 2.0)}\n{add_active_module.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n{add_active_module.instant(spell.refresh, 28.0)}\n{add_active_module.instant(spell.recharge, 28.0)}\n{add_active_module.instant(barrier.temporal, 28.0)}\n{add_active_module.instant(spell.floof, 28.0)}\n{add_active_module.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize_module_activation(3, 0.0)}\n{add_active_module.instant(spell.cooling, 29.0)}\n{add_active_module.instant(spell.recharge, 29.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_active_module.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize_module_activation(7, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 31.0)}\n{add_active_module.instant(spell.recharge, 31.0)}\n{add_active_module.instant(spell.refresh, 31.0)}\n{add_active_module.instant(barrier.temporal, 31.0)}\n{add_active_module.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_active_module.instant(spell.snapOfDestiny, 33.0)}\n\n{syncronize_module_activation(4, 0.0)}\n{add_active_module.instant(spell.snapOfDestiny, 57.0)}\n\n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file rather than copy them\n; Putting the const declaration here is also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n\n:const int spells_count {lua(return #spell.active_module.module_instance)}\n\n:const int sync_precision {lua(return spell.sync_precision)}\n:const int time_precision {lua(return 2 + spell.timer_precision)}\n:const int placement_precision {lua(return 2 + spell.placement_precision)}\n:const int attribute_size {lua(return spell.attribute_size)}\n\n:const int batch {lua(return spell.batch_max_size)}\n:const int increment {lua(return spell.max_name_size)}\n\n\n;/{active_module_list}\n"],["Cods Spell Compactor",":name Lua Madness\n; \n; Package found on discord or on my github repo\n; discord: https://discord.com/channels/488444879836413975/1275961817151307847/1275961817151307847\n; github: https://github.com/Codrineye/Codrineye-s-TPT2-Compendium/blob/main/TPT2%20Scripting/Codrineye's%20Compact%20Spell-Caster/README.md\n; \n; This macro handles every single action\n; The way it works is by creating a string value\n; :const string spellname<spell number> 'data given for the spell'\n; you will get a string dictated as the following values\n; \n; A timer for the module activation, this works in conjunction with winemast\n;   this timer is cut/extended to contain the number of digits seen\n;   in spell.timer_precision\n; \n; A coordinate x for the module, if this spell is placed\n;  similarly to our timer, this too is cut but it is linked\n;  to spell.placement_precision\n; Coordinate y is the same as coordinate x\n; \n; An attribute that is either 'instant ' or 'grounded'\n;   This is always sized 8 characters\n; That permits active modules to be used without a delay\n; \n; And finally, the spell name\n; It is the internal spell name, followed by a ';' to mark its end\n; \n; an extra function of this macro is to create a \"sync\" constant\n; This constant is given a precision dictated by spell.sync_precision\n; \n; There is no need to look beneath this, sync already\n; has you covered on the activation sequence\n; The only requirement is that you have the following macros\n;  * a pointer macro that \"points\" to our curent index block\n;  * a pointer_get that gets the value of your pointer\n;  * a pointer_set that updates your pointer via the pre-defined 'increment'\n;  * a timer macro that indicates the winemast timer\n;  and finally\n;  * a timer_get macro, that retrieves the value of our timer\n; \n; All of these macros are defined inside of winAI_lib\n; \n; \n\n{lua(\\\n  spell = {};\\\n  spell.debugging = false;\\\n  spell.active_module = {};\\\n  spell.active_module.module_instance = {};\\\n  spell.active_module.placement_positions = {};\\\n  spell.active_module.syncronization = {};\\\n  spell.sync_delay = 0.0;\\\n  spell.sync_precision = 2;\\\n  spell.timer_precision = 6;\\\n  spell.placement_precision = 4;\\\n  spell.attribute_size = 8;\\\n  spell.max_name_size = 0;\\\n  spell.batch = {};\\\n  spell.batch_instance = 1;\\\n  spell.batch_max_size = 0;\\\n\\\n  local function x_digit_precision(digits, input)\\\n    return string.sub(string.format(\"%.\" .. digits .. \"f\", input), 1, digits + 2);\\\n  end\\\n\\\n  function spell.add_spell(name, timer, attribute, coord_1, coord_2)\\\n    local excess = table.pack(coord_1, coord_2);\\\n    local spell_index = 1 + #spell.active_module.module_instance;\\\n  \\\n    local batch_update = 1;\\\n    if spell.batch[spell.batch_instance] ~= nil then\\\n      batch_update = batch_update + spell.batch[spell.batch_instance];\\\n    end\\\n    spell.batch_max_size = math.max(\\\n      spell.batch_max_size, \\\n      batch_update\\\n    );\\\n    spell.batch[spell.batch_instance] = batch_update;\\\n  \\\n    local new_spell = {};\\\n    new_spell.name = string.gsub(name, \" \", \"\");\\\n    local syncronization_timer_delay = 0.0;\\\n    if #spell.active_module.syncronization ~= 0 then\\\n      local syncronization_index = #spell.active_module.syncronization;\\\n      local syncronization_parent = spell.active_module.syncronization[syncronization_index].name;\\\n      syncronization_timer_delay = spell.sync_delay * (spell_index - syncronization_parent);\\\n    end\\\n    \\\n    new_spell.timer = x_digit_precision(spell.timer_precision, syncronization_timer_delay + timer);\\\n    new_spell.attribute = string.gsub(attribute, \" \", \"\");\\\n    local attribute_fit = string.rep([[.]], spell.attribute_size);\\\n    new_spell.attribute = string.sub(new_spell.attribute .. attribute_fit, 1, spell.attribute_size);\\\n    new_spell.identifier = [[spellname]] .. spell_index;\\\n    \\\n    if excess[1] == nil then\\\n      excess[1] = 0.0;\\\n    end\\\n    if excess[2] == nil then\\\n      excess[2] = 0.0;\\\n    end\\\n    new_spell.coords = {};\\\n    new_spell.coords[1] = x_digit_precision(spell.placement_precision, excess[1]);\\\n    new_spell.coords[2] = x_digit_precision(spell.placement_precision, excess[2]);\\\n    new_spell.constant = new_spell.timer .. \\\n      new_spell.coords[1] .. new_spell.coords[2] .. \\\n      new_spell.attribute .. new_spell.name;\\\n    new_spell.name_size = spell.sync_precision + #new_spell.constant;\\\n    \\\n    spell.active_module.module_instance[spell_index] = new_spell;\\\n    spell.active_module.placement_positions[spell_index] = new_spell.coords;\\\n    spell.max_name_size = math.max(\\\n      spell.max_name_size, \\\n      new_spell.name_size\\\n    );\\\n    return [[:const string ]] .. new_spell.identifier .. \\\n      [[ ']] .. new_spell.constant .. [[']];\\\n  end\\\n\\\n  function spell.concatinate_spell_names()\\\n    print(\"run\");\\\n    local batch = 1;\\\n    local inc = 1;\\\n    local spells_concat = {};\\\n    local sync = 1;\\\n    if spell.active_module.syncronization[sync] == nil then\\\n      spell.active_module.syncronization[sync] = {};\\\n      spell.active_module.syncronization[sync].name = {};\\\n      spell.active_module.syncronization[sync].name = 0;\\\n      print(spell.active_module.syncronization[sync].name);\\\n    end\\\n    \\\n    local function batch_loop()\\\n      for i = 1, spell.batch[batch] do\\\n        if debugging == true then\\\n          print(\"spell(\" .. i .. \") in batch(\" .. batch .. \") limit to \" .. spell.batch[batch]);\\\n          print(\"inc = \" .. inc);\\\n          print(\"sync(\" .. sync .. \")\" .. spell.active_module.syncronization[sync].name);\\\n        end\\\n        if inc == spell.active_module.syncronization[sync].name then\\\n          spells_concat[1 + #spells_concat] = [[\" . sync]] .. sync .. [[ . \"]];\\\n          sync = math.min(sync + 1, #spell.active_module.syncronization);\\\n        else\\\n          spells_concat[1 + #spells_concat] = string.sub(math.floor(10 ^ spell.sync_precision), 2);\\\n        end\\\n        spells_concat[1 + #spells_concat] = [[\" . spellname]] .. inc .. [[ . \"]];\\\n        spells_concat[1 + #spells_concat] = string.rep(\\\n          [[.]], \\\n          spell.max_name_size - spell.active_module.module_instance[inc].name_size\\\n        );\\\n        if debugging == true then\\\n          print(spell.batch[batch] .. \"-\" .. i .. \">\" .. 0);\\\n          print(spell.batch[batch] - i > 0);\\\n        end\\\n        inc = inc + 1;\\\n      end\\\n    end\\\n    \\\n    spells_concat[1] = [[\"]];\\\n    while (batch < spell.batch_instance) or (inc < #spell.active_module.module_instance) do\\\n      if debugging == true then\\\n        print(\"spell.batch[\" .. batch .. \"] = \" .. spell.batch[batch]);\\\n        print(batch .. \"<\" .. spell.batch_instance);\\\n        print(batch < spell.batch_instance);\\\n        print(inc .. \"<\" .. #spell.active_module.module_instance);\\\n        print(inc < #spell.active_module.module_instance);\\\n      end\\\n      batch_loop();\\\n      if debugging == true then\\\n        print(\"\\n\" .. \"inc = \" .. inc .. \"\\n\");\\\n      end\\\n      local spacer = spell.batch_max_size - spell.batch[batch];\\\n      spacer = spacer * spell.max_name_size;\\\n      spells_concat[1 + #spells_concat] = string.rep([[.]], spacer);\\\n      batch = math.min(\\\n        batch + 1,\\\n        spell.batch_instance\\\n      );\\\n    end\\\n    \\\n    spells_concat[#spells_concat + 1] = [[\"]];\\\n    return table.concat(spells_concat);\\\n  end\\\n\\\n  function spell.syncronize(copies, delay)\\\n    local sync_amount = copies - 1;\\\n    local sync = {};\\\n    sync.count = math.floor(10 ^ spell.sync_precision + sync_amount);\\\n    sync.name = 1 + #spell.active_module.module_instance;\\\n    local sync_index = 1 + #spell.active_module.syncronization;\\\n    spell.active_module.syncronization[sync_index] = sync;\\\n    spell.sync_delay = delay;\\\n    return [[:const string sync]] .. sync_index .. [[ ']] .. string.sub(\\\n      sync.count, \\\n      spell.sync_precision\\\n    ) .. [[']];\\\n  end\\\n\\\n  function spell.add_batch()\\\n    local batch_checkpoint = spell.batch_instance;\\\n    local batch_recording = 0;\\\n    if spell.batch[batch_checkpoint] ~= nil then\\\n      batch_recording = spell.batch[batch_checkpoint];\\\n    end\\\n    spell.batch[batch_checkpoint] = batch_recording;\\\n    spell.batch_instance = batch_checkpoint + 1;\\\n    return [[:const int batch]] .. batch_checkpoint .. [[ ]] .. batch_recording;\\\n  end\\\n)}\n\n#syncronize_module_activation(modules_count, added_dellay) {lua(\\\n  return spell.syncronize(\\\n    [[{modules_count}]], \\\n    [[{added_dellay}]]\\\n  );\\\n)}\n#add_active_module.instant(spell_name, spell_timer) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[instant]],\\\n    0.0,\\\n    0.0\\\n  );\\\n)}\n#add_active_module.grounded(spell_name, spell_timer, spell_location_x, spell_location_y) {lua(\\\n  return spell.add_spell(\\\n    [[{spell_name};]], \\\n    [[{spell_timer}]], \\\n    [[grounded]], \\\n    {spell_location_x}, \\\n    {spell_location_y}\\\n  );\\\n)}\n#add_batch {lua(\\\n  return spell.add_batch()\\\n)}\n\n; This is the macro that concatinates every\n; added active module together\n#active_module_list {lua(\\\n  return spell.concatinate_spell_names();\\\n)}\n\n"],["Spell Config MADE BETTER",":import Cods Spell Compactor MADE BETTER\n\n:name Spell Config\n\n{debug.log(0)}\n{debug.halt_compilation(0)}\n{debug.recordings_before_halt(6)}\n{debug.display_spells(0)}\n{debug.display_spells_in_batch(1)}\n{debug.display_format('\\n|')}\n\n\n; Welcome to the configuration\n; This is the only area you have to make changes to\n; Here you will configure the following properties\n; *  what active modules you want to be used\n; *  the order in which you want them to be used\n; *  the timings of the activation\n; *  and lastly\n; *  if the module is placed, you will have to specify the coordinates\n; \n; you have 4 functions at your disposal:\n; All of these macros generate :const <type> <token> 'contents'\n; \n; syncronize_module_activation()\n; This macro will create a token sync<sync count> containing the value 'module_count - 1'\n; You will need to specify the amount of modules you want to activate at this time and\n; a delay to the activation\n; This will make it so you have <module_count> sync scripts active at once\n; The excess scripts will remove themselves after spell activation\n; \n; add_batch()\n; This macro will declare the end of one batch and the start of another\n;   it's curently the only macro that returns a :const int, with the token being batch<batch count>\n; A 'batch' means a sellection of modules so that you may separate module sequences\n;   with only needing arithmetic operations\n; By default you're in batch1, if you call for this macro you will move to batch2\n;   by calling this macro, you change the string within sync created by <active_module_list> \n;   so that each batch has equal length\n; \n; add_active_module.type()\n; This macro will create a token spellname<spell count> containing the following values\n; 'spell_timer' . 'coord_x' . 'coord_y' . 'attribute' . 'spell_name' . ';'\n; \n; add_active_module.instant()\n; The first type of addition, where you need to specify the spell name and the timer\n; coord_x and coord_y are 0.0 and the attribute is 'instant '\n; the extra ' ' is there for consistent spacing\n; \n; add_active_module.grounded()\n; The second type of addition, where you need to specify everything field\n; The field meaning spell_name, spell_timer, coord_x and coord_y\n; the attribute for it is 'grounded'\n; \n; I do not recommend defining a ground module as an instant module nor vice versa\n; the system will accept your input, but you will not cast anything\n\n{syncronize(2, 0.0)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{syncronize(4, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize(6, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize(5, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file rather than copy them\n; Putting the const declaration here is also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n\n:const string actives '{lua(return spell.concat_actives())}'\n:const int spells_count {lua(return #spell.active)}\n\n:const int sync_precision {lua(return spell.precision.sync)}\n:const int time_precision {lua(return 2 + spell.precision.timer)}\n:const int placement_precision {lua(return 2 + spell.precision.placement)}\n:const int attribute_size {lua(return spell.text.attribute_max_length)}\n\n:const int increment {lua(return spell.active_max_length)}\n\n{debug}\n\n"],["Cods Spell Compactor MADE BETTER",":import Compactors Debugger\n:name lua madness but better\n\n; \n; \n\n{lua(\\\n  spell = {};\\\n  spell.active = {};\\\n  spell.active.batch = {};\\\n  spell.active.batch.max_batch = 0;\\\n  spell.active.sync = {};\\\n  spell.active.sync.index = 0;\\\n  spell.active.sync.copies_internal = 0;\\\n  spell.active.sync.delay_internal = 0;\\\n  spell.active_max_length = 0;\\\n  spell.text = {};\\\n  spell.text.name_max_length = 0;\\\n  spell.text.attribute_max_length = 0;\\\n  spell.text.text_ending_character = ':';\\\n  spell.precision = {};\\\n  spell.precision.sync = 0;\\\n  spell.precision.timer = 0;\\\n  spell.precision.placement = 0;\\\n)}\n\n{lua(\\\n  local function x_digit_precision(digits, input)\\\n    local number = tostring(input):gsub(\" \", \"\"):gsub(\"'\", \"\");\\\n    local format = \"%.\";\\\n    if math.type(tonumber(number)) == 'integer' then\\\n      format = \"%0\"; \\\n    end\\\n    return string.sub(\\\n      string.format(format .. digits .. \"f\", number),\\\n      1,\\\n      digits + 2\\\n    );\\\n  end\\\n\\\n\\\n  function spell.add_batch()\\\n    local batch_index = 1 + #spell.active.batch;\\\n    local batch = {};\\\n    batch.checkpoint = #spell.active;\\\n    batch.size = 0;\\\n    if batch_index > 1 then\\\n      local curent_checkpoint = batch.checkpoint;\\\n      active_batch = spell.active.batch;\\\n      local previous_checkpoint = active_batch[#active_batch].checkpoint;\\\n      batch.size = curent_checkpoint - previous_checkpoint;\\\n    end\\\n    spell.active.batch[batch_index] = batch;\\\n    spell.active.batch.max_batch = math.max(\\\n      spell.active.batch.max_batch,\\\n      batch.size\\\n    );\\\n  end\\\n  \\\n  function spell.syncronization(copies, delay)\\\n    local sync_index = 1 + #spell.active.sync;\\\n    local sync = {};\\\n    sync.copies = -1 + math.tointeger(tonumber(copies));\\\n    sync.delay = 0.0 + tonumber(delay);\\\n    spell.active.sync[sync_index] = sync;\\\n    spell.precision.sync = math.max(\\\n      spell.precision.sync,\\\n      #tostring(sync.copies)\\\n    );\\\n  end\\\n  \\\n  function spell.add_spell(name, attribute, coord_x, coord_y, timer)\\\n    local actives_index = 1 + #spell.active;\\\n    local new_spell = {};\\\n    new_spell.name = name .. spell.text.text_ending_character;\\\n    new_spell.attribute = attribute:gsub(\" \", \"\");\\\n    new_spell.coord_x = 0.0 + tonumber(coord_x);\\\n    new_spell.coord_y = 0.0 + tonumber(coord_y);\\\n    \\\n    new_spell.sync = 0;\\\n    local sync = spell.active.sync;\\\n    local function add_sync()\\\n      --[[/*\\\n          * Function to handle the sync system\\\n          * if we've run through the internal copies\\\n          *   if the next sync exists\\\n          *     increment the index\\\n          *     update our internal copies\\\n          *     add a sync to the spell\\\n          *   setup so we only have 1 return\\\n          *   1 return means only 1 logic sequence\\\n          *   to follow\\\n          * we can continue\\\n          * by increasing the delay and\\\n          * decreasing our internal copies\\\n         */]]\\\n      if sync.copies_internal == 0 then\\\n        if #sync > sync.index then\\\n          sync.index = sync.index + 1;\\\n          sync.copies_internal = sync[sync.index].copies;\\\n          new_spell.sync = sync[sync.index].copies;\\\n        end\\\n        sync.copies_internal = sync.copies_internal + 1;\\\n        sync.delay_internal = 0.0 - sync[sync.index].delay;\\\n      end\\\n      sync.delay_internal = sync.delay_internal + sync[sync.index].delay;\\\n      sync.copies_internal = sync.copies_internal - 1;\\\n      return sync.delay_internal;\\\n    end\\\n    \\\n    local sync_offset = add_sync();\\\n    new_spell.timer = sync_offset + tonumber(timer);\\\n    spell.active[actives_index] = new_spell;\\\n    \\\n    spell.text.name_max_size = math.max(\\\n      spell.text.name_max_length,\\\n      #new_spell.name\\\n    );\\\n    spell.text.attribute_max_size = math.max(\\\n      spell.text.attribute_max_length,\\\n      #new_spell.attribute\\\n    );\\\n    spell.precision.placement = math.max(\\\n      spell.precision.placement,\\\n      #tostring(math.max(new_spell.coord_x, new_spell.coord_y)) - 1\\\n    );\\\n    spell.precision.timer = math.max(\\\n      spell.precision.timer,\\\n      #tostring(new_spell.timer) - 1\\\n    );\\\n  \\\n    local active_length = spell.precision.timer;\\\n    active_length = active_length + spell.precision.sync;\\\n    active_length = active_length + spell.precision.placement;\\\n    active_length = active_length + spell.precision.placement;\\\n    active_length = active_length + spell.text.attribute_max_length;\\\n    active_length = active_length + spell.text.name_max_length;\\\n  \\\n    spell.active_max_length = math.max(\\\n      spell.active_max_length,\\\n      active_length\\\n    );\\\n    local debug_check = debug.can_halt;\\\n    debug_check = debug_check + debug.can_log;\\\n    if debug_check > 0 then\\\n      debug.log();\\\n    end\\\n    local halt_limit = debug.can_halt - debug.should_halt;\\\n    if debug.can_halt > 0 then\\\n      if halt_limit > 0 then\\\n        return debug.halt();\\\n      end\\\n      debug.should_halt = debug.should_halt - 1;\\\n    end\\\n    local constant_int = \"spell.\" .. actives_index;\\\n    local spell_name = [[']] .. new_spell.name .. [[']];\\\n    return [[:const string ]] .. constant_int .. [[ ]] .. spell_name;\\\n  end\\\n  \\\n  function spell.concat_actives()\\\n    local spells = {};\\\n  \\\n    local recordings = spell.active;\\\n    local active_count = #spell.active;\\\n  \\\n    spell.add_batch();\\\n    local batches = spell.active.batch;\\\n    local batch_index = 1;\\\n    local batch_concat = '';\\\n    local index = 0;\\\n  \\\n    local spells_debug = {};\\\n    spells_debug.format = '';\\\n    spells_debug.spacer_open = '';\\\n    spells_debug.spacer_close = '';\\\n    spells_debug.chunk = '';\\\n  \\\n    local spells_format = {};\\\n    spells_format.encase = 0;\\\n    spells_format.batch = 0;\\\n    \\\n    \\\n    local debug_text = debug.text.concat_in_batch;\\\n    debug_text = debug_text + debug.text.can_concat;\\\n    if debug_text > 0 then\\\n      spells_debug.spacer_open = debug.text.spacer_open;\\\n    \\\n      if debug_text == debug.text.concat_in_batch then\\\n        batch_concat = debug.text.concat_format;\\\n        spells[1 + #spells] = batch_concat;\\\n      else\\\n        spells_debug.format = debug.text.concat_format;\\\n        spells_debug.chunk = debug.text.chunk;\\\n      end\\\n    \\\n      spells_debug.spacer_close = debug.text.spacer_close;\\\n    end\\\n  \\\n  \\\n      --[[/*\\\n          * Sequence for concatenation\\\n          * It will get broken up into separate\\\n          * local functions\\\n          * This is done to add implementation flexibility\\\n          * and to improve overall readability\\\n         */]]\\\n  \\\n    local function sequence_encase(sequence)\\\n        --[[/*\\\n            * General purpose function\\\n            * permits easy encasing of\\\n            * any section of code\\\n           */]]\\\n      local spacer = {};\\\n      spacer[1 + #spacer] = spells_debug.spacer_open;\\\n      spacer[1 + #spacer] = sequence;\\\n      spacer[1 + #spacer] = spells_debug.spacer_close;\\\n      return table.concat(spacer);\\\n    end\\\n    local function concat_format()\\\n        --[[/*\\\n            * Function that formats the\\\n            * contents of spells according\\\n            * to the debugging values\\\n           */]]\\\n      local start = '';\\\n      if text_debug == 0 then\\\n        return;\\\n      end\\\n      \\\n    end\\\n    local function number_handling()\\\n        --[[/*\\\n            * Function that handles numbers\\\n            * called by the for loop\\\n            * actions performed outside the for loop\\\n            * for a clean and easy to understand\\\n            * sequence\\\n           */]]\\\n      local function spells_number_formatting(digits, input)\\\n        return spells_debug.format .. x_digit_precision(digits, input);\\\n      end\\\n      \\\n      spells[1 + #spells] = spells_number_formatting(\\\n        spell.precision.sync,\\\n        recordings[index].sync\\\n      );\\\n      spells[1 + #spells] = spells_number_formatting(\\\n        spell.precision.timer,\\\n        recordings[index].timer\\\n      );\\\n      spells[1 + #spells] = spells_number_formatting(\\\n        spell.precision.placement,\\\n        recordings[index].coord_x\\\n      );\\\n      spells[1 + #spells] = spells_number_formatting(\\\n        spell.precision.placement,\\\n        recordings[index].coord_y\\\n      );\\\n    end\\\n    local function text_handling()\\\n        --[[/*\\\n            * Function to handle all text inputs\\\n            * featuring an internal function spacing()\\\n            * that returns a spacing string\\\n            * This is done to keep spacing consistent\\\n            * since spacing is so important, all actions get\\\n            * filtered down through it\\\n           */]]\\\n      local spells_text = '';\\\n    \\\n      local function spells_text_formatting(text)\\\n         return spells_debug.format .. text;\\\n      end\\\n      local function spacing(max_size)\\\n        local spacing_size = max_size - #spells_text;\\\n        local space = string.rep('.', spacing_size);\\\n        return spells_text_formatting(sequence_encase(space));\\\n      end\\\n    \\\n      spells_text = recordings[index].attribute;\\\n      spells[1 + #spells] = spells_text_formatting(spells_text);\\\n      spells[1 + #spells] = spacing(spell.text.attribute_max_size);\\\n    \\\n      spells_text = recordings[index].name;\\\n      spells[1 + #spells] = spells_text_formatting(spells_text);\\\n      spells[1 + #spells] = spacing(spell.text.name_max_size);\\\n    end\\\n    local function batch_handling()\\\n        --[[/*\\\n            * Function that handles batch\\\n            * creation and formatting\\\n           */]]\\\n      local function d()\\\n      end\\\n      \\\n      if debug.text.concat_in_batch == text_debug then\\\n        \\\n      end\\\n      if #batches > batch_index then\\\n        batch_index = batch_index + 1;\\\n      end\\\n    end\\\n  \\\n    while index < active_count do\\\n      index = index + 1;\\\n      number_handling();\\\n      text_handling();\\\n      batch_handling();\\\n      spells[1 + #spells] = spells_debug.format .. spells_debug.chunk;\\\n    end\\\n    return table.concat(spells);\\\n  end\\\n)}\n\n#add_batch {lua(return spell.add_batch())}\n\n#syncronize(copies, delay) {lua(return spell.syncronization(\\\n  [[{copies}]],\\\n  [[{delay}]]\\\n))}\n\n#add_spell(name, attribute, placement_x, placement_y, timer) {lua(\\\n  return spell.add_spell(\\\n    {name},\\\n    {attribute},\\\n    [[{placement_x}]],\\\n    [[{placement_y}]],\\\n    [[{timer}]]\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  '{name}',\\\n  'instant',\\\n  0.0,\\\n  0.0,\\\n  {timer}\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  '{name}',\\\n  'grounded',\\\n  {coord_x},\\\n  {coord_y},\\\n  {timer}\\\n)}\n\n"],["Compactors Debugger","; Lua macros that define functions that\n; permit debugging Cods Spell Compactor\n\n{lua(\\\n  debug = {};\\\n  debug.can_log = 0;\\\n  debug.can_halt = 0;\\\n  debug.should_halt = 0;\\\n  debug.text = {};\\\n  debug.text.can_concat = 0;\\\n  debug.text.concat_in_batch = 0;\\\n  debug.text.concat_format = '';\\\n  debug.text.chunk = \"Chunk Separation\" .. '\\n';\\\n  debug.text.spacer_open = '[';\\\n  debug.text.spacer_close = ']';\\\n)}\n\n; \n; \n\n{lua(\\\n  function debug.log()\\\n      --[[/*\\\n          * Debugger function for logging\\\n          * featuring additional functions to\\\n          * streamline the format in which data\\\n          * is printed\\\n          * using print instead of return to\\\n          * provide as non-intrusive a logging experience\\\n          * as possible\\\n         */]]\\\n    local function print_text(text_type, text_name, text)\\\n        --[[/*\\\n            * text_type is the starting attribute\\\n            * text_name is the name of our text\\\n            *   ex: Name, Name Size,\\\n            *       Attribute, Attribute Size,\\\n            *       coord_x, coord_y,\\\n            *       timer, sync ...\\\n            * text is the text we want returned\\\n            * for simplicity, this is the beginning part\\\n            * It's flexible and does little, but saves room\\\n           */]]\\\n      local printer = {};\\\n      printer[1 + #printer] = text_type;\\\n      printer[1 + #printer] = ' ';\\\n      printer[1 + #printer] = text_name;\\\n      printer[1 + #printer] = \" = \";\\\n      printer[1 + #printer] = text;\\\n      return table.concat(printer)\\\n    end\\\n    local function print_text_type(text_type, text_name, text)\\\n        --[[/*\\\n            * text_type, text_name and text from print_text()\\\n            * function to return the type of [text]\\\n           */]]\\\n      local printer = {};\\\n      printer[1 + #printer] = print_text(\\\n        text_type,\\\n        text_name,\\\n        text\\\n      );\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = \"And is of type\" .. ' ';\\\n      printer[1 + #printer] = type(text);\\\n      return table.concat(printer);\\\n    end\\\n    local function print_text_size(type, name, text, max_length)\\\n        --[[/*\\\n            * type, name and text from print_text()\\\n            * max_length is the size of \\\n            * the maximum in spell.text.type\\\n            * \\\n            * function seems redundant, but it's\\\n            * for flexibility and easier logging\\\n           */]]\\\n      local printer = {};\\\n      local size_text_name = name .. \" Size\";\\\n      printer[1 + #printer] = print_text(\\\n        type,\\\n        size_text_name,\\\n        #text\\\n      );\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = print_text(\\\n        [[Max]],\\\n        size_text_name,\\\n        max_length\\\n      );\\\n      return table.concat(printer)\\\n    end\\\n      --[[/*\\\n         * Separate functions for numbers\\\n         * Parameters text<block> are replaced with\\\n         * number<block> to easily differentiate the two\\\n         * functions separated because text is logged\\\n         * differently to how numbers are logged\\\n         */]]\\\n    local function print_number_type(type, name, number, expected_type)\\\n        --[[/*\\\n            * type, name and number are the same\\\n            * as in print_text_size()\\\n            * expected_type is the type we\\\n            * expect this number to be\\\n            */]]\\\n      local printer = {};\\\n      printer[1 + #printer] = print_text_type(\\\n        type,\\\n        name,\\\n        number\\\n      );\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Should be a number, of type \";\\\n      debugger[1 + #debugger] = expected_type;\\\n      debugger[1 + #debugger] = \", and such \" .. '\\n';\\\n      debugger[1 + #debugger] = \"And is a number of type\" .. ' ';\\\n      debugger[1 + #debugger] = math.type(number);\\\n      return table.concat(debugger)\\\n    end\\\n    local function print_number_size(type, name, number, max_length)\\\n        --[[/*\\\n           * type and name are the same\\\n           * from print_number_type()\\\n           * this time, number is the length for the number\\\n           * max_length is the expected precision from\\\n           * spell.precision\\\n           */]]\\\n      local printer = {};\\\n      local size_number_name = name .. \" Size\"\\\n      printer[1 + #printer] = print_text(\\\n        type,\\\n        size_number_name,\\\n        number\\\n      );\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = print_text(\\\n        size_number_name,\\\n        [[Precision]],\\\n        max_length\\\n      );\\\n      return table.concat(printer);\\\n    end\\\n      --[[/*\\\n         * Special function calls\\\n         * methods to output types\\\n         * for the future\\\n         * These require per-case formatting\\\n         */]]\\\n    local function print_sync(sync_name, sync, info)\\\n      --[[/*\\\n         * sync_name and sync are like\\\n         * text_name and text in print_text()\\\n         * sync requires representation sequences\\\n         * to describe what it represents\\\n         * \\\n         * these sequences can have as many\\\n         * line breaks in them, as the :gsub turns\\\n         * all whitespace [  ] into 1 single space [ ]\\\n         */]]\\\n      local printer = {};\\\n      printer[1 + #printer] = print_text(\\\n        [[Sync]],\\\n        sync_name,\\\n        sync\\\n      );\\\n      printer[1 + #printer] = '\\n';\\\n      local representation = info:gsub(\"%s+\", \" \");\\\n      printer[1 + #printer] = representation;\\\n      return table.concat(printer);\\\n    end\\\n    \\\n    local active = spell.active;\\\n    local spell_index = #active;\\\n    print(print_text_type(\\\n      [[Spell]],\\\n      [[Name]],\\\n      active[spell_index].name\\\n    ));\\\n    print(print_text_size(\\\n      [[Spell]],\\\n      [[Name]],\\\n      active[spell_index].name, \\\n      spell.text.name_max_length\\\n    ));\\\n    \\\n    print(print_text_type(\\\n      [[Spell]],\\\n      [[Attribute]],\\\n      active[spell_index].attribute\\\n    ));\\\n    print(print_text_size(\\\n      [[Spell]],\\\n      [[Attribute]],\\\n      active[spell_index].attribute,\\\n      spell.text.attribute_max_length\\\n    ));\\\n  \\\n  \\\n    print(print_number_type(\\\n      [[Spell]],\\\n      [[coord_x]],\\\n      active[spell_index].coord_x,\\\n      [[float]]\\\n    ));\\\n    print(print_number_type(\\\n      [[Spell]],\\\n      [[coord_y]],\\\n      active[spell_index].coord_y,\\\n      [[float]]\\\n    ));\\\n    print(print_number_size(\\\n      [[Spell Max]],\\\n      [[Coord]],\\\n      #tostring(math.max(\\\n        active[spell_index].coord_x,\\\n        active[spell_index].coord_y\\\n      )) - 1,\\\n      spell.precision.placement\\\n    ));\\\n    \\\n    print(print_number_type(\\\n      [[Spell]],\\\n      [[timer]],\\\n      active[spell_index].timer,\\\n      [[float]]\\\n    ));\\\n    print(print_number_size(\\\n      [[Spell]],\\\n      [[Timer]],\\\n      #tostring(active[spell_index].timer) - 1,\\\n      spell.precision.timer\\\n    ))\\\n    \\\n    print(print_number_type(\\\n      [[Spell]],\\\n      [[sync]],\\\n      active[spell_index].sync,\\\n      [[integer]]\\\n    ));\\\n    print(print_number_size(\\\n      [[Spell]],\\\n      [[Sync]],\\\n      #tostring(active[spell_index].sync),\\\n      spell.precision.sync\\\n    ));\\\n    print(print_text([[Spell]], [[index]], spell_index));\\\n  \\\n    local batch = spell.active.batch;\\\n    local batch_size = 0;\\\n    if #batch > 0 then\\\n      batch_size = batch[#batch].size;\\\n    end\\\n    print(print_number_type(\\\n      [[Batch]],\\\n      [[size]],\\\n      batch_size,\\\n      [[integer]]\\\n    ));\\\n    print(print_number_type(\\\n      [[Spell]],\\\n      [[active_max_length]],\\\n      spell.active_max_length,\\\n      [[integer]]\\\n    ));\\\n    print(print_text([[Batch]], [[index]], #batch));\\\n  \\\n    local sync = spell.active.sync;\\\n    print(print_sync(\\\n      [[internal copies]],\\\n      sync.copies_internal,\\\n      \"Representing how many more sync itterations are left\"\\\n    ));\\\n    print(print_sync(\\\n      [[copies]],\\\n      sync[sync.index].copies,\\\n      \"Being what the internal copies are based of\"\\\n    ));\\\n    print(print_sync(\\\n      [[internal delay]],\\\n      sync.delay_internal,\\\n      \"Representing how much delay got added to the timer\"\\\n    ));\\\n    print(print_sync(\\\n      [[delay]],\\\n      sync[sync.index].delay,\\\n      \"Being the ammount added to the \\\n      internal delay\"\\\n    ));\\\n    print(print_text([[Sync]], [[internal index]], sync.index));\\\n    print(\"Blocker\");\\\n  end\\\n  \\\n  function debug.halt()\\\n    local debugger = {};\\\n    local debug_check = debug.can_halt;\\\n    debug_check = debug_check + debug.text.can_concat;\\\n    debug_check = debug_check + debug.text.concat_in_batch;\\\n    if debug_check <= 0 then return; end\\\n    \\\n    debugger[1 + #debugger] = \"Compilation Stopped,\" .. ' ';\\\n    debugger[1 + #debugger] = \"Debug mode enabled\";\\\n    \\\n    if debug.can_halt > debug.should_halt then\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Logging enabled, logs are visible in \";\\\n      debugger[1 + #debugger] = \"your browsers developer console\";\\\n    end\\\n    \\\n    local text_check = debug.text.can_concat + debug.text.concat_in_batch;\\\n    if text_check > 0 then\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Output formatting enabled\" .. '\\n';\\\n      debugger[1 + #debugger] = \"Every component of the\" .. ' ';\\\n      debugger[1 + #debugger] = \"output will begin with the\" .. ' ';\\\n      debugger[1 + #debugger] = \"string inputed in\" .. ' ';\\\n      debugger[1 + #debugger] = \"debugging.output_separator\" .. '\\n';\\\n      debugger[1 + #debugger] = \"Every spacing sequence will be\" .. ' ';\\\n      debugger[1 + #debugger] = \"inbetween the characters\" .. \" \";\\\n      debugger[1 + #debugger] = \"'['\";\\\n      debugger[1 + #debugger] = \" \" .. \"and\" .. \" \";\\\n      debugger[1 + #debugger] = \"']'\" .. '\\n';\\\n      debugger[1 + #debugger] = \"Retrieving output showing\" .. ' ';\\\n      debugger[1 + #debugger] = #spell.active;\\\n      debugger[1 + #debugger] = ' ';\\\n      debugger[1 + #debugger] = \"recording\";\\\n      if #spell.active > 1 then\\\n        debugger[1 + #debugger] = 's';\\\n      end\\\n      debugger[1 + #debugger] = spell.concat_actives();\\\n    end\\\n    return table.concat(debugger);\\\n  end\\\n)}\n\n; \n; \n\n{lua(\\\n  function debug.data_validation(level)\\\n    local data = tonumber(level);\\\n    data = math.max(\\\n      data, \\\n      0 - data\\\n    );\\\n    if data == nil then\\\n      local printer = {};\\\n      printer[1 + #printer] = \"Inputed data returned\" .. ' ';\\\n      printer[1 + #printer] = \"nil after computation\" .. '\\n';\\\n      printer[1 + #printer] = \"If your input was not\" .. ' ';\\\n      printer[1 + #printer] = \"malformed, please report\" .. ' ';\\\n      printer[1 + #printer] = \"this to me\";\\\n      return table.concat(printer);\\\n    end\\\n    return data;\\\n  end\\\n)}\n\n#debug {lua(return debug.halt())}\n\n#debug.log(level) {lua(\\\n  debug.can_log = debug.data_validation({level});\\\n)}\n\n#debug.halt_compilation(level) {lua(\\\n  debug.can_halt = debug.data_validation({level});\\\n)}\n#debug.recordings_before_halt(limit) {lua(\\\n  debug.should_halt = {limit};\\\n)}\n\n#debug.display_spells(level) {lua(\\\n  debug.text.can_concat = debug.data_validation({level});\\\n)}\n\n#debug.display_spells_in_batch(level) {lua(\\\n  debug.text.concat_in_batch = debug.data_validation(\\\n    {level}\\\n  );\\\n)}\n\n#debug.display_format(separator) {lua(\\\n  debug.text.concat_format = {separator}\\\n)}\n\n"],["sync",":import winAI_lib\n:import Spell Config\n:name {package(sync)}\n \n#substring(value, size) sub(\\\n  {active_module_list}, \\\n  index + {value}, \\\n  {size}\\\n)\n#substring_index(search, value) index(\\\n  {active_module_list}, \\\n  {search}, \\\n  index + {value}\\\n) - (index + {value})\n\n:const double threshold 0.50\n\n:local string spell_name\n:local double timer\n:local double placement_x\n:local double placement_y\n:local int index\n:local int syncronize\n:local bool copy_activator\n\ncopy_activator = contains(impulse(), \"{package(sync)}\")\ncheck:\nindex = {pointer_get}\ngotoif(if(\\\n    copy_activator, \\\n    skip, \\\n    syncronization_needed\\\n  ), false == contains(\"00\", {substring(0, sync_precision)})\\\n)\nskip:\n{pointer_set(increment)}\ntimer = s2d(\\\n  {substring(sync_precision, time_precision)}, \\\n  0.0\\\n)\nplacement_x = s2d(\\\n  {substring(\\\n    sync_precision + time_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nplacement_y = s2d(\\\n  {substring(\\\n    sync_precision + time_precision + placement_precision, \\\n    placement_precision\\\n  )}, \\\n  0.0\\\n)\nspell_name = {substring(\\\n  sync_precision + time_precision + placement_precision + placement_precision + attribute_size, \\\n  {substring_index(\\\n    \";\",\\\n    sync_precision + time_precision + placement_precision + placement_precision + attribute_size\\\n  )}\\\n)}\n\nwaitwhile(time.scale() == 0.0 || {timer_get} % timer > threshold || {timer_get} < timer)\nuseinstant(active.index(spell_name))\nuseposition(active.index(spell_name), vec(placement_x, placement_y))\ngoto(if(copy_activator, 99, check))\n\nsyncronization_needed:\nsyncronize = s2i({substring(0, sync_precision)}, 0)\n\ncopy:\nsyncronize = syncronize - 1\n{execute_package(sync)}\ngoto(if(syncronize <= 0, check, copy))\n\n"],["winAI_lib","; Consistent naming across scripts\n#package(name) winAI:{name}\n#execute_package(script) execute(\"{package({script})}\")\n\n; A package identifier used within\n; the names of global variables for a unique value\n#identifier \"winAI\"\n\n#pointer \"<size=0>\" . \"pointer\" . {identifier}\n#pointer_get global.int.get({pointer})\n#pointer_set(value) global.int.set(\\\n  {pointer}, \\\n  ({pointer_get} + {value}) % (spells_count * increment)\\\n)\n\n; The pointer chunk\n; Since I do not want to messy up the users screen\n; the pointer is a block hider, so you don't have to\n; see the pointer increment and decrement\n; \n; pointer_get is self explanetory\n; Make sure your pointer is an int, as sub() requires integers\n; \n; pointer_set is also self explanetory, but the set value is interesting\n; We add the value to our pointer, however, we're working with strings\n; Because of this, we loop over after we've exhausted our space\n; \n; our space is dictated by spells_count * increment, which are\n; :const int values found at the end of Spell Config\n\n#timer \"t\"\n#timer_get global.double.get({timer})\n"],["era",":import winAI_lib\n:name {package(era)}\n\ngame.newround()\n:const int element_length 12\n\n:const string element1 'light;      '\n:const string element2 'darkness;   '\n:const string element3 'nature;     '\n:const string element4 'electricity;'\n:const string element5 'universal;  '\n:const string element6 'fire;       '\n:const string element7 'neutral;    '\n:const string element8 'water;      '\n:const string element9 'earth;      '\n\n:local string element_name\n:local int index\n\n#elements_list element1 . element2 . element3 . element4 . element5 . element6 . element7 . element8 . element9\n\nera:\nelement_name = sub({elements_list}, index, index({elements_list}, \";\", index) - index)\n\nloop:\ndisable.era(element_name)\nglobal.string.set(\"no more hiding\", \"</size>\")\n\ngotoif(loop, disable.cost(element_name) >= 0.0)\nindex = index + element_length\ngotoif(era, contains(sub({elements_list}, index, element_length), \";\"))\n"],["tick",":import winAI_lib\n:name {package(tick)}\n\nglobal.double.set({timer}, {timer_get} + time.delta())\n{execute_package(tick)}\ngotoif(99, contains(impulse(), \"{package(tick)}\"))\n\nstop(\"Codrineye's TowerTesting:Stats Exit Diff_Change\")\nexecute(if(true, \"Codrineye's TowerTesting:Stats Exit Diff_Change\", \"{package(Null_Cond)}\"))\nwaituntil({timer_get} >= 2.0)\n{execute_package(3spam)}\n"],["3spam",":import winAI_lib\n:name {package(3spam)}\n\nwait(0.2)\nuseinstant(active.index(\"spell.response.neutral\"))\ngoto(1)\n"],["init",":import winAI_lib\n:name {package(init)}\n\ngame.newround()\n\nglobal.int.set({pointer}, 0)\nuseinstant(active.index(\"barrier.temporal\"))\n\nstop(\"{package(3spam)}\")\nstop(\"{package(tick)}\")\nstop(\"{package(sync)}\")\n\nloop:\nstop(\"{package(inf)}\")\ngoto(if(\\\n  isTowerTesting() && contains(impulse(), \"game.newround\"), \\\n  if(tower.health(false) > 0.0, exit, loop), \\\n  99\\\n))\nexit:\n\nglobal.double.set({timer}, time.delta() * 2.0)\nuseinstant(active.index(\"barrier.temporal\"))\n\n{execute_package(tick)}\n{execute_package(sync)}\n{execute_package(inf)}\n\nuseinstant(active.index(\"crate.rex\"))\nwaitwhile(health(false) > 0.0 && disable.cost(\"nature\") < 0.0)\nexecute(if(health(false) <= 0.0, \"{package(init)}\", \"{package(Null_Cond)}\"))\n"],["inf",":import winAI_lib\n:name {package(inf)}\n\nupgrade.era(\"health\", 42069)\ngotoif(0, xp() < disable.inf.cost())\n\ndisable.inf(\"aura.death\")\ndisable.inf(\"reflect.wince\")\ndisable.inf(\"reflect.captain\")\ndisable.inf(\"barrier.temporal\")\ndisable.inf(\"spell.void\")\ndisable.inf(\"spell.snapOfDestiny\")\ndisable.inf(\"spell.response.neutral\")\n\ngoto(0)\n"],["New 1","{lua(\\\n  local function foo(...)\\\n    local imp = table.pack(...);\\\n    local str = table.concat(imp);\\\n    return table.concat(imp);\\\n  end\\\n  return foo(\"abc\",1);\\\n)}\"\n"]]}}
```

# Import code
Requirements:
- impulse: 1
- conditions: 0
- lines: 16
- scripts: 6
```
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
```

