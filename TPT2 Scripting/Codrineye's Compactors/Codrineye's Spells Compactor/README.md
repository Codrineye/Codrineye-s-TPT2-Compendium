# Codrineye's Spell Compactor

The spell compactor is system for recordings spells that creates a string of spell contents and constant variables which can be sent to the stand-alone spell-compactor to handle spell activation.

## The import packages

The compactor has 2 types of imports, a source import and a game import

The game import will likely be moved to the [root TPT2 Scripting README](/TPT2%20Scripting/README.md), but for the time being, there's still work to be done.

## The source import

The source import is a code you import inside the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/). This import is required for the editor to use the compactor in the first place. If you get an error message when adding a Spell Config file, you likely have copies of the old spell compactors workspace, in which case I recommend deleting all workspaces and files that you have which are related to the spell compactor and re-importing the source.

This import contains the Compactor, its resource folder that's used to communicate with the game import of the compactor, the spell compactors library which uses [Editor_actions lib](/TPT2%20Scripting/Editor%20Actions%20lib/README.md) to create the substrings and 2 game compactor versions:
- [Spell Compactor](#spell-compactor)
- [Debugger Version](#spell-compactor-with-debugger)

You can get an explanation of how to use the compactor by heading over to its manual [Compactor manual](Compactor%20manual.md)

```
{"workspaces":{"Codrineye's Spell Compactor":[["Cods Spell Compactor","\n{lua(\\\n  Spell = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  Spell.debug = {};\\\n  Spell.debug.can_log = false;\\\n  Spell.debug.can_halt = false;\\\n  Spell.debug.halt_limit = 0;\\\n  Spell.debug.can_display = false;\\\n  Spell.debug.concat_format = \"\";\\\n  \\\n  --[[Table holding information needed for recording]]\\\n  Spell.active = {};\\\n  Spell.active.space = 0;\\\n  Spell.active.sync_ammount = 0;\\\n  \\\n  --[[Table that has spell_compactor data]]\\\n  Spell.comp = {};\\\n  Spell.comp.active = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(Spell.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  Spell.debug.can_display = true;\\\n  Spell.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(Spell.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  Spell.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  Spell.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  Spell.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  Spell.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local spell_debug_stop = false;\\\n  \\\n  function Spell.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local active_index = #Spell.comp.active;\\\n      Spell.comp.active[active_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that we can\\\n          * easily check it with a contains of the full spell\\\n         */]]\\\n    end\\\n    local bp_name = name:match('%b\"\"'):sub(2, -2);\\\n    bp_name = string.format(\"blueprint_%s\", bp_name);\\\n    \\\n    local space = Spell.active.space;\\\n    return string.format(\":const int %s %s\", bp_name, space)\\\n  end\\\n  function Spell.comp.sync(spell_ammount)\\\n    --[[/*\\\n        * The synchronization system prevents the\\\n        * script from refreshing the budget untill\\\n        * all synchronized spells have been used.\\\n       */]]\\\n    \\\n    local sync = tonumber(spell_ammount);\\\n    assert(sync >= 0, \"Trying to add a negative sync_ammount\");\\\n    --[[Synchronizing less than 1 spell is meaningless]]\\\n    \\\n    sync = sync - 1;\\\n    --[[/*\\\n        * We subtract 1 from the sync_ammount\\\n        * to cover the first spell\\\n        * \\\n        * Sync_ammount always gets overwritten\\\n       */]]\\\n    Spell.active.sync_ammount = sync;\\\n  end\\\n  \\\n  function Spell.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local dbug = Spell.debug;\\\n    local halt_limit = dbug.halt_limit == 0 and dbug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our halt limit has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or spell_debug_stop then\\\n      Spell.debug.halt();\\\n    end\\\n    \\\n    local match_string = [[%b\"\"]];\\\n    local active_name = name:match(match_string):sub(2, -2);\\\n    \\\n    local actives_index = 1 + #Spell.comp.active;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * to loop our sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    \\\n    local used_space = 2;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 2 because, sync and loop_sign\\\n        * are length-1 signals\\\n       */]]\\\n    local sync = Spell.active.sync_ammount;\\\n    if sync > 0 then\\\n      new_spell.sync = \"s\";\\\n      Spell.active.sync_ammount = sync - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the budget.]]\\\n    new_spell.name = active_name;\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      new_spell[variable] = {};\\\n      new_spell[variable] = 0.0 + value\\\n      --[[/*\\\n          * the addition with 0.0 here is to guarantee \\\n          * the correct data type.\\\n          * timer, coord_x and coord_y need to be doubles \\\n          * for the actions waitwhile() and vec().\\\n          * float and double are the same type in this editor\\\n         */]]\\\n    end\\\n    spell_values[4] = \"name\";\\\n    for _, variable in ipairs(spell_values) do\\\n      new_spell[variable] = string.format(\"%s|\", new_spell[variable]);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * string.format converts the value in\\\n          * new_spell[variable] into a string. Meaning that\\\n          * I no longer have to convert the value to a string myself\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      new_spell.space = string.format(\"%s|\", used_space);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[/*\\\n        * Add the extra space taken up by our signal bits\\\n        * and space recording.  We add our space here so that\\\n        * we don't have to pass through the entire string an extra time\\\n       */]]\\\n    \\\n    Spell.comp.active[actives_index] = new_spell;\\\n    Spell.active.space = Spell.active.space + used_space;\\\n    \\\n    local logging_check = dbug.can_halt or dbug.can_log;\\\n    if logging_check then Spell.debug.log() end\\\n    \\\n    if dbug.can_halt then\\\n      Spell.debug.halt_limit = dbug.halt_limit - 1;\\\n    end\\\n    --[[/*\\\n        * Check if we're logging or\\\n        * if compilation should be halted\\\n        * \\\n        * Remember that dbug is the same as Spell.debug\\\n        * in this function\\\n       */]]\\\n    local spell_number = string.format(\"spell_%s\", actives_index);\\\n    local const_txt = \":const int %s %s\";\\\n    return const_txt:format(spell_number, Spell.active.space);\\\n  end\\\n  \\\n  function Spell.comp.concat_actives()\\\n    local spells = {};\\\n    --[[table holding the compacted data]]\\\n  \\\n    local actives = Spell.comp.active;\\\n    local dbug = Spell.debug;\\\n    --[[access our recordings]]\\\n    \\\n    local actives_count = #actives;\\\n    --[[nr of recordings]]\\\n    \\\n    actives[actives_count].loop_sign = \"#\";\\\n    --[[Set the last sign to # to enable sequence looping]]\\\n    \\\n    local concat_debug = {};\\\n    concat_debug.format = \"\";\\\n    concat_debug.separation = \"\";\\\n    concat_debug.bit_format = \"\";\\\n    concat_debug.spell_data = \"%s\";\\\n    concat_debug.chunk_end = \"\";\\\n    \\\n    if dbug.can_display then\\\n      concat_debug.format = dbug.concat_format;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = dbug.concat_format .. \"Bit signal %s = \";\\\n      concat_debug.spell_data = dbug.concat_format .. \"%s  %s\";\\\n      concat_debug.chunk_end = \"End of recording %s\";\\\n    end\\\n    \\\n    for i = 1, actives_count do\\\n      --[[/*\\\n          * Spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local active_data = actives[i];\\\n      local spell_data = table.pack(\\\n        concat_debug.format,\\\n        \\\n        concat_debug.bit_format:format(\"loop\"), active_data.loop_sign,\\\n        --[[Adds the loop_sign bit]]\\\n        \\\n        concat_debug.bit_format:format(\"sync\"), active_data.sync,\\\n        --[[adds the sync signal bit]]\\\n        \\\n        concat_debug.spell_data:format(active_data.space, #active_data.space),\\\n        --[[Adds the space we take up]]\\\n        concat_debug.spell_data:format(active_data.timer, #active_data.timer),\\\n        --[[Adds the spell timer]]\\\n        concat_debug.spell_data:format(active_data.coord_x, #active_data.coord_x),\\\n        --[[Adds the spells x coord]]\\\n        concat_debug.spell_data:format(active_data.coord_y, #active_data.coord_y),\\\n        --[[Adds the spells y coord]]\\\n        concat_debug.spell_data:format(active_data.name, #active_data.name),\\\n        --[[Adds the spells name]]\\\n        \\\n        concat_debug.format, concat_debug.chunk_end:format(i)\\\n      );\\\n      \\\n      for _, data in ipairs(spell_data) do\\\n        spells[1 + #spells] = data;\\\n      end\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(spells));\\\n  end\\\n  function Spell.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from Spell.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local active = Spell.comp.active;\\\n    local spell_index = #active;\\\n    local spell = active[spell_index];\\\n    \\\n    local logging_text = table.pack(\\\n      \"%s| Spell has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 7\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value] or \"nil\";\\\n      --[[/*\\\n          * Gets our logging_value\\\n          * If its respecitve value exists then \\\n          * * spell_value = spell[value]\\\n          * else\\\n          * * spell_value = \"nil\" to signal that\\\n          * * something has gone wrong\\\n          * \\\n        */]]\\\n      \\\n      local fmt = table.pack(log, value, logging_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, logging_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function Spell.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * Spell.comp.add_spell\\\n        * * Spell Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local debug = Spell.debug;\\\n    local should_halt = debug.can_halt or debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local compactor = Spell.comp;\\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #compactor.active,\\\n        \" \"\\\n      );\\\n      if #compactor.active == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = compactor.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return Spell.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n\n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(Spell.comp.sync({spell_count}))}\n\n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return Spell.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0, \\\n  0\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n"],["Spell Compactor resources","; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n\n#spell_compactor Spell Compactor\n\n#hider.start <size=0>\n#hider.close </size>\n\n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n\n:const string pointer_var \"{hider.start}Spell Compactor Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n\n:const string compactor_string \"Spell Compactor access string\"\n#compactor.get global.string.get(compactor_string)\n#compactor.set(string) global.string.set(compactor_string, {string})\n\n:const string caller_ID \"{hider.close}Spell Comp caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n\n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n"],["Spell Compactor lib",":import Editor_actions lib\n:import Spell Compactor resources\n\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[compactor]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"space\",\\\n    \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 1 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n\n:local int pointer\n:local string compactor\n\n:local double clock\n:local string spell_ID\n\n#get_bits sub(compactor, pointer, 2)\n#get_space {lua(return Compactor.space_value)}\n#get_timer {lua(return Compactor.timer_value)}\n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  contains({get_bits}, \"#\"),\\\n  0, \\\n  pointer + {get_space}\\\n)\n"],["Spell Compactor",":import Spell Compactor lib\n:name {spell_compactor}\n\n:budget_cap max\n\n\ngotoif(timer, contains(impulse(), \"{spell_compactor}\"))\n; The compactor calls itself only when it needs to start the \n\npointer = {pointer.get}\ncompactor = {compactor.get}\n\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\ngotoif(loop, {timer.get} != 0.0)\n; We skip setting the timer if it was already run\n\n{timer.set(time.delta() * 2.0)}\nexecute(\"{spell_compactor}\")\n; If the timer hasn't been run yet, we do the\n; normal winemast initialization, setting a ticker\n; and going into our loop\ngoto(loop)\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(\\\n  contains({caller.get}, \"idle mode\"), \\\n  end, \\\n  timer\\\n))\n\n; The timer will always run, even if the compactor shuts down\n; the only way to stop the timer is by calling the compactor, again\n; outside of towertesting or by stopping all instances of the compactor\n\nloop:\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\n; 0.05 is a timer buffer aka the minimum ammount of deviation\n; the timer allows\n; \nwaituntil({timer.get} % clock < 0.5 && {timer.get} >= clock)\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\"\", sub(compactor, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string of size 1\n; so it can only return true if we truely are at the end of our string\n\ngoto(if(\\\n  {end_of_compactor}, \\\n  99, \\\n  if(isTowerTesting(), loop, idle)\\\n))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would've stopped, de-synchronizing things\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(\"idle mode\")}"],["Spell Compactor With Debugger",":import Spell Compactor lib\n:name {spell_compactor}\n; \n; This script is a version of the ordinairy compactor, and as such\n; is intended to make every script that uses the compactor think\n; this is their target. This way, you don't have to change much\n; of your blueprint AI\n\n; \n; The debugger adds a layer of complexity to the compactor\n; and makes everything a little bit more computationally intense\n; (so your game will likely be laggier when you run the compactor like this)\n; \n; This is used to tell you what the compactor sees at any 1 time\n; if durring run-time you get undesirable spell execution\n; \n; While the primary goal here is to diagnose issues,\n; you can also use this as a spell compactor to test any changes you've made.\n; This debugger isn't just for uncovering bugs in the compactor\n; —though if you find any, please let me know!\n; Instead, it's meant to help you, the end user, understand:\n; * What you're instructing the compactor to do\n; * How the substring used to compute the\n;   activation sequence changed the recording string\n; \n\n:budget_cap max\n\nkey.x()\n; You have the impulse that lets you cycle through your spells\n; \n:local bool debugging\n\ndebugging = true\n; This debugging_bool is set to true if you want\n; to search for what's going wrong\n; \n; By default I've set this to true so you have to manually disable\n; debugging if you don't want it\ngoto(if(\\\n  contains(impulse(), \"{spell_compactor}\"),\\\n  timer,\\\n  if(\\\n    contains(impulse(), \"key.x\") || debugging, \\\n    debug, \\\n    start\\\n  )\\\n))\n\nstart:\n; The compactor calls itself only when it needs to start the \n\npointer = {pointer.get}\ncompactor = {compactor.get}\n\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\ngotoif(loop, {timer.get} != 0.0)\n; We skip setting the timer if it was already run\n\n{timer.set(time.delta() * 2.0)}\nexecute(\"{spell_compactor}\")\n; If the timer hasn't been run yet, we do the\n; normal winemast initialization, setting a ticker\n; and going into our loop\ngoto(loop)\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(contains({caller.get}, \"idle mode\"), end, loop))\n\n; The timer will always run, even if the compactor shuts down\n; the only way to stop the timer is by calling the compactor, again\n; outside of towertesting or by stopping all instances of the compactor\n\nloop:\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\n; 0.05 is a timer buffer aka the minimum ammount of deviation\n; the timer allows\n; \nwaituntil({timer.get} % clock < 0.5 && {timer.get} >= clock)\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\"\", sub(compactor, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string of size 1\n; so it can only return true if we truely are at the end of our string\n\ngoto(if(\\\n  {end_of_compactor}, \\\n  99, \\\n  if(isTowerTesting(), loop, idle)\\\n))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would've stopped, de-synchronizing things\n\n; This is the only addition of the debugger\ndebug:\ncompactor = {compactor.get}\npointer = global.int.get(\"next pointer\")\n{caller.set(\"debugging\")}\n\n; It sets the caller to \"debugging\" so that when you\n; force your blueprint AI to send the string over, there's\n; a concrete spot that tells it that it can shut down\n; \nglobal.string.set(\"spell_chunk\", sub(\\\n  compactor,\\\n  pointer,\\\n  {get_space}\\\n))\n; The chunk shows you how the spell is stored\n; the order is as shown bellow:\n; * `loop_signal bit` that is / to move to the next spell and # to loop\n; * `sync bit` that is / to refresh budget and `s` to skip refreshing budget\n\nglobal.int.set(\"pointer\", pointer)\n; We also have a pointer and next_pointer that shows what value\n; this pointer has at that state\n\nglobal.string.set(\"spell space\", {lua(return Compactor.space)})\n; space value which is the ammount of space\n; the spell takes up in the recording\n\nglobal.string.set(\"spell_timer\", {lua(return Compactor.timer)})\n; timer value which is the timer\n; you set when adding a spell\n\nglobal.string.set(\"coord_x\", {lua(return Compactor.coord_x)})\n; coord_x which is the coordinate you add\n; if you added a grounded spell\nglobal.string.set(\"coord_y\", {lua(return Compactor.coord_y)})\n; coord_y which is the same idea as coord_x\n; \n; Remember that add_spell.instant is the same\n; as add_spell.grounded with 0, 0 as coordinates\n; \nglobal.string.set(\"spell_name\", {get_name})\n; name which is the spells identifier so we can take an active index of it\n\n{pointer.increment}\n; We finally increment our pointer and add the next pointer state\nglobal.int.set(\"next pointer\", pointer)\n\nwaitframe()\n; \n; To prevent debugging from being executed when\n; shutting down, and to avoid adding another action\n; debugging also sets the caller to \"idle mode\" when it's done\n; \n; This should be a useless addition however, as setting this should\n; have given your blueprint AI enough time to top itself\n; But just to be safe, the waitframe() should guarantee that your\n; AI has self-terminated successfully\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(\"idle mode\")}"]]}}
```

## The game import

The game import is a code you import inside TPT2

### Spell Compactor

This is the program that will execute your spells durring towertesting.<br>
You can read its comments by importing the source version or by looking at [Spell Compactor](Spell%20Compactor.tpt2). The comments explain how it does things in more detail.

Using the compactor is strictly within the External Editor. While you could communicate with the compactor ingame, I highly advise against it as it uses hidden variables to prevent UI clutter.

Requirements:

- impulse: 0
- conditions: 0
- lines: 22
- scripts: 1

```
7VrdbtMwFH6VEqRdQBeSlrGp2gZi3HAFErujFXKck2LNsSvb2QZj78Ij8AaT2IuhNM7WJU6btKNrNqtSmyY+5/P5d0/PhSOxIBMlncHXCwdhRThLr51h4nkejIGBINgdc8VJNAwwZ1IhpqZPe8Ps0yu9R1IJwsYu5kwhwmTGLENySTxJqIQCs9cZ4ZcJUNo54vEEYcWF03WGgnKMqEuYciUoI9nuhBOmQOhNUx5ogrGZwI/2JfkJB95hAa/zOWOU4qbrvAxbi2OCVzinnRL4GlxTVOGHRVyEMUjZychy9AKzCun9vf1XqTQzsnQwojRXhwLBkPihuaxmH38wVDIJZljNp+pVOIinabNtEBbC+aeoyS6awdxhqbW70LkjMzvfn1pcEMmZG/IkoHDHWNmtKst7vvl279lB4X5/rkyG96LX6I1UxYyvstVIEPU9BkVwLg1TJAY3BKqQmfLF8lt9l2s/yrUP54ATVT8dRLNmq2O0W71owjNEVCRQDOvT2MtmLlKWM70f5JFM9HJTGNfNQNVJo5ThSEihE/PQGNz+jsHUNepE/QwbyHSL3z5+KKSeAqlJ0LvJ2YMZy+U6NOSgZoyNFvxl8daAN3MyqIqlm5NBRVia6oipmjQg9x8b+SaY2uK1G8+G6sORb2+EB1g8G1HtIy8cUxf8QtjBlOOT6WVf9sLWH1jb42OboC1rnRaWpbYqsVbP5frP3ytj+yNhitDpmmimmxVwTofzWlzlzsfqna9+zENDiq3iolOsEWB/KR39fmvuyG1tzdXFau2+w4PGMueG3FX8DIQb8zCh4CYSyC2BvzdGMeTP0nb+KWRhVDOIbpotOdpeEW3CJUn/JbhfuCw2TwG7keDxEecilI+njtqk1qgy2LK/SXhPxpk2+JRibb4Wm9c+VNnS1Ba8J+rJtpJaPOv7tvBvOp510XU0fxbOOqUmrmJamjJZ5cizvL0bGlbOH/tpOlS4ePamFVp5biSvcqH/EKxJdm4m935uXmMisXmzqjo+2K5611fZa9nJOdNuvAeLabZYYFzhmEVR/f60RUvkcdrHPQapUmmKgKZZV1ONeFNe13yIcolaNg9w6enokvFuBh2dUdfBnIUkH4cfdR09Pay/sbSODJzyfOoE4RM0Tp85XSdIwjEoZ7Dtd51Ewnv9VYkELkeX/wA=
```


### Spell Compactor with Debugger

This is the program, similar to the normal [Spell Compactor](#spell-compactor) that also has debugging functionality.<br>
You can read an explanation of what it does by looking at the comments in [Spell Compactor with Debugger](Spell%20Compactor%20with%20Debugger.tpt2).<br>

You have a local boolean called "debugging" set to true by default. This lets you see the data string obtained from your blueprint AI. You use key.x() to go through your spells.

Requirements:

- impulse: 1
- conditions: 0
- lines: 36
- scripts: 1

```
7VzdbtNIFH6VrFlxAcHYKWyrqgUE3HDFSsvdpkL2+MSMas9YnjGktLwLj7BvgLS8GBr/hMQeJ3GcJnZyVMlN7DnznTm/k5OTuTUEiWkkhXH+763hEEk5U6+NcWJZFgScOIHpch6YAuTYJZwJ6TCZPn02lh64ie9T5pce2dnVGBrjiQ8MYkpMn0ue3nYlxMyJb0yaj54IGVPmm4Qz6VAmMuyMMZOGURIIqGCnhP9EEASDNzyMHCJ5XBo0GrP0v1W5Vlkgao6YCs7S5bbj6/k13JhT7aPR3V1FtH4T0Y7U1f5LszDNOOukOk4pJc7QKZNavarracQpkxBn3PoBd3MCHbeKpcmFoF/h0npRUsrg72wihavGWRl2LlutWZGZQhWBnYPnFHX4XhnXIQSEGGRkBXppsprV22cXT9Vq5tYyIE4QFOIozCebpZ2x2OdjKRJ3bqrlVKMam7Zy2owNyjyYvp804aIZzMKUuXQtmHd2OqlMGeuns+059/N44gawoKzsVp3mLVt/e/THZem+xhuWX8tWkzNS5zO2zEY7MZWfQpCUFKthkoZgehBIR0/5aHNWXxXSn4VamAJJ5Hoxsxqj11Dab7nkhF8cKiexE8LuJPa4mYm0yEXrRqD6oFGJcNQLYBByr+LcD9YI7EsUsjq4ukJx9/Hd21LUKZFqc9JCXLZgTmmF+DThp9nEWuXdId4O8OY2BXVuNNsU1HikLoXoEkkDcvvQyLugasTrNx666v7In3TCAhAPPap/5KVt6ooPB89JwMl1+vJEjLzeb1j7Y2NdkBZqp4dpqa9CXKvc8vO//39oKx8JkzQvGWvqyLXVrWrRo33R6yTknibE1s2Sh1gtwMVGMvr+Ul+Me/hwqSzaVfpeXDZec6HIU8m/QGyG3EsCMBMB9DeBfeY7IRTP1LcjnyFzozWdaFZsKdDOymgRF1R96bJduMw3PwMxJzEP33Aee+Jw8igGtUaZAdN+l/COxpg6vEtBne9E52tvqjA19QXvSC0ZMynioe1j4u86HproLoo/K9uclIqf1UxUaTBps+XZXN8NFSuWd/w07Sdc3XbTC6k80JLXmdA9OGuS7Zvp1vfNOwwkGDfrsuPeuBr9/JH9bdo0p+PG2ptP67rAS2NIjWGWl2qfpCVaKj6oOu4HEFLXoa1rcy2N+bM6ZP8N0ttuC58wmMpBtNj/3boDuyKNWat8MwgrL5eTTwm73plxYsjGkH3fIbvsmyuduQHbG/nYQEQOATR5NPk2XG0W3tXvCOLeF5b3rXssfR6GdjpcnOuNEBvGoVOi+i8+Tnsfg9AgGnkVhswu4R2NMXU4wqPO70fnmyWkG0xIHcc7FvvF/Il4aPtbJD/OdI8m2kkTbbA7YVnJjjnh9ovFh26Nh46H3oZ7KcTrBR66Km79EA89qm/k2MpaIsdWVmwS6VmTSHlc076ohZ7FzRqj2p+JuXi79bGl22u1nJ1baVwNDcKZR4sTo6+GRn4YbHp+dHoCshqkPssb50b11NHIIdeOr54ZQ8NNPB+kcf7EHhqJgNf5Wxkn8O3q2y8=
```


# Changelog

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
