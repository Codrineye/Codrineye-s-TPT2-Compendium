# Codrineye's Blueprint Compactor

The blueprint compactor is a library of a multitude of macros that will simplify the creation of an AI for your specific blueprint.<br>
It capable of recording module activation sequences, recording a security sequence that prevents infinity enemies from copying them, software configuration and era disables.

## The import packages

The compactor has 2 types of imports, a source import and a game import

The game import will likely be moved to the [root TPT2 Scripting README](/TPT2%20Scripting/README.md), but for the time being, there's still work to be done.

## The source import

The source import is a code you import inside the [external AI editor by d0sboots](https://d0sboots.github.io/perfect-tower/). This import is required for the editor to use the compactor in the first place. If you get an error message when adding a Spell Config file, you likely have copies of the old spell compactors workspace, in which case I recommend deleting all workspaces and files that you have which are related to the spell compactor and re-importing the source.

This import contains the Compactor, its resource folder that's used to communicate with the game import of the compactor, the spell compactors library which uses [Editor_actions lib](/TPT2%20Scripting/Editor%20Actions%20lib/README.md) to create the substrings and 2 game compactor versions:

- [Blueprint Compactor](#blueprint-compactor)
- [Debugger Version](#spell-compactor-with-debugger)

You can get an explanation of how to use the compactor by heading over to its manual [Compactor manual](Compactor%20manual.md)

```
{"workspaces":{"Codrineye's Blueprint Compactor":[["Cods Blueprint Compactor","\n{lua(\\\n  BP = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  BP.debug = {};\\\n  BP.debug.can_log = false;\\\n  BP.debug.can_halt = false;\\\n  BP.debug.halt_limit = 0;\\\n  BP.debug.can_display = false;\\\n  BP.debug.concat_format = \"\";\\\n  \\\n  --[[Table that has data needed in compacting data]]\\\n  BP.misc = {};\\\n  BP.misc.space = {};\\\n  BP.misc.space.secure = 0;\\\n  BP.misc.space.active = 0;\\\n  BP.misc.sync_ammount = 0;\\\n  \\\n  --[[Table that has compactor specific data]]\\\n  BP.comp = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  \\\n  BP.comp.software = {}\\\n  --[[Store the module secures]]\\\n  BP.comp.secure = {};\\\n  BP.comp.defined_secures = {};\\\n  \\\n  --[[Blueprint activation]]\\\n  BP.comp.active = {};\\\n  BP.comp.blueprint = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(BP.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  BP.debug.can_display = true;\\\n  BP.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(BP.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  BP.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  BP.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  BP.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  BP.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local bp_debug_stop = false;\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  for _, soft in ipairs(software_list) do\\\n    BP.comp.software[soft] = -50;\\\n  end\\\n  \\\n  function BP.comp.add_software(software, level)\\\n    assert(\\\n      BP.comp.software[software],\\\n      \"Attempt to assign a security level to an unrecognized software\\n\"\\\n      .. \"If this is a new software, add it to the software_list\"\\\n    ); --[[triggers an error if software_name isn't in software_list]]\\\n    assert(\\\n      BP.comp.software[software] == -50,\\\n      \"Trying to assign a security level to an already set software\"\\\n    ); \\\n    --[[/*\\\n        * lowest security level I've seen yet is -1\\\n        * thus, a security level of -50 is the default value\\\n       */]]\\\n    local secure_level = level:match([[%b\"\"]]):sub(2, -2):gsub(\" \", \"\");\\\n    assert(\\\n      tonumber(secure_level), \\\n      \"Trying to assign an empty security level\"\\\n    );\\\n    --[[Assert will trigger an error if tonumber() returns nil]]\\\n    \\\n    local software_name = string.format(\"software.%s\", software);\\\n    local lvl = string.rep(\" \", #software_name - #secure_level);\\\n    secure_level = string.format(\"%s%s\", secure_level, lvl);\\\n    BP.comp.software[software] = secure_level;\\\n  end\\\n  \\\n  function BP.comp.concat_software(concat_mode)\\\n    do\\\n      local modes = {};\\\n      modes.software_list = 0;\\\n      modes.software_secure = 1;\\\n      assert(\\\n        modes[concat_mode],\\\n        \"Invalid concat_mode.\\n\"\\\n        .. \"If you're seeing this, you're either a user that messed \"\\\n        .. \"with something you shouldn't have, or I messed up\"\\\n      );\\\n    end\\\n    --[[using a do-end block to prevent lingering local values]]\\\n    local software = \"\";\\\n    \\\n    if concat_mode == [[software_list]] then\\\n      local software_fmt = \"software.%s|\";\\\n      for _, soft in ipairs(software_list) do\\\n        local software_name = software_fmt:format(soft);\\\n        software = software .. software_name;\\\n      end\\\n    else\\\n      local secure_fmt = \"%s%s|\";\\\n      for _, soft in ipairs(software_list) do\\\n        local software_val = BP.comp.software[soft];\\\n        software = secure_fmt:format(software, software_val);\\\n      end\\\n    end\\\n    return string.format([[\"%s\"]], software);\\\n  end\\\n  \\\n  function BP.comp.recorded_secures(blueprint_name)\\\n    assert(\\\n      #BP.comp.secure,\\\n      \"Attempt to define a security recording before \" ..\\\n      \"adding a module to secure\"\\\n    );\\\n    local space = BP.misc.space.secure;\\\n    BP.comp.defined_secures[blueprint_name] = space;\\\n    local const = [[:const int secures_%s %s]];\\\n    return const:format(blueprint_name, space);\\\n  end\\\n  function BP.comp.add_secure(module_name)\\\n    local secures_idx = 1 + #BP.comp.secure;\\\n    local secure_name = string.format(\"%s|\", module_name:gsub(\" \",  \"\"));\\\n    BP.comp.secure[secures_idx] = secure_name;\\\n    BP.misc.space.secure = #secure_name + BP.misc.space.secure;\\\n  end\\\n  function BP.comp.concat_secures()\\\n    return table.concat(BP.comp.secure);\\\n  end\\\n  \\\n  function BP.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local active_index = #BP.comp.active;\\\n      BP.comp.active[active_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that we can\\\n          * easily check it with a contains of the full spell\\\n         */]]\\\n    end\\\n    \\\n    local space = BP.misc.space.active;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    local bp_name = name:match([[%b\"\"]]):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    BP.comp.blueprint[bp_name] = space;\\\n    --[[/*\\\n        * And create a blueprint that stores\\\n        * How much space we've used up thus far\\\n       */]]\\\n    bp_name = string.format(\"blueprint_%s\", bp_name);\\\n    --[[change the bp_name so we can output it as a const int]]\\\n    return string.format(\":const int %s %s\", bp_name, space)\\\n  end\\\n  function BP.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local spell = BP.comp.active[#BP.comp.active];\\\n    assert(\\\n      spell.timer_base, \\\n      \"Trying to add a timer_base without any recorded spells\"\\\n    );\\\n    spell.timer_base = string.format(\"%s|\", defined_base);\\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    space = space + #spell.timer_base;\\\n    spell.space = string.format(\"%s|\", space);\\\n    --[[We're adding to the recording, we update the recording space]]\\\n  end\\\n  \\\n  function BP.comp.sync(spell_ammount)\\\n    --[[/*\\\n        * The synchronization system prevents the\\\n        * script from refreshing the budget untill\\\n        * all synchronized spells have been used.\\\n       */]]\\\n    \\\n    local sync = tonumber(spell_ammount);\\\n    assert(sync >= 0, \"Trying to add a negative sync_ammount\");\\\n    --[[Synchronizing less than 1 spell is meaningless]]\\\n    \\\n    sync = sync - 1;\\\n    --[[/*\\\n        * We subtract 1 from the sync_ammount\\\n        * to cover the first spell\\\n        * \\\n        * Sync_ammount always gets overwritten\\\n       */]]\\\n    BP.misc.sync_ammount = sync;\\\n  end\\\n  \\\n  function BP.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local dbug = BP.debug;\\\n    local halt_limit = dbug.halt_limit == 0 and dbug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our halt limit has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or bp_debug_stop then\\\n      BP.debug.halt();\\\n    end\\\n    \\\n    local match_string = [[%b\"\"]];\\\n    local active_name = name:match(match_string):sub(2, -2);\\\n    \\\n    local actives_index = 1 + #BP.comp.active;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * to loop our sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because, sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    local sync = BP.misc.sync_ammount;\\\n    if sync > 0 then\\\n      new_spell.sync = \"s\";\\\n      BP.misc.sync_ammount = sync - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the budget.]]\\\n    new_spell.name = active_name;\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      new_spell[variable] = {};\\\n      new_spell[variable] = 0.0 + value\\\n      --[[/*\\\n          * the addition with 0.0 here is to guarantee \\\n          * the correct data type.\\\n          * timer, coord_x and coord_y need to be doubles \\\n          * for the actions waitwhile() and vec().\\\n          * float and double are the same type in this editor\\\n         */]]\\\n    end\\\n    spell_values[4] = \"name\";\\\n    for _, variable in ipairs(spell_values) do\\\n      new_spell[variable] = string.format(\"%s|\", new_spell[variable]);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * string.format converts the value in\\\n          * new_spell[variable] into a string. Meaning that\\\n          * I no longer have to convert the value to a string myself\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      new_spell.space = string.format(\"%s|\", used_space);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[/*\\\n        * Add the extra space taken up by our signal bits\\\n        * and space recording.  We add our space here so that\\\n        * we don't have to pass through the entire string an extra time\\\n       */]]\\\n    \\\n    BP.comp.active[actives_index] = new_spell;\\\n    BP.misc.space.active = BP.misc.space.active + used_space;\\\n    \\\n    local logging_check = dbug.can_halt or dbug.can_log;\\\n    if logging_check then BP.debug.log() end\\\n    \\\n    if dbug.can_halt then\\\n      BP.debug.halt_limit = dbug.halt_limit - 1;\\\n    end\\\n    --[[/*\\\n        * Check if we're logging or\\\n        * if compilation should be halted\\\n        * \\\n        * Remember that dbug is the same as BP.debug\\\n        * in this function\\\n       */]]\\\n    local spell_number = string.format(\"spell_%s\", actives_index);\\\n    local const_txt = \":const int %s %s\";\\\n    return const_txt:format(spell_number, BP.misc.space.active);\\\n  end\\\n  \\\n  function BP.comp.concat_actives()\\\n    local spells = {};\\\n    --[[table holding the compacted data]]\\\n  \\\n    local actives = BP.comp.active;\\\n    local dbug = BP.debug;\\\n    --[[access our recordings]]\\\n    \\\n    local actives_count = #actives;\\\n    --[[nr of recordings]]\\\n    \\\n    do\\\n      local identifier = [[\"BP.comp.Define_entire_blueprint\"]]\\\n      BP.comp.recorded_blueprint(identifier, false);\\\n    end\\\n    --[[/*\\\n        * Record the final blueprint to the BP.comp.Blueprint table\\\n        * without forcing the blueprint to be in a loop\\\n        * \\\n        * I'm doing this in a do...end block so that the identifier\\\n        * doesn't linger in the rest of the code\\\n       */]]\\\n    \\\n    local concat_debug = {};\\\n    concat_debug.format = \"\";\\\n    concat_debug.separation = \"\";\\\n    concat_debug.bit_format = \"%s\";\\\n    concat_debug.spell_data = \"%s\";\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    if dbug.can_display then\\\n      local fmt = dbug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    end\\\n    \\\n    for i = 1, actives_count do\\\n      --[[/*\\\n          * spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data_pack = {};\\\n      do\\\n        local data = actives[i];\\\n        if dbug.can_display then\\\n          data_pack.loop_bit = table.pack(\"loop\", data.loop_sign);\\\n          data_pack.sync_bit = table.pack(\"sync\", data.sync);\\\n          \\\n          data_pack.base = table.pack(\\\n            data.timer_base, \"timer_base\",\\\n            #data.timer_base\\\n          );\\\n          data_pack.space = table.pack(\\\n            data.space, \"space\",\\\n            #data.space\\\n          );\\\n          data_pack.timer = table.pack(\\\n            data.timer, \"timer\",\\\n            #data.timer\\\n          );\\\n          \\\n          data_pack.coord_x = table.pack(\\\n            data.coord_x, \"coord_x\",\\\n            #data.coord_x\\\n          );\\\n          data_pack.coord_y = table.pack(\\\n            data.coord_y, \"coord_y\",\\\n            #data.coord_y\\\n          );\\\n          \\\n          data_pack.name = table.pack(\\\n            data.name, \"name\",\\\n            #data.name\\\n          );\\\n          data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        else\\\n          data_pack.loop_bit = table.pack(data.loop_sign);\\\n          data_pack.sync_bit = table.pack(data.sync);\\\n          \\\n          data_pack.base = table.pack(data.timer_base);\\\n          \\\n          data_pack.space = table.pack(data.space);\\\n          data_pack.timer = table.pack(data.timer);\\\n          \\\n          data_pack.coord_x = table.pack(data.coord_x);\\\n          data_pack.coord_y = table.pack(data.coord_y);\\\n          \\\n          data_pack.name = table.pack(data.name);\\\n          data_pack.chunk_end = \"\";\\\n        end\\\n      end\\\n      \\\n      local spell_data = table.pack(\\\n        concat_debug.format,\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.loop_bit)),\\\n        --[[Adds the loop_sign bit]]\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.sync_bit)),\\\n        --[[adds the sync signal bit]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.base)),\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.space)),\\\n        --[[Adds the space we take up]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.timer)),\\\n        --[[Adds the spell timer]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_x)),\\\n        --[[Adds the spells x coord]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_y)),\\\n        --[[Adds the spells y coord]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.name)),\\\n        --[[Adds the spells name]]\\\n        \\\n        concat_debug.format, data_pack.chunk_end\\\n      );\\\n      \\\n      for _, data in ipairs(spell_data) do\\\n        spells[1 + #spells] = data;\\\n      end\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(spells));\\\n  end\\\n  function BP.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from BP.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local active = BP.comp.active;\\\n    local spell_index = #active;\\\n    local spell = active[spell_index];\\\n    \\\n    local logging_text = table.pack(\\\n      \"%s| BP has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 7\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value] or \"nil\";\\\n      --[[/*\\\n          * Gets our logging_value\\\n          * If its respecitve value exists then \\\n          * * spell_value = spell[value]\\\n          * else\\\n          * * spell_value = \"nil\" to signal that\\\n          * * something has gone wrong\\\n          * \\\n        */]]\\\n      \\\n      local fmt = table.pack(log, value, logging_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, logging_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function BP.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * BP.comp.add_spell\\\n        * * BP Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local debug = BP.debug;\\\n    local should_halt = debug.can_halt or debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #BP.comp.active,\\\n        \" \"\\\n      );\\\n      if #BP.comp.active == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = BP.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n#recorded_secures(secure_name) {lua(\\\n  return BP.comp.recorded_secures([[{secure_name}]])\\\n)}\n#add_secure(secure_name) {lua(BP.comp.add_secure([[{secure_name}]]))}\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return BP.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; \n#timer_modulo(modulo) {lua(BP.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(BP.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return BP.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0, \\\n  0\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n\n#software.concat(concat_mode) {lua(\\\n  return BP.comp.concat_software([[{concat_mode}]])\\\n)}\n\n#software.secure(software_name, level) {lua(\\\n  BP.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}\n"],["Blueprint Compactor resources","\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#blueprint_compactor Blueprint Compactor\n#identifier B#C|\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{identifier}I\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string compactor_actives \"{identifier}AAstr\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{identifier}ASstr\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_actives, {str})\n; \n:const string caller_ID \"</size>{blueprint_compactor} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n:const string got_timer_base \"{identifier}LBP\"\n#timer_baseCheck.get global.bool.get(got_timer_base)\n#timer_baseCheck.set(value) global.bool.set(got_timer_base, {value})\n; \n:const string timer_base_var \"{identifier}TB\"\n#timer_base.get global.double.get(timer_base_var)\n#timer_base.set(value) global.double.set(timer_base_var, {value})\n\n; \n; Adds era securing capabilities\n; \n\n{lua(\\\n  Era = {};\\\n  Era.elements = {};\\\n  Era.element_cost = {};\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[no parse blocks]] are recommended here to\n; ensuse our input is a string\n; \n; Use this to create the priority listing\n; The macro doesn't check if it's a valid element since\n; the editor checks for us :D\n#set_priority(element_name) {lua(\\\n  local elems = Era.elements;\\\n  local name = [[\"{element_name}\"]];\\\n  --[[/*\\\n      * Prevent recording the same element multiple times\\\n      * by checking if its name has already been read\\\n      * if it has, return to prevent another entry\\\n     */]]\\\n  if elems[name] ~= nil then\\\n    return;\\\n  end\\\n  local index = 1 + #elems;\\\n  elems[index] = name;\\\n  \\\n  local disable_era = [[\"disable.era(%s)\"]]\\\n  Era.element_cost[index] = disable_era:format(elems[index]);\\\n  elems[name] = index;\\\n)}\n\n; important thing to know about disable.cost(element)\n; if we input an element we can't disable, disable.cost returns -1.0\n; \n; Here we use this fact to create an if statement\n; if(disable.cost(\"element\"), \"element\", if(next_element))\n; and we repeat this until our last recorded element\n; that if statement is\n; if(disable.cost(\"element\"), \"element\", \"last_element\")\n#disable.era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.elenent_cost;\\\n  \\\n  local condition_fmt = [[%s != -1]]\\\n  local if_fmt = [[if(%s, %s, %s)]];\\\n  \\\n  local last_element = elems[#elems];\\\n  for i = #elems - 1, 1, -1 do\\\n    local cost = elem_costs[i];\\\n    local condition = condition_fmt:format(cost);\\\n    local caseTrue = elems[i];\\\n    last_element = if_fmt:format(condition, case_true, last_element);\\\n  end\\\n  return last_element;\\\n)}\n\n; Here we construct the condition for the bool ended_era\n; ended_era = -<number_of_elements> == <sum_of_elements_cost>\n#disabled_era {lua(\\\n  local elems = Era.elements;\\\n  local elem_costs = Era.element_cost;\\\n  \\\n  local sum_fmt = [[%s + %s]];\\\n  \\\n  local last_cost = elem_costs[#elems];\\\n  for i = #elements - 1, 1, -1 do\\\n    last_cost = sum_fmt:format(last_cost, elem_costs[i]);\\\n  end\\\n  local negative_costs = 0.0 - #elems;\\\n  local not_equal = [[%s != %s]]\\\n  return not_equal:format(negative_costs, last_cost);\\\n)}\n\n"],["Blueprint Compactor lib",":import Editor_actions lib\n:import Blueprint Compactor resources\n\n; The Devbuild Compactor uses verbose names.\n; Normal compactor uses shortened names to\n; minimize the size of the import code\n\n:const string pointer_var_str \"p\"\n:const string actives \"a\"\n:const string secures \"s\"\n\n:const string timer_base_detector \"dtb\"\n:const string timer_base \"tb\"\n:const string clock \"c\"\n:const string spell_ID \"SI\"\n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[local.int.get(pointer_var_str)]];\\\n  local actives = [[local.string.get(actives)]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = Editor_math(pointer, \"+\", 2);\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, local.int.get(pointer_var_str), 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment local.int.set(pointer_var_str, if(\\\n  contains({get_bits}, \"#\"),\\\n  0,\\\n  local.int.get(pointer_var_str) + {get_space}\\\n))\n\n; \n#modulo_timer {timer.get} % local.double.get(timer_base)\n"],["Blueprint Compactor",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n\n:budget_cap max\n\ngotoif(\\\n  if({timer.get} == 0.0, start_timer, start_secures), \\\n  contains(impulse(), \"{blueprint_compactor}\")\\\n)\n\nlocal.int.set(pointer_var_str, {pointer.get})\nlocal.string.set(actives, {comp_active.get})\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{timer_baseCheck.set({timer_baseCheck.get})}\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n\nexecute(\"{blueprint_compactor}\")\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nassign_base:\nlocal.double.set(timer_base, {timer_base.get})\nlocal.bool.set(\\\n  timer_base_detector,\\\n  {timer_baseCheck.get} || local.int.get(pointer_var) + 3 ==\\\n  index(local.string.get(actives), \"|\", local.int.get(pointer_var_str))\\\n)\n\nloop:\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nlocal.string.set(spell_ID, {get_name})\nlocal.double.set(clock, {get_timer})\n; \nwaituntil({modulo_timer} <= local.double.get(clock))\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(local.string.get(spell_ID)))\nuseposition(active.index(local.string.get(spell_ID)), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\\\n  \"\", \\\n  sub(\\\n    local.string.get(actives),\\\n    local.int.get(pointer_var_str),\\\n    10\\\n  )\\\n)\n\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(lbg(timer_base_detector), loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would've stopped, de-synchronizing things\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(contains({caller.get}, \"idle mode\"), end, timer))\n; The timer will always run, even if the compactor shuts down\n; the only way to stop the timer is by calling the compactor, again\n; outside of towertesting or by stopping all instances of the compactor\n\nstart_secures:\n:local double i\ni = 1.0\nlocal.string.set(secures, {comp_secure.get})\n\nloop_secures:\ndisable.inf(sub(\\\n  local.string.get(secures), \\\n  local.int.get(pointer_var_str), \\\n  index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  ) - local.int.get(pointer_var_str)\\\n))\nwaitframe()\nlocal.int.set(pointer_var_str, if(\\\n  disable.inf.cost() <= 1e3 ^ i, \\\n  local.int.get(pointer_var_str), \\\n  index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  )\\\n))\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\ngoto(if(\\\n  contains({caller.get}, \"idle\") || index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  ) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(\"idle mode\")}\n\nend_instance:"],["Blueprint Compactor with Debugger",":import Blueprint Compactor lib\n:name {blueprint_compactor}\n; \n; This script is a version of the ordinairy compactor, and as such\n; is intended to make every script that uses the compactor think\n; this is their target. This way, you don't have to change much\n; of your blueprint AI\n; \n\n; \n; The debugger adds a layer of complexity to the compactor\n; and makes everything a little bit more computationally intense\n; (so your game will likely be laggier when you\n; run the compactor like this)\n; \n; This is used to tell you what the compactor sees at any 1 time\n; if durring run-time you get undesirable spell execution\n; \n; While the primary goal here is to diagnose issues,\n; you can also use this as a spell compactor to test\n; any changes you've made.\n; This debugger isn't just for uncovering bugs in the compactor\n; —though if you find any, please let me know!\n; Instead, it's meant to help you, the end user, understand:\n; * What you're instructing the compactor to do\n; * How the substring used to compute the\n;   activation sequence changed the recording string\n; \n\n:budget_cap max\n\nkey.x()\n; You have the impulse that lets you cycle through your spells\n; \n:local bool debugging\n\ndebugging = true\n; This debugging_bool is set to true if you want\n; to search for what's going wrong\n; \n; By default I've set this to true so you have to manually disable\n; debugging if you don't want it\ngotoif(\\\n  if(debugging, debug, if(\\\n    {timer.get} == 0.0, \\\n    start_timer, \\\n    start_secures\\\n  )), \\\n  contains(impulse(), \"{blueprint_compactor}\") || debugging\\\n)\n\nlocal.int.set(pointer_var_str, {pointer.get})\nlocal.string.set(actives, {comp_active.get})\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{timer_baseCheck.set({timer_baseCheck.get})}\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n\nexecute(\"{blueprint_compactor}\")\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\nassign_base:\nlocal.double.set(timer_base, {timer_base.get})\nlocal.bool.set(\\\n  timer_base_detector,\\\n  {timer_baseCheck.get} || local.int.get(pointer_var) + 3 ==\\\n  index(local.string.get(actives), \"|\", local.int.get(pointer_var_str))\\\n)\n\nloop:\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nlocal.string.set(spell_ID, {get_name})\nlocal.double.set(clock, {get_timer})\n; \nwaituntil({modulo_timer} <= local.double.get(clock))\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(local.string.get(spell_ID)))\nuseposition(active.index(local.string.get(spell_ID)), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\\\n  \"\", \\\n  sub(\\\n    local.string.get(actives),\\\n    local.int.get(pointer_var_str),\\\n    10\\\n  )\\\n)\n\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, end_instance, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(lbg(timer_base_detector), loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would've stopped, de-synchronizing things\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\nexecute(\"{blueprint_compactor}\")\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\ngoto(if(contains({caller.get}, \"idle mode\"), end, timer))\n; The timer will always run, even if the compactor shuts down\n; the only way to stop the timer is by calling the compactor, again\n; outside of towertesting or by stopping all instances of the compactor\n\nstart_secures:\n:local double i\ni = 1.0\nlocal.string.set(secures, {comp_secure.get})\n\nloop_secures:\ndisable.inf(sub(\\\n  local.string.get(secures), \\\n  local.int.get(pointer_var_str), \\\n  index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  ) - local.int.get(pointer_var_str)\\\n))\nwaitframe()\nlocal.int.set(pointer_var_str, if(\\\n  disable.inf.cost() <= 1e3 ^ i, \\\n  local.int.get(pointer_var_str), \\\n  index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  )\\\n))\ni = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)\ngoto(if(\\\n  contains({caller.get}, \"idle\") || index(\\\n    local.string.get(secures), \\\n    \"|\", \\\n    local.int.get(pointer_var_str)\\\n  ) == -1, \\\n  end_instance, \\\n  loop_secures\\\n))\n\ndebug:\n; It sets the caller to \"debugging\" so that when you\n; force your blueprint AI to send the string over, there's\n; a concrete spot that tells it that it can shut down\n; \n\nlocal.int.set(pointer_var_str, {pointer.get})\nlocal.string.set(actives, {comp_active.get})\n\nglobal.string.set(\"spell_chunk\", sub(\\\n  local.string.get(actives),\\\n  local.int.get(pointer_var_str),\\\n  {get_space}\\\n))\n; The chunk shows you how the spell is stored\n; the order is as shown bellow:\n; * `loop_signal bit` that is / to move to the next spell and # to loop\n; * `sync bit` that is / to refresh budget and `s`\n;    to skip refreshing budget\n\nglobal.int.set(\"pointer\", local.int.get(pointer_var_str))\n; We also have a pointer and next_pointer that shows what value\n; this pointer has at that state\n\nglobal.string.set(\"timer_base\", {lua(return Compactor.timer_base)})\nglobal.string.set(\"spell space\", {lua(return Compactor.space)})\n; space value which is the ammount of space\n; the spell takes up in the recording\n\nglobal.string.set(\"spell_timer\", {lua(return Compactor.timer)})\n; timer value which is the timer\n; you set when adding a spell\n\nglobal.string.set(\"coord_x\", {lua(return Compactor.coord_x)})\n; coord_x which is the coordinate you add\n; if you added a grounded spell\nglobal.string.set(\"coord_y\", {lua(return Compactor.coord_y)})\n; coord_y which is the same idea as coord_x\n; \n; Remember that add_spell.instant is the same\n; as add_spell.grounded with 0, 0 as coordinates\n; \nglobal.string.set(\"spell_name\", {get_name})\n; name which is the spells identifier so we can\n; take an active index of it\n\n{pointer.increment}\n; We finally increment our pointer and add the next pointer state\nglobal.int.set(\"next pointer\", local.int.get(pointer_var_str))\n\nwaitframe()\n; \n; To prevent debugging from being executed when\n; shutting down, and to avoid adding another action\n; debugging also sets the caller to \"idle mode\" when it's done\n; \n; This should be a useless addition however, as setting this should\n; have given your blueprint AI enough time to top itself\n; But just to be safe, the waitframe() should guarantee that your\n; AI has self-terminated successfully\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(\"idle mode\")}\n\nend_instance:"]]}}
```

## The game import

The game import is a code you import inside TPT2

### Blueprint Compactor

This is the program that will execute your spells durring towertesting.<br>
You can read its comments by importing the source version or by looking at [Blueprint Compactor](Blueprint%20Compactor.tpt2). The comments explain how it does things in more detail.

Using the compactor is strictly within the External Editor. While you could communicate with the compactor ingame, I highly advise against it as it uses hidden variables to prevent UI clutter.

Requirements:

- impulse: 0
- conditions: 0
- lines: 30
- scripts: 1

```
7VxNcts2FL6Ky+wamSHpTuPx2K5jr7LqwsvKCxAEZUxIgAOAcdo4Z+hVeoPMJBfrgKASigIkgKYsycJ4hrZgAh/wvR888uHpc8Ahw5XgwdlfnwMABaZE/h1M6yiK0AwRxDAMZ1RQnDdtqUCMAPZ3iImQDXEMaVkBhjklYUbrtECqeVbQFBRtUzhDYppCSrgAql/0W3ON9c3JxUWv/aS5Rg7Xxf6JmpXlfb8bRs25YJjMQkiJAJhwRZPiMMRlVRcc6RYUn1wXNaoYJuLoRvIFBWXBJJiygkJQSDJDbqKoaoWhCJW36thk5xz/gy6iy+tXN4/v5dgSN1Ljt9M2QoAFmbV361CEHP3dOy7YHKHXSQPxy/kbObVLDQVHEBQFYmqBc81SIz2J7yg+mwpep52hVvdKVioTaqeBSYY+/Zm7zMINZmHIluEon5sh+oRgLdwUrKMErSmalCARqbI0nmQ98npqZDRmoJYBGBb3JRIYNl6io+PGnpW++bWWPxOLfWCD6OxXo21+3N4itd2Pt0p6HAlcIi5AWYW1gIQ+zNUWqRmklBZGnTvJWqVDnV1kk6IbTovckgYQveiWXQjX7HhuXj25fT+qHT+nOXms/cLanvvTd18f6B1W923rh8fyWN53vKDu+qjzpaqox/Jm/sK7u70siGHza/R3BV7591b5t03xS8U6ANXxEcbhSdkqofP9v29ffyYa2tfgDwCLmghcTFflnzr8jpaWOilpNl3eJE2jyDfq2vbzC4dRYjhn4K2gD4iFJc3qAoU1R/jnzfHpDJRo/j+ZyfuIlNI6qGxy+yNxdNrHqijHMj04JpiyhI8Ihjmj5Q2lLFMpHh9X7CDWwbkoHwIdIJbXch+t7RSWV8gNBZbqbh9pHDaWNy8fFHmsHcLyBunjN4/lbWcPuru+w1w6Ua+DzQ0DLZ2F7kStBs0Zog6Ocufa17M5AyVyO9/eLyzY0fW+0nY3CX9U+6zV4wre28eVffBO2+bIy2MvgpX9oy75/lX9SLecd/chS/erm0002BcNc9Vk/TKhwahtCtdylfS6R6AQ972B4xVCkQm9AZHBqmU0U0SWa1motTDR2dRa9FFSu5lEmoK4fgHYuhNDLevLeVkiK0jCDBXCYIK/Dif3arQiKn188zwEvNbhmHPXQy3crgbQopyvPy2BswIdlTTTlt3FmaU5rK+IWScCPCyA/8OxnNKWyrac8rZTTpl0M+scwZqhgT6WW/rYDWyl+s3iSeVX8bFd5009jpjOmbxdllcIKTcceWgPfmh8gJNeXn3790rv4yv6oLEHI13YRUe2pQ/ONt7Mdi6/7uGfEUQYX+6aBFecdrIewyrStHWWTtC2e1VHdDLKeeYNrLnKTUxv1o/tQ8K4Rawb8KLL36vw47HAJo7Wbcqny/e5B0ZPDJ5H/S4Cc/AS3E0CSEmG51+TcTcJ2lr99hOR+8xZoA8jKwA/gJn8fzAJ0jqbIRGcHceToObouv0oWI2+3H35Hw==
```

### Blueprint Compactor with Debugger

This is the program, similar to the normal [Blueprint Compactor](#blueprint-compactor), that includes debugging functionality.<br>
You can read an explanation of what it does by looking at the comments in [Blueprint Compactor with Debugger](Blueprint%20Compactor%20with%20Debugger.tpt2).

You have a local boolean called "debugging" set to true by default. This lets you see the data string obtained from your blueprint AI. You use key.x() to go through your spells.

Requirements:

- impulse: 1
- conditions: 0
- lines: 44
- scripts: 1

```
7V3dUts4FH4V1r1bgjcOnUmXAZbCVa/2gssNwyiyYjTYkkeSC2zpM+yr7Bt0pn2xji0HjC0TyySNHZ9hxoBi6ZOOvvNjyUf54kgsaKykc/TPFwdhRTlL/3ZmyXg8JiHHKHTnnIeuJGo2x5xJhZjKPn0/Uz6ZJ0FAWVD6yNNXZ5S3ExBGBMVuwBWni6xsrohgSDy4NK9TBAtswCbp1SPZ3+PKtYzjeZhHMRJUcub6PJmHRBcHIZ+jMC8y9iAbk7l4cnJSKj+s6U/91TSqScP7pjWtLgqDTSWrC6USlAUu5kwhyqQWvyaCS6M4CSUxjdI7PA8TEgvK1N5F2i5WXJjF8fhoOacpVYS+mzJlZFsm/jgnlJ6s9FZTu+JY0n/Jyfj0/N3F46echt5Yt5+PvhYCveBDfrex92nrHz9KJZYIpUoGiN+O/0i7dmqQ5B5GYUiEHuCStbqlN03b2DuaKZnMC029XstEuucrybtBmU/u/17Y9MIO5kWTS1OyWJoSck9woprztESCXM3rSDBRc63FcuKXhFeiUa2hQHoYSFB1ExFFcWaBChyvrRmbi/eN8quTYhm4Zuqaj8ZY/Li9QRqrH2xV6N5Y0YhIhaLYTRRm/O7JA67wpBnX/Jx0pGC0Nzl17cWSursWgn5plm0EbvCmdlZ9cvlprXr8K9UJsPqFtT3zZ67uQfXKdShcBKx+YYHt6GF1c9S5qxQFLFDzHa9ut1jg4ezX2tcKgPy9Jf+2RbyrWAOgDkQYw5vlRptFP/7//u15oyFfBr9DVCVM0XD22t5WQb5r2/I6jLg/qzrJulbSFXVj+fGJRSseXkpgqvgdEW7E/SQkbiIJfb7Z+xCgiCw/S3c1PxNNWgvKTi6fNo4+lLFiLmm6VbpOMK0Jnwl2F4JHF5wLX2/xQFzRQazBmSgIgQaIBSyHaK1TWEDIDQWW+m6INIaNBeoFQRFgdQgLFBLiN8AC3elBdds1zEpWgAHWq2uo8i50IWqtYU4bOljOuzQuzy4Eiojd++2V5IhujvedsXrdnK1VPxP9uEJ7+7jSB+u0bRnBfPQiWOmf6CY/vumf1Cwvin6oofk19Wbc2ha1M9Vs9TBxjVI3SYpb6E2vG4JCdVNq2HtlUtINvRaRwWvDGDUcxsp8s2SZZlGWpVrdiexqyLMr536telkoF3h1S5alySOuT0JVo32/t5fr2dryp8yhza8RwL4Jp37buq1yN0v/a5DJV+6Won5I9iLuVzLu9pvxz3tfvc/yXTXaLmz/yzKJsqkU8yTKy0IS5aS4ny4JTgRpaVllQ8u6AQdqdhFvSrryDppV3tRDSN3bJdPqfLmYy5oXHfLXPQzqb8XLs+//nZnNe8zvDPpQKy5qw5Ft8cFax7PeLuev+MrPGqbQO+3aDL7yjlPjNhrFl02NpRV0UzfVNJV/M74ru6b+y6zWy4T/9aaubsCKVk9qeHoYaBI9m5zyn9X7hnKcgaaqjEkYXuObhN1u+BkogWUfWPYZ2nzAss8mln3KhrfOuk1jTpkiwjb4Xmk6s8ddcT1Hsu3zDRwxMqgjRlq55T0ZI7xegg1jnsFf9nU+wF+2FV27wD/zY721MEABMIY9wBoAdTpqt2GWt+hipjhNhLy+B/fSMazdZyp4QsACloPT7hQWEHIj8cUDxBcDxgKlglAIsDqEBQoJURtgge50sbrNDr/eH2Eo6u8GLGD1CwvUv9vVt80PwAIssB07VB2idsACNd+h6nBUCBwV0jt93baMYD56ESr0T3TWOSMLRu7VXsukkbefrfCy2ProjbV+k3G5i8/nHzhXIwdz5tPlF45fjZz8m36zrx+/JQ/ufXpTunbmHDnmAylihG9RkH7ujJx54gdEOUcH3shJJDnP/1UiIV+vvv4E
```

# Changelog

## version 2.7.2

Removed To Be Done<br>
The user can now define a base for their timer.<br>
The compactor can now also secure modules durring towertesting.<be>
Added watercat and easy eracat macros.

## version 2.6.0

Added a To Be Done<br>
At this stage, I'm never going to be able to get any work done with it.

Modified recorded_blueprint to also save the ammount of space used in the recording to a global table Spell.comp.blueprint. This way, the user can retrieve this value dynamically in lua code, and, as shuch, does not need to manually change the value after modifying the blueprint.

## version 2.5.0

Added the Compactors manual.<br>
Adding a spell now also returns a const int holding the recordings space after adding the spell.<br>
Finally finished this thing and can publish it on discord.

## version 2.1.5

Re-introduced the index dependency as using sizes was far too expensive<br>
The compactor now also has a version with the debugger.

## version 2.0.0

Overhauled the entire recording system to no longer use index.

## version 1.05.1

Changed syncronize to synchronize

## version 1.05.0

Formatted the README to be a concise description of the compactor.

## version 1.01.0

The stand-alone debugger can now read the naming scheme.<br>
Fixed 2 major bugs in the compactor:

1. it would crash if there wasn't a sync before the first recording
1. spell.active_max_size would be 6 units shorter because they wouldn't be taken into account

## verson 1.0.0

Released the stand alone spell compactor and made it functional
