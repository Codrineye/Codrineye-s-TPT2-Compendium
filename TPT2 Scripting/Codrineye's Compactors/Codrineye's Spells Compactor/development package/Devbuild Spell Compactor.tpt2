:import Devbuild Spell Compactor Utils
:name devbuild Spell Compactor

; 
; Welcome to the compactor, a set of 2 lua macros + macros defined
; at the bottom of the script for the user interactions
; 
; This compactor is structured to be as easy to read and as
; flexible as possible, the following comments will explain
; what you are looking at
; 
; This first lua macro defines our global variables
; working in the table `spell`
; everything here is strictly to process spell values
; if a name appends spell. it is defined in the spell compactor
; if a name appends utils. it is defined in the compactors Utils
; if a name appends spell_comp it's a spell compactor utility
; if a name appends spell_debug it's a debugging utility
; 

{lua(\
  spell = {}; --[[Root Table]]\
  spell.stop = false;\
  spell.active = {}; --[[Table holds spell data]]\
  spell.active.space = 0; --[[keep track of how much space is used]]\
  spell.active.pointer_mult = 1; --[[getting implemented]]\
  spell.active.sync_ammount = 0; --[[ammount of spells getting sync'd]]\
)}

; Recording format change
; currently we have
; `sync` . `timer` . `coord_x` . `coord_y` . `name` . `text end char`
; 
; format change to
; sync . cooldown . coord_x . coord_y . name . pointer mult
; ---------------------------
; sync detector = always 1 character
; sync no longer makes copies of the script, it now tells the AI to
; perform a waitframe() after all spells that required synchronization
; have been activated
; 
; size of cooldown size
; cooldown size
; spell activation timer
; 
; size of coord_x size
; coord_x size
; coord_x
; 
; size of coory_y size
; coord_y size
; coord_y
; 
; size of name_size
; name_size
; name
; 
; pointer_mult
; 1 by default
; 0 on add_blueprint() call
; this works by pointer = pointer * s2i(sub(`pointer_mult`, pointer, 1), 0)
; always 1 character
; ---------------------------
; 
; Also, remove a large majority of comments in public build
; and include comments **in** the lua macros as well as outside
; 

{lua(\
  function spell.add_blueprint(blueprint_name)\
      --[[/*\
          * Adding a new blueprint marks the end of this "chunk"\
          * For the stand-alone compactor to recognize this, we set\
          * this multiplier to 0, so that the pointer can go back\
          * to the start of the recorded sequence.\
         */]]\
    spell.active.pointer_mult = 0;\
    local bp_name = "blueprint_" .. blueprint_name;\
    return spell_comp.const("int", bp_name, spell.active.space);\
    --[[/*\
        * Returned value is used by user to take an index in a\
        * substring action to extract the desired recorded sequence\
       */]]\
  end\
  \
  function spell.sync(spell_ammount)\
    --[[/*\
        * Sync system prevents the compactor from refreshing its budget\
        * until all synchronized spells have been used.\
       */]]\
    local sync_ammount = tonumber(spell_ammount);\
    if sync_ammount < 0 then\
      local printer = table.pack(\
        "Attempt to add a negative sync ammount at spell nr ",\
        1 + #spell.active, "\n", "Default behaviour sets it to 0"\
      );\
      print(table.concat(printer));\
    end\
    sync_ammount = math.max(0, sync_ammount);\
    --[[/*\
        * max operation prevents sync_ammount from being negative\
        * value in spell.active.sync_ammount always gets overwritten\
       */]]\
    spell.active.sync_ammount = sync_ammount;\
  end\
  \
  function spell.add_spell(name, spell_type, timer, ...)\
    local halt_limit_reached = spell_debug.halt_limit == 0;\
    halt_limit_reached = halt_limit_reached and spell_debug.can_halt;\
    --[[Check if our halt limit has been reached]]\
    \
    if halt_limit_reached or spell.stop then\
      --[[/*\
          * Prevent spells from getting recorded if halted,\
          * a halted compactor stops recording data\
         */]]\
      return;\
    end\
    \
    local actives_index = 1 + #spell.active;\
    local new_spell = {};\
    --[[/*\
        * Record the pointer multiplier and then set it to 1,\
        * Must be reset to 1 in case we added a blueprint\
       */]]\
    new_spell.pointer_mult = spell.active.pointer_mult;\
    local used_space = 1\
    --[[/*\
        * Recordings take space in the compacted data\
        * We keep track of the space we're taking up with this variable\
       */]]\
    spell.active.pointer_mult = 1;\
    \
    new_spell.sync = 0;\
    used_space = 1 + used_space;\
    --[[Add the ammount of space the sync marker takes up]]\
    \
    local can_sync = spell.active.sync_ammount > 0;\
    if can_sync then\
      new_spell.sync = 1;\
      spell.active.sync_ammount = spell.active.sync_ammount - 1;\
      --[[/*\
          * Signals that we don't refresh the execution budget\
          * Decrement our sync ammount\
         */]]\
    end\
    new_spell.name = name:gsub(" ", "");\
    \
    local grounded_spell = spell_type:gsub(" ", "") == "grounded";\
    new_spell.grounded = grounded_spell;\
    --[[/*\
         * Check to see if the spell_type is grounded\
         * if it is, we've got to include our coordinates\
        */]]\
    local parameters = table.pack(timer);\
    local doubles = table.pack("timer");\
    if grounded_spell then\
      parameters = table.pack(timer, ...);\
      doubles = table.pack("timer", "coord_x", "coord_y");\
    end\
    \
    for i, variable in ipairs(doubles) do\
      local value = tonumber(parameters[i]);\
      new_spell[variable] = {};\
      new_spell[variable] = 0.0 + value\
      --[[/*\
          * the addition with 0.0 here is to guarantee\
          * the correct data type. timer, coord_x, coord_y need to be\
          * doubles for the actions waitwhile() and vec().\
          * float and double are the same type in this editor\
         */]]\
    end\
    --[[/*\
        * Get all our spell data inside a table. We use table.unpack\
        * instead of table.concat() here to retain the ability to\
        * index between the values in the "doubles" table\
       */]]\
    local spell_data = table.pack("name", "timer");\
    local sizes = table.pack("name_size", "timer_size");\
    if grounded_spell then\
      spell_data = table.pack(\
        table.unpack(spell_data), \
        "coord_x", "coord_y"\
      );\
      sizes = table.pack(\
        table.unpack(sizes), \
        "size_x", "size_y"\
      );\
    end\
    for i, variable in ipairs(spell_data) do\
      local size = sizes[i];\
      new_spell[size] = {};\
      new_spell[size] = #tostring(new_spell[variable]);\
      used_space = used_space + new_spell[size];\
      --[[/*\
          * Get the ammount of characters in each variable\
          * and add this ammount to our used space\
         */]]\
    end\
    for i, size in ipairs(sizes) do\
      local size_of_size = size .. "_size";\
      new_spell[size_of_size] = {};\
      new_spell[size_of_size] = #tostring(new_spell[size]);\
      used_space = used_space + 1 + new_spell[size_of_size];\
      --[[/*\
          * Get the size of each variables size\
          * then add these to the used space\
          * we add 1 to it because we've also got\
          * a marker telling us this size\
         */]]\
    end\
    \
    local space = used_space;\
    local prev_space = -1;\
    \
    while space ~= prev_space do\
      prev_space = space\
      new_spell.space = space;\
      new_spell.space_size = #tostring(new_spell.space);\
      new_spell.space_size_size = #tostring(new_spell.space_size);\
      space = used_space;\
      local spaces = table.pack("space_size", "space_size_size");\
      for _, size in ipairs(spaces) do\
        space = space + new_spell[size];\
      end\
    end\
    \
    used_space = space;\
    \
    spell.active[actives_index] = new_spell;\
    spell.active.space = spell.active.space + used_space;\
    --[[/*\
        * Add the space used in this recording to our\
        * overall used space\
       */]]\
    \
    local logging_check = spell_debug.can_halt or spell_debug.can_log;\
    if logging_check then\
      spell_debug.log();\
    end\
    if spell_debug.can_halt then\
      spell_debug.halt_limit = spell_debug.halt_limit - 1;\
    end\
  end\
  \
  function spell.concat_actives()\
    local spells = {}; --[[table holding the compacted data]]\
  \
    local actives = spell.active; --[[access our recordings]]\
    local actives_count = #spell.active; --[[nr of recordings]]\
    actives[actives_count].pointer_mult = 0;\
    --[[Set the last multiplier to 0 to enables sequence looping]]\
    \
    local index = 0; --[[index to access our recordings]]\
    \
    local spells_debug = table.pack(\
      "format", "space", "chunk"\
    );\
    utils.pack_assign(spells_debug, "", table.unpack(spells_debug));\
    \
    local text_debugging = spell_debug.can_display;\
    \
    if text_debugging then\
      spells_debug.format = spell_debug.concat_format;\
      spells_debug.space = " ";\
      spells_debug.chunk = spell_debug.chunk;\
    end\
    \
     --[[/*\
         * Sequence for concatenation. Broken up into separate\
         * local functions to add implementation flexibility and to\
         * improve overall readability\
        */]]\
    \
    local function number_handling()\
      local nr = actives[index];\
      \
      spells = table.pack(\
        table.concat(spells), \
        spells_debug.format, nr.space_size_size,\
        spell_debug.space, nr.space_size,\
        spell_debug.space, nr.space,\
        \
        spell_debug.format, nr.sync\
      );\
      --[[Add the used_space and the sync]]\
      \
      local numbers = table.pack("timer");\
      local number_sizes = table.pack("timer_size");\
      if actives[index].grounded then\
        numbers = table.pack("timer", "coord_x", "coord_y");\
        number_sizes = table.pack("timer_size", "size_x", "size_y")\
      end\
      local size_sizes = {};\
      for i, size in ipairs(number_sizes) do\
        size_sizes[i] = size .. "_size";\
      end\
      \
      for i, number in ipairs(numbers) do\
        local size_of_size = size_sizes[i];\
        local number_size = number_sizes[i];\
        spells = table.pack(\
          table.concat(spells),\
          spells_debug.format, nr[size_of_size], \
          spells_debug.space, nr[number_size], \
          spells_debug.space, nr[number]\
        );\
      end\
    end\
    local function text_handling()\
      local text = actives[index]\
      spells = table.pack(\
        table.concat(spells),\
        spells_debug.format, text.name_size_size,\
        spells_debug.space, text.name_size,\
        spells_debug.space, text.name\
      )\
    end\
    while index < actives_count do\
      index = index + 1;\
      number_handling();\
      text_handling();\
      spells = table.pack(\
        table.concat(spells), \
        spells_debug.format, actives[index].pointer_mult,\
        spells_debug.format, spells_debug.chunk\
      );\
    end\
    return table.concat(spells);\
  end\
)}

; 
; Helper macros to make the user interact with the
; compactor in an easier manner
; 

#add_blueprint(name) {lua(return spell.add_blueprint("{name}"))}
#synchronize(spell_count) {lua(return spell.sync({spell_count}))}

; general add_spell lua function call
#add_spell(name, type, timer, coord_x, coord_y) {lua(\
  return spell.add_spell(\
    '{name}',\
    [[{type}]],\
    [[{timer}]],\
    [[{coord_x}]],\
    [[{coord_y}]]\
  );\
)}

#add_spell.instant(name, timer) {add_spell(\
  {name},\
  instant,\
  {timer}, ,\
)}
; Exclude the x, y coordinates for instant spells
#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\
  {name},\
  grounded,\
  {timer},\
  {coord_x},\
  {coord_y}\
)}
