:import Editor_actions lib
:import Devbuild Spell Compactor resources
:name devbuild Spell Comp lib

; Editor_actions lib lets me create actions; that the editor can parse
; in a lua macro
; 
; The main goal is to extract all the data of a spell into its components
; The spell data is compacted as follows
; 
; loop_sign bit
; sync bit
; space
; timer
; coord_x coord_y
; name
{lua(\
  local pointer = [[pointer]];\
  local actives = [[compactor]]\
  \
  local function s2i(compactor)\
    return Editor_convertStringToInt(compactor, -1);\
  end\
  local function s2d(compactor)\
    return Editor_convertStringToDouble(compactor, -1.0);\
  end\
  \
  local offset = [[pointer + 2]];\
  local index = "";\
  local size = "";\
  local separator = Editor_stringify_value("|");\
  \
  local compactor_vals = table.pack(\
    "space",\
    "timer",\
    "coord_x", "coord_y",\
    "name"\
  );\
  Compactor = {};\
  \
  for i, value in ipairs(compactor_vals) do\
    index = Editor_index(actives, separator, offset);\
    size = Editor_encase_value(offset);\
    size = Editor_math(index, "-", size);\
    Compactor[value] = Editor_sub(actives, offset, size);\
    local val = string.format("%s_value", value);\
    if i == 1 then\
      Compactor[val] = s2i(Compactor[value]);\
    elseif i < #compactor_vals then\
      Compactor[val] = s2d(Compactor[value]);\
    end\
    offset = Editor_math(index, "+", 1);\
  end\
)}

; 
; guide for size
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 

:local int pointer
:local string compactor

:local double clock
:local string spell_ID

#get_bits sub(compactor, pointer, 2)
#get_space {lua(return Compactor.space_value)}
#get_timer {lua(return Compactor.timer_value)}
#get_coord_x {lua(return Compactor.coord_x_value)}
#get_coord_y {lua(return Compactor.coord_y_value)}
#get_pos vec({get_coord_x}, {get_coord_y})
#get_name {lua(return Compactor.name)}

#pointer.increment pointer = if(\
  contains({get_bits}, "#"),\
  0, \
  pointer + {get_space}\
)
