# Codrineye's Spell Compactor

This subset of the compactor is for development purposes only.

It features a packaged in Spell Config, for using the debug functions for development and not just for a broad look in what's going on.

```
{"workspaces":{"Spell Compactor Devbuild":[["Devbuild Software Config",":import Devbuild Spell Config\n:name devbuild Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(0)}\n{wave_streaming(0)}\n{wave_surge(0)}\n{critical_wave_jump(0)}\n{wave_momentum(0)}\n{wave_storm(0)}\n{wave_persistence(0)}\n{wave_instability(0)}\n{wave_vortex(0)}\n{wave_catalyst(0)}\n{wave_endurance(0)}\n{new_bounds(0)}\n{wave_marathon(0)}\n{wave_compression(0)}\n{era_surge(1)}\n{era_burst(0)}\n{era_swirl(0)}\n{wave_horizon(0)}\n{no_bounds(0)}\n{era_tunneling(0)}\n{wave_breach(0)}\n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n{wave_restart(0)}\n{infinity_horizon(0)}\n\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n:const string secure_list {software.concat(secure_list)}\n\n; sub(software_list, i + 2, s2i(sub(software_list, i, 2), 0))\n; sub(software_secure, i + 1, s2i(sub(software_secure, i, 1), 0))\n; \n\n; sub = 3\n; index = 3\n; a.i = 3\n; lig = 1\n; s2i = 2\n; \n; sub(secure_list, i + 2, s2i(sub(secure_list, i, 2), 0))\n; sub + a.i + lig + s2i + sub + lig\n; 3 + 3 + 1 + 2 + 3 + 1 = 13\n; sub(\\\n;   secure_list, \\\n;   i + 3 + s2i(sub(secure_list, i, 2), 0), \\\n;   s2i(\\\n;     sub(\\\n;       secure_list, \\\n;       i + 4 + s2i(sub(secure_list, i, 2), 0), \\\n;       0\\\n;     ), \\\n;     0\\\n;   )\\\n; )\n; sub +\n; a.i + lig + a.i + s2i + lig +\n; s2i + sub + a.i + lig + a.i + s2i + lig\n; 3 + \n; 3 + 1 + 3 + 2 + 1 +\n; 2 + 3 + 3 + 1 + 3 + 2 + 1\n; = 3 + 10 + 2 + 10 + 2 + 1 = 3 + 3 + 22 = 25\n; 13 + 25 = 38\n; \n; sub(secure_list, i, index(secure_list, \"|\", i) - i)\n; sub + lig + a.i + index + lig + lig\n; 3 + 1 + 3 + 3 + 1 + 1 = 12\n; sub(\\\n;   secure_list, \\\n;   1 + index(secure_list, \"|\", i), \\\n;   index(\\\n;     secure_list, \\\n;     \"|\", \\\n;     1 + index(secure_list, \"|\", i)\\\n;   ) - index(secure_list, \"|\", i)\\\n; )\n; sub +\n; a.i + index + lig +\n; a.i + index + a.i + index + lig + index + lig\n; 3 + \n; 3 + 3 + 1 +\n; 3 + 3 + 3 + 3 + 1 + 3 + 1 \n; = 3 + 7 + 17 = 27\n; 12 + 27 = 39\n; "],["Devbuild Security Config",":import Devbuild Spell Compactor\n:name devbuild Security Config\n\n"],["Devbuild Spell Config",":import Devbuild Spell Compactor\n:name devbuild Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; Please read the compactor manual on the repo for a better\n; understanding of how to use it\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n\n{add_spell.instant(barrier.temporal, 0.0)}\n; adds the instant spell `temporal barrier` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t >= 0.0\n\n{recorded_blueprint(start, false)}\n; defines the blueprint called \"blueprint_start\" that doesn't loop\n; the spell activation sequence when it executes the last spell\n\n{synchronize(2)}\n; makes the next 2 recordings happen on the same game_tick\n\n{add_spell.instant(spell.response.neutral, 0.0)}\n; adds the instant spell `neutral response` to be used when t >= 0.0\n{add_spell.grounded(spell.void, 10.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t is a multiple of 10.0\n{timer_modulo(0.0)}\n{recorded_blueprint(loop, true)}\n; defines the blueprint called \"blueprint_loop\" that loops\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n; adds the instant spell `snap of destiny` to be used\n; when t is a multiple of 28.0\n\n; \n; If you just sent the sequence `recorded_actives` to the compactor\n; you'd execute\n; temporal barier, void, neutral response, void\n; and loop back to using temporal barrier\n; \n; Notice that, since blueprint_loop has the loop property\n; snap of destiny will never be executed\n\n; \n; To execute just blueprint_start, you can cut that sequence\n; by using sub(recorded_actives, 0, blueprint_start)\n; \n; If you want to isolate blueprint_loop, you cut it using\n; sub(recorded_actives, blueprint_start, blueprint_loop - blueprint_start)\n; \n; and if you want to use snap of destiny every 28 seconds you use\n; sub(recored_actives, blueprint_loop, recording_size)\n; The last spell always gets the looping tag\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return Spell.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n\n:const int recoring_size {lua(return Spell.active.space)}\n"],["Devbuild Spell Compactor",":name devbuild Spell Compactor\n\n{lua(\\\n  Spell = {};\\\n  \\\n  --[[Table holding information needed for debugging]]\\\n  Spell.debug = {};\\\n  Spell.debug.can_log = false;\\\n  Spell.debug.can_halt = false;\\\n  Spell.debug.halt_limit = 0;\\\n  Spell.debug.can_display = false;\\\n  Spell.debug.concat_format = \"\";\\\n  \\\n  --[[Table holding information needed for recording]]\\\n  Spell.active = {};\\\n  Spell.active.space = 0;\\\n  Spell.active.sync_ammount = 0;\\\n  \\\n  --[[Table that has spell_compactor data]]\\\n  Spell.comp = {};\\\n  \\\n  --[[Store the module secures]]\\\n  Spell.comp.secure = {};\\\n  \\\n  --[[Store the software security levels]]\\\n  Spell.comp.software = {}\\\n  \\\n  --[[Blueprint activation]]\\\n  Spell.comp.active = {};\\\n  Spell.comp.blueprint = {};\\\n)}\n\n; macros for communicating with the compactors debugging system\n#spell_debug {lua(Spell.debug.halt())}\n#spell_debug.add_breakpoint {lua(\\\n  Spell.debug.can_display = true;\\\n  Spell.debug.halt();\\\n)}\n\n#spell_debug.log(level) {lua(Spell.debug.can_log = {level})}\n#spell_debug.can_halt(level) {lua(\\\n  Spell.debug.can_halt = {level};\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  Spell.debug.halt_limit = {limit};\\\n)}\n#spell_debug.display_spells(level) {lua(\\\n  Spell.debug.can_display = {level};\\\n)}\n#spell_debug.display_format(format) {lua(\\\n  Spell.debug.concat_format = {format};\\\n)}\n\n{lua(\\\n  --[[Internal method to terminate the program for debugging]]\\\n  local spell_debug_stop = false;\\\n  \\\n  --[[list of all the software]]\\\n  local software_list = table.pack(\"autoskip\", \"wavestreaming\", \\\n    \"wavesurge\", \"criticalWavejump\", \"wavemomentum\",\\\n    \"wavestorm\", \"wavepersistence\", \"waveinstability\",\\\n    \"wavevortex\", \"wavecatalyst\", \"waveendurance\",\\\n    \"newbounds\", \"wavemarathon\", \"wavecompression\",\\\n    \"erasurge\", \"eraburst\", \"eraswirl\", \"wavehorizon\",\\\n    \"nobounds\", \"eratunneling\", \"wavebreach\", \"wavefloor\",\\\n    \"erafloor\", \"erahorizon\", \"waverestart\", \"infinityhorizon\"\\\n  );\\\n  for _, soft in ipairs(software_list) do\\\n    local software_name = string.format(\"software.%s\", soft);\\\n    Spell.comp.software[software_name] = -50;\\\n  end\\\n  \\\n  function Spell.comp.add_software(software, level)\\\n    local software_name = string.format(\"software.%s\", software);\\\n    assert(\\\n      Spell.comp.software[software_name],\\\n      \"Attempt to assign a security level to an unrecognized software\\n\"\\\n      .. \"If this is a new software, add it to the software_list\"\\\n    ); --[[triggers an error if software_name isn't in software_list]]\\\n    assert(\\\n      Spell.comp.software[software_name] == -50,\\\n      \"Trying to assign a security level to an already set software\"\\\n    ); \\\n    --[[/*\\\n        * lowest security level I've seen yet is -1\\\n        * thus, a security level of -50 is the default value\\\n       */]]\\\n    local secure_level = level:match('%b\"\"'):sub(2, -2);\\\n    assert(\\\n      tonumber(secure_level), \\\n      \"Trying to assign an empty security level\"\\\n    );\\\n    --[[Assert will trigger an error if tonumber() returns nil]]\\\n    Spell.comp.software[software_name] = tonumber(secure_level);\\\n    local printer = \"%s = %s\";\\\n  end\\\n  \\\n  function Spell.comp.concat_software(concat_mode)\\\n    local string_fmt = [[\"%s\"]];\\\n    do\\\n      local modes = {};\\\n      modes.software_list = 0;\\\n      modes.software_secure = 1;\\\n      modes.secure_list = 2;\\\n      assert(\\\n        modes[concat_mode],\\\n        \"Invalid concat_mode.\\n\"\\\n        .. \"If you're seeing this, you're either a user that messed \"\\\n        .. \"with something you shouldn't have, or I messed up\"\\\n      );\\\n    end\\\n    local software = \"\";\\\n    if concat_mode == [[software_list]] then\\\n      local software_fmt = \"software.%s|\";\\\n      for _, soft in ipairs(software_list) do\\\n        local software_name = software_fmt:format(soft);\\\n        software = software .. software_name;\\\n      end\\\n    elseif concat_mode == [[software_secure]] then\\\n      local software_fmt = \"software.%s\";\\\n      local secure_fmt = \"%s%s|\";\\\n      for _, soft in ipairs(software_list) do\\\n        local software_name = software_fmt:format(soft);\\\n        local software_val = Spell.comp.software[software_name];\\\n        software = secure_fmt:format(software, software_val);\\\n      end\\\n    else\\\n      local software_fmt = \"software.%s\";\\\n      local secure_fmt = string.rep(\"%s\", 5);\\\n      for _, soft in ipairs(software_list) do\\\n        local software_name = software_fmt:format(soft);\\\n        local software_val = Spell.comp.software[software_name];\\\n        local secure_pack = table.pack(\\\n          software, \\\n          #software_name, software_name, \\\n          #tostring(software_val), software_val\\\n        );\\\n        software = secure_fmt:format(table.unpack(secure_pack));\\\n      end\\\n    end\\\n    return string_fmt:format(software);\\\n  end\\\n  \\\n  function Spell.comp.recorded_secures(blueprint_name)\\\n    \\\n  end\\\n  function Spell.comp.add_secure(module_name)\\\n    \\\n  end\\\n  function Spell.comp.concat_secures()\\\n  end\\\n  \\\n  function Spell.comp.recorded_blueprint(name, loopable)\\\n    --[[/*\\\n        * This function is used to mark the end\\\n        * of a blueprint recording to start making another recording\\\n        * \\\n        * It returns a const int that holds how much space you used up\\\n        * so that you can take a substring of the compacted string\\\n        * more easily\\\n        * \\\n        * blueprint_name is used to create the const int name\\\n        * loopable_blueprint determines if this is a blueprint sequence\\\n        * that gets looped or not\\\n       */]]\\\n    if loopable then\\\n      local active_index = #Spell.comp.active;\\\n      Spell.comp.active[active_index].loop_sign = \"#\";\\\n      --[[/*\\\n          * Changes the loop sign to `#` so that we can\\\n          * easily check it with a contains of the full spell\\\n         */]]\\\n    end\\\n    local space = Spell.active.space;\\\n    --[[Get the ammount of space we've currently used up]]\\\n    local bp_name = name:match('%b\"\"'):sub(2, -2);\\\n    --[[removes the quote marks from the match operation]]\\\n    Spell.comp.blueprint[bp_name] = space;\\\n    --[[/*\\\n        * And create a blueprint that stores\\\n        * How much space we've used up thus far\\\n       */]]\\\n    bp_name = string.format(\"blueprint_%s\", bp_name);\\\n    --[[change the bp_name so we can output it as a const int]]\\\n    return string.format(\":const int %s %s\", bp_name, space)\\\n  end\\\n  function Spell.comp.blueprint_base(defined_base)\\\n    --[[/*\\\n        * Defines the base at which a loopable blueprint\\\n        * uses the timer. This is used to calculate `tm` such that\\\n        * the active timer is compared to tm, which makes\\\n        * spell activation more precise\\\n       */]]\\\n    local spell = Spell.comp.active[#Spell.comp.active];\\\n    assert(\\\n      spell.timer_base, \\\n      \"Trying to add a timer_base without any recorded spells\"\\\n    );\\\n    spell.timer_base = string.format(\"%s|\", defined_base);\\\n    local space = tonumber(spell.space:sub(1, -2));\\\n    space = space + #spell.timer_base;\\\n    spell.space = string.format(\"%s|\", space);\\\n    --[[We're adding to the recording, we update the recording space]]\\\n  end\\\n  \\\n  function Spell.comp.sync(spell_ammount)\\\n    --[[/*\\\n        * The synchronization system prevents the\\\n        * script from refreshing the budget untill\\\n        * all synchronized spells have been used.\\\n       */]]\\\n    \\\n    local sync = tonumber(spell_ammount);\\\n    assert(sync >= 0, \"Trying to add a negative sync_ammount\");\\\n    --[[Synchronizing less than 1 spell is meaningless]]\\\n    \\\n    sync = sync - 1;\\\n    --[[/*\\\n        * We subtract 1 from the sync_ammount\\\n        * to cover the first spell\\\n        * \\\n        * Sync_ammount always gets overwritten\\\n       */]]\\\n    Spell.active.sync_ammount = sync;\\\n  end\\\n  \\\n  function Spell.comp.add_spell(name, timer, coord_x, coord_y)\\\n    --[[Function that records a spell]]\\\n    \\\n    local dbug = Spell.debug;\\\n    local halt_limit = dbug.halt_limit == 0 and dbug.can_halt;\\\n    --[[/*\\\n        * Check if we should halt the program\\\n        * \\\n        * We halt if our halt limit has been reached\\\n        * or if our spell_debug_stop flag has been set to true\\\n       */]]\\\n    if halt_limit or spell_debug_stop then\\\n      Spell.debug.halt();\\\n    end\\\n    \\\n    local match_string = [[%b\"\"]];\\\n    local active_name = name:match(match_string):sub(2, -2);\\\n    \\\n    local actives_index = 1 + #Spell.comp.active;\\\n    local new_spell = {};\\\n    \\\n    new_spell.loop_sign = \"/\";\\\n    --[[/*\\\n        * loop sign is by default \"/\" to show that nothing happens\\\n        * aka, our pointer is increased by 2 + space.\\\n        * \\\n        * When loop_sign is \"#\", our pointer is reset to 0\\\n        * to loop our sequence\\\n       */]]\\\n    new_spell.sync = \"/\";\\\n    new_spell.timer_base = \"|\";\\\n    local used_space = 3;\\\n    --[[/*\\\n        * Recordings take up space, we keep track\\\n        * of how much space has been used with used_space\\\n        * used_space is currently 3 because, sync and loop_sign\\\n        * are length-1 signals and the timer_base is empty by default\\\n       */]]\\\n    local sync = Spell.active.sync_ammount;\\\n    if sync > 0 then\\\n      new_spell.sync = \"s\";\\\n      Spell.active.sync_ammount = sync - 1;\\\n    end\\\n    --[[\"s\" means that the script skips refreshing the budget.]]\\\n    new_spell.name = active_name;\\\n    \\\n    local parameters = table.pack(timer, coord_x, coord_y);\\\n    local spell_values = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    \\\n    for i, variable in ipairs(spell_values) do\\\n      local value = tonumber(parameters[i]);\\\n      new_spell[variable] = {};\\\n      new_spell[variable] = 0.0 + value\\\n      --[[/*\\\n          * the addition with 0.0 here is to guarantee \\\n          * the correct data type.\\\n          * timer, coord_x and coord_y need to be doubles \\\n          * for the actions waitwhile() and vec().\\\n          * float and double are the same type in this editor\\\n         */]]\\\n    end\\\n    spell_values[4] = \"name\";\\\n    for _, variable in ipairs(spell_values) do\\\n      new_spell[variable] = string.format(\"%s|\", new_spell[variable]);\\\n      used_space = used_space + #new_spell[variable];\\\n      --[[/*\\\n          * string.format converts the value in\\\n          * new_spell[variable] into a string. Meaning that\\\n          * I no longer have to convert the value to a string myself\\\n         */]]\\\n    end\\\n    \\\n    local internal_space = used_space;\\\n    local prev = -1\\\n    while prev ~= used_space do\\\n      prev = used_space;\\\n      new_spell.space = string.format(\"%s|\", used_space);\\\n      used_space = internal_space + #new_spell.space;\\\n    end\\\n    --[[/*\\\n        * Add the extra space taken up by our signal bits\\\n        * and space recording.  We add our space here so that\\\n        * we don't have to pass through the entire string an extra time\\\n       */]]\\\n    \\\n    Spell.comp.active[actives_index] = new_spell;\\\n    Spell.active.space = Spell.active.space + used_space;\\\n    \\\n    local logging_check = dbug.can_halt or dbug.can_log;\\\n    if logging_check then Spell.debug.log() end\\\n    \\\n    if dbug.can_halt then\\\n      Spell.debug.halt_limit = dbug.halt_limit - 1;\\\n    end\\\n    --[[/*\\\n        * Check if we're logging or\\\n        * if compilation should be halted\\\n        * \\\n        * Remember that dbug is the same as Spell.debug\\\n        * in this function\\\n       */]]\\\n    local spell_number = string.format(\"spell_%s\", actives_index);\\\n    local const_txt = \":const int %s %s\";\\\n    return const_txt:format(spell_number, Spell.active.space);\\\n  end\\\n  \\\n  function Spell.comp.concat_actives()\\\n    local spells = {};\\\n    --[[table holding the compacted data]]\\\n  \\\n    local actives = Spell.comp.active;\\\n    local dbug = Spell.debug;\\\n    --[[access our recordings]]\\\n    \\\n    local actives_count = #actives;\\\n    --[[nr of recordings]]\\\n    \\\n    do\\\n      local identifier = [[\"Spell.comp.Define_entire_blueprint\"]]\\\n      Spell.comp.recorded_blueprint(identifier, false);\\\n    end\\\n    --[[/*\\\n        * Record the final blueprint to the Spell.comp.Blueprint table\\\n        * without forcing the blueprint to be in a loop\\\n        * \\\n        * I'm doing this in a do...end block so that the identifier\\\n        * doesn't linger in the rest of the code\\\n       */]]\\\n    \\\n    local concat_debug = {};\\\n    concat_debug.format = \"\";\\\n    concat_debug.separation = \"\";\\\n    concat_debug.bit_format = \"%s\";\\\n    concat_debug.spell_data = \"%s\";\\\n    concat_debug.chunk_end = \"End of recording %s\";\\\n    \\\n    if dbug.can_display then\\\n      local fmt = dbug.concat_format;\\\n      concat_debug.format = fmt;\\\n      concat_debug.separation = \" \";\\\n      concat_debug.bit_format = fmt .. \"Bit signal %s = '%s'\";\\\n      concat_debug.spell_data = fmt .. \"%s %s size %s\";\\\n    end\\\n    \\\n    for i = 1, actives_count do\\\n      --[[/*\\\n          * Spell data is compacted in the order\\\n          * \\\n          * loop_sign\\\n          * sync signal\\\n          * timer_base\\\n          * space\\\n          * timer\\\n          * coord_x coord_y\\\n          * name\\\n         */]]\\\n      local data_pack = {};\\\n      do\\\n        local data = actives[i];\\\n        if dbug.can_display then\\\n          data_pack.loop_bit = table.pack(\"loop\", data.loop_sign);\\\n          data_pack.sync_bit = table.pack(\"sync\", data.sync);\\\n          \\\n          data_pack.base = table.pack(\\\n            data.timer_base, \"timer_base\",\\\n            #data.timer_base\\\n          );\\\n          data_pack.space = table.pack(\\\n            data.space, \"space\",\\\n            #data.space\\\n          );\\\n          data_pack.timer = table.pack(\\\n            data.timer, \"timer\",\\\n            #data.timer\\\n          );\\\n          \\\n          data_pack.coord_x = table.pack(\\\n            data.coord_x, \"coord_x\",\\\n            #data.coord_x\\\n          );\\\n          data_pack.coord_y = table.pack(\\\n            data.coord_y, \"coord_y\",\\\n            #data.coord_y\\\n          );\\\n          \\\n          data_pack.name = table.pack(\\\n            data.name, \"name\",\\\n            #data.name\\\n          );\\\n          data_pack.chunk_end = concat_debug.chunk_end:format(i);\\\n        else\\\n          data_pack.loop_bit = table.pack(data.loop_sign);\\\n          data_pack.sync_bit = table.pack(data.sync);\\\n          \\\n          data_pack.base = table.pack(data.timer_base);\\\n          \\\n          data_pack.space = table.pack(data.space);\\\n          data_pack.timer = table.pack(data.timer);\\\n          \\\n          data_pack.coord_x = table.pack(data.coord_x);\\\n          data_pack.coord_y = table.pack(data.coord_y);\\\n          \\\n          data_pack.name = table.pack(data.name);\\\n          data_pack.chunk_end = \"\";\\\n        end\\\n      end\\\n      \\\n      local spell_data = table.pack(\\\n        concat_debug.format,\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.loop_bit)),\\\n        --[[Adds the loop_sign bit]]\\\n        \\\n        concat_debug.bit_format:format(table.unpack(data_pack.sync_bit)),\\\n        --[[adds the sync signal bit]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.base)),\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.space)),\\\n        --[[Adds the space we take up]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.timer)),\\\n        --[[Adds the spell timer]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_x)),\\\n        --[[Adds the spells x coord]]\\\n        concat_debug.spell_data:format(table.unpack(data_pack.coord_y)),\\\n        --[[Adds the spells y coord]]\\\n        \\\n        concat_debug.spell_data:format(table.unpack(data_pack.name)),\\\n        --[[Adds the spells name]]\\\n        \\\n        concat_debug.format, data_pack.chunk_end\\\n      );\\\n      \\\n      for _, data in ipairs(spell_data) do\\\n        spells[1 + #spells] = data;\\\n      end\\\n    end\\\n    \\\n    local str_fmt = [[\"%s\"]]\\\n    return str_fmt:format(table.concat(spells));\\\n  end\\\n  function Spell.debug.log()\\\n    --[[/*\\\n        * Function handles logging logic.\\\n        * It can only be called from Spell.comp.add_spell\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local active = Spell.comp.active;\\\n    local spell_index = #active;\\\n    local spell = active[spell_index];\\\n    \\\n    local logging_text = table.pack(\\\n      \"%s| Spell has %s: '%s'\\n\"\\\n    ); --[[/*\\\n           * list of the logging messages\\\n           * There were more messages here, but they've been\\\n           * removed.\\\n           * \\\n           * I'm keeping it a table just in case I need\\\n           * to add more messages\\\n          */]]\\\n    local logging_values = table.pack(\\\n      \"name\",\\\n      \"sync\", \"loop_sign\",\\\n      \"timer\", \"coord_x\", \"coord_y\", \"space\"\\\n    ); --[[/*\\\n        * List of values that get logged\\\n        * in the same order they're listed here\\\n       */]]\\\n    \\\n    local values_index_for_space = 7\\\n    --[[Indicates what value means we're logging space]]\\\n    \\\n    local text = \"| Logging spell number %s:\\n|\\n\";\\\n    local log = text:format(spell_index);\\\n    --[[/*\\\n        * Our log is built within the string `log`;\\\n        * The string `text` is the text we're adding to the log\\\n        * and then we use string.format(text, log, other values)\\\n        * which is truncated to text:format(log, other values);\\\n       */]]\\\n    for i, value in ipairs(logging_values) do\\\n      text = logging_text[1];\\\n      local spell_value = spell[value] or \"nil\";\\\n      --[[/*\\\n          * Gets our logging_value\\\n          * If its respecitve value exists then \\\n          * * spell_value = spell[value]\\\n          * else\\\n          * * spell_value = \"nil\" to signal that\\\n          * * something has gone wrong\\\n          * \\\n        */]]\\\n      \\\n      local fmt = table.pack(log, value, logging_value);\\\n      if i == values_index_for_space then\\\n        text = \"%s| Summing up to a total space of %s\\n\"\\\n        fmt = table.pack(log, logging_value);\\\n      end\\\n      log = text:format(table.unpack(fmt));\\\n    end\\\n    print(log);\\\n    --[[And finally, we print our formatted log]]\\\n  end\\\n  \\\n  function Spell.debug.halt()\\\n    --[[/*\\\n        * Function handles halting logic.\\\n        * It's access points are \\\n        * * Spell.comp.add_spell\\\n        * * Spell Config\\\n        * \\\n        * halting is performed through error() to stop compilation\\\n       */]]\\\n    local debug = Spell.debug;\\\n    local should_halt = debug.can_halt or debug.can_display;\\\n    if not should_halt then return end\\\n    --[[We return if we shouldn't halt]]\\\n    \\\n    local halt_text = table.pack(\\\n      \"\\n\", \\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.can_log then\\\n      local halt_logging = table.pack(\\\n        \"\\n\", \\\n        \"Logging enabled, logs are visible \",\\\n        \"in your browsers developer console\"\\\n      );\\\n      for _, text in ipairs(halt_logging) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    if debug.can_display then\\\n      local halt_display = table.pack(\\\n        \"\\n\", \\\n        \"Output formatting enabled\\n\", \\\n        \"Every component of the output will begin \",\\\n        \"with the string inputed in \",\\\n        \"spell_debug.display_format\\n\", \\\n        \"Retrieving output showing \",\\\n        #Spell.comp.active,\\\n        \" \"\\\n      );\\\n      if #Spell.comp.active == 1 then\\\n        halt_display[9] = \"recording\";\\\n      else\\\n        halt_display[9] = \"recordings\";\\\n      end\\\n      halt_display[10] = Spell.comp.concat_actives();\\\n      for _, text in ipairs(halt_display) do\\\n        halt_text[1 + #halt_text] = text;\\\n      end\\\n    end\\\n    error(table.concat(halt_text), 0);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n; Returns a const int with the value of the current space occupied\n#recorded_blueprint(name, can_loop) {lua(\\\n  return Spell.comp.recorded_blueprint([[\"{name}\"]], {can_loop});\\\n)}\n; \n; \n#timer_modulo(modulo) {lua(Spell.comp.blueprint_base([[{modulo}]]))}\n; \n; Synchronize spell_count ammount of spell activations\n#synchronize(spell_count) {lua(Spell.comp.sync({spell_count}))}\n; \n; general add_spell lua function call\n#add_spell(name, timer, coord_x, coord_y) {lua(\\\n  return Spell.comp.add_spell(\\\n    [[{name}]],\\\n    [[{timer}]],\\\n    {coord_x},\\\n    {coord_y}\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  \"{name}\",\\\n  {timer}, \\\n  0, \\\n  0\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  \"{name}\",\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n\n#software.concat(concat_mode) {lua(\\\n  return Spell.comp.concat_software([[{concat_mode}]])\\\n)}\n\n#software.secure(software_name, level) {lua(\\\n  Spell.comp.add_software([[{software_name}]], [[\"{level}\"]])\\\n)}\n; Centralized securing lua macro call so that there's only\n; 1 macro to edit\n\n#auto_skip(level) {software.secure(autoskip, {level})}\n#wave_streaming(level) {software.secure(wavestreaming, {level})}\n#wave_surge(level) {software.secure(wavesurge, {level})}\n#critical_wave_jump(level) {software.secure(criticalWavejump, {level})}\n#wave_momentum(level) {software.secure(wavemomentum, {level})}\n#wave_storm(level) {software.secure(wavestorm, {level})}\n#wave_persistence(level) {software.secure(wavepersistence, {level})}\n#wave_instability(level) {software.secure(waveinstability, {level})}\n#wave_vortex(level) {software.secure(wavevortex, {level})}\n#wave_catalyst(level) {software.secure(wavecatalyst, {level})}\n#wave_endurance(level) {software.secure(waveendurance, {level})}\n#new_bounds(level) {software.secure(newbounds, {level})}\n#wave_marathon(level) {software.secure(wavemarathon, {level})}\n#wave_compression(level) {software.secure(wavecompression, {level})}\n#era_surge(level) {software.secure(erasurge, {level})}\n#era_burst(level) {software.secure(eraburst, {level})}\n#era_swirl(level) {software.secure(eraswirl, {level})}\n#wave_horizon(level) {software.secure(wavehorizon, {level})}\n#no_bounds(level) {software.secure(nobounds, {level})}\n#era_tunneling(level) {software.secure(eratunneling, {level})}\n#wave_breach(level) {software.secure(wavebreach, {level})}\n#wave_floor(level) {software.secure(wavefloor, {level})}\n#era_floor(level) {software.secure(erafloor, {level})}\n#era_horizon(level) {software.secure(erahorizon, {level})}\n#wave_restart(level) {software.secure(waverestart, {level})}\n#infinity_horizon(level) {software.secure(infinityhorizon, {level})}"],["Devbuild Spell Compactor resources",":name devbuild Spell Cmp Res\n; \n; This is a library that declairs the naming scheme\n; needed to use the spell compactor\n; \n#spell_compactor Spell Compactor\n#identifier Spell Compactor\n; \n#hider.start <size=0>\n#hider.close </size>\n; \n:const string hider.start \"{hider.start}\"\n:const string hider.close \"{hider.close}\"\n; \n:const string pointer_var \"{hider.start}{identifier} Pointer\"\n#pointer.get global.int.get(pointer_var)\n#pointer.set(value) global.int.set(pointer_var, {value})\n; \n:const string compactor_actives \"{identifier}access string\"\n#comp_active.get global.string.get(compactor_actives)\n#comp_active.set(str) global.string.set(compactor_actives, {str})\n; \n:const string compactor_secures \"{identifier}access secures\"\n#comp_secure.get global.string.get(compactor_secures)\n#comp_secure.set(str) global.string.set(compactor_actives, {str})\n; \n:const string caller_ID \"{spell_compactor} caller\"\n#caller.get global.string.get(caller_ID)\n#caller.set(caller_ID) global.string.set(caller_ID, {caller_ID})\n; \n:const string timer_var \"t\"\n#timer.get global.double.get(timer_var)\n#timer.set(value) global.double.set(timer_var, {value})\n#timer.add(value) {timer.set(({value}) + {timer.get})}\n; \n:const string got_timer_base \"{identifier}loopable blueprint\"\n#timer_baseCheck.get global.bool.get(got_timer_base)\n#timer_baseCheck.set(value) global.bool.set(got_timer_base, {value})\n; \n:const string timer_base_var \"timer_base\"\n#timer_base.get global.double.get(timer_base_var)\n#timer_base.set(value) global.double.set(timer_base_var, {value})\n; \n:const string timer_mod_var \"tm\"\n#timer_mod.get global.double.get(timer_mod_var)\n#timer_mod.set(value) global.double.set(timer_mod_var, {value})\n; "],["Devbuild Spell Compactor lib",":import Devbuild Spell Compactor resources\n:name devbuild Spell Comp lib\n\n; The Devbuild Compactor uses verbose names.\n; Normal compactor uses shortened names to\n; minimize the size of the import code\n\n:local int pointer\n:local string actives\n:local string secures\n; \n:local bool det_timer_base\n:local double timer_base\n:local double clock\n; \n:local string spell_ID\n; \n\n:const string script_signaler \"{identifier}signal manager\"\n#signal.get global.string.get(script_signaler)\n#signal.set(signal) global.string.set(\\\n  script_signaler, \\\n  {signal} . \"{hider.close}\"\\\n)\n; the signaler determines what purpose the compactor instance serves\n; It's also used to stop the block hider\n:const string all_signals \"compactor|timer|secures\"\n:const string dead_signals \"compactor\"\n:const string allowed_signals \"timer|secures\"\n; \n#contains.signal(signal) contains({signal.get}, \"{signal}\")\n\n:import Editor_actions lib\n; Editor_actions lib lets me create actions; that the editor can parse\n; in a lua macro\n; \n; The main goal is to extract all the data of a spell into its components\n; The spell data is compacted as follows\n; \n; loop_sign bit\n; sync bit\n; timer_base\n; \n; space\n; timer\n; coord_x coord_y\n; name\n{lua(\\\n  local pointer = [[pointer]];\\\n  local actives = [[actives]]\\\n  \\\n  local function s2i(compactor)\\\n    return Editor_convertStringToInt(compactor, -1);\\\n  end\\\n  local function s2d(compactor)\\\n    return Editor_convertStringToDouble(compactor, -1.0);\\\n  end\\\n  \\\n  local offset = [[pointer + 2]];\\\n  local index = \"\";\\\n  local size = \"\";\\\n  local separator = Editor_stringify_value(\"|\");\\\n  \\\n  local compactor_vals = table.pack(\\\n    \"timer_base\", \"space\", \"timer\",\\\n    \"coord_x\", \"coord_y\",\\\n    \"name\"\\\n  );\\\n  Compactor = {};\\\n  \\\n  for i, value in ipairs(compactor_vals) do\\\n    index = Editor_index(actives, separator, offset);\\\n    size = Editor_encase_value(offset);\\\n    size = Editor_math(index, \"-\", size);\\\n    Compactor[value] = Editor_sub(actives, offset, size);\\\n    local val = string.format(\"%s_value\", value);\\\n    if i == 2 then\\\n      Compactor[val] = s2i(Compactor[value]);\\\n    elseif i < #compactor_vals then\\\n      Compactor[val] = s2d(Compactor[value]);\\\n    end\\\n    offset = Editor_math(index, \"+\", 1);\\\n  end\\\n)}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n#get_bits sub(actives, pointer, 2)\n#get_base s2d({lua(return Compactor.timer_base)}, utcnow())\n; \n#get_space {lua(return Compactor.space_value)}\n; \n#get_timer {lua(return Compactor.timer_value)}\n; \n#get_coord_x {lua(return Compactor.coord_x_value)}\n#get_coord_y {lua(return Compactor.coord_y_value)}\n#get_pos vec({get_coord_x}, {get_coord_y})\n; \n#get_name {lua(return Compactor.name)}\n\n#pointer.increment pointer = if(\\\n  {timer_baseCheck.get}, \\\n  0, \\\n  pointer + {get_space}\\\n)\n\n; \n#timer_mod.update {timer_mod.set({timer.get} % timer_base)}\n"],["Devbuild Compactor",":import Devbuild Spell Compactor lib\n:name {spell_compactor}\n; \n; This script is a version of the ordinairy compactor, and as such\n; is intended to make every script that uses the compactor think\n; this is their target. This way, you don't have to change much\n; of your blueprint AI\n; \n\n; \n; The debugger adds a layer of complexity to the compactor\n; and makes everything a little bit more computationally intense\n; (so your game will likely be laggier when you\n; run the compactor like this)\n; \n; This is used to tell you what the compactor sees at any 1 time\n; if durring run-time you get undesirable spell execution\n; \n; While the primary goal here is to diagnose issues,\n; you can also use this as a spell compactor to test\n; any changes you've made.\n; This debugger isn't just for uncovering bugs in the compactor\n; â€”though if you find any, please let me know!\n; Instead, it's meant to help you, the end user, understand:\n; * What you're instructing the compactor to do\n; * How the substring used to compute the\n;   activation sequence changed the recording string\n; \n\n:budget_cap max\n\nkey.x()\n; You have the impulse that lets you cycle through your spells\n; \n:local bool debugging\n\ndebugging = true\n; This debugging_bool is set to true if you want\n; to search for what's going wrong\n; \n; By default I've set this to true so you have to manually disable\n; debugging if you don't want it\ngotoif(\\\n  if(debugging, debug, if(\\\n    contains(dead_signals, {signal.get}), \\\n    end_instance,\\\n    if({contains.signal(timer)}, start_timer, start_secures)\\\n  )), \\\n  contains(all_signals, {signal.get}) ||\\\n  contains(impulse(), \"key.x\") || debugging\\\n)\npointer = {pointer.get}\nactives = {comp_active.get}\n; We use local variables to prevent a messy interface\n; And to let the user have more instances\n; of the compactor running at the same time\n\n{timer_baseCheck.set({timer_baseCheck.get})}\n{signal.set(if({timer.get} == 0.0, \"idle\", if(\\\n  contains(\"\", secures), \\\n  if(contains(\"\", actives), \"idle\", \"compactor\"), \\\n  \"secures\"\\\n)))}\n\n{caller.set(if(\\\n  contains(impulse(), \":\"), \\\n  sub(impulse(), 0, index(impulse(), \":\", 0)),\\\n  impulse()\\\n))}\n; We also set the caller so that the user knows\n; how the compactor got accessed\n; \n; This will typically only have 1 value, but if\n; it has a name that you don't expect, it should tell the\n; user that there's another script that uses the compactor\n; which they might want to shut down\n\ngoto(assign_base)\n\nstart_timer:\n{timer.set(time.delta() * 2.0)}\n{signal.set(\"idle\")}\n\ntimer:\nwaitframe()\n{timer.add(time.delta())}\n{timer_mod.update}\ngoto(if(contains({caller.get}, \"idle mode\"), end, timer))\n; The timer will always run, even if the compactor shuts down\n; the only way to stop the timer is by calling the compactor, again\n; outside of towertesting or by stopping all instances of the compactor\n\nassign_base:\ntimer_base = {timer_base.get}\ndet_timer_base = {timer_baseCheck.get} \\\n  || pointer + 3 == index(actives, \"|\", pointer)\n\nloop:\n; Since getting the timer and spell_ID are resource intensive operations\n; whose values are called more than once, we calculate then here\nspell_ID = {get_name}\nclock = {get_timer}\n\n; \nwaituntil({timer_mod.get} <= clock)\n; \n; We use both instant and grounded spells here because we\n; don't actually know what spell we're casting, just that we\n; have to cast one with the given parameters\nuseinstant(active.index(spell_ID))\nuseposition(active.index(spell_ID), {get_pos})\n\n; If we're activating multiple spells through synchronization\n; this checks if we skip refreshing the budget (signaled with an `s`)\ngotoif(no_frame, contains({get_bits}, \"s\"))\nwaitframe()\n\nno_frame:\n\n{pointer.increment}\n; We add to our pointer the size of our spell\n\n#end_of_compactor contains(\"\", sub(actives, pointer, 10))\n; when we initialize our compactor, we add the ending bit \"e\" as the\n; last character in our string. This e is used to check\n; if we've ended our string (aka, haven't looped)\n; \n; We also take a substring of size 10 and compare it with a string\n; of size 1 so it can only return true if we truely are at the end\n; of our string\n\ngoto(if({end_of_compactor}, 99, if(\\\n  health(false) <= 0.0, \\\n  idle,\\\n  if(det_timer_base, loop, assign_base)\\\n)))\n; We terminate the program if we reach the end of the string\n; This doesn't enter idle mode, as it's possible that the user might\n; want to send another blueprint over our way. In that case, if we\n; did enter idle mode, the timer would've stopped, de-synchronizing things\n\nstart_secures:\n\n; This is the only addition of the debugger\n\ndebug:\n; It sets the caller to \"debugging\" so that when you\n; force your blueprint AI to send the string over, there's\n; a concrete spot that tells it that it can shut down\n; \n\npointer = {pointer.get}\nactives = {comp_active.get}\n\nglobal.string.set(\"spell_chunk\", sub(\\\n  actives,\\\n  pointer,\\\n  {get_space}\\\n))\n; The chunk shows you how the spell is stored\n; the order is as shown bellow:\n; * `loop_signal bit` that is / to move to the next spell and # to loop\n; * `sync bit` that is / to refresh budget and `s`\n;    to skip refreshing budget\n\nglobal.int.set(\"pointer\", pointer)\n; We also have a pointer and next_pointer that shows what value\n; this pointer has at that state\n\nglobal.string.set(\"timer_base\", {lua(return Compactor.timer_base)})\nglobal.string.set(\"spell space\", {lua(return Compactor.space)})\n; space value which is the ammount of space\n; the spell takes up in the recording\n\nglobal.string.set(\"spell_timer\", {lua(return Compactor.timer)})\n; timer value which is the timer\n; you set when adding a spell\n\nglobal.string.set(\"coord_x\", {lua(return Compactor.coord_x)})\n; coord_x which is the coordinate you add\n; if you added a grounded spell\nglobal.string.set(\"coord_y\", {lua(return Compactor.coord_y)})\n; coord_y which is the same idea as coord_x\n; \n; Remember that add_spell.instant is the same\n; as add_spell.grounded with 0, 0 as coordinates\n; \nglobal.string.set(\"spell_name\", {get_name})\n; name which is the spells identifier so we can\n; take an active index of it\n\n{pointer.increment}\n; We finally increment our pointer and add the next pointer state\nglobal.int.set(\"next pointer\", pointer)\n\nwaitframe()\n; \n; To prevent debugging from being executed when\n; shutting down, and to avoid adding another action\n; debugging also sets the caller to \"idle mode\" when it's done\n; \n; This should be a useless addition however, as setting this should\n; have given your blueprint AI enough time to top itself\n; But just to be safe, the waitframe() should guarantee that your\n; AI has self-terminated successfully\n\nend:\n{timer.set(0.0)}\n; The timer should be reset when the compactor enters idle mode\n; \nidle:\n{caller.set(\"idle mode\")}\n\nend_instance:"]]}}
```

Devbuild should probably also have versioning XD

# Versions 

## version 2.6.7

Added 2 new config spaces. "Secures Config" and "Software Config".<br>
Sort of finished Software Config, just need to figure out the output format.

## version 2.6.4

Added a timer_base to the compactor. The user now defines the base used for their timer via the macro {timer_modulo(<base>)}
