# Codrineye's Spell Compactor

This subset of the compactor is for development purposes only

It features a packaged in Spell Config, for using the debug functions for development and not just for a broad look in what's going on

```
{"workspaces":{"Spell Compactor Devbuild":[["Devbuild Spell Config",":import Devbuild Spell Compactor\n:name devbuild Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; The following macros let you communicate\n; with the debugger\n; You can freely change the values you\n; give the macros, if you're curious as\n; to what each debug macro effects\n; \n; spell_debug.log permits logging to\n; the browser developer console\n; \n; \n; What does it mean for the compactor to halt?\n; When the compactor halts, it means that \n; adding a spell will no longer be stored\n; \n; Halting is useful when debugging, as you can see\n; what the program \"sees\" at that time\n; \n; spell_debug.halt_compilation signals to the\n; compactor that compilation should halt eventually\n; \n; spell_debug.recordings_before_halt is the amount\n; of spells you can add before compilation halts\n; this value has no effect if spell_debug.halt_compilation\n; is set to 0\n; \n; spell_debug.display_spells tells the debugger\n; to display the spells you added\n; \n; spell_debug.display_spacers_as_numbers tells\n; the debugger to convert all spacing sequences\n; as the number of spaces, instead of the\n; spacing sequence itself\n; \n; essentially, it converts [...] to [3]\n; This improves readability when\n; displaying spells\n; \n; spell_debug.display_spells_in_batch signals the\n; compactor to display your spells, but to only add\n; a `display_format` at the start of a new batch \n; \n; spell_debug.display_format is a string that\n; acts as a separtor for inputs\n; the string you input in this field will be\n; at the beginning of every recorded field\n; this only applies if you want to display the output\n; \n\n{spell_debug.log(false)}\n{spell_debug.halt_compilation(false)}\n{spell_debug.recordings_before_halt(2)}\n{spell_debug.display_spells(true)}\n{spell_debug.display_format('\\n|')}\n\n; \n; Time for the actual recording\n; you have 4 functions at your disposal\n; \n; add_spell.instant()\n; this takes in 2 parameters \n; * the name of the spell, this can be obtained by\n;   simply importing a script that uses all the modules you want\n; * the timer for the spell, being the amount of time you want\n;   to pass before activation\n; \n; add_spell.grounded()\n; this takes in 4 parameters\n; * the name, just like in add_spell.instant()\n; * the timer, just like in add_spell.instant()\n; * the x position of where you want to cast the spell\n; * the y position of where you want to cast the spell\n; \n; blueprint AI's usually use winemast for the timer `t`\n; the timer is the value of `t` at the time of activation\n; \n; synchronize()\n; this takes in 2 parameters\n; * the number of modules you want to activate at once\n; * a potential delay you may want to add to the spell timers\n; \n; add_batch()\n; this takes in 1 parameter\n; * the name you want to give this batch\n; \n; a batch reprezents a separation in the recording\n; this is done when you have multiple activation sequences\n; that you want to have in the same actives string\n; \n; The batch name is used to determine\n; when a batch starts\n; \n; \n; If you have a grounded module with coordinates 0,0\n; I do not recommend defining it as an instant module\n; \n; Even tho your input will be correctly processed\n; you will likely have to change things at some point\n; and this definition can lead to confusion\n; \n; You should not define an instant module as grounded\n; for the same reason, make the sequence easier for you\n; to follow\n; \n\n{synchronize(2)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{synchronize(1)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{synchronize(0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{synchronize(2)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{synchronize(6)}\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{synchronize(2)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{synchronize(5)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; \n; This marks the end of spell configuration\n; we now have a macro spell_debug\n; this is in charge of outputing debugging data\n; and prevents the output string from being read\n; when its contents are modified for displaying\n; \n\n{spell_debug}\n\n; \n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file\n; rather than copy them\n; Putting the const declaration here is\n; also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n; \n\n"],["Devbuild Spell Compactor",":import Devbuild Spell Compactor Utils\n:name devbuild Spell Compactor\n\n; \n; Welcome to the compactor, a set of 2 lua macros + macros defined\n; at the bottom of the script for the user interactions\n; \n; This compactor is structured to be as easy to read and as\n; flexible as possible, the following comments will explain\n; what you are looking at\n; \n; This first lua macro defines our global variables\n; working in the table `spell`\n; everything here is strictly to process spell values\n; if a name appends spell. it is defined in the spell compactor\n; if a name appends utils. it is defined in the compactors Utils\n; if a name appends spell_comp it's a spell compactor utility\n; if a name appends spell_debug it's a debugging utility\n; \n\n{lua(\\\n  spell = {}; --[[Root Table]]\\\n  spell.stop = false;\\\n  spell.active = {}; --[[Table holds spell data]]\\\n  spell.active.space = 0; --[[keep track of how much space is used]]\\\n  spell.active.pointer_mult = 1; --[[getting implemented]]\\\n  spell.active.sync_ammount = 0; --[[ammount of spells getting sync'd]]\\\n)}\n\n; Recording format change\n; currently we have\n; `sync` . `timer` . `coord_x` . `coord_y` . `name` . `text end char`\n; \n; format change to\n; sync . cooldown . coord_x . coord_y . name . pointer mult\n; ---------------------------\n; sync detector = always 1 character\n; sync no longer makes copies of the script, it now tells the AI to\n; perform a waitframe() after all spells that required synchronization\n; have been activated\n; \n; size of cooldown size\n; cooldown size\n; spell activation timer\n; \n; size of coord_x size\n; coord_x size\n; coord_x\n; \n; size of coory_y size\n; coord_y size\n; coord_y\n; \n; size of name_size\n; name_size\n; name\n; \n; pointer_mult\n; 1 by default\n; 0 on add_blueprint() call\n; this works by pointer = pointer * s2i(sub(`pointer_mult`, pointer, 1), 0)\n; always 1 character\n; ---------------------------\n; \n; Also, remove a large majority of comments in public build\n; and include comments **in** the lua macros as well as outside\n; \n\n{lua(\\\n  function spell.add_blueprint(blueprint_name)\\\n      --[[/*\\\n          * Adding a new blueprint marks the end of this \"chunk\"\\\n          * For the stand-alone compactor to recognize this, we set\\\n          * this multiplier to 0, so that the pointer can go back\\\n          * to the start of the recorded sequence.\\\n         */]]\\\n    spell.active.pointer_mult = 0;\\\n    local bp_name = \"blueprint_\" .. blueprint_name;\\\n    return spell_comp.const(\"int\", bp_name, spell.active.space);\\\n    --[[/*\\\n        * Returned value is used by user to take an index in a\\\n        * substring action to extract the desired recorded sequence\\\n       */]]\\\n  end\\\n  \\\n  function spell.sync(spell_ammount)\\\n    --[[/*\\\n        * Sync system prevents the compactor from refreshing its budget\\\n        * until all synchronized spells have been used.\\\n       */]]\\\n    local sync_ammount = tonumber(spell_ammount);\\\n    if sync_ammount < 0 then\\\n      local printer = table.pack(\\\n        \"Attempt to add a negative sync ammount at spell nr \",\\\n        1 + #spell.active, \"\\n\", \"Default behaviour sets it to 0\"\\\n      );\\\n      print(table.concat(printer));\\\n    end\\\n    sync_ammount = math.max(0, sync_ammount);\\\n    --[[/*\\\n        * max operation prevents sync_ammount from being negative\\\n        * value in spell.active.sync_ammount always gets overwritten\\\n       */]]\\\n    spell.active.sync_ammount = sync_ammount;\\\n  end\\\n  \\\n  function spell.add_spell(name, spell_type, timer, ...)\\\n    local halt_limit_reached = spell_debug.halt_limit == 0;\\\n    halt_limit_reached = halt_limit_reached and spell_debug.can_halt;\\\n    --[[Check if our halt limit has been reached]]\\\n    \\\n    if halt_limit_reached or spell.stop then\\\n      --[[/*\\\n          * Prevent spells from getting recorded if halted,\\\n          * a halted compactor stops recording data\\\n         */]]\\\n      return;\\\n    end\\\n    \\\n    local actives_index = 1 + #spell.active;\\\n    local new_spell = {};\\\n    --[[/*\\\n        * Record the pointer multiplier and then set it to 1,\\\n        * Must be reset to 1 in case we added a blueprint\\\n       */]]\\\n    new_spell.pointer_mult = spell.active.pointer_mult;\\\n    local used_space = 1\\\n    --[[/*\\\n        * Recordings take space in the compacted data\\\n        * We keep track of the space we're taking up with this variable\\\n       */]]\\\n    spell.active.pointer_mult = 1;\\\n    \\\n    new_spell.sync = 0;\\\n    used_space = 1 + used_space;\\\n    --[[Add the ammount of space the sync marker takes up]]\\\n    \\\n    local can_sync = spell.active.sync_ammount > 0;\\\n    if can_sync then\\\n      new_spell.sync = 1;\\\n      spell.active.sync_ammount = spell.active.sync_ammount - 1;\\\n      --[[/*\\\n          * Signals that we don't refresh the execution budget\\\n          * Decrement our sync ammount\\\n         */]]\\\n    end\\\n    new_spell.name = name:gsub(\" \", \"\");\\\n    \\\n    local grounded_spell = spell_type:gsub(\" \", \"\") == \"grounded\";\\\n    new_spell.grounded = grounded_spell;\\\n    --[[/*\\\n         * Check to see if the spell_type is grounded\\\n         * if it is, we've got to include our coordinates\\\n        */]]\\\n    local parameters = table.pack(timer);\\\n    local doubles = table.pack(\"timer\");\\\n    if grounded_spell then\\\n      parameters = table.pack(timer, ...);\\\n      doubles = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n    end\\\n    \\\n    for i, variable in ipairs(doubles) do\\\n      local value = tonumber(parameters[i]);\\\n      new_spell[variable] = {};\\\n      new_spell[variable] = 0.0 + value\\\n      --[[/*\\\n          * the addition with 0.0 here is to guarantee\\\n          * the correct data type. timer, coord_x, coord_y need to be\\\n          * doubles for the actions waitwhile() and vec().\\\n          * float and double are the same type in this editor\\\n         */]]\\\n    end\\\n    --[[/*\\\n        * Get all our spell data inside a table. We use table.unpack\\\n        * instead of table.concat() here to retain the ability to\\\n        * index between the values in the \"doubles\" table\\\n       */]]\\\n    local spell_data = table.pack(\"name\", \"timer\");\\\n    local sizes = table.pack(\"name_size\", \"timer_size\");\\\n    if grounded_spell then\\\n      spell_data = table.pack(\\\n        table.unpack(spell_data), \\\n        \"coord_x\", \"coord_y\"\\\n      );\\\n      sizes = table.pack(\\\n        table.unpack(sizes), \\\n        \"size_x\", \"size_y\"\\\n      );\\\n    end\\\n    for i, variable in ipairs(spell_data) do\\\n      local size = sizes[i];\\\n      new_spell[size] = {};\\\n      new_spell[size] = #tostring(new_spell[variable]);\\\n      used_space = used_space + new_spell[size];\\\n      --[[/*\\\n          * Get the ammount of characters in each variable\\\n          * and add this ammount to our used space\\\n         */]]\\\n    end\\\n    for i, size in ipairs(sizes) do\\\n      local size_of_size = size .. \"_size\";\\\n      new_spell[size_of_size] = {};\\\n      new_spell[size_of_size] = #tostring(new_spell[size]);\\\n      used_space = used_space + 1 + new_spell[size_of_size];\\\n      --[[/*\\\n          * Get the size of each variables size\\\n          * then add these to the used space\\\n          * we add 1 to it because we've also got\\\n          * a marker telling us this size\\\n         */]]\\\n    end\\\n    \\\n    local space = used_space;\\\n    local prev_space = -1;\\\n    \\\n    while space ~= prev_space do\\\n      prev_space = space\\\n      new_spell.space = space;\\\n      new_spell.space_size = #tostring(new_spell.space);\\\n      new_spell.space_size_size = #tostring(new_spell.space_size);\\\n      space = used_space;\\\n      local spaces = table.pack(\"space_size\", \"space_size_size\");\\\n      for _, size in ipairs(spaces) do\\\n        space = space + new_spell[size];\\\n      end\\\n    end\\\n    \\\n    used_space = space;\\\n    \\\n    spell.active[actives_index] = new_spell;\\\n    spell.active.space = spell.active.space + used_space;\\\n    --[[/*\\\n        * Add the space used in this recording to our\\\n        * overall used space\\\n       */]]\\\n    \\\n    local logging_check = spell_debug.can_halt or spell_debug.can_log;\\\n    if logging_check then\\\n      spell_debug.log();\\\n    end\\\n    if spell_debug.can_halt then\\\n      spell_debug.halt_limit = spell_debug.halt_limit - 1;\\\n    end\\\n  end\\\n  \\\n  function spell.concat_actives()\\\n    local spells = {}; --[[table holding the compacted data]]\\\n  \\\n    local actives = spell.active; --[[access our recordings]]\\\n    local actives_count = #spell.active; --[[nr of recordings]]\\\n    actives[actives_count].pointer_mult = 0;\\\n    --[[Set the last multiplier to 0 to enables sequence looping]]\\\n    \\\n    local index = 0; --[[index to access our recordings]]\\\n    \\\n    local spells_debug = table.pack(\\\n      \"format\", \"space\", \"chunk\"\\\n    );\\\n    utils.pack_assign(spells_debug, \"\", table.unpack(spells_debug));\\\n    \\\n    local text_debugging = spell_debug.can_display;\\\n    \\\n    if text_debugging then\\\n      spells_debug.format = spell_debug.concat_format;\\\n      spells_debug.space = \" \";\\\n      spells_debug.chunk = spell_debug.chunk;\\\n    end\\\n    \\\n     --[[/*\\\n         * Sequence for concatenation. Broken up into separate\\\n         * local functions to add implementation flexibility and to\\\n         * improve overall readability\\\n        */]]\\\n    \\\n    local function number_handling()\\\n      local nr = actives[index];\\\n      \\\n      spells = table.pack(\\\n        table.concat(spells), \\\n        spells_debug.format, nr.space_size_size,\\\n        spell_debug.space, nr.space_size,\\\n        spell_debug.space, nr.space,\\\n        \\\n        spell_debug.format, nr.sync\\\n      );\\\n      --[[Add the used_space and the sync]]\\\n      \\\n      local numbers = table.pack(\"timer\");\\\n      local number_sizes = table.pack(\"timer_size\");\\\n      if actives[index].grounded then\\\n        numbers = table.pack(\"timer\", \"coord_x\", \"coord_y\");\\\n        number_sizes = table.pack(\"timer_size\", \"size_x\", \"size_y\")\\\n      end\\\n      local size_sizes = {};\\\n      for i, size in ipairs(number_sizes) do\\\n        size_sizes[i] = size .. \"_size\";\\\n      end\\\n      \\\n      for i, number in ipairs(numbers) do\\\n        local size_of_size = size_sizes[i];\\\n        local number_size = number_sizes[i];\\\n        spells = table.pack(\\\n          table.concat(spells),\\\n          spells_debug.format, nr[size_of_size], \\\n          spells_debug.space, nr[number_size], \\\n          spells_debug.space, nr[number]\\\n        );\\\n      end\\\n    end\\\n    local function text_handling()\\\n      local text = actives[index]\\\n      spells = table.pack(\\\n        table.concat(spells),\\\n        spells_debug.format, text.name_size_size,\\\n        spells_debug.space, text.name_size,\\\n        spells_debug.space, text.name\\\n      )\\\n    end\\\n    while index < actives_count do\\\n      index = index + 1;\\\n      number_handling();\\\n      text_handling();\\\n      spells = table.pack(\\\n        table.concat(spells), \\\n        spells_debug.format, actives[index].pointer_mult,\\\n        spells_debug.format, spells_debug.chunk\\\n      );\\\n    end\\\n    return table.concat(spells);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n\n#add_blueprint(name) {lua(return spell.add_blueprint(\"{name}\"))}\n#synchronize(spell_count) {lua(return spell.sync({spell_count}))}\n\n; general add_spell lua function call\n#add_spell(name, type, timer, coord_x, coord_y) {lua(\\\n  return spell.add_spell(\\\n    '{name}',\\\n    [[{type}]],\\\n    [[{timer}]],\\\n    [[{coord_x}]],\\\n    [[{coord_y}]]\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  {name},\\\n  instant,\\\n  {timer}, ,\\\n)}\n; Exclude the x, y coordinates for instant spells\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  {name},\\\n  grounded,\\\n  {timer},\\\n  {coord_x},\\\n  {coord_y}\\\n)}\n"],["Devbuild Spell Compactor Utils",":name devbiuld Spell Cmp Utils\n\n; Spell Compactor Utility functions\n\n{lua(\\\n  utils = {}; --[[General Utilities table]]\\\n  \\\n  spell_comp = {}; --[[Spell Compactor utils]]\\\n  \\\n  spell_debug = {}; --[[Spell Debugging utils]]\\\n  spell_debug.can_log = false; --[[logging logic]]\\\n  spell_debug.can_halt = false; --[[halting logic]]\\\n  spell_debug.halt_limit = 0; --[[ammount of recordings before halt]]\\\n  spell_debug.can_display = false; --[[display recorded logic]]\\\n  spell_debug.concat_format = \"\"; --[[display format between values]]\\\n  spell_debug.spacer = table.pack(\"[\", \"]\");\\\n  spell_debug.chunk = \"Chunk Separation\\n\";\\\n)}\n\n#spell_debug {lua(return spell_debug.halt())}\n; \n#spell_debug.log(level) {lua(\\\n  spell_debug.can_log = {level};\\\n)}\n; \n#spell_debug.halt_compilation(level) {lua(\\\n  spell_debug.can_halt = {level};\\\n)}\n#spell_debug.recordings_before_halt(limit) {lua(\\\n  spell_debug.halt_limit = {limit};\\\n)}\n; \n#spell_debug.display_spells(level) {lua(\\\n  spell_debug.can_display = {level};\\\n)}\n; \n#spell_debug.display_format(separator) {lua(\\\n  spell_debug.concat_format = {separator};\\\n)}\n\n{lua(\\\n  function utils.pack_assign(pack_target, value, ...)\\\n    --[[Assign the same value to multiple variables]]\\\n    local pack_data = table.pack(...);\\\n    local target = pack_target;\\\n    for _, append in ipairs(pack_data) do\\\n      target[append] = value;\\\n    end\\\n  end\\\n  \\\n  --[[General Utility Functions defined above]]\\\n  \\\n  function spell_comp.const(type, name, value)\\\n    --[[/*\\\n        * Function to construct and output a :const definition\\\n        * user must specify const type, const value name and\\\n        * value assigned to the const variable\\\n       */]]\\\n  \\\n    local const_value = table.pack(value); --[[variable of type table]]\\\n    if type == \"string\" then\\\n      const_value = table.pack(\"'\", value, \"'\");\\\n      --[[Special case if the type is string, value must be encased]]\\\n    end\\\n    local const = table.pack(\\\n      \":const \", type, \\\n      \" \", name, \" \", \\\n      table.concat(const_value)\\\n    );\\\n    --[[/*\\\n        * Construct our constant definition, concat the const_value\\\n        * to encase the value if we are of type string\\\n       */]]\\\n    return table.concat(const);\\\n  end\\\n  \\\n  --[[Spell Compactor Utility Functions defined above]]\\\n  \\\n  function spell_debug.log()\\\n    --[[/*\\\n        * function handles logging logic\\\n        * Uses sub-functions for improved readability\\\n        * \\\n        * logging is performed through print() to not stop compilation\\\n       */]]\\\n    local active = spell.active; --[[access to spell data]]\\\n    local logged_values = table.pack(\\\n      \"name\", \"name_size\", \"name_size_size\", \\\n      \"sync\", \"pointer_mult\",\\\n      \"timer\", \"timer_size\", \"timer_size_size\", \\\n      \"coord_x\", \"size_x\", \"size_x_size\",\\\n      \"coord_y\", \"size_y\", \"size_y_size\"\\\n    );--[[list of all values that can be logged]]\\\n    \\\n    --[[/*\\\n        * How to log these values\\\n        * Group by type:\\\n        * name is the spells name\\\n        * sync an pointer_mult are 1 character signs\\\n        * Timer, Coord_X and Coord_Y are float\\\n       */]]\\\n  end\\\n  \\\n  function spell_debug.halt()\\\n    --[[function handles halting logic]]\\\n    local debug = spell_debug;\\\n    local debug_check = false; --[[assumed false for `or` operation]]\\\n    local debug_values = table.pack(\"can_halt\", \"can_display\");\\\n    for _, append in ipairs(debug_values) do\\\n      debug_check = debug_check or debug[append];\\\n    end\\\n    if not debug_check then\\\n      return; --[[Debugging disabled]]\\\n    end\\\n    local debug_text = table.pack(\\\n      \"Compilation stopped, debug mode enabled\\n\", \\\n      \"Output has been modified by a spell_debug macro\"\\\n    );\\\n    if debug.halt_limit > 0 and debug.can_halt then\\\n      --[[concat contents so text previously added isn't lost]]\\\n      debug_text = table.pack(\\\n        table.concat(debug_text), \"\\n\",\\\n        \"Logging enabled, logs are visible in your \",\\\n        \"browsers developer console\"\\\n      );\\\n    end\\\n    if debug.can_display then\\\n      debug_text = table.pack(\\\n        table.concat(debug_text), \"\\n\",\\\n        \"Output formatting enabled\\n\",\\\n        \"Every component of the output will begin with \",\\\n        \"the string inputed in spell_debug.display_format\\n\",\\\n        \"Retrieving output showing \", #spell.active, \" recording\"\\\n      );\\\n      debug_text = table.concat(debug_text);\\\n      if #spell.active > 1 then\\\n        debug_text = debug_text .. 's'\\\n        --[[turn recording into recordings if more than 1 spells]]\\\n      end\\\n      debug_text = table.pack(debug_text, spell.concat_actives());\\\n    end\\\n    return table.concat(debug_text);\\\n  end\\\n  \\\n  --[[Spell Debugging Utility Functions defined above]]\\\n)}\n"],["Devbuild Spell Compactor resources",":name devbuild Spell Cmp Res\n; \n; This is a library that declairs\n; the naming scheme needed to use\n; the stand-alone spell compactor\n; \n; Name of the stand-alone compactor\n; use this to call it\n; \n\n#spell_compactor_package(name) Spell Compactor:{name}\n\n; \n; the hider macros\n; these are simple strings\n; that control how\n; the variable hider works\n; \n\n#hider.start \"<size=0><line-height=0%>\"\n#hider.close \"</line-height></size>\"\n\n; \n; starting with a pointer\n; the pointer needs an identifier, this is defined within\n; your blueprint AI's library file\n; \n; the pointer lets you read from\n; your spells constant by cycling through them\n; \n; the pointer is also a block hider\n; this is so that it doesn't messy up the users screen\n; \n\n#pointer {hider.start} . \"pointer\" . {identifier}\n#pointer.get global.int.get({pointer})\n#pointer.set(value) global.int.set({pointer}, {value})\n\n; \n; this helper macro encases our\n; global variable inbetween 2\n; macros\n; * compactor_type is a multipurpose macro\n;   that can be used for data transfer\n;   without disturbing the overlay\n; \n; * identifier is a macro for script identification\n;   this should be equivalent to the name of our package\n;   for the compactor to easily read it\n; \n; it's written in a lua macro just\n; for easier modifications\n; \n\n#compactor_encasement(caller) {lua(\\\n  local encasement = {};\\\n  encasement[1 + #encasement] = [[{compactor_type}]];\\\n  encasement[1 + #encasement] = \" . ' ' . \";\\\n  encasement[1 + #encasement] = [[{caller}]];\\\n  encasement[1 + #encasement] = \" . ' ' . \";\\\n  encasement[1 + #encasement] = [[{identifier}]];\\\n  return table.concat(encasement);\\\n)}\n\n; \n; moving on to spell_size\n; this is contained within the pointers\n; hiding block, and it contains the\n; constant int spell_size\n; this is for comunication with the\n; standalone spell compactor, to\n; trim down the scripts needed for\n; blueprint AI's\n; \n\n#spells_size {compactor_encasement(\"spells_size\")}\n#spells_size.get global.int.get({spells_size})\n#spells_size.set(value) global.int.set({spells_size}, {value})\n\n; \n; Precision field\n; This is another helper macro\n; that lets me easily assign\n; const int precision variables\n; in a global manner, for using\n; the stand-alone spell compactor\n; \n\n#precision(type) {compactor_encasement(\"precision\" . {type})}\n#precision.get(type) global.int.get({precision({type})})\n#precision.set(type, value) global.int.set({precision({type})}, {value})\n\n; \n; I will now create the macros\n; * count to define the number of spells in the\n;   provided active_spells string\n; * sync to define sync_precision\n; * timer to define timer_precision\n; * placement to define placement_precision\n; \n; built by using the previously\n; defined precision macros\n; \n\n#precision_count {precision(\"count\")} \n#precision_count.get {precision.get(\"count\")}\n#precision_count.set(value) {precision.set(\"count\", {value})}\n\n\n#precision_sync (precision(\"sync\"))\n#precision_sync.get {precision.get(\"sync\")}\n#precision_sync.set(value) {precision.set(\"sync\", {value})}\n\n#precision_timer {precision(\"timer\")}\n#precision_timer.get {precision.get(\"timer\")}\n#precision_timer.set(value) {precision.set(\"timer\", {value})}\n\n#precision_placement {precision(\"placement\")}\n#precision_placement.get {precision.get(\"placement\")}\n#precision_placement.set(value) {precision.set(\"placement\", {value})}\n\n; \n; we have a dedicated string that\n; gives us the `text_ending_character` character\n; \n; this is done for the explicit definition\n; \n\n#text_ending_character {compactor_encasement(\"text_ending_character\")}\n#text_ending_character.get global.string.get({text_ending_character})\n#text_ending_character.set(value) global.string.set(\\\n  {text_ending_character},\\\n  ({value})\\\n)\n\n; \n; we end the block hider by storing\n; our active_spells string\n; this way, we can use the stand-alone compactor\n; without needing a complete design overhaul\n; \n\n#active_spells {compactor_encasement(\"active_spells\")}\n#active_spells.get global.string.get({active_spells})\n#active_spells.set(value) global.string.set(\\\n  {active_spells},\\\n  {value} . {hider.close}\\\n)\n\n; \n; ending with the timer\n; the timer is just t, to keep\n; backwards compatibility with other\n; scripts using winemast\n; \n\n#timer \"t\"\n#timer.get global.double.get({timer})\n#timer.set(value) global.double.set({timer}, {value})\n#timer.add(value) {timer.set({timer.get} + ({value}))}\n"],["Devbuild Spell Compactor lib",":import Devbuild Spell Compactor resources\n:name devbuild Spell Cmp Util\n\n#package(name) {spell_compactor_package({name})}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n\n; \n; This is the stand-alone spell compactor\n; importing this should be the first action\n; performed if you're using the compactor\n; \n\n#identifier \"Spell Compactor\"\n\n#internal_pointer \"<size=0>\" . {identifier} . \"internal\" . \"pointer\"\n#internal_pointer.get global.int.get({internal_pointer})\n#internal_pointer.set(value) global.int.set({internal_pointer}, {value})\n#pointer.increment {internal_pointer.set(\\\n  ({internal_pointer.get} + 1) % {spells_count.get}\\\n)}\n\n; \n; spells_count        = precision_count\n; spell_size          = spells_size\n; sync_precision      = precision_sync\n; time_precision      = precision_timer\n; placement_precision = precision_placement\n; text_end_character  = text_ending_character\n; actives             = active_spells\n; \n\n#spells_count \"iternal\" . \"count_precision\" . {identifier}\n#spells_count.get global.int.get({spells_count})\n#spells_count.set(value) global.int.set({spells_count}, {value})\n\n#spell_size \"internal\" . \"spells_size\" . {identifier}\n#spell_size.get global.int.get({spell_size})\n#spell_size.set(value) global.int.set({spell_size}, {value})\n\n#sync_precision \"internal\" . \"precision_sync\" . {identifier}\n#sync_precision.get global.int.get({sync_precision})\n#sync_precision.set(value) global.int.set({sync_precision}, {value})\n\n#time_precision \"internal\" . \"precision_time\" . {identifier}\n#time_precision.get global.int.get({time_precision})\n#time_precision.set(value) global.int.set({time_precision}, {value})\n\n#placement_precision \"internal\" . \"precision_placement\" . {identifier}\n#placement_precision.get global.int.get({placement_precision})\n#placement_precision.set(value) global.int.set(\\\n  {placement_precision}, \\\n  {value}\\\n)\n\n\n#text_end_character \"internal\" . \"text_ending_character\" . {identifier}\n#text_end_character.get global.string.get({text_end_character})\n#text_end_character.set(value) global.string.set(\\\n  {text_end_character}, \\\n  {value}\\\n)\n\n#actives \"internal\" . \"active_spells\" . {identifier}\n#actives.get global.string.get({actives})\n#actives.set(value) global.string.set(\\\n  {actives},\\\n  ({value}) . {hider.close}\\\n)\n\n\n#actives.displace(sync, timer, positions) position + (\\\n  {sync} * {sync_precision.get} + \\\n  {timer} * {time_precision.get} + \\\n  {positions} * {placement_precision.get}\\\n)\n\n#actives.substring(sync, timer, positions, length) sub(\\\n  {actives.get},\\\n  {actives.displace({sync}, {timer}, {positions})},\\\n  {length}\\\n)\n\n#actives.index(sync, timer, positions) index(\\\n  {actives.get},\\\n  {text_end_character.get},\\\n  {actives.displace({sync}, {timer}, {positions})}\\\n) - ({actives.displace({sync}, {timer}, {positions})})\n"]]}}
```
