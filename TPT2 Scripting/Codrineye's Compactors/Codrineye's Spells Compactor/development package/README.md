# Codrineye's Spell Compactor

This subset of the compactor is for development purposes only

It features a packaged in Spell Config, for using the debug functions for development and not just for a broad look in what's going on

```
{"workspaces":{"Spell Compactor Devbuild":[["Devbuild Spell Config",":import Devbuild Spell Compactor\n:name devbuild Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; The following macros let you communicate\n; with the debugger\n; You can freely change the values you\n; give the macros, if you're curious as\n; to what each debug macro effects\n; \n; spell_debug.log permits logging to\n; the browser developer console\n; \n; \n; What does it mean for the compactor to halt?\n; When the compactor halts, it means that \n; adding a spell will no longer be stored\n; \n; Halting is useful when debugging, as you can see\n; what the program \"sees\" at that time\n; \n; spell_debug.halt_compilation signals to the\n; compactor that compilation should halt eventually\n; \n; spell_debug.recordings_before_halt is the amount\n; of spells you can add before compilation halts\n; this value has no effect if spell_debug.halt_compilation\n; is set to 0\n; \n; spell_debug.display_spells tells the debugger\n; to display the spells you added\n; \n; spell_debug.display_spacers_as_numbers tells\n; the debugger to convert all spacing sequences\n; as the number of spaces, instead of the\n; spacing sequence itself\n; \n; essentially, it converts [...] to [3]\n; This improves readability when\n; displaying spells\n; \n; spell_debug.display_spells_in_batch signals the\n; compactor to display your spells, but to only add\n; a `display_format` at the start of a new batch \n; \n; spell_debug.display_format is a string that\n; acts as a separtor for inputs\n; the string you input in this field will be\n; at the beginning of every recorded field\n; this only applies if you want to display the output\n; \n\n{spell_debug.log(0)}\n{spell_debug.halt_compilation(0)}\n{spell_debug.recordings_before_halt(2)}\n{spell_debug.display_spells(0)}\n{spell_debug.display_spacers_as_numbers(0)}\n{spell_debug.display_spells_in_batch(0)}\n{spell_debug.display_format('\\n|')}\n\n; \n; Time for the actual recording\n; you have 4 functions at your disposal\n; \n; add_spell.instant()\n; this takes in 2 parameters \n; * the name of the spell, this can be obtained by\n;   simply importing a script that uses all the modules you want\n; * the timer for the spell, being the amount of time you want\n;   to pass before activation\n; \n; add_spell.grounded()\n; this takes in 4 parameters\n; * the name, just like in add_spell.instant()\n; * the timer, just like in add_spell.instant()\n; * the x position of where you want to cast the spell\n; * the y position of where you want to cast the spell\n; \n; blueprint AI's usually use winemast for the timer `t`\n; the timer is the value of `t` at the time of activation\n; \n; synchronize()\n; this takes in 2 parameters\n; * the number of modules you want to activate at once\n; * a potential delay you may want to add to the spell timers\n; \n; add_batch()\n; this takes in 1 parameter\n; * the name you want to give this batch\n; \n; a batch reprezents a separation in the recording\n; this is done when you have multiple activation sequences\n; that you want to have in the same actives string\n; \n; The batch name is used to determine\n; when a batch starts\n; \n; \n; If you have a grounded module with coordinates 0,0\n; I do not recommend defining it as an instant module\n; \n; Even tho your input will be correctly processed\n; you will likely have to change things at some point\n; and this definition can lead to confusion\n; \n; You should not define an instant module as grounded\n; for the same reason, make the sequence easier for you\n; to follow\n; \n\n{synchronize(2, 0.0)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{synchronize(4, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{synchronize(6, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{synchronize(5, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; \n; This marks the end of spell configuration\n; we now have a macro spell_debug\n; this is in charge of outputing debugging data\n; and prevents the output string from being read\n; when its contents are modified for displaying\n; \n\n{spell_debug}\n\n; \n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file\n; rather than copy them\n; Putting the const declaration here is\n; also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n; \n\n:const string actives '{lua(return spell.concat_actives())}'\n:const string text_end_character '{lua(return spell.text.text_ending_character)}'\n:const int spells_count {lua(return #spell.active)}\n:const int spell_size {lua(return spell.active_max_length)}\n\n:const int sync_precision {lua(return spell.precision.sync)}\n:const int time_precision {lua(return 2 + spell.precision.timer)}\n:const int placement_precision {lua(return 2 + spell.precision.placement)}\n\n"],["Devbuild Spell Compactor",":import Devbuild Spell Compactor Debugger\n:name devbuild Spell Compactor\n\n; \n; Package found on discord or on my github repo\n; discord: https://discord.com/channels/488444879836413975/1275961817151307847/1275961817151307847\n; github: https://github.com/Codrineye/Codrineye-s-TPT2-Compendium/blob/e22ebcef5fa54fa5d8c3726f8163ea59d4c69a91/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Spells%20Compactor/README.md\n; \n; Welcome to the compactor, a set of 2 lua macros\n; and macros defined at the bottom of the script for the user interactions\n; \n; This compactor is structured to be as easy to read and as\n; flexible as possible, the following comments will explain\n; what you are looking at\n; \n; This first lua macro defines our global variables\n; working in the table `spell`\n; everything here is strictly to process spell values\n; if a name appends spell. it is defined in the spell compactor\n; if a name appends spell_debug. it is defined in the compactors debugger\n; \n; .active defines processes relevant to user input\n; all spells are registered inside of spell.active\n; \n; .batch is a part of .active that stores data relevant to batches\n; batches mark sequences of spells, to support multiple\n; sections of spells in the same string\n; this stores the\n; \n; .max_batch is a helper value attatched to .batch\n; to store the maximum length of the batch size\n; \n; .sync is the process of synchronization, a part of .active\n; sync tells the script \"sync\" how many copies of itself to make\n; this is done when you want to activate multiple spells\n; at once\n; \n; .index is a helper value attatched to .sync\n; to store the index of the curent sync sequence\n; \n; .copies_internal is a helper value attatched to .sync\n; to store how many copies we're making\n; \n; .delay_internal is a helper value attatched to .sync\n; to store how much delay is added to the timer\n; \n; spell.active_max_length is the length of the maximum\n; spell size we can store\n; \n; spell.text is a table in charge of all values\n; related to text\n; \n; .name_max_length is self explanetory, storing the\n; maximum length of the spell name\n; \n; .attribute_max_length is like the previous one, but\n; stores the maximum length of the spell attribute\n; \n; .text_ending_character is a character that marks\n; the end of a string\n; \n; finally, spell.precision\n; .precision is used to store dynamically changing\n; length values relative to the inputed number values\n; \n; .sync is the precision of a sync, this is the maximum\n; amount of active modules you want to run\n; \n; if this value is 1, you're within values 0 to 9\n; if this value is 2, you're within valuse 00 to 09\n; to 10 to 99\n; \n; .timer is the precision of a time value\n; .placement is the precision of a coordinate\n; \n\n{lua(\\\n  spell = {};\\\n  spell.active = {};\\\n  spell.active.batch = {};\\\n  spell.active.batch.max_batch = 0;\\\n  spell.active.sync = {};\\\n  spell.active.sync.index = 0;\\\n  spell.active.sync.copies_internal = 0;\\\n  spell.active.sync.delay_internal = 0;\\\n  spell.active_max_length = 0;\\\n  spell.text = {};\\\n  spell.text.name_max_length = 0;\\\n  spell.text.attribute_max_length = 0;\\\n  spell.text.text_ending_character = ':';\\\n  spell.precision = {};\\\n  spell.precision.sync = 0;\\\n  spell.precision.timer = 0;\\\n  spell.precision.placement = 0;\\\n)}\n\n; \n; This is the second lua macro\n; all function definitions are here\n; \n; first function, spell.add_batch()\n; it takes 1 parameter\n; * batch_name is the name assigned to this batch\n;   this name can be used for identifying the\n;   sequence we're looking at\n; \n; we initialize 2 local variables\n; the next batch index, being 1 + how many batches\n; we have recorded\n; and the table batch\n; \n; batch.checkpoint is the position in the configuration we\n; were declaired in\n; we make this checkpoint for 2 reasons\n; to calculate the size of this batch\n; to know when we've reached this batch\n; when inside of spell.concat_actives()\n; \n; if this is the first batch being recorded, we are of size 0\n; alternatively, if there exists a previous batch\n; we can calculate the size of our batch\n; \n; we record this batch, by adding it to the root table\n; spell.active.batch and update our max_batch\n; \n; we end by creating a table 'printer' and\n; building a :const int batch_name #spell.active\n; \n; spell.synchronization()\n; this function requires 2 parameters\n; * copies represent how many activations we want\n; * delay represents how much time to add to the\n;   timer of the copies it has\n; \n; this means that\n; copy1 = spell_timer + 0 * delay\n; copy2 = spell_timer + 1 * delay\n; copy3 = spell_timer + 2 * delay\n; and so on\n; \n; just like in spell.add_batch, we start\n; by creating our local index and sync table\n; \n; due to how sync works, we give sync.copies 1 less\n; copy than requested because the frist spell is covered by\n; how spell recording works\n; \n; so, we assign sync.copies copies - 1 and then\n; sync.delay 0.0 + tonumber(timer)\n; sync.delay needs to be a floating point number, and float\n; operations with non float numbers returns a float result\n; thus, 0.0 + toumber(timer) will always return a float\n; we perform tonumber(timer) as we get a number, if a number is\n; inputed, or nil if the input is not a number.\n; since the timer must be a number, this error message\n; will make sure no invalid input is let in\n; \n; we add our sync to spell.active.sync\n; and just like in batch, we update our max value\n; \n; \n; spell.add_spell()\n; this function takes 5 parameters\n; * name of the spell\n; * attribute assigned to the spell\n; * coord_x of the spell\n; * coord_y of the spell\n; * timer of the spell\n; \n; this function uses our debugger function spell_debug.log()\n; the spell_debug functions are defined inside the debugger\n; \n; for the definitions of `spell_debug.`, please look at\n; the comments inside of the Compactors Debugger\n; \n; the script compilation can halt, and this enables\n; logging, but just because the next lines aren't being compiled\n; they're still being recorded and logged\n; \n; this beginning part prevents this\n; by returning nothing if the process is halted\n; \n; the same structure as the beginning of our previous functions\n; active_index is the index and new_spell is our spell table\n; \n; new_spell.name is the spell name with the ending of\n; text_ending_input\n; \n; new_spell.attribute is the value of attribute without any\n; whitespace ` `\n; new_spell.coord_x and .coord_y are stored as floating point numbers\n; \n; new_spell.sync is initialised with 0 and\n; assign to a local table sync the global table spell.active.sync\n; so that looking at the code is easier to understand\n; \n; we now define an internal local function to handle\n; sync(), featuring comments to explain what\n; it's doing\n; \n; inside this function, we assign to new_spell.sync a non\n; 0 value only if we can increase our sync index\n; \n; we create a local sync_offset variable and\n; assign it the return value from our add_sync() function\n; the function only returns a positive floating point number\n; \n; we now assign to new_spell.timer tonumber(timer) + sync_offset\n; and have the guarantee that it too is stored as a floating\n; point number\n; \n; we can now add our new_spell to our spell.active at position\n; of active_index, followed by updating our max values\n; \n; .name_max_length is the maximum between itself and the\n; amount of characters in new_spell.name\n; .attribute_max_length is the same as .name_max_length but\n; with new_spell.attribute\n; \n; for numbers, we convert our numbers to strings and\n; perform the calculations like we do for the text\n; when we have floating point numbers, we have to\n; subtract 1 to the size because of the added dot `.`\n; additionally, when updating .precision.placement, we\n; convert the maximum between our 2 coordinates\n; in order not to update the same value 2 times \n; \n; the update ends with declaring the local active_length\n; which is the sum of our max values and is then compared\n; arithmetically to our attribte_max_length\n; \n; \n; this is the only function that returns a :const\n; this const isn't used for reading, and is\n; a relic kept from the old compactor\n; it can be repurposed to act as a safety net\n; as it's a const string spell.<active_index> 'new_spell.name'\n; \n; \n; final function, spell.concat_actives()\n; this is the complex one, so there's a lot of\n; comments inside to describe the functions purpose\n; \n; yes, this one function is comprised of multiple interlocking\n; functions, that work give the output its structure\n; \n; the complexity comes from integrating our debugging separators\n; inside of it, for an easy way for users to enable debugging\n; \n; we add a batch at the finale of our recordings\n; so that our batch.max_batch is accurate to the recordings\n; additionally, this simplifies the logic a little bit by\n; always knowing that there's at minimum 1 registered batch\n; \n; and now, we get to the function definitions\n; there's a big comment that explains the reason this logic\n; is broken up into peaces, but essentially\n; having functions provides an easier implementation\n; cycle than adding the same lines of code over and over\n; again\n; \n; it does make the flow of logic slightly harder to\n; follow, but the function definitions are written from\n; most important process to least important process,\n; included in-function comments to help explain\n; what is happening and made the function names as explicit\n; as I could in as little words possible\n; \n\n{lua(\\\n  function spell.add_batch(batch_name)\\\n    local batch_index = 1 + #spell.active.batch;\\\n    local batch = {};\\\n    batch.checkpoint = #spell.active;\\\n    batch.size = 0;\\\n    if batch_index > 1 then\\\n      local curent_checkpoint = batch.checkpoint;\\\n      active_batch = spell.active.batch;\\\n      local previous_checkpoint = active_batch[#active_batch].checkpoint;\\\n      batch.size = curent_checkpoint - previous_checkpoint;\\\n    end\\\n    spell.active.batch[batch_index] = batch;\\\n    spell.active.batch.max_batch = math.max(\\\n      spell.active.batch.max_batch,\\\n      batch.size\\\n    );\\\n    local printer = {};\\\n    printer[1 + #printer] = \":const int\" .. ' ';\\\n    printer[1 + #printer] = batch_name:gsub(\" \", \"\");\\\n    printer[1 + #printer] = ' ';\\\n    printer[1 + #printer] = #spell.active;\\\n    return table.concat(printer);\\\n  end\\\n  \\\n  function spell.synchronization(copies, delay)\\\n    local sync_index = 1 + #spell.active.sync;\\\n    local sync = {};\\\n    sync.copies = -1 + math.tointeger(tonumber(copies));\\\n    sync.delay = 0.0 + tonumber(delay);\\\n    spell.active.sync[sync_index] = sync;\\\n    spell.active.sync.index = math.max(\\\n      1,\\\n      spell.active.sync.index\\\n    );\\\n    spell.precision.sync = math.max(\\\n      spell.precision.sync,\\\n      #tostring(sync.copies)\\\n    );\\\n  end\\\n  \\\n  function spell.add_spell(name, coord_x, coord_y, timer)\\\n    local halt_limit = spell_debug.should_halt;\\\n    halt_limit = halt_limit - spell_debug.can_halt;\\\n    if spell_debug.can_halt > 0 then\\\n      if halt_limit <= 0 then\\\n        return;\\\n      end\\\n    end\\\n    local actives_index = 1 + #spell.active;\\\n    local new_spell = {};\\\n    new_spell.name = name .. spell.text.text_ending_character;\\\n    new_spell.coord_x = 0.0 + tonumber(coord_x);\\\n    new_spell.coord_y = 0.0 + tonumber(coord_y);\\\n    \\\n    new_spell.sync = 0;\\\n    local sync = spell.active.sync;\\\n    local function add_sync()\\\n      --[[/*\\\n          * Function to handle the sync system\\\n          * if we've run through the internal copies\\\n          *   if the next sync exists\\\n          *     increment the index\\\n          *     update our internal copies\\\n          *     add a sync to the spell\\\n          *   setup so we only have 1 return\\\n          *   1 return means only 1 logic sequence\\\n          *   to follow\\\n          * we can continue\\\n          * by increasing the delay and\\\n          * decreasing our internal copies\\\n         */]]\\\n      if sync.index == 0 then\\\n        return 0.0;\\\n      end\\\n      if sync.copies_internal == 0 then\\\n        if #sync > sync.index then\\\n          sync.index = sync.index + 1;\\\n          sync.copies_internal = sync[sync.index].copies;\\\n          new_spell.sync = sync[sync.index].copies;\\\n        end\\\n        sync.copies_internal = sync.copies_internal + 1;\\\n        sync.delay_internal = 0.0 - sync[sync.index].delay;\\\n      end\\\n      sync.delay_internal = sync.delay_internal + sync[sync.index].delay;\\\n      sync.copies_internal = sync.copies_internal - 1;\\\n      return sync.delay_internal;\\\n    end\\\n    \\\n    local sync_offset = add_sync();\\\n    new_spell.timer = sync_offset + tonumber(timer);\\\n    spell.active[actives_index] = new_spell;\\\n    \\\n    spell.text.name_max_length = math.max(\\\n      spell.text.name_max_length,\\\n      #new_spell.name\\\n    );\\\n    spell.precision.placement = math.max(\\\n      spell.precision.placement,\\\n      #tostring(math.max(new_spell.coord_x, new_spell.coord_y)) - 1\\\n    );\\\n    spell.precision.timer = math.max(\\\n      spell.precision.timer,\\\n      #tostring(new_spell.timer) - 1\\\n    );\\\n  \\\n    local active_length = spell.precision.sync;\\\n    active_length = active_length + spell.precision.timer;\\\n    active_length = active_length + 2;\\\n    active_length = active_length + spell.precision.placement;\\\n    active_length = active_length + 2;\\\n    active_length = active_length + spell.precision.placement;\\\n    active_length = active_length + 2;\\\n    active_length = active_length + spell.text.name_max_length;\\\n  \\\n    spell.active_max_length = math.max(\\\n      spell.active_max_length,\\\n      active_length\\\n    );\\\n    local debug_check = spell_debug.can_halt;\\\n    debug_check = debug_check + spell_debug.can_log;\\\n    if debug_check > 0 then\\\n      spell_debug.log();\\\n    end\\\n    if spell_debug.can_halt > 0 then\\\n      spell_debug.should_halt = spell_debug.should_halt - 1;\\\n    end\\\n    \\\n    local output = {};\\\n    output[1 + #output] = \":const string\" .. ' ';\\\n    output[1 + #output] = \"spell.\";\\\n    output[1 + #output] = actives_index;\\\n    output[1 + #output] = \" '\" .. new_spell.name .. \"'\";\\\n    return table.concat(output);\\\n  end\\\n  \\\n  function spell.concat_actives()\\\n    local spells = {};\\\n  \\\n    local recordings = spell.active;\\\n    local active_count = #spell.active;\\\n    \\\n    spell.add_batch('');\\\n    local batches = spell.active.batch;\\\n    local batch_index = 1;\\\n    local batch_concat = '';\\\n    local index = 0;\\\n    \\\n    local spells_debug = {};\\\n    spells_debug.format = '';\\\n    spells_debug.spacer_open = '';\\\n    spells_debug.spacer_close = '';\\\n    spells_debug.chunk = '';\\\n  \\\n    local spells_format = {};\\\n    spells_format.debug_format = 1;\\\n    spells_format.batch = 0;\\\n    \\\n    spells_format.number = 0;\\\n    spells_format.text = 0;\\\n    \\\n    spells_format.target = 0;\\\n    \\\n    spells_format.encase = 0;\\\n    spells_format.chunk = 0;\\\n    \\\n  \\\n    local debug_text = spell_debug.text.concat_in_batch;\\\n    debug_text = debug_text + spell_debug.text.can_concat;\\\n    \\\n    local debug_batch = debug_text;\\\n    debug_batch = debug_batch + spell_debug.text.spacer_in_number;\\\n    if debug_text > 0 then\\\n      spells_debug.spacer_open = spell_debug.text.spacer_open;\\\n    \\\n      if debug_text == spell_debug.text.concat_in_batch then\\\n        batch_concat = spell_debug.text.concat_format;\\\n        spells_format.batch = 1;\\\n      else\\\n        spells_debug.format = spell_debug.text.concat_format;\\\n        spells_debug.chunk = spell_debug.text.chunk;\\\n      end\\\n    \\\n      spells_debug.spacer_close = spell_debug.text.spacer_close;\\\n    end\\\n    \\\n     --[[/*\\\n         * Sequence for concatenation\\\n         * It will get broken up into separate\\\n         * local functions\\\n         * This is done to add implementation flexibility\\\n         * and to improve overall readability\\\n        */]]\\\n    \\\n    local function concat_format()\\\n      \\\n       --[[/*\\\n           * Function that formats the\\\n           * contents of spells according\\\n           * to the values in spells_format\\\n          */]]\\\n      \\\n      local printer = {};\\\n      local fmt = spells_format;\\\n      \\\n      if fmt.debug_format == 1 then\\\n        printer[1 + #printer] = spells_debug.format;\\\n      end\\\n      if fmt.batch == 1 then\\\n        printer[1 + #printer] = batch_concat;\\\n      end\\\n      \\\n      printer[1 + #printer] = spells[#spells];\\\n      if fmt.number == 1 then\\\n        local number = printer[#printer];\\\n        local format = \"%.\";\\\n        if math.type(number) == 'integer' then\\\n          format = \"%0\";\\\n        end\\\n        format = format .. fmt.target .. \"f\";\\\n        local number_format = string.format(format, number);\\\n        printer[#printer] = string.sub(\\\n          number_format,\\\n          1,\\\n          fmt.target + 2\\\n        );\\\n      end\\\n      \\\n      if fmt.text == 1 then\\\n        local spells_text = printer[#printer];\\\n      \\\n        local spacing_size = fmt.target;\\\n        spacing_size = spacing_size - #spells_text;\\\n      \\\n        local spacer = spacing_size;\\\n        if spell_debug.text.spacer_in_number == 0 then\\\n          spacer = string.rep('.', spacing_size);\\\n        end\\\n        printer[1 + #printer] = spells_debug.format;\\\n        printer[1 + #printer] = spacer;\\\n      end\\\n      \\\n      if fmt.encase == 1 then\\\n        local sequence = printer[#printer];\\\n        printer[#printer] = spells_debug.spacer_open;\\\n        printer[1 + #printer] = sequence;\\\n        printer[1 + #printer] = spells_debug.spacer_close;\\\n      end\\\n    \\\n      if fmt.chunk == 1 then\\\n        printer[1 + #printer] = spells_debug.format;\\\n        printer[1 + #printer] = spells_debug.chunk;\\\n      end\\\n      \\\n      fmt.debug_format = 1;\\\n      fmt.batch = 0;\\\n      fmt.number = 0;\\\n      fmt.text = 0;\\\n      fmt.target = 0;\\\n      fmt.encase = 0;\\\n      fmt.chunk = 0;\\\n      \\\n      spells[#spells] = table.concat(printer);\\\n    end\\\n    \\\n    local function number_handling()\\\n      local numbers = {};\\\n      local precisions = {};\\\n      \\\n      table.insert(numbers, recordings[index].sync);\\\n      table.insert(numbers, recordings[index].timer);\\\n      table.insert(numbers, recordings[index].coord_x);\\\n      table.insert(numbers, recordings[index].coord_y);\\\n      \\\n      local precision = spell.precision\\\n      table.insert(precisions, precision.sync);\\\n      table.insert(precisions, precision.timer);\\\n      table.insert(precisions, precision.placement);\\\n      table.insert(precisions, precision.placement);\\\n      \\\n      for i = 1, #numbers do\\\n        spells_format.number = 1;\\\n        spells_format.target = precisions[i];\\\n        spells[1 + #spells] = numbers[i];\\\n        concat_format();\\\n      end\\\n    end\\\n    local function text_handling()\\\n      local texts = {};\\\n      table.insert(texts, recordings[index].name);\\\n      \\\n      local lengths = {};\\\n      local stxt = spell.text;\\\n      table.insert(lengths, stxt.name_max_length);\\\n      \\\n      for i = 1, #texts do\\\n        spells[1 + #spells] = texts[i];\\\n        spells_format.debug_format = #texts - i;\\\n        spells_format.text = 1;\\\n        spells_format.target = lengths[i];\\\n        spells_format.encase = 1;\\\n        concat_format();\\\n      end\\\n    \\\n    end\\\n    local function batch_handling()\\\n      local batch = batches.max_batch;\\\n      batch = batch - batches[batch_index].size;\\\n      if batches[batch_index].checkpoint ~= index then\\\n        batch = 0;\\\n      end\\\n      batch = batch * spell.active_max_length;\\\n      batch = batch + #spells[#spells];\\\n    \\\n      spells_format.debug_format = 0;\\\n      spells_format.text = 1;\\\n      spells_format.target = batch;\\\n      if debug_batch > 0 then\\\n        spells_format.encase = 1;\\\n      end\\\n      concat_format();\\\n    \\\n      if #batches > batch_index then\\\n        if index == batches[batch_index].checkpoint then\\\n          batch_index = batch_index + 1;\\\n          spells_format.batch = 1;\\\n        end\\\n      end\\\n    end\\\n  \\\n    while index < active_count do\\\n      index = index + 1;\\\n      number_handling();\\\n      text_handling();\\\n      batch_handling();\\\n      spells_format.chunk = spell_debug.text.can_concat;\\\n      concat_format();\\\n    end\\\n    return table.concat(spells);\\\n  end\\\n)}\n\n; \n; Helper macros to make the user interact with the\n; compactor in an easier manner\n; \n\n#add_batch(name) {lua(return spell.add_batch(\"{name}\"))}\n\n\n#synchronize(copies, delay) {lua(return spell.synchronization(\\\n  [[{copies}]],\\\n  [[{delay}]]\\\n))}\n\n; \n; Root add_spell that all spell_types\n; get filtered down through\n; \n\n#add_spell(name, placement_x, placement_y, timer) {lua(\\\n  return spell.add_spell(\\\n    {name},\\\n    [[{placement_x}]],\\\n    [[{placement_y}]],\\\n    [[{timer}]]\\\n  );\\\n)}\n\n#add_spell.instant(name, timer) {add_spell(\\\n  '{name}',\\\n  0.0,\\\n  0.0,\\\n  {timer}\\\n)}\n\n#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\\\n  '{name}',\\\n  {coord_x},\\\n  {coord_y},\\\n  {timer}\\\n)}\n"],["Devbuild Spell Compactor Debugger",":name devbuild Spell Cmp Debug\n\n; \n; Welcome to the Spell Compactors debugger\n; this handles the logging functions and the\n; actions you define in the debugger macros\n; \n; \n; Lua macros that define functions that\n; permit debugging the Spell Compactor\n; \n; Debugging is an essential part of developing\n; a compactor, so having a dedicated\n; script to manage this is very important\n; \n; The debugger is separated in 2 macros\n; * the variable declarations\n; * the function definitions\n; \n; the variable declarations have the job\n; of defining what you want to use\n; \n; values whose names start with `can_` are\n; integer values that get treated as bools\n; \n; should_halt is a decrementing value, which cannot\n; go bellow 0, that's modified inside of spell.add_spell()\n; \n; the .text table is used for concatenating text\n; since we've got batch implementation, it's more\n; convenient to look at the number than the respective\n; number of dots\n; \n; \n; \n; \n\n{lua(\\\n  spell_debug = {};\\\n  spell_debug.can_log = 0;\\\n  spell_debug.can_halt = 0;\\\n  spell_debug.should_halt = 0;\\\n  spell_debug.text = {};\\\n  spell_debug.text.can_concat = 0;\\\n  spell_debug.text.spacer_in_number = 0;\\\n  spell_debug.text.concat_in_batch = 0;\\\n  spell_debug.text.concat_format = '';\\\n  spell_debug.text.chunk = \"Chunk Separation\" .. '\\n';\\\n  spell_debug.text.spacer_open = '[';\\\n  spell_debug.text.spacer_close = ']';\\\n)}\n\n; \n; \n\n{lua(\\\n  function spell_debug.log()\\\n    \\\n     --[[/*\\\n         * Debugger function for logging\\\n         * featuring additional functions to\\\n         * streamline the format in which data\\\n         * is printed\\\n         * using print instead of return to\\\n         * provide as non-intrusive a logging experience\\\n         * as possible\\\n        */]]\\\n    \\\n    local function print_spacer(name)\\\n      \\\n       --[[/*\\\n           * simple function to print\\\n           * a separation sequence\\\n          */]]\\\n      \\\n      local printer = {};\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = \"Entering sequence\" .. ' ';\\\n      printer[1 + #printer] = name;\\\n      return table.concat(printer);\\\n    end\\\n    local function print_text(text_type, text_name, text)\\\n      \\\n       --[[/*\\\n           * text_type is the starting attribute\\\n           * text_name is the name of our text\\\n           *   ex: Name, Name Size,\\\n           *       Attribute, Attribute Size,\\\n           *       coord_x, coord_y,\\\n           *       timer, sync ...\\\n           * text is the text we want returned\\\n           * for simplicity, this is the beginning part\\\n           * It's flexible and does little, but saves room\\\n          */]]\\\n      \\\n      local printer = {};\\\n      printer[1 + #printer] = text_type;\\\n      printer[1 + #printer] = ' ';\\\n      printer[1 + #printer] = text_name;\\\n      printer[1 + #printer] = \" = \";\\\n      printer[1 + #printer] = text;\\\n      return table.concat(printer)\\\n    end\\\n    local function print_text_type(text_type, text_name, text)\\\n      \\\n       --[[/*\\\n           * text_type, text_name and text from print_text()\\\n           * function to return the type of [text]\\\n          */]]\\\n      \\\n      local printer = {};\\\n      printer[1 + #printer] = print_text(\\\n        text_type,\\\n        text_name,\\\n        text\\\n      );\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = \"And is of type\" .. ' ';\\\n      printer[1 + #printer] = type(text);\\\n      return table.concat(printer);\\\n    end\\\n    local function print_text_size(type, name, text, max_length)\\\n      \\\n       --[[/*\\\n           * type, name and text from print_text()\\\n           * max_length is the size of \\\n           * the maximum in spell.text.type\\\n           * \\\n           * function seems redundant, but it's\\\n           * for flexibility and easier logging\\\n          */]]\\\n      \\\n      local printer = {};\\\n      local size_text_name = name .. \" Size\";\\\n      printer[1 + #printer] = print_text(type, size_text_name, #text);\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = print_text(\\\n        \"Max\",\\\n        size_text_name,\\\n        max_length\\\n      );\\\n      return table.concat(printer)\\\n    end\\\n    \\\n     --[[/*\\\n        * Separate functions for numbers\\\n        * Parameters text<block> are replaced with\\\n        * number<block> to easily differentiate the two\\\n        * functions separated because text is logged\\\n        * differently to how numbers are logged\\\n        */]]\\\n    \\\n    local function print_number_type(type, name, number, expected_type)\\\n      \\\n       --[[/*\\\n           * type, name and number are the same\\\n           * as in print_text_size()\\\n           * expected_type is the type we\\\n           * expect this number to be\\\n          */]]\\\n      \\\n      local printer = {};\\\n      printer[1 + #printer] = print_text_type(type, name, number);\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = \"Should be a number, of type \";\\\n      printer[1 + #printer] = expected_type;\\\n      printer[1 + #printer] = \", and such \" .. '\\n';\\\n      printer[1 + #printer] = \"And is a number of type\" .. ' ';\\\n      printer[1 + #printer] = math.type(number);\\\n      return table.concat(printer)\\\n    end\\\n    local function print_number_size(type, name, number, max_length)\\\n      \\\n       --[[/*\\\n           * type and name are the same\\\n           * from print_number_type()\\\n           * this time, number is the length for the number\\\n           * max_length is the expected precision from\\\n           * spell.precision\\\n          */]]\\\n      \\\n      local printer = {};\\\n      local size_number_name = name .. \" Size\"\\\n      printer[1 + #printer] = print_text(type, size_number_name, number);\\\n      printer[1 + #printer] = '\\n';\\\n      printer[1 + #printer] = print_text(\\\n        size_number_name,\\\n        \"Precision\",\\\n        max_length\\\n      );\\\n      return table.concat(printer);\\\n    end\\\n    \\\n     --[[/*\\\n         * Special function calls\\\n         * methods to output types\\\n         * for the future\\\n         * These require per-case formatting\\\n        */]]\\\n    \\\n    local function print_sync(sync_name, sync, info)\\\n      \\\n       --[[/*\\\n           * sync_name and sync are like\\\n           * text_name and text in print_text()\\\n           * sync requires representation sequences\\\n           * to describe what it represents\\\n           * \\\n           * these sequences can have as many\\\n           * line breaks in them, as the :gsub turns\\\n           * all whitespace [  ] into 1 single space [ ]\\\n          */]]\\\n      \\\n      local printer = {};\\\n      printer[1 + #printer] = print_text(\"Sync\", sync_name, sync);\\\n      printer[1 + #printer] = '\\n';\\\n      local representation = info:gsub(\"%s+\", \" \");\\\n      printer[1 + #printer] = representation;\\\n      return table.concat(printer);\\\n    end\\\n    \\\n    local active = spell.active;\\\n    local spell_index = #active;\\\n    print(print_text_type(\"Spell\", \"Name\", active[spell_index].name));\\\n    print(print_text_size(\\\n      \"Spell\",\\\n      \"Name\",\\\n      active[spell_index].name,\\\n      spell.text.name_max_length\\\n    ));\\\n    print(print_spacer(\"spell numbers\"));\\\n  \\\n    print(print_number_type(\\\n      \"Spell\",\\\n      \"coord_x\",\\\n      active[spell_index].coord_x,\\\n      \"float\"\\\n    ));\\\n    print(print_number_type(\\\n      \"Spell\",\\\n      \"coord_y\",\\\n      active[spell_index].coord_y,\\\n      \"float\"\\\n    ));\\\n    print(print_number_size(\\\n      \"Spell Max\",\\\n      \"Coord\",\\\n      #tostring(math.max(\\\n        active[spell_index].coord_x,\\\n        active[spell_index].coord_y\\\n      )) - 1,\\\n      spell.precision.placement\\\n    ));\\\n    \\\n    print(print_number_type(\\\n      \"Spell\",\\\n      \"timer\",\\\n      active[spell_index].timer,\\\n      \"float\"\\\n    ));\\\n    print(print_number_size(\\\n      \"Spell\",\\\n      \"Timer\",\\\n      #tostring(active[spell_index].timer) - 1,\\\n      spell.precision.timer\\\n    ));\\\n    \\\n    print(print_number_type(\\\n      \"Spell\",\\\n      \"sync\",\\\n      active[spell_index].sync,\\\n      \"integer\"\\\n    ));\\\n    print(print_number_size(\\\n      \"Spell\",\\\n      \"Sync\",\\\n      #tostring(active[spell_index].sync),\\\n      spell.precision.sync\\\n    ));\\\n    print(print_text(\"Spell\", \"index\", spell_index));\\\n  \\\n    print(print_spacer(\"Batch\"));\\\n    local batch = spell.active.batch;\\\n    local batch_size = 0;\\\n    if #batch > 0 then\\\n      batch_size = batch[#batch].size;\\\n    end\\\n    print(print_number_type(\"Batch\", \"size\", batch_size, \"integer\"));\\\n    print(print_number_size(\\\n      \"Spell\",\\\n      \"batch\",\\\n      batch_size,\\\n      batch.max_batch\\\n    ));\\\n    print(print_number_type(\\\n      \"Spell\",\\\n      \"active_max_length\",\\\n      spell.active_max_length,\\\n      \"integer\"\\\n    ));\\\n    print(print_text(\"Batch\", \"index\", #batch));\\\n  \\\n    print(print_spacer(\"Sync\"));\\\n    local sync = spell.active.sync;\\\n    print(print_sync(\\\n      \"internal copies\",\\\n      sync.copies_internal,\\\n      \"Representing how many more sync itterations are left\"\\\n    ));\\\n    print(print_sync(\\\n      \"copies\",\\\n      sync[sync.index].copies,\\\n      \"Being what the internal copies are based of\"\\\n    ));\\\n    print(print_sync(\\\n      \"internal delay\",\\\n      sync.delay_internal,\\\n      \"Representing how much delay got added to the timer\"\\\n    ));\\\n    print(print_sync(\\\n      \"delay\",\\\n      sync[sync.index].delay,\\\n      \"Being the ammount added to the internal delay\"\\\n    ));\\\n    print(print_text(\"Sync\", \"internal index\", sync.index));\\\n    print(print_spacer(\"Blocker\"));\\\n  end\\\n  \\\n  function spell_debug.halt()\\\n    local debugger = {};\\\n    local debug_check = spell_debug.can_halt;\\\n    debug_check = debug_check + spell_debug.text.can_concat;\\\n    debug_check = debug_check + spell_debug.text.concat_in_batch;\\\n    debug_check = debug_check + spell_debug.text.spacer_in_number;\\\n    if debug_check <= 0 then return; end\\\n    \\\n    debugger[1 + #debugger] = \"Compilation Stopped,\" .. ' ';\\\n    debugger[1 + #debugger] = \"debug mode enabled\" .. '\\n';\\\n    debugger[1 + #debugger] = \"Output has been modified\" .. ' ';\\\n    debugger[1 + #debugger] = \"by a spell_debug macro\"\\\n    \\\n    if spell_debug.can_halt >= spell_debug.should_halt then\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Logging enabled, logs are visible in \";\\\n      debugger[1 + #debugger] = \"your browsers developer console\";\\\n    end\\\n    \\\n    local text_check = spell_debug.text.can_concat;\\\n    text_check = text_check + spell_debug.text.concat_in_batch;\\\n    if text_check > 0 then\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Output formatting enabled\" .. '\\n';\\\n      debugger[1 + #debugger] = \"Every component of the\" .. ' ';\\\n      debugger[1 + #debugger] = \"output will begin with the\" .. ' ';\\\n      debugger[1 + #debugger] = \"string inputed in\" .. ' ';\\\n      debugger[1 + #debugger] = \"spell_debug.display_format\" .. '\\n';\\\n      debugger[1 + #debugger] = \"Every spacing sequence will be\" .. ' ';\\\n      debugger[1 + #debugger] = \"inbetween the characters\" .. \" \";\\\n      debugger[1 + #debugger] = \"'[' and ']'\";\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Retrieving output showing\" .. ' ';\\\n      debugger[1 + #debugger] = #spell.active;\\\n      debugger[1 + #debugger] = ' ';\\\n      debugger[1 + #debugger] = \"recording\";\\\n      if #spell.active > 1 then\\\n        debugger[1 + #debugger] = 's';\\\n      end\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Featuring precisions:\";\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Sync precision = \";\\\n      debugger[1 + #debugger] = spell.precision.sync;\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Timer precision = \";\\\n      debugger[1 + #debugger] = spell.precision.timer;\\\n      debugger[1 + #debugger] = '\\n';\\\n      debugger[1 + #debugger] = \"Placement precision = \";\\\n      debugger[1 + #debugger] = spell.precision.placement;\\\n      \\\n      debugger[1 + #debugger] = spell.concat_actives();\\\n    end\\\n    return table.concat(debugger);\\\n  end\\\n)}\n\n; \n; \n\n{lua(\\\n  function spell_debug.data_validation(value)\\\n    local data = tonumber(value);\\\n    if not data then\\\n      data = 0;\\\n    end\\\n    data = math.max(data, 0 - data);\\\n    return data;\\\n  end\\\n)}\n\n#spell_debug {lua(return spell_debug.halt())}\n#spell_debug.assign(table, value) {lua(spell_debug{table} = {value})}\n\n#spell_debug.log(level) {spell_debug.assign(\\\n  [\"can_log\"], \\\n  spell_debug.data_validation({level})\\\n)}\n\n#spell_debug.halt_compilation(level) {spell_debug.assign(\\\n  [\"can_halt\"], \\\n  spell_debug.data_validation({level})\\\n)}\n\n#spell_debug.recordings_before_halt(limit) {spell_debug.assign(\\\n  [\"should_halt\"], \\\n  {limit}\\\n)}\n\n#spell_debug.display_spells(level) {spell_debug.assign(\\\n  [\"text\"][\"can_concat\"], \\\n  spell_debug.data_validation({level})\\\n)}\n\n#spell_debug.display_spacers_as_numbers(level) {spell_debug.assign(\\\n  [\"text\"][\"spacer_in_number\"], \\\n  spell_debug.data_validation({level})\\\n)}\n\n#spell_debug.display_spells_in_batch(level) {spell_debug.assign(\\\n  [\"text\"][\"concat_in_batch\"], \\\n  spell_debug.data_validation({level})\\\n)}\n\n#spell_debug.display_format(separator) {spell_debug.assign(\\\n  [\"text\"][\"concat_format\"], \\\n  {separator}\\\n)}\n\n"],["Devbuild Spell Compactor resources",":name devbuild Spell Cmp Res\n; \n; This is a library that declairs\n; the naming scheme needed to use\n; the stand-alone spell compactor\n; \n; Name of the stand-alone compactor\n; use this to call it\n; \n\n#spell_compactor_package(name) Spell Compactor:{name}\n\n; \n; the hider macros\n; these are simple strings\n; that control how\n; the variable hider works\n; \n\n#hider.start \"<size=0><line-height=0%>\"\n#hider.close \"</line-height></size>\"\n\n; \n; starting with a pointer\n; the pointer needs an identifier, this is defined within\n; your blueprint AI's library file\n; \n; the pointer lets you read from\n; your spells constant by cycling through them\n; \n; the pointer is also a block hider\n; this is so that it doesn't messy up the users screen\n; \n\n#pointer {hider.start} . \"pointer\" . {identifier}\n#pointer.get global.int.get({pointer})\n#pointer.set(value) global.int.set({pointer}, {value})\n\n; \n; this helper macro encases our\n; global variable inbetween 2\n; macros\n; * compactor_type is a multipurpose macro\n;   that can be used for data transfer\n;   without disturbing the overlay\n; \n; * identifier is a macro for script identification\n;   this should be equivalent to the name of our package\n;   for the compactor to easily read it\n; \n; it's written in a lua macro just\n; for easier modifications\n; \n\n#compactor_encasement(caller) {lua(\\\n  local encasement = {};\\\n  encasement[1 + #encasement] = [[{compactor_type}]];\\\n  encasement[1 + #encasement] = \" . ' ' . \";\\\n  encasement[1 + #encasement] = [[{caller}]];\\\n  encasement[1 + #encasement] = \" . ' ' . \";\\\n  encasement[1 + #encasement] = [[{identifier}]];\\\n  return table.concat(encasement);\\\n)}\n\n; \n; moving on to spell_size\n; this is contained within the pointers\n; hiding block, and it contains the\n; constant int spell_size\n; this is for comunication with the\n; standalone spell compactor, to\n; trim down the scripts needed for\n; blueprint AI's\n; \n\n#spells_size {compactor_encasement(\"spells_size\")}\n#spells_size.get global.int.get({spells_size})\n#spells_size.set(value) global.int.set({spells_size}, {value})\n\n; \n; Precision field\n; This is another helper macro\n; that lets me easily assign\n; const int precision variables\n; in a global manner, for using\n; the stand-alone spell compactor\n; \n\n#precision(type) {compactor_encasement(\"precision\" . {type})}\n#precision.get(type) global.int.get({precision({type})})\n#precision.set(type, value) global.int.set({precision({type})}, {value})\n\n; \n; I will now create the macros\n; * count to define the number of spells in the\n;   provided active_spells string\n; * sync to define sync_precision\n; * timer to define timer_precision\n; * placement to define placement_precision\n; \n; built by using the previously\n; defined precision macros\n; \n\n#precision_count {precision(\"count\")} \n#precision_count.get {precision.get(\"count\")}\n#precision_count.set(value) {precision.set(\"count\", {value})}\n\n\n#precision_sync (precision(\"sync\"))\n#precision_sync.get {precision.get(\"sync\")}\n#precision_sync.set(value) {precision.set(\"sync\", {value})}\n\n#precision_timer {precision(\"timer\")}\n#precision_timer.get {precision.get(\"timer\")}\n#precision_timer.set(value) {precision.set(\"timer\", {value})}\n\n#precision_placement {precision(\"placement\")}\n#precision_placement.get {precision.get(\"placement\")}\n#precision_placement.set(value) {precision.set(\"placement\", {value})}\n\n; \n; we have a dedicated string that\n; gives us the `text_ending_character` character\n; \n; this is done for the explicit definition\n; \n\n#text_ending_character {compactor_encasement(\"text_ending_character\")}\n#text_ending_character.get global.string.get({text_ending_character})\n#text_ending_character.set(value) global.string.set(\\\n  {text_ending_character},\\\n  ({value})\\\n)\n\n; \n; we end the block hider by storing\n; our active_spells string\n; this way, we can use the stand-alone compactor\n; without needing a complete design overhaul\n; \n\n#active_spells {compactor_encasement(\"active_spells\")}\n#active_spells.get global.string.get({active_spells})\n#active_spells.set(value) global.string.set(\\\n  {active_spells},\\\n  {value} . {hider.close}\\\n)\n\n; \n; ending with the timer\n; the timer is just t, to keep\n; backwards compatibility with other\n; scripts using winemast\n; \n\n#timer \"t\"\n#timer.get global.double.get({timer})\n#timer.set(value) global.double.set({timer}, {value})\n#timer.add(value) {timer.set({timer.get} + ({value}))}\n"],["Devbuild Spell Compactor lib",":import Devbuild Spell Compactor resources\n:name devbuild Spell Cmp Util\n\n#package(name) {spell_compactor_package({name})}\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n\n; \n; This is the stand-alone spell compactor\n; importing this should be the first action\n; performed if you're using the compactor\n; \n\n#identifier \"Spell Compactor\"\n\n#internal_pointer \"<size=0>\" . {identifier} . \"internal\" . \"pointer\"\n#internal_pointer.get global.int.get({internal_pointer})\n#internal_pointer.set(value) global.int.set({internal_pointer}, {value})\n#pointer.increment {internal_pointer.set(\\\n  ({internal_pointer.get} + 1) % {spells_count.get}\\\n)}\n\n; \n; spells_count        = precision_count\n; spell_size          = spells_size\n; sync_precision      = precision_sync\n; time_precision      = precision_timer\n; placement_precision = precision_placement\n; text_end_character  = text_ending_character\n; actives             = active_spells\n; \n\n#spells_count \"iternal\" . \"count_precision\" . {identifier}\n#spells_count.get global.int.get({spells_count})\n#spells_count.set(value) global.int.set({spells_count}, {value})\n\n#spell_size \"internal\" . \"spells_size\" . {identifier}\n#spell_size.get global.int.get({spell_size})\n#spell_size.set(value) global.int.set({spell_size}, {value})\n\n#sync_precision \"internal\" . \"precision_sync\" . {identifier}\n#sync_precision.get global.int.get({sync_precision})\n#sync_precision.set(value) global.int.set({sync_precision}, {value})\n\n#time_precision \"internal\" . \"precision_time\" . {identifier}\n#time_precision.get global.int.get({time_precision})\n#time_precision.set(value) global.int.set({time_precision}, {value})\n\n#placement_precision \"internal\" . \"precision_placement\" . {identifier}\n#placement_precision.get global.int.get({placement_precision})\n#placement_precision.set(value) global.int.set(\\\n  {placement_precision}, \\\n  {value}\\\n)\n\n\n#text_end_character \"internal\" . \"text_ending_character\" . {identifier}\n#text_end_character.get global.string.get({text_end_character})\n#text_end_character.set(value) global.string.set(\\\n  {text_end_character}, \\\n  {value}\\\n)\n\n#actives \"internal\" . \"active_spells\" . {identifier}\n#actives.get global.string.get({actives})\n#actives.set(value) global.string.set(\\\n  {actives},\\\n  ({value}) . {hider.close}\\\n)\n\n\n#actives.displace(sync, timer, positions) position + (\\\n  {sync} * {sync_precision.get} + \\\n  {timer} * {time_precision.get} + \\\n  {positions} * {placement_precision.get}\\\n)\n\n#actives.substring(sync, timer, positions, length) sub(\\\n  {actives.get},\\\n  {actives.displace({sync}, {timer}, {positions})},\\\n  {length}\\\n)\n\n#actives.index(sync, timer, positions) index(\\\n  {actives.get},\\\n  {text_end_character.get},\\\n  {actives.displace({sync}, {timer}, {positions})}\\\n) - ({actives.displace({sync}, {timer}, {positions})})\n"]]}}
```
