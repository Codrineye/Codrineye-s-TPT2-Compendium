:import Cods Spell Compactor

; 
; Welcome to the configuration
; This script has macros that allow you to
; communicate with the compactor and its debugger
; 
; The following macros let you communicate
; with the debugger
; spell_debug.log permits logging to the console
; 
; spell_debug.halt_compilation signals to the
; compactor that compilation should halt eventually
; 
; spell_debug.recordings_before_halt is the amount
; of spells you can add before compilation halts
; this value has no effect if you haven't signaled
; to the compactor that compilation should halt eventually
; 
; spell_debug.display_spells tells the debugger to
; display the spells you added
; 
; spell_debug.display_spacers_as_numbers is a
; field that converts all spacers into the amount of
; space they would have added, this improves visibility
; when debugging the output
; 
; spell_debug.display_spells_in_batch signals the
; compactor to display your spells, but to only add
; a separator at the start of a new batch 
; 
; spell_debug.display_format is a string that
; acts as a separtor for inputs
; the string you input in this field will be
; at the beginning of every recorded field
; this only applies if you want to display the output
; 

{spell_debug.log(0)}
{spell_debug.halt_compilation(0)}
{spell_debug.recordings_before_halt(2)}
{spell_debug.display_spells(0)}
{spell_debug.display_spacers_as_numbers(0)}
{spell_debug.display_spells_in_batch(0)}
{spell_debug.display_format('\n|')}

; 
; Time for the actual recording
; you have 4 functions at your disposal
; 
; add_spell.instant()
; this takes in 2 parameters 
; * the name of the spell, this can be obtained by
;   simply importing a script that uses all the modules you want
; * the timer for the spell, being the amount of time you want
;   to pass before activation
; 
; add_spell.grounded()
; this takes in 4 parameters
; * the name, just like in add_spell.instant()
; * the timer, just like in add_spell.instant()
; * the x position of where you want to cast the spell
; * the y position of where you want to cast the spell
; 
; blueprint AI's usually use winemast for the timer t
; the timer is the value of `t` at the time of activation
; 
; syncronize()
; this takes in 2 parameters
; * the number of modules you want to activate at once
; * a potential delay you may want to add to the spell timers
; 
; add_batch()
; this takes in 0 parameters
; it defines a batch chunk, meaning a separation
; between one spell sequence and another
; 
; I do not recommend defining a grounded module as an instant module
; nor vice versa the system will accept your input
; but you will cast the grounded module at position 0.0
; 

{syncronize(2, 0.0)}
{add_spell.instant(barrier.temporal, 0.0)}
{add_spell.instant(spell.floof, 0.0)}

{syncronize(2, 0.0)}
{add_spell.instant(spell.response.neutral, 0.0)}
{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}

{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}

{syncronize(4, 0.0)}
{add_spell.instant(spell.snapOfDestiny, 1.0)}
{add_spell.instant(spell.recharge, 1.0)}
{add_spell.instant(spell.cooling, 1.0)}
{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}

{syncronize(2, 0.0)}
{add_spell.instant(spell.response.neutral, 2.0)}
{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}

{add_spell.instant(spell.snapOfDestiny, 3.0)}

{syncronize(6, 0.0)}
{add_spell.instant(spell.snapOfDestiny, 28.0)}
{add_spell.instant(spell.refresh, 28.0)}
{add_spell.instant(spell.recharge, 28.0)}
{add_spell.instant(barrier.temporal, 28.0)}
{add_spell.instant(spell.floof, 28.0)}
{add_spell.instant(spell.snapOfDestiny, 28.0)}

{syncronize(2, 0.0)}
{add_spell.instant(spell.cooling, 29.0)}
{add_spell.instant(spell.recharge, 29.0)}

{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}

{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}

{syncronize(5, 0.0)}
{add_spell.instant(spell.snapOfDestiny, 31.0)}
{add_spell.instant(spell.recharge, 31.0)}
{add_spell.instant(spell.refresh, 31.0)}
{add_spell.instant(barrier.temporal, 31.0)}
{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}

{add_spell.instant(spell.snapOfDestiny, 33.0)}

{add_spell.instant(spell.snapOfDestiny, 57.0)}

; 
; This marks the end of spell configuration
; we now have a macro spell_debug
; this is in charge of outputing debugging data
; and prevents the output string from being read
; when its contents are modified for displaying
; 

{spell_debug}

; 
; These are the constants you'll be dealing with
; It's more convenient to put them at the end of this file
; rather than copy them
; Putting the const declaration here is
; also beneficial since it shows you can
; create separate sequences if need be
; Such as for a fragment AI
; 

:const string actives '{lua(return spell.concat_actives())}'
:const string text_end_character '{lua(return spell.text.text_ending_character)}'
:const int spells_count {lua(return #spell.active)}
:const int spell_size {lua(return spell.active_max_length)}

:const int sync_precision {lua(return spell.precision.sync)}
:const int time_precision {lua(return 2 + spell.precision.timer)}
:const int placement_precision {lua(return 2 + spell.precision.placement)}

