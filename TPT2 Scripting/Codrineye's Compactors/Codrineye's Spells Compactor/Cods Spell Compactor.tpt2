:import Compactors Debugger
:name lua madness but better

; 
; 

{lua(\
  spell = {};\
  spell.active = {};\
  spell.active.batch = {};\
  spell.active.batch.max_batch = 0;\
  spell.active.sync = {};\
  spell.active.sync.index = 0;\
  spell.active.sync.copies_internal = 0;\
  spell.active.sync.delay_internal = 0;\
  spell.active_max_length = 0;\
  spell.text = {};\
  spell.text.name_max_length = 0;\
  spell.text.attribute_max_length = 0;\
  spell.text.text_ending_character = ':';\
  spell.precision = {};\
  spell.precision.sync = 0;\
  spell.precision.timer = 0;\
  spell.precision.placement = 0;\
)}

{lua(\
  local function x_digit_precision(digits, input)\
    local number = tostring(input):gsub(" ", ""):gsub("'", "");\
    local format = "%.";\
    if math.type(tonumber(number)) == 'integer' then\
      format = "%0"; \
    end\
    return string.sub(\
      string.format(format .. digits .. "f", number),\
      1,\
      digits + 2\
    );\
  end\
\
\
  function spell.add_batch()\
    local batch_index = 1 + #spell.active.batch;\
    local batch = {};\
    batch.checkpoint = #spell.active;\
    batch.size = 0;\
    if batch_index > 1 then\
      local curent_checkpoint = batch.checkpoint;\
      active_batch = spell.active.batch;\
      local previous_checkpoint = active_batch[#active_batch].checkpoint;\
      batch.size = curent_checkpoint - previous_checkpoint;\
    end\
    spell.active.batch[batch_index] = batch;\
    spell.active.batch.max_batch = math.max(\
      spell.active.batch.max_batch,\
      batch.size\
    );\
  end\
  \
  function spell.syncronization(copies, delay)\
    local sync_index = 1 + #spell.active.sync;\
    local sync = {};\
    sync.copies = -1 + math.tointeger(tonumber(copies));\
    sync.delay = 0.0 + tonumber(delay);\
    spell.active.sync[sync_index] = sync;\
    spell.precision.sync = math.max(\
      spell.precision.sync,\
      #tostring(sync.copies)\
    );\
  end\
  \
  function spell.add_spell(name, attribute, coord_x, coord_y, timer)\
    local actives_index = 1 + #spell.active;\
    if debug.can_halt > 0 then\
      if debug.can_halt > debug.should_halt then\
        return;\
      end\
    end\
    local new_spell = {};\
    new_spell.name = name .. spell.text.text_ending_character;\
    new_spell.attribute = attribute:gsub(" ", "");\
    new_spell.coord_x = 0.0 + tonumber(coord_x);\
    new_spell.coord_y = 0.0 + tonumber(coord_y);\
    \
    new_spell.sync = 0;\
    local sync = spell.active.sync;\
    local function add_sync()\
      --[[/*\
          * Function to handle the sync system\
          * if we've run through the internal copies\
          *   if the next sync exists\
          *     increment the index\
          *     update our internal copies\
          *     add a sync to the spell\
          *   setup so we only have 1 return\
          *   1 return means only 1 logic sequence\
          *   to follow\
          * we can continue\
          * by increasing the delay and\
          * decreasing our internal copies\
         */]]\
      if sync.copies_internal == 0 then\
        if #sync > sync.index then\
          sync.index = sync.index + 1;\
          sync.copies_internal = sync[sync.index].copies;\
          new_spell.sync = sync[sync.index].copies;\
        end\
        sync.copies_internal = sync.copies_internal + 1;\
        sync.delay_internal = 0.0 - sync[sync.index].delay;\
      end\
      sync.delay_internal = sync.delay_internal + sync[sync.index].delay;\
      sync.copies_internal = sync.copies_internal - 1;\
      return sync.delay_internal;\
    end\
    \
    local sync_offset = add_sync();\
    new_spell.timer = sync_offset + tonumber(timer);\
    spell.active[actives_index] = new_spell;\
    \
    spell.text.name_max_size = math.max(\
      spell.text.name_max_length,\
      #new_spell.name\
    );\
    spell.text.attribute_max_size = math.max(\
      spell.text.attribute_max_length,\
      #new_spell.attribute\
    );\
    spell.precision.placement = math.max(\
      spell.precision.placement,\
      #tostring(math.max(new_spell.coord_x, new_spell.coord_y)) - 1\
    );\
    spell.precision.timer = math.max(\
      spell.precision.timer,\
      #tostring(new_spell.timer) - 1\
    );\
  \
    local active_length = spell.precision.timer;\
    active_length = active_length + spell.precision.sync;\
    active_length = active_length + spell.precision.placement;\
    active_length = active_length + spell.precision.placement;\
    active_length = active_length + spell.text.attribute_max_length;\
    active_length = active_length + spell.text.name_max_length;\
  \
    spell.active_max_length = math.max(\
      spell.active_max_length,\
      active_length\
    );\
    local debug_check = debug.can_halt;\
    debug_check = debug_check + debug.can_log;\
    if debug_check > 0 then\
      debug.log();\
    end\
    local halt_limit = debug.can_halt - debug.should_halt;\
    if debug.can_halt > 0 then\
      if halt_limit > 0 then\
        return debug.halt();\
      end\
      debug.should_halt = debug.should_halt - 1;\
    end\
    local constant_int = "spell." .. actives_index;\
    local spell_name = [[']] .. new_spell.name .. [[']];\
    return [[:const string ]] .. constant_int .. [[ ]] .. spell_name;\
  end\
  \
  function spell.concat_actives()\
    if debug.print > 0 then\
      return;\
    end\
    debug.print = debug.print + 1;\
    local spells = {};\
  \
    local recordings = spell.active;\
    local active_count = #spell.active;\
  \
    spell.add_batch();\
    local batches = spell.active.batch;\
    local batch_index = 1;\
    local batch_concat = '';\
    local index = 0;\
  \
    local spells_debug = {};\
    local last_log = debug.can_log;\
    last_log = last_log + debug.can_halt;\
    if last_log > 0 then\
      debug.log()\
    end\
    spells_debug.format = '';\
    spells_debug.spacer_open = '';\
    spells_debug.spacer_close = '';\
    spells_debug.chunk = '';\
  \
    local spells_format = {};\
    spells_format.encase = 0;\
    spells_format.batch = 0;\
    spells_format.chunk = 0;\
    \
    \
    local debug_text = debug.text.concat_in_batch;\
    debug_text = debug_text + debug.text.can_concat;\
    local debug_batch = debug_text + debug.text.batch_in_number;\
    if debug_text > 0 then\
      spells_debug.spacer_open = debug.text.spacer_open;\
    \
      if debug_text == debug.text.concat_in_batch then\
        batch_concat = debug.text.concat_format;\
        spells_format.batch = 1;\
      else\
        spells_debug.format = debug.text.concat_format;\
        spells_debug.chunk = debug.text.chunk;\
      end\
    \
      spells_debug.spacer_close = debug.text.spacer_close;\
    end\
  \
  \
      --[[/*\
          * Sequence for concatenation\
          * It will get broken up into separate\
          * local functions\
          * This is done to add implementation flexibility\
          * and to improve overall readability\
         */]]\
  \
    local function concat_format()\
        --[[/*\
            * Function that formats the\
            * contents of spells according\
            * to the spells_format values\
           */]]\
      local printer = {};\
      local spells_pos = 1 + #spells;\
      printer[1 + #printer] = spells_debug.format;\
      \
      local fmt = spells_format;\
      if fmt.batch == 1 then\
        printer[1 + #printer] = batch_concat;\
      end\
      if fmt.encase == 1 then\
        spells_pos = #spells;\
        local sequence = spells[#spells];\
        printer[1 + #printer] = spells_debug.spacer_open;\
        printer[1 + #printer] = sequence;\
        printer[1 + #printer] = spells_debug.spacer_close;\
      end\
      if fmt.chunk == 1 then\
        printer[1 + #printer] = spells_debug.format;\
        printer[1 + #printer] = spells_debug.chunk;\
      end\
      \
      fmt.batch = 0;\
      fmt.encase = 0;\
      fmt.chunk = 0;\
      spells[spells_pos] = table.concat(printer);\
    end\
    local function number_handling()\
        --[[/*\
            * Function that handles numbers\
            * called by the for loop\
            * actions performed in functions\
            * for a clean and easy to understand\
            * sequence\
           */]]\
      \
      if debug_batch > 0 then\
        spells_format.encase = 1;\
        spells[1 + #spells] = x_digit_precision(\
          #tostring(#recordings),\
          math.tointeger(index)\
        );\
        concat_format();\
      end\
      concat_format();\
      spells[1 + #spells] = x_digit_precision(\
        spell.precision.sync,\
        recordings[index].sync\
      );\
      concat_format();\
      spells[1 + #spells] = x_digit_precision(\
        spell.precision.timer,\
        recordings[index].timer\
      );\
      concat_format();\
      spells[1 + #spells] = x_digit_precision(\
        spell.precision.placement,\
        recordings[index].coord_x\
      );\
      concat_format();\
      spells[1 + #spells] = x_digit_precision(\
        spell.precision.placement,\
        recordings[index].coord_y\
      );\
    end\
    local function text_handling()\
        --[[/*\
            * Function to handle all text inputs\
            * featuring an internal function spacing()\
            * that returns a spacing string\
            * This is done to keep spacing consistent\
            * since spacing is so important, all actions get\
            * filtered down through it\
           */]]\
      local spells_text = '';\
    \
      local function spacing(max_size)\
        local spacing_size = max_size - #spells_text;\
        local space = string.rep('.', spacing_size);\
        return space;\
      end\
    \
      spells_text = recordings[index].attribute;\
      concat_format();\
      spells[1 + #spells] = spells_text;\
      spells[1 + #spells] = spacing(spell.text.attribute_max_size);\
      spells_format.encase = 1;\
      concat_format();\
    \
      spells_text = recordings[index].name;\
      concat_format();\
      spells[1 + #spells] = spells_text;\
      spells[1 + #spells] = spacing(spell.text.name_max_size);\
      spells_format.encase = 1;\
      concat_format();\
    end\
    local function batch_handling()\
        --[[/*\
            * Function that handles batch\
            * creation and formatting\
           */]]\
      local batch = batches.max_batch;\
      batch = batch - batches[batch_index].size;\
      if batches[batch_index].checkpoint ~= index then\
        batch = 0;\
      end\
      batch = batch * spell.active_max_length;\
      local spacer = string.rep('.', batch);\
      if debug.text.batch_in_number > 0 then\
        spacer = batch;\
      end\
      if debug_batch > 0 then\
        spells_format.encase = 1;\
      end\
      spells[1 + #spells] = spacer;\
      if #batches > batch_index then\
        if index == batches[batch_index].checkpoint then\
          batch_index = batch_index + 1;\
          spells_format.batch = 1;\
        end\
      end\
    end\
  \
    while index < active_count do\
      index = index + 1;\
      number_handling();\
      text_handling();\
      batch_handling();\
      spells_format.chunk = debug.text.can_concat;\
      concat_format();\
    end\
    concat_format();\
    return table.concat(spells);\
  end\
)}

#add_batch {lua(return spell.add_batch())}

#syncronize(copies, delay) {lua(return spell.syncronization(\
  [[{copies}]],\
  [[{delay}]]\
))}

#add_spell(name, attribute, placement_x, placement_y, timer) {lua(\
  return spell.add_spell(\
    {name},\
    {attribute},\
    [[{placement_x}]],\
    [[{placement_y}]],\
    [[{timer}]]\
  );\
)}

#add_spell.instant(name, timer) {add_spell(\
  '{name}',\
  'instant',\
  0.0,\
  0.0,\
  {timer}\
)}

#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\
  '{name}',\
  'grounded',\
  {coord_x},\
  {coord_y},\
  {timer}\
)}

