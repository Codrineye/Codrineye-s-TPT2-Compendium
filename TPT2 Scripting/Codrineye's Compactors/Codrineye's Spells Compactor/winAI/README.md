# winAI


```
{"workspaces":{"winAI":[["Spell Config winAI",":import Cods Spell Compactor\n\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; The following macros let you communicate\n; with the debugger\n; spell_debug.log permits logging to the console\n; \n; spell_debug.halt_compilation signals to the\n; compactor that compilation should halt eventually\n; \n; spell_debug.recordings_before_halt is the amount\n; of spells you can add before compilation halts\n; this value has no effect if you haven't signaled\n; to the compactor that compilation should halt eventually\n; \n; spell_debug.display_spells tells the debugger to\n; display the spells you added\n; \n; spell_debug.display_spacers_as_numbers is a\n; field that converts all spacers into the amount of\n; space they would have added, this improves visibility\n; when debugging the output\n; \n; spell_debug.display_spells_in_batch signals the\n; compactor to display your spells, but to only add\n; a separator at the start of a new batch \n; \n; spell_debug.display_format is a string that\n; acts as a separtor for inputs\n; the string you input in this field will be\n; at the beginning of every recorded field\n; this only applies if you want to display the output\n; \n\n{spell_debug.log(0)}\n{spell_debug.halt_compilation(0)}\n{spell_debug.recordings_before_halt(2)}\n{spell_debug.display_spells(0)}\n{spell_debug.display_spacers_as_numbers(0)}\n{spell_debug.display_spells_in_batch(0)}\n{spell_debug.display_format('\\n|')}\n\n; \n; Time for the actual recording\n; you have 4 functions at your disposal\n; \n; add_spell.instant()\n; this takes in 2 parameters \n; * the name of the spell, this can be obtained by\n;   simply importing a script that uses all the modules you want\n; * the timer for the spell, being the amount of time you want\n;   to pass before activation\n; \n; add_spell.grounded()\n; this takes in 4 parameters\n; * the name, just like in add_spell.instant()\n; * the timer, just like in add_spell.instant()\n; * the x position of where you want to cast the spell\n; * the y position of where you want to cast the spell\n; \n; blueprint AI's usually use winemast for the timer t\n; the timer is the value of `t` at the time of activation\n; \n; syncronize()\n; this takes in 2 parameters\n; * the number of modules you want to activate at once\n; * a potential delay you may want to add to the spell timers\n; \n; add_batch()\n; this takes in 0 parameters\n; it defines a batch chunk, meaning a separation\n; between one spell sequence and another\n; \n; I do not recommend defining a grounded module as an instant module\n; nor vice versa the system will accept your input\n; but you will cast the grounded module at position 0.0\n; \n\n{syncronize(2, 0.0)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{syncronize(4, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize(6, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize(5, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; \n; This marks the end of spell configuration\n; we now have a macro spell_debug\n; this is in charge of outputing debugging data\n; and prevents the output string from being read\n; when its contents are modified for displaying\n; \n\n{spell_debug}\n\n; \n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file\n; rather than copy them\n; Putting the const declaration here is\n; also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n; \n\n:const string actives '{lua(return spell.concat_actives())}'\n:const string text_end_character '{lua(return spell.text.text_ending_character)}'\n:const int spells_count {lua(return #spell.active)}\n:const int spell_size {lua(return spell.active_max_length)}\n\n:const int sync_precision {lua(return spell.precision.sync)}\n:const int time_precision {lua(return 2 + spell.precision.timer)}\n:const int placement_precision {lua(return 2 + spell.precision.placement)}\n\n"],["winAI_lib",":import Spell Config winAI\n:import Spell Compactor resources\n; Consistent naming across scripts\n#package(name) winAI:{name}\n#compactor_type \"external\"\n\n; A package identifier used within\n; the names of global variables for a unique value\n#identifier \"winAI\"\n"],["init",":import winAI_lib\n:name {package(init)}\n\ngame.newround()\n\nglobal.int.set({pointer}, 0)\nuseinstant(active.index(\"barrier.temporal\"))\n\n{precision_count.set(spells_count)}\n\n{spells_size.set(spell_size)}\n\n{precision_sync.set(sync_precision)}\n{precision_timer.set(time_precision)}\n{precision_placement.set(placement_precision)}\n\n{text_ending_character.set(text_end_character)}\n{active_spells.set(actives)}\n\nstop(\"{package(3spam)}\")\nexecute(\"{package(3spam)}\")\n"],["inf",":import winAI_lib\n:name {package(inf)}\n\nupgrade.era(\"health\", 42069)\ngotoif(0, xp() < disable.inf.cost())\n\ndisable.inf(\"aura.death\")\ndisable.inf(\"reflect.wince\")\ndisable.inf(\"reflect.captain\")\ndisable.inf(\"barrier.temporal\")\ndisable.inf(\"spell.void\")\ndisable.inf(\"spell.snapOfDestiny\")\ndisable.inf(\"spell.response.neutral\")\n\ngoto(0)\n"],["3spam",":import winAI_lib\n:name {package(3spam)}\n\nuseinstant(active.index(\"barrier.temporal\"))\n\nstop(\"{package(inf)}\")\nexecute(\"{package(inf)}\")\n\nexecutesync(\"{spell_compactor_package(main)}\")\n\nuseinstant(active.index(\"crate.rex\"))\n\nwaituntil({timer.get} >= 2.0)\n\nspam:\nwait(0.2)\nuseinstant(active.index(\"spell.response.neutral\"))\ngoto(spam)\n"],["era",":import winAI_lib\n:name {package(era)}\n\nwakeup()\n\n:const int element_length 12\n\n:const string element1 'light;......'\n:const string element2 'darkness;...'\n:const string element3 'nature;.....'\n:const string element4 'electricity;'\n:const string element5 'universal;..'\n:const string element6 'fire;.......'\n:const string element7 'neutral;....'\n:const string element8 'water;......'\n:const string element9 'earth;......'\n\n:local string element_name\n:local int index\n\n#elements_list element1 . element2 . element3 . element4 . element5 . element6 . element7 . element8 . element9\n\nera:\nelement_name = sub({elements_list}, index, index({elements_list}, \";\", index) - index)\n\nloop:\ndisable.era(element_name)\n\ngotoif(loop, disable.cost(element_name) > 0.0)\nindex = index + element_length\ngotoif(era, contains(sub({elements_list}, index, element_length), \";\"))\n"]]}}
```


# Import Code
Requirements:
- impulse: 1
- conditions: 0
- actions: 11
- scripts: 4


```
1VjLbuM2FP2VjNCu6uFIdjyZOo7bot10NYuiqzowaOpKIkKRAnkVOx0M0G0/obOeL0l/rCBlOYpE2XLcKVAHEGzp8L4fR/kQGKZ5gSaY/fYhoAy5kvZ7sCzDMIRUqDUVhEskBnC5ZkoapBLd08uv5ob/DjfhYi64hNcZ8DTDm/DrRaG4RNAbLn/4uXVo7K5h9xqMnM7oCtUGNMlVXAogpQH+dDp6l9Ic6mfW2nsgXMawbZvm0OGaas1BE4S8UJqKnY5jfrnDMWwRtKTiotDAuOFKMlVKvOj1Kop7vRqkke41mgKEMCsbXb+6V+dpYl3fzINk/a6F0XkKPcFEnoM+oHH6Yo2vusoKQRnkcCh7BxRG0U6hQc1l6m2FvU6ELa5AxlymK5ZRTRn2+HlZRXY2XEsreVUDrKpq8at4/GOJUUisM/tLuytmxH3CFsyJJYlQKtkh3KctrYJpMIWSBoiEEq1Mv7R7xeOmMKt0GobRmNh2JTXMqBww4zKtsZPIJ81IWrxPfgKDXD5YaOiFabB5SGGv2A9jSomGyho2tZdo2m+bM35AQLywbkAmgzydjt+RIQHxwjQkGkzW8LQH1o5bC9ZXSF5pnULywzouRONvPbBusrwwjws+mCcLti6PluVlVZdHs+CFdW3rgbWT1YL1ZcHBjlZvOJkMcmF6NQQ2f9NgAov5G7vBFna+JSlI0JwRg6rwzsG1m1+ziSloXg/6/SnYAisRjh+8HQVMyZjXPOZ2FPC8KIUBx2ocfZCw0aqUsQVLmkMwC7jkGIyCgrI7mtobTmbwcdThRFHoZJRFqmkMBDT1GvU2Ayoway+aXx8/+xfazs9UoeLJUMpUbQ2m8oJqbpQksSrXApZYCPoAmmz9kY7mFdFqcikDrNRAmDJYr6Nx93lHnKSlpiQGitkpx7SGRABDsuGSwSknXVXUpxktkHJ54vleWjjM46eJcareiadpTpXx1r9dnrWYLaLBrPtwwzQ7JBnYIF+awB8eJVhNg8rcYUOkcySatI5Ycuw18PIXm46LH20LMlR6ljfq8V8KBDJNEYiG7RNR3Jm3oRxLiVz0TYImraxukdRPK8PIf3u8uGndnxwaR8+v3z/Ll7W2Levx0+Nf9d/ff373BV4Cz+qYqzM6pt5kg5aKUOww809AuBeYlZW+RFOuK3AbKIRdvdfVco+pvpNgjP0pKZYaqgdgx6fmjOPDdSn5PWhDxTUhCa8RpI6T+7mhCHr3AKjGbPd9qSu77YtYX11Nq9S4NUc1xywH5Mweqe7tfHao9+3V9x+74+2L6xO89Ap4PVxAXf8VyYi5obZlLcnoVolP0rMqOYVd9CyIvpkybdvnmMNLjPSHbPHymfPErBpR73mXPlScZyb9m06YE7+VQzPk+Q9Mtd52kWZKWjJk/oezYUCkelrzGN/f0DsoiwbRB019I/n24z8=
```
