:import Blueprint Compactor lib
:name {blueprint_compactor}

:budget_cap max

gotoif(\
  if({timer.get} == 0.0, start_timer, start_secures), \
  contains(impulse(), "{blueprint_compactor}")\
)

local.int.set(pointer_var_str, {pointer.get})
local.string.set(actives, {comp_active.get})
; We use local variables to prevent a messy interface
; And to let the user have more instances
; of the compactor running at the same time

{caller.set(if(\
  contains(impulse(), ":"), \
  sub(impulse(), 0, index(impulse(), ":", 0)),\
  impulse()\
))}

execute("{blueprint_compactor}")
; We also set the caller so that the user knows
; how the compactor got accessed
; 
; This will typically only have 1 value, but if
; it has a name that you don't expect, it should tell the
; user that there's another script that uses the compactor
; which they might want to shut down

assign_base:
local.double.set(timer_base, {get_base})
local.bool.set(timer_base_detector,\
  index(local.string.get(actives), "|", local.int.get(pointer_var_str))\
  == local.int.get(pointer_var) + 3\
)

loop:
; Since getting the timer and spell_ID are resource intensive operations
; whose values are called more than once, we calculate then here
local.string.set(spell_ID, {get_name})
local.double.set(clock, {get_timer})
; 
waituntil({modulo_timer} <= local.double.get(clock))
; 
; We use both instant and grounded spells here because we
; don't actually know what spell we're casting, just that we
; have to cast one with the given parameters
useinstant(active.index(local.string.get(spell_ID)))
useposition(active.index(local.string.get(spell_ID)), {get_pos})

; If we're activating multiple spells through synchronization
; this checks if we skip refreshing the budget (signaled with an `s`)
gotoif(no_frame, contains({get_bits}, "s"))
waitframe()

no_frame:

{pointer.increment}
; We add to our pointer the size of our spell

#end_of_compactor contains(\
  "", \
  sub(\
    local.string.get(actives),\
    local.int.get(pointer_var_str),\
    10\
  )\
)

; when we initialize our compactor, we add the ending bit "e" as the
; last character in our string. This e is used to check
; if we've ended our string (aka, haven't looped)
; 
; We also take a substring of size 10 and compare it with a string
; of size 1 so it can only return true if we truely are at the end
; of our string

goto(if({end_of_compactor}, end_instance, if(\
  health(false) <= 0.0, \
  idle,\
  if(lbg(timer_base_detector), loop, assign_base)\
)))
; We terminate the program if we reach the end of the string
; This doesn't enter idle mode, as it's possible that the user might
; want to send another blueprint over our way. In that case, if we
; did enter idle mode, the timer would've stopped, de-synchronizing things

start_timer:
{timer.set(time.delta() * 2.0)}
execute("{blueprint_compactor}")

timer:
waitframe()
{timer.add(time.delta())}
goto(if(contains({caller.get}, "idle mode"), end, timer))
; The timer will always run, even if the compactor shuts down
; the only way to stop the timer is by calling the compactor, again
; outside of towertesting or by stopping all instances of the compactor

start_secures:
:local double i
i = 1.0
local.string.set(secures, {comp_secure.get})

loop_secures:
disable.inf(sub(\
  local.string.get(secures), \
  local.int.get(pointer_var_str), \
  index(\
    local.string.get(secures), \
    "|", \
    local.int.get(pointer_var_str)\
  ) - local.int.get(pointer_var_str)\
))
waitframe()
local.int.set(pointer_var_str, if(\
  disable.inf.cost() <= 1e3 ^ i, \
  local.int.get(pointer_var_str), \
  index(\
    local.string.get(secures), \
    "|", \
    local.int.get(pointer_var_str)\
  )\
))
i = if(disable.inf.cost() > 1000.0 ^ i, i + 1.0, i)
goto(if(\
  contains({caller.get}, "idle") || index(\
    local.string.get(secures), \
    "|", \
    local.int.get(pointer_var_str)\
  ) == -1, \
  end_instance, \
  loop_secures\
))

end:
{timer.set(0.0)}
; The timer should be reset when the compactor enters idle mode
; 
idle:
{caller.set("idle mode")}

end_instance: