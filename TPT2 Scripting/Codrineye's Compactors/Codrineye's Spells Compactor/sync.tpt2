:import Spell Compactor lib
:name {package(sync)}

; sync + timer + coord_x + coord_y + name

#actives.displace(sync, timer, positions) position + (\
  {sync} * {sync_precision.get} + \
  {timer} * {time_precision.get} + \
  {positions} * {placement_precision.get}\
)

#actives.substring(sync, timer, positions, length) sub(\
  {actives},\
  {actives.displace({sync}, {timer}, {positions})},\
  {length}\
)

#actives.index(sync, timer, positions) index(\
  {actives},\
  {text_end_character},\
  {actives.displace({sync}, {timer}, {positions})}\
) - ({actives.displace({sync}, {timer}, {positions})})

:const string sync_needed '{lua(return string.rep("0", 50))}'
:const double threshold 50.0

:local int position
:local int syncronize_copies
:local bool copy_activator
:local double timer

copy_activator = contains(impulse(), "{package(sync)}")

check:
position = {pointer.get}
gotoif(\
  if(copy_activator, skip, syncronize),\
  not(contains(\
    sync_needed, \
    {actives.substring(0, 0, 0, {sync_precision.get})}\
  ))\
)

skip:
timer = s2d(\
  {actives.substring(1, 0, 0, {time_precision.get})},\
  0.0\
)
waitwhile({timer.get} % timer > threshold && {timer.get} < timer)
useinstant(active.index(\
  {actives.substring(\
    1, 1, 2, \
    {actives.index(1, 1, 2)}\
  )}\
))
useposition(\
  active.index(\
    {actives.substring(\
      1, 1, 2, \
      {actives.index(1, 1, 2)}\
    )}\
  ), vec(\
    s2d({actives.substring(1, 1, 0, {placement_precision.get})}, 0.0),\
    s2d({actives.substring(1, 1, 1, {placement_precision.get})}, 0.0)\
  )\
)
gotoif(check, not(copy_activator))

syncronize:
syncronize_copies = s2i(\
  {actives.substring(0, 0, 0, {sync_precision.get})},\
  0\
)

copy:
execute("{package(sync)}")
goto(if(syncronize_copies < 0, check, copy))
