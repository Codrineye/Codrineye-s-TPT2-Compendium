:name lua madness but better
; at least, I hope so XD
; 
; 
; Original global declaration:
; |-------------------------|
; debugging = false;\
; spell = {};\
; spell.active_module = {};\
; spell.active_module.module_instance = {};\
; spell.active_module.placement_positions = {};\
; spell.active_module.syncronization = {};\
; spell.sync_delay = 0.0;\
; spell.sync_precision = 2;\
; spell.timer_precision = 6;\
; spell.placement_precision = 4;\
; spell.attribute_size = 8;\
; spell.max_name_size = 0;\
; spell.batch = {};\
; spell.batch_instance = 1;\
; spell.batch_max_size = 0;\
; |----------------------|
; 
; enable debugging in Spell Debugging
; 
{lua( \
  spell = {};\
  spell.debugging = {};\
  spell.debugging.log = 0;\
  spell.debugging.can_halt = 0;\
  spell.debugging.halt_after = 1;\
  spell.active = {};\
  spell.active.sync = {};\
  spell.active.sync.index = 0;\
  spell.active.sync.copies_internal = 0;\
  spell.active.sync.delay_internal = 0;\
  spell.active_max_length = 0;\
  spell.text = {};\
  spell.text.name_max_length = 0;\
  spell.text.attribute_max_length = 0;\
  spell.text.text_ending_character = '|';\
  spell.text.debugging = 0;\
  spell.text.debugging_separator = '\n|';\
  spell.precision = {};\
  spell.precision.sync = 0;\
  spell.precision.timer = 0;\
  spell.precision.placement = 0;\
)}

{lua(\
  local function x_digit_precision(digits, input)\
    local number = tostring(input):gsub(" ", ""):gsub("'", "");\
    return string.sub(\
      string.format("%." .. digits .. "f", number),\
      1,\
      digits + 2\
    );\
  end\
  local function text_formatting(input)\
    local text = input:gsub(" ", ""):gsub("'", "");\
    return text .. spell.text.text_ending_character;\
  end\
  local function debugging()\
    print(\
      "Spell Name =", spell.active[#spell.active].name, "\n",\
      "And is of type", type(spell.active[#spell.active].name)\
    );\
    print(\
      "Spell Name Size =", #spell.active[#spell.active].name, "\n",\
      "Max Name Size =", spell.text.name_max_length\
    );\
    print(\
      "Spell Attribute =", spell.active[#spell.active].attribute, "\n",\
      "And is of type", type(spell.active[#spell.active].attribute)\
    );\
    print(\
      "Spell Attribute Size =", #spell.active[#spell.active].attribute,\
      "\n", "Max Attribute Size =", spell.text.attribute_max_length\
    );\
    print(\
      "Spell coord_x =", spell.active[#spell.active].coord_x, "\n",\
      "And is of type", type(spell.active[#spell.active].coord_x), "\n",\
      "Should be a number, of type float, and such", "\n",\
      "And is a number of type", math.type(spell.active[#spell.active].coord_x)\
    );\
    print(\
      "Spell coord_y =", spell.active[#spell.active].coord_y, "\n",\
      "And is of type", type(spell.active[#spell.active].coord_y), "\n",\
      "Should be a number, of type float, and such", "\n",\
      "And is a number of type", math.type(spell.active[#spell.active].coord_y)\
    );\
    print(\
      "Spell Max Coord Size =", -1 + #tostring(math.max(\
        spell.active[#spell.active].coord_x, \
        spell.active[#spell.active].coord_y\
      )), "\n",\
      "Coord Precision =", spell.precision.placement\
    );\
    print(\
      "Spell timer = ", spell.active[#spell.active].timer, "\n",\
      "And is of type", type(spell.active[#spell.active].timer), "\n",\
      "Should be a number, of type float, and such", "\n",\
      "And is a number of type", math.type(spell.active[#spell.active].timer)\
    );\
    print(\
      "Spell Timer Size =", -1 + #tostring(spell.active[#spell.active].timer),\
      "\n", "Timer Precision =", spell.precision.timer\
    );\
    print(\
      "Spell sync = ", spell.active[#spell.active].sync, "\n",\
      "And is of type", type(spell.active[#spell.active].sync), "\n",\
      "Should be a number, of type integer, and such", "\n",\
      "And is a number of type", math.type(spell.active[#spell.active].sync)\
    );\
    print("Spell index =", #spell.active);\
    print("Blocker");\
  end\
\
\
  function spell.syncronization(copies, delay)\
    local sync_index = 1 + #spell.active.sync;\
    local sync = {};\
    sync.copies = -1 + math.tointeger(tonumber(copies));\
    sync.delay = 0.0 + tonumber(delay);\
    spell.active.sync[sync_index] = sync;\
    spell.precision.sync = math.max(\
      spell.precision.sync,\
      #tostring(sync.copies)\
    );\
  end\
  \
  function spell.add_spell(name, attribute, coord_x, coord_y, timer)\
    local actives_index = 1 + #spell.active;\
    local new_spell = {};\
    new_spell.name = text_formatting(name);\
    new_spell.attribute = attribute:gsub(" ", "");\
    new_spell.coord_x = 0.0 + tonumber(coord_x);\
    new_spell.coord_y = 0.0 + tonumber(coord_y);\
    \
    new_spell.sync = 0;\
    local sync = spell.active.sync;\
    local function add_sync()\
      --[[/*\
         * Function to handle the sync system\
         * \
         */]]\
      if sync.copies_internal == 0 and sync[1 + sync.index] ~= nil then\
        sync.index = sync.index + 1;\
        sync.delay_internal = 0.0;\
        sync.copies_internal = sync[sync.index].copies;\
        new_spell.sync = sync.copies_internal;\
        return sync.delay_internal;\
      end\
      sync.delay_internal = sync.delay_internal + sync[sync.index].delay;\
      sync.copies_internal = sync.copies_internal - 1;\
      return sync.delay_internal;\
    end\
    local sync_offset = 0.0;\
    if sync[sync.index] ~= nil then\
      sync_offset = add_sync();\
    end\
    new_spell.timer = sync_offset + tonumber(timer);\
    \
    spell.active[actives_index] = new_spell;\
    if spell.debugging.log + spell.debugging.can_halt > 0 then\
      debugging();\
      if spell.debugging.can_halt > spell.debugging.halt_after then\
        return "Debugging Enabled, compilation stopped \n" .. \
          "check the dev-console in your browser";\
      end\
      spell.debugging.halt_after = spell.debugging.halt_after - 1;\
    end\
    spell.text.name_max_size = math.max(\
      spell.text.name_max_length,\
      #new_spell.name\
    );\
    spell.text.attribute_max_size = math.max(\
      spell.text.attribute_max_length,\
      #new_spell.attribute\
    );\
    spell.precision.placement = math.max(\
      spell.precision.placement,\
      -1 + #tostring(math.max(new_spell.coord_x, new_spell.coord_y))\
    );\
    spell.precision.timer = math.max(\
      spell.precision.timer,\
      -1 + #tostring(new_spell.timer)\
    );\
    local constant_int = "spell." .. actives_index;\
    local spell_name = [[']] .. new_spell.name .. [[']];\
    return [[:const string ]] .. constant_int .. [[ ]] .. spell_name;\
  end\
  \
  function spell.concat_actives()\
    local active_count = #spell.active;\
    local index = 0;\
    local spells = {};\
    local recordings = spell.active;\
    local spells_debugging = '';\
    if spell.text.debugging > 0 then\
      spells_debugging = spell.text.debugging_separator;\
    end\
  \
      --[[/*\
        * Sequence for concatenation\
        * It will get broken up into separate\
        * local functions\
        * This is done to add implementation flexibility\
       */]]\
  \
    local function number_handling()\
        --[[/*\
          * Function that handles numbers\
          * called by the for loop\
          * actions performed outside the for loop\
          * for a clean and easy to understand\
          * sequence\
         */]]\
      local function spells_number_formatting(digits, input)\
        return spells_debugging .. x_digit_precision(digits, input);\
      end\
      \
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.sync,\
        recordings[index].sync\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.timer,\
        recordings[index].timer\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.placement,\
        recordings[index].coord_x\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.placement,\
        recordings[index].coord_y\
      );\
    end\
    local function text_handling()\
        --[[/*\
          * Function to handle all text inputs\
          * featuring an internal function spacing()\
          * that returns a spacing string\
          * This is done to keep spacing consistent\
          * since spacing is so important, all actions get\
          * filtered down through this\
         */]]\
      local spells_text = '';\
      local function spells_text_formatting(text)\
         return spells_debugging .. text;\
      end\
      local function spacing(max_size)\
        local spacing_size = max_size - #spells_text;\
        local spacer = string.rep('.', spacing_size);\
        return spells_text_formatting(spacer);\
      end\
    \
      spells_text = recordings[index].attribute;\
      spells[1 + #spells] = spells_text_formatting(spells_text);\
      spells[1 + #spells] = spacing(spell.text.attribute_max_size);\
    \
      spells_text = recordings[index].name;\
      spells[1 + #spells] = spells_text_formatting(spells_text);\
      spells[1 + #spells] = spacing(spell.text.name_max_size);\
    end\
  \
    while index < active_count do\
      index = index + 1;\
      number_handling();\
      text_handling();\
      spells[1 + #spells] = spells_debugging;\
    end\
    return table.concat(spells);\
  end\
)}

#add_spell(name, attribute, placement_x, placement_y, timer) {lua(\
  return spell.add_spell(\
    {name},\
    {attribute},\
    [[{placement_x}]],\
    [[{placement_y}]],\
    [[{timer}]]\
  );\
)}

#add_spell.instant(name, timer) {add_spell(\
  '{name}',\
  'instant',\
  0.0,\
  0.0,\
  {timer}\
)}

#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\
  '{name}',\
  'grounded',\
  {coord_x},\
  {coord_y},\
  {timer}\
)}

#syncronize(copies, delay) {lua(return spell.syncronization(\
  [[{copies}]],\
  [[{delay}]]\
))}

; concat names =>
; sync + timer + x_pos + y_pos + type + name

{syncronize(3, 1)}
{add_spell.instant(a, 0)}
{add_spell.grounded(b, 0, 0, 0)}

#spells_concat {lua(return spell.concat_actives())}
":const string spells '{spells_concat}'
