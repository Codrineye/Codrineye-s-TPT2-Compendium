:name lua madness but better
; at least, I hope so XD
; 
; 
; Original global declaration:
; |-------------------------|
; debugging = false;\
; spell = {};\
; spell.active_module = {};\
; spell.active_module.module_instance = {};\
; spell.active_module.placement_positions = {};\
; spell.active_module.syncronization = {};\
; spell.sync_delay = 0.0;\
; spell.sync_precision = 2;\
; spell.timer_precision = 6;\
; spell.placement_precision = 4;\
; spell.attribute_size = 8;\
; spell.max_name_size = 0;\
; spell.batch = {};\
; spell.batch_instance = 1;\
; spell.batch_max_size = 0;\
; |----------------------|
; 
; 

{lua(\
  spell = {};\
  spell.active = {};\
  spell.active.batch = {};\
  spell.active.batch.max_batch = 0;\
  spell.active.sync = {};\
  spell.active.sync.index = 0;\
  spell.active.sync.copies_internal = 0;\
  spell.active.sync.delay_internal = 0;\
  spell.active_max_length = 0;\
  spell.text = {};\
  spell.text.name_max_length = 0;\
  spell.text.attribute_max_length = 0;\
  spell.text.text_ending_character = ':';\
  spell.precision = {};\
  spell.precision.sync = 0;\
  spell.precision.timer = 0;\
  spell.precision.placement = 0;\
)}

{lua(\
  local function x_digit_precision(digits, input)\
    local number = tostring(input):gsub(" ", ""):gsub("'", "");\
    local format = "%.";\
    if math.type(tonumber(number)) == 'integer' then\
      format = "%0"; \
    end\
    return string.sub(\
      string.format(format .. digits .. "f", number),\
      1,\
      digits + 2\
    );\
  end\
  \
  local function text_formatting(input)\
    local text = input:gsub(" ", ""):gsub("'", "");\
    return text .. spell.text.text_ending_character;\
  end\
\
\
  function spell.add_batch()\
    local batch_index = 1 + #spell.active.batch;\
    local batch = {};\
    batch.checkpoint = #spell.active;\
    batch.size = 0;\
    if spell.active.batch[batch_index - 1] ~= nil then\
      batch.size = batch.checkpoint - spell.active.batch[batch_index - 1].checkpoint;\
    end\
    spell.active.batch[batch_index] = batch;\
    spell.active.batch.max_batch = math.max(\
      spell.active.batch.max_batch,\
      batch.size\
    );\
  end\
  \
  function spell.syncronization(copies, delay)\
    local sync_index = 1 + #spell.active.sync;\
    local sync = {};\
    sync.copies = -1 + math.tointeger(tonumber(copies));\
    sync.delay = 0.0 + tonumber(delay);\
    spell.active.sync[sync_index] = sync;\
    spell.precision.sync = math.max(\
      spell.precision.sync,\
      #tostring(sync.copies)\
    );\
  end\
  \
  function spell.add_spell(name, attribute, coord_x, coord_y, timer)\
    local actives_index = 1 + #spell.active;\
    local new_spell = {};\
    if debug.can_halt > 0 then\
      if debug.can_halt > debug.should_halt then\
        return;\
      end\
    end\
    new_spell.name = text_formatting(name);\
    new_spell.attribute = attribute:gsub(" ", "");\
    new_spell.coord_x = 0.0 + tonumber(coord_x);\
    new_spell.coord_y = 0.0 + tonumber(coord_y);\
    \
    new_spell.sync = 0;\
    local sync = spell.active.sync;\
    local function add_sync()\
      --[[/*\
         * Function to handle the sync system\
         * if we've run through the internal copies\
         *   if the next index holds a sync\
         *     increment the index and update\
         *     our internal copies\
         *   setup so we only have 1 return\
         *   1 return means only 1 logic sequence\
         *   to follow\
         * we can continue\
         * by increasing the delay and\
         * decreasing our internal copies\
         */]]\
      if sync.copies_internal == 0 then\
        if sync[1 + sync.index] ~= nil then\
          sync.index = sync.index + 1;\
          sync.copies_internal = sync[sync.index].copies;\
          new_spell.sync = sync[sync.index].copies;\
        end\
        sync.copies_internal = sync.copies_internal + 1;\
        sync.delay_internal = 0.0 - sync[sync.index].delay;\
      end\
      sync.delay_internal = sync.delay_internal + sync[sync.index].delay;\
      sync.copies_internal = sync.copies_internal - 1;\
      return sync.delay_internal;\
    end\
    \
    local sync_offset = add_sync();\
    new_spell.timer = sync_offset + tonumber(timer);\
    if #spell.active.batch > 0 then\
      spell.active.batch.max_batch = math.max(\
        spell.active.batch.max_batch,\
        actives_index - spell.active.batch[#spell.active.batch].size\
      );\
    end\
    spell.active[actives_index] = new_spell;\
    local debug_check = debug.can_halt + debug.can_log;\
    if debug_check > 0 then\
      debug.log();\
    end\
    \
    spell.text.name_max_size = math.max(\
      spell.text.name_max_length,\
      #new_spell.name\
    );\
    spell.text.attribute_max_size = math.max(\
      spell.text.attribute_max_length,\
      #new_spell.attribute\
    );\
    spell.precision.placement = math.max(\
      spell.precision.placement,\
      -1 + #tostring(math.max(new_spell.coord_x, new_spell.coord_y))\
    );\
    spell.precision.timer = math.max(\
      spell.precision.timer,\
      #tostring(new_spell.timer) - 1\
    );\
    spell.active_max_length = math.max(\
      spell.active_max_length,\
      spell.precision.timer + spell.precision.sync\
      + 2 * spell.precision.placement + \
      spell.text.attribute_max_length + \
      spell.text.name_max_length\
    );\
    local halt_limit = debug.should_halt;\
    if debug.can_halt > 0 then\
      if debug.can_halt > halt_limit then\
        return debug.halt();\
      end\
      debug.should_halt = halt_limit - 1;\
    end\
    local constant_int = "spell." .. actives_index;\
    local spell_name = [[']] .. new_spell.name .. [[']];\
    return [[:const string ]] .. constant_int .. [[ ]] .. spell_name;\
  end\
  \
  function spell.concat_actives()\
    local active_count = #spell.active;\
    local index = 0;\
    local spells = {};\
    local recordings = spell.active;\
    local batches = spell.active.batch;\
    local batch_index = 1;\
    if #batches > 0 then\
      batch_index = 1;\
    end\
    local batch_concat = '';\
    local spells_debug = {};\
    spells_debug.format = '';\
    spells_debug.spacer_open = '';\
    spells_debug.spacer_close = '';\
    spells_debug.chunk = '';\
    local debug_text = debug.text.can_concat + debug.text.concat_in_batch;\
    if debug_text > 0 then\
      if debug_text == debug.text.concat_in_batch then\
        batch_concat = debug.text.concat_format;\
      else\
        spells_debug.format = debug.text.concat_format;\
        spells_debug.chunk = "Chunk Separation\n";\
      end\
      spells_debug.spacer_open = debug.text.spacer_open;\
      spells_debug.spacer_close = debug.text.spacer_close\
    end\
  \
      --[[/*\
        * Sequence for concatenation\
        * It will get broken up into separate\
        * local functions\
        * This is done to add implementation flexibility\
        * and to improve overall readability\
       */]]\
  \
    local function number_handling()\
        --[[/*\
          * Function that handles numbers\
          * called by the for loop\
          * actions performed outside the for loop\
          * for a clean and easy to understand\
          * sequence\
         */]]\
      local function spells_number_formatting(digits, input)\
        return spells_debug.format .. x_digit_precision(digits, input);\
      end\
      \
      if debug.text.can_concat > 0 then\
        spells[1 + #spells] = spells_number_formatting(\
          #tostring(#recordings),\
          index\
        );\
      end\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.sync,\
        recordings[index].sync\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.timer,\
        recordings[index].timer\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.placement,\
        recordings[index].coord_x\
      );\
      spells[1 + #spells] = spells_number_formatting(\
        spell.precision.placement,\
        recordings[index].coord_y\
      );\
    end\
    local function text_handling()\
        --[[/*\
          * Function to handle all text inputs\
          * featuring an internal function spacing()\
          * that returns a spacing string\
          * This is done to keep spacing consistent\
          * since spacing is so important, all actions get\
          * filtered down through it\
         */]]\
      local spells_text = '';\
    \
      local function spells_text_formatting(text)\
         return spells_debug.format .. text;\
      end\
      local function spacing(max_size)\
        local spacing_size = max_size - #spells_text;\
        local spacer = {};\
        spacer[1 + #spacer] = spells_debug.spacer_open;\
        spacer[1 + #spacer] = string.rep('.', spacing_size);\
        spacer[1 + #spacer] = spells_debug.spacer_close;\
        return spells_text_formatting(table.concat(spacer));\
      end\
      local function space_batch()\
        spells_text = '';\
        local space = 0;\
        local temp_format = spells_debug.format;\
        if index >= batches[batch_index].checkpoint then\
          space = batches.max_batch - batches[batch_index].checkpoint;\
          batches[batch_index].checkpoint = active_count + index;\
          spells_debug.format = temp_format .. batch_concat;\
          if batches[batch_index + 1] ~= nil then\
            batch_index = batch_index + 1;\
          end\
        end\
        spells_text = spacing(space * spell.active_max_length);\
        spells_debug.format = temp_format;\
        return spells_text;\
      end\
    \
      spells_text = recordings[index].attribute;\
      spells[1 + #spells] = spells_text_formatting(spells_text);\
      spells[1 + #spells] = spacing(spell.text.attribute_max_size);\
    \
      spells_text = recordings[index].name;\
      spells[1 + #spells] = spells_text_formatting(spells_text);\
      spells[1 + #spells] = spacing(spell.text.name_max_size);\
    \
      spells[1 + #spells] = space_batch();\
    end\
  \
    while index < active_count do\
      index = index + 1;\
      number_handling();\
      text_handling();\
      spells[1 + #spells] = spells_debug.format .. spells_debug.chunk;\
    end\
    return table.concat(spells);\
  end\
)}

#syncronize(copies, delay) {lua(return spell.syncronization(\
  [[{copies}]],\
  [[{delay}]]\
))}

#add_batch {lua(return spell.add_batch())}

#add_spell(name, attribute, placement_x, placement_y, timer) {lua(\
  return spell.add_spell(\
    {name},\
    {attribute},\
    [[{placement_x}]],\
    [[{placement_y}]],\
    [[{timer}]]\
  );\
)}

#add_spell.instant(name, timer) {add_spell(\
  '{name}',\
  'instant',\
  0.0,\
  0.0,\
  {timer}\
)}

#add_spell.grounded(name, timer, coord_x, coord_y) {add_spell(\
  '{name}',\
  'grounded',\
  {coord_x},\
  {coord_y},\
  {timer}\
)}


; concat names =>
; sync + timer + x_pos + y_pos + type + name

#spells_concat {lua(return spell.concat_actives())}

; Space for convenience

