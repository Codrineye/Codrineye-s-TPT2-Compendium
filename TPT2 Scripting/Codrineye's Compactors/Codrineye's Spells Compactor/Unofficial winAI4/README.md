# winAI

winAI is a blueprint AI made by WootImNoob for the blueprint of the same name.<br>
It was originally 8 scripts long, but now that it uses the stand alone compactor, it's only 2 scripts big.

## Source import

winAI was not made as a source program, but I've reworked it so that anyone can look at it for a practical example.<br>
To remove any 

```
{"workspaces":{"unofficial winAI4":[["Spell Config winAI",":import Cods Spell Compactor\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{synchronize(2)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{synchronize(4)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{synchronize(2)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{synchronize(6)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.cooling, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n\n{add_spell.grounded(spell.void, 30.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{synchronize(5)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return Spell.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n\n:const int recoring_size {lua(return Spell.active.space)}\n"],["winAI_lib",":import Spell Config winAI\n:import Spell Compactor resources\n:import Editor_actions lib\n; Consistent naming across scripts\n#package(name) Unofficial winAI4:{name}\n\n{lua(\\\n  elements = {};\\\n  element_cost = {};\\\n)}\n\n; helper macro so you can use set_priority easier\n; the [[no parse blocks]] are recommended here to\n; ensuse our input is a string\n; \n; Use this to create the priority listing\n; The macro doesn't check if it's a valid element since\n; the editor checks for us :D\n#set_priority(element_name) {lua(\\\n  local name = [[{element_name}]];\\\n  --[[/*\\\n      * Prevent recording the same element multiple times\\\n      * by checking if its name has already been read\\\n      * if it has, return to prevent another entry\\\n     */]]\\\n  if elements[name] ~= nil then\\\n    return;\\\n  end\\\n  local index = 1 + #elements;\\\n  elements[index] = Editor_stringify_value(name);\\\n  element_cost[index] = Editor_disableCost(elements[index]);\\\n  elements[name] = index;\\\n)}\n\n; important thing to know about disable.cost(element)\n; if we input an element we can't disable, disable.cost returns -1.0\n; \n; Here we use this fact to create an if statement\n; if(disable.cost(\"element\"), \"element\", if(next_element))\n; and we repeat this until our last recorded element\n; that if statement is if(disable.cost(\"element\"), \"element\", \"last_element\")\n#disable.era {lua(\\\n  local last_element = elements[#elements];\\\n  for i = #elements - 1, 1, -1 do\\\n    local cost = element_cost[i];\\\n    local condition = Editor_math(cost, \"!=\", -1.0);\\\n    local caseTrue = elements[i];\\\n    last_element = Editor_if(condition, caseTrue, last_element);\\\n  end\\\n  return last_element;\\\n)}\n\n; Here we construct the condition for the bool ended_era\n; ended_era = -<number_of_elements> == <sum_of_elements_cost>\n#disabled_era {lua(\\\n  local negative_costs = 0.0 - #elements;\\\n  local last_cost = element_cost[#elements];\\\n  for i = #elements - 1, 1, -1 do\\\n    last_cost = Editor_math(last_cost, \"+\", element_cost[i]);\\\n  end\\\n  return Editor_math(negative_costs, \"!=\", last_cost);\\\n)}\n\n"],["init",":import winAI_lib\n:name {package(init)}\n\ngame.newround()\n\nuseinstant(active.index(\"barrier.temporal\"))\n\n{pointer.set(0)}\n{compactor.set(recorded_actives)}\nexecute(\"{spell_compactor}\")\n\nexecute(\"{package(disables)}\")\nwaituntil(health(false) <= 0.0)\n\nstop(\"{package(disables)}\")\nstop(\"{spell_compactor}\")\n{timer.set(0.0)}\n"],["disables",":import winAI_lib\n:name {package(disables)}\n\n:budget_cap 200\ngame.newround()\n\n:local bool disabled_era\n\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(nature)}\n{set_priority(electricity)}\n{set_priority(universal)}\n{set_priority(fire)}\n{set_priority(neutral)}\n{set_priority(water)}\n{set_priority(earth)}\n\ngotoif(spam3, contains(impulse(), \"{package(init)}\"))\n\nera:\ndisable.era({disable.era})\ndisabled_era = {disabled_era}\n\ndivider:\nupgrade.era(\"health\", 42069)\n\ngotoif(era, xp() < disable.inf.cost())\n\ndisable.inf(\"aura.death\")\ndisable.inf(\"reflect.wince\")\ndisable.inf(\"reflect.captain\")\ndisable.inf(\"barrier.temporal\")\ndisable.inf(\"spell.void\")\ndisable.inf(\"spell.snapOfDestiny\")\ndisable.inf(\"spell.response.neutral\")\n\ngoto(if(disabled_era, divider, era))\n\nspam3:\n\nuseinstant(active.index(\"crate.rex\"))\n\nwaituntil({timer.get} >= 2.0)\n\nspam:\nwait(0.2)\nuseinstant(active.index(\"spell.response.neutral\"))\ngoto(spam)\n"]]}}
```

If you do encounter issues with it, please contact me on the compactors discord post, in the ai-help channel or by giving me a message directly.

# DO NOT CONTACT WOOTIMNOOB ABOUT ANY ISSUES THAT ACCOUR WHILE USING THE COMPACTOR

Woot does not know how to use the compactor and cannot provide assistance.
