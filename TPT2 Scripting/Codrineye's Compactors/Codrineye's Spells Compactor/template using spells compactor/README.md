This source import gives you a skeleton build of a blueprint AI that uses the compactor.<br>
There is no game import code because to communicate with the compactor you need to be in the external editor. Looking at a compactor output ingame is also just plain confusing.

If you want an example that also produces an export code, check out the [unofficial winAI](/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Spells%20Compactor/Unofficial%20winAI4/README.md) that doesn't have as many comments, but does produce an example you can look at and use.

```
{"workspaces":{"blueprint AI using the compactor":[["Spell Config_blueprint AI using the compactor",":import Cods Spell Compactor\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n\n{add_spell.instant(barrier.temporal, 0.0)}\n; adds the instant spell `temporal barrier` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t >= 0.0\n\n{recorded_blueprint(start, false)}\n; defines the blueprint called \"blueprint_start\" that doesn't loop\n; the spell activation sequence when it executes the last spell\n\n{synchronize(2)}\n; makes the next 2 recordings happen on the same game_tick\n\n{add_spell.instant(spell.response.neutral, 0.0)}\n; adds the instant spell `neutral response` to be used when t >= 0.0\n{add_spell.grounded(spell.void, 10.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t is a multiple of 10.0\n\n{recorded_blueprint(loop, true)}\n; defines the blueprint called \"blueprint_loop\" that loops\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n; adds the instant spell `snap of destiny` to be used\n; when t is a multiple of 28.0\n\n; \n; If you just sent the sequence `recorded_actives` to the compactor\n; you'd execute\n; temporal barier, void, neutral response, void\n; and loop back to using temporal barrier\n; \n; Notice that, since blueprint_loop has the loop property\n; snap of destiny will never be executed\n\n; \n; To execute just blueprint_start, you can cut that sequence\n; by using sub(recorded_actives, 0, blueprint_start)\n; \n; If you want to isolate blueprint_loop, you cut it using\n; sub(recorded_actives, blueprint_start, blueprint_loop - blueprint_start)\n; \n; and if you want to use snap of destiny every 28 seconds you use\n; sub(recored_actives, blueprint_loop, recording_size)\n; The last spell always gets the looping tag\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return Spell.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n\n:const int recoring_size {lua(return Spell.active.space)}\n"],["example_text library",":import Spell Config_blueprint AI using the compactor\n:import Spell Compactor resources\n\n; \n; A blueprint AI most of the time\n; has a library for convenience\n; \n; Here, we import the Spell Config you just made\n; and Spell Compactor resources\n; \n; if you get an error saying\n; 'Import failed: Script \"Spell Compactor resources\" does not exist!'\n; Please make sure you have Codrineye's Spell Compactor imported\n; \n\n#package(name) example_text:{name}\n\n; \n; this package macro is kept for use in the\n; :name function for consistent naming and\n; to easily detect if you were called by a\n; scrit of your own\n; \n; As of game update 0.49.0, you no longer\n; need to include the package name when executing\n; as it will automaticall execute the script of the\n; same name inside of your package\n; if none are found, it will try to execute a script\n; of that name, that is not included in a package\n; \n; My recommendation is that you keep the execute format\n; execute(\"package:name\")\n; so that it's easier to understand what you're looking at\n; when making a source project\n; \n\n#identifier \"example_text\"\n\n; \n; identifier is a string used when creating\n; global variables that ensures your variable\n; is unique to your AI\n; \n; This identifier should preferably\n; be the package name to ensure you're\n; the only one who can access it\n"],["blueprint AI caller",":import example_text library\n:name {package(blueprint AI caller)}\n\n; \n; this is a caller script, it\n; can be integrated into any\n; part of your script, but\n; so that you don't have to read\n; a novel, and so I don't have to write a novel\n; this is what you have to do\n; for your blueprint to be executed\n; by the spell compactor\n; \n; \n; the macro names you see here\n; have been declaired inside of\n; Spell Compactor Resources\n; \n\n{pointer.set({pointer.get})}\n\n; \n; Set a hiding block for your script, this prevents\n; the recording string from being shown on the user interface\n; as this string is usually rather large\n\n{compactor.set(recorded_actives)}\n\n; \n; If your AI already has a block hider, you\n; could simply remove creating the hide blocker\n; If you do not want to close the hide blocker\n; you should probably redesign your interface values\n; as the block hider is ended in the compactor itself\n; \n\n"]]}}
```

This workspace does not contain an integrated compactor, as having more than just 1 would be wasting script space and very computationally demanding.
