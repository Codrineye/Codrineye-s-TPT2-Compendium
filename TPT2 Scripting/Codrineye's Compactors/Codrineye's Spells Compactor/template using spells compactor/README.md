just a basic template of how to make a blueprint AI using the compactor

source import

```
{"workspaces":{"blueprint AI using the compactor":[["Spell Config_blueprint AI using the compactor",":import Cods Spell Compactor\n\n:name Spell Config\n\n{debug.log(0)}\n{debug.halt_compilation(0)}\n{debug.recordings_before_halt(6)}\n{debug.display_spells(0)}\n{debug.display_batch_in_numbers(0)}\n{debug.display_spells_in_batch(0)}\n{debug.display_format('\\n|')}\n\n\n; Welcome to the configuration\n; \n; This is not a finished comment\n; \n; This is the only area you have to make changes to\n; Here you will configure the following properties\n; *  what active modules you want to be used\n; *  the order in which you want them to be used\n; *  the timings of the activation\n; *  and lastly\n; *  if the module is placed, you will have to specify the coordinates\n; \n; you have 4 functions at your disposal:\n; All of these macros generate :const <type> <token> 'contents'\n; \n; limit\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; over this is too much\n; \n; syncronize_module_activation()\n; This macro will create a token sync<sync count> containing the value 'module_count - 1'\n; You will need to specify the amount of modules you want to activate at this time and\n; a delay to the activation\n; This will make it so you have <module_count> sync scripts active at once\n; The excess scripts will remove themselves after spell activation\n; \n; add_batch()\n; This macro will declare the end of one batch and the start of another\n;   it's curently the only macro that returns a :const int, with the token being batch<batch count>\n; A 'batch' means a sellection of modules so that you may separate module sequences\n;   with only needing arithmetic operations\n; By default you're in batch1, if you call for this macro you will move to batch2\n;   by calling this macro, you change the string within sync created by <active_module_list> \n;   so that each batch has equal length\n; \n; add_active_module.type()\n; This macro will create a token spellname<spell count> containing the following values\n; 'spell_timer' . 'coord_x' . 'coord_y' . 'attribute' . 'spell_name' . ';'\n; \n; add_active_module.instant()\n; The first type of addition, where you need to specify the spell name and the timer\n; coord_x and coord_y are 0.0 and the attribute is 'instant '\n; the extra ' ' is there for consistent spacing\n; \n; add_active_module.grounded()\n; The second type of addition, where you need to specify everything field\n; The field meaning spell_name, spell_timer, coord_x and coord_y\n; the attribute for it is 'grounded'\n; \n; I do not recommend defining a ground module as an instant module nor vice versa\n; the system will accept your input, but you will not cast anything\n\n{syncronize(2, 0.0)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{syncronize(4, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{syncronize(6, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{syncronize(2, 0.0)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{syncronize(5, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file rather than copy them\n; Putting the const declaration here is also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n\n{debug}\n\n:const string actives '{lua(return spell.concat_actives())}'\n:const string text_end_character '{lua(return spell.text.text_ending_character)}'\n:const int spells_count {lua(return #spell.active)}\n\n:const int sync_precision {lua(return spell.precision.sync)}\n:const int time_precision {lua(return 2 + spell.precision.timer)}\n:const int placement_precision {lua(return 2 + spell.precision.placement)}\n:const int attribute_size {lua(return spell.text.attribute_max_length)}\n\n:const int increment {lua(return spell.active_max_length)}\n"],["example_text library",":import Spell Config_blueprint AI using the compactor\n\n#package example_text\n\n"],["blueprint AI main",":import example_text library\n:name {package}:blueprint AI main\n\n"],["Debugging the blueprint AI ingame",":import example_text library\n:name {package}:Debugging ingame\n\n"]]}}
```