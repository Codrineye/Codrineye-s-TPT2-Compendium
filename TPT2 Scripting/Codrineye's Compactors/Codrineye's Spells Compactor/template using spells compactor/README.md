This source import is a blueprint AI template you can use to more easily design your AI to use the stand-alone compactor

This does not feature an export code, but it contains a lot of comments explaining what's going on

If you want an example that also produces an export code, check out [winAI](/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Spells%20Compactor/winAI/README.md) that doesn't have comments, but does produce an example you can look at and use

```
{"workspaces":{"blueprint AI using the compactor":[["Spell Config_blueprint AI using the compactor",":import Cods Spell Compactor\n\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n; The following macros let you communicate\n; with the debugger\n; You can freely change the values you\n; give the macros, if you're curious as\n; to what each debug macro effects\n; \n; spell_debug.log permits logging to\n; the browser developer console\n; \n; \n; What does it mean for the compactor to halt?\n; When the compactor halts, it means that \n; adding a spell will no longer be stored\n; \n; Halting is useful when debugging, as you can see\n; what the program \"sees\" at that time\n; \n; spell_debug.halt_compilation signals to the\n; compactor that compilation should halt eventually\n; \n; spell_debug.recordings_before_halt is the amount\n; of spells you can add before compilation halts\n; this value has no effect if spell_debug.halt_compilation\n; is set to 0\n; \n; spell_debug.display_spells tells the debugger\n; to display the spells you added\n; \n; spell_debug.display_spacers_as_numbers tells\n; the debugger to convert all spacing sequences\n; as the number of spaces, instead of the\n; spacing sequence itself\n; \n; essentially, it converts [...] to [3]\n; This improves readability when\n; displaying spells\n; \n; spell_debug.display_spells_in_batch signals the\n; compactor to display your spells, but to only add\n; a `display_format` at the start of a new batch \n; \n; spell_debug.display_format is a string that\n; acts as a separtor for inputs\n; the string you input in this field will be\n; at the beginning of every recorded field\n; this only applies if you want to display the output\n; \n\n{spell_debug.log(0)}\n{spell_debug.halt_compilation(0)}\n{spell_debug.recordings_before_halt(2)}\n{spell_debug.display_spells(0)}\n{spell_debug.display_spacers_as_numbers(0)}\n{spell_debug.display_spells_in_batch(0)}\n{spell_debug.display_format('\\n|')}\n\n; \n; Time for the actual recording\n; you have 4 functions at your disposal\n; \n; add_spell.instant()\n; this takes in 2 parameters \n; * the name of the spell, this can be obtained by\n;   simply importing a script that uses all the modules you want\n; * the timer for the spell, being the amount of time you want\n;   to pass before activation\n; \n; add_spell.grounded()\n; this takes in 4 parameters\n; * the name, just like in add_spell.instant()\n; * the timer, just like in add_spell.instant()\n; * the x position of where you want to cast the spell\n; * the y position of where you want to cast the spell\n; \n; blueprint AI's usually use winemast for the timer `t`\n; the timer is the value of `t` at the time of activation\n; \n; synchronize()\n; this takes in 2 parameters\n; * the number of modules you want to activate at once\n; * a potential delay you may want to add to the spell timers\n; \n; add_batch()\n; this takes in 1 parameter\n; * the name you want to give this batch\n; \n; a batch reprezents a separation in the recording\n; this is done when you have multiple activation sequences\n; that you want to have in the same actives string\n; \n; The batch name is used to determine\n; when a batch starts\n; \n; \n; If you have a grounded module with coordinates 0,0\n; I do not recommend defining it as an instant module\n; \n; Even tho your input will be correctly processed\n; you will likely have to change things at some point\n; and this definition can lead to confusion\n; \n; You should not define an instant module as grounded\n; for the same reason, make the sequence easier for you\n; to follow\n; \n\n{synchronize(2, 0.0)}\n{add_spell.instant(barrier.temporal, 0.0)}\n{add_spell.instant(spell.floof, 0.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 0.0)}\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 0.5, 12.0, 10.0)}\n\n{synchronize(4, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 1.0)}\n{add_spell.instant(spell.recharge, 1.0)}\n{add_spell.instant(spell.cooling, 1.0)}\n{add_spell.grounded(spell.something, 1.0, 5.0, 15.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.response.neutral, 2.0)}\n{add_spell.grounded(spell.void, 2.0, 0.0, 0.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 3.0)}\n\n{synchronize(6, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n{add_spell.instant(spell.refresh, 28.0)}\n{add_spell.instant(spell.recharge, 28.0)}\n{add_spell.instant(barrier.temporal, 28.0)}\n{add_spell.instant(spell.floof, 28.0)}\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n\n{synchronize(2, 0.0)}\n{add_spell.instant(spell.cooling, 29.0)}\n{add_spell.instant(spell.recharge, 29.0)}\n\n{add_spell.grounded(spell.void, 29.0, 0.0, 0.0)}\n\n{add_spell.grounded(spell.something, 30.5, 12.0, 10.0)}\n\n{synchronize(5, 0.0)}\n{add_spell.instant(spell.snapOfDestiny, 31.0)}\n{add_spell.instant(spell.recharge, 31.0)}\n{add_spell.instant(spell.refresh, 31.0)}\n{add_spell.instant(barrier.temporal, 31.0)}\n{add_spell.grounded(spell.something, 31.0, 5.0, 15.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 33.0)}\n\n{add_spell.instant(spell.snapOfDestiny, 57.0)}\n\n; \n; This marks the end of spell configuration\n; we now have a macro spell_debug\n; this is in charge of outputing debugging data\n; and prevents the output string from being read\n; when its contents are modified for displaying\n; \n\n{spell_debug}\n\n; \n; These are the constants you'll be dealing with\n; It's more convenient to put them at the end of this file\n; rather than copy them\n; Putting the const declaration here is\n; also beneficial since it shows you can\n; create separate sequences if need be\n; Such as for a fragment AI\n; \n\n:const string actives '{lua(return spell.concat_actives())}'\n:const string text_end_character '{lua(return spell.text.text_ending_character)}'\n:const int spells_count {lua(return #spell.active)}\n:const int spell_size {lua(return spell.active_max_length)}\n\n:const int sync_precision {lua(return spell.precision.sync)}\n:const int time_precision {lua(return 2 + spell.precision.timer)}\n:const int placement_precision {lua(return 2 + spell.precision.placement)}\n\n\n"],["example_text library",":import Spell Config_blueprint AI using the compactor\n:import Spell Compactor resources\n\n; \n; A blueprint AI most of the time\n; has a library just for convenience\n; \n; Here, we import the Spell Config you just made\n; and Spell Compactor resources\n; \n; if you get an error saying\n; 'Import failed: Script \"Spell Compactor resources\" does not exist!'\n; Please make sure you have Codrineye's Spell Compactor imported\n; \n\n#package(name) example_text:{name}\n\n; \n; this package macro is kept for use in the\n; :name function for consistent naming and\n; to easily detect if you were called by a\n; scrit of your own\n; \n; As of game update 0.49.0, you no longer\n; need to include the package name when executing\n; as it will automaticall execute the script of the\n; same name inside of your package\n; if none are found, it will try to execute a script\n; of that name, that is not included in a package\n; \n; My recommendation is that you keep the execute format\n; execute(\"package:name\")\n; so that it's easier to understand what you're looking at\n; when making a source project\n; \n\n; \n; The following two macros are dependencies\n; added by importing Spell Compactor resources\n; \n\n#identifier \"example_text\"\n\n; \n; identifier is a string used when creating\n; global variables that ensures your variable\n; is unique to your AI\n; \n; This identifier should preferably\n; be the package name, as the stand-alone compactor\n; will retrieve the data you sent by breaking\n; off the package name from the caller scripts name\n; \n\n#compactor_type \"external\"\n\n; \n; this dependency makes it possible for you\n; follow the naming scheme required when communicating\n; with the stand-alone compactor\n; \n; by this being a macro, you can also\n; use the naming format to communicate with\n; another script, if you know the compactor_type\n; \n; For this library, \"external\" is used\n; as that's the type it's reading from\n; \n\n"],["blueprint AI caller",":import example_text library\n:name {package(blueprint AI caller)}\n\n; \n; this is a caller script, it\n; can be integrated into any\n; part of your script, but\n; so that you don't have to read\n; a novel, and so I don't have to write a novel\n; this is what you have to do\n; for your blueprint to be executed\n; by the stand-alone spell compactor\n; \n; \n; the macro names you see here\n; have been declaired inside of\n; Spell Compactor Resources\n; \n\n{pointer.set({pointer.get})}\n\n; \n; Set a hiding block for your\n; script, this prevents\n; the following from showing on\n; the user interface\n; \n\n{spells_size.set(spell_size)}\n{precision_count.set(spells_count)}\n{precision_sync.set(sync_precision)}\n{precision_timer.set(time_precision)}\n{precision_placement.set(placement_precision)}\n\n{text_ending_character.set(text_end_character)}\n{active_spells.set(actives)}\n\n; \n; These 8 lines send the const values\n; found at the bottom of your respective\n; Spell Config\n; and setting active_spells closes your hiding block\n; meaning that any new global variable\n; you set now will be visible on the overlay\n; \n\n\n; \n; If your AI already has a block hider, you\n; can remove creating the hide blocker\n; If you do not want to close the hide blocker\n; you can use\n; active_spells.set(actives . {hider.start})\n; as that will prevent the hiding block\n; from ending\n; \n; or you can manipulate the value yourself\n; by using\n; global.string.set({active_spells}, actives)\n; \n; I do not recommend manipulating internal\n; compactor values yourself as that can\n; have unexpected outcomes\n; \n; you can, however, read from the\n; values you've set, as all macros\n; have .set and .get functionality\n; \n\n\n"],["integrated compactor lib",":import example_text library\n\n; \n; In this library, I will give you\n; the tools needed to integrate a\n; script that executes the spells\n; stored inside of the :const string\n; 'actives' in your AI\n; \n; I do not personally recommend\n; doing this, as it can take up\n; more space in scripts, but\n; I recognize that not everybody\n; likes to rely on the existance of\n; a script for their blueprint to work\n\n; \n; One more warning\n; if you're planning on integrating\n; the compactor internally\n; and your Spell Config includes\n; batches, I strongly recommend\n; you avoid the headache that comes\n; with making batches work internally\n; \n; the stand-alone compactor was made partly\n; to deal with batches in an easy manner\n; by having the user select the part of\n; actives they would like to be executed\n; \n\n; \n; Additional mention\n; if you want to integrate the compactor\n; in your script, you would probably\n; prefer not to include Spell Compact resources\n; all-together, as it has so many macros you\n; might be annoyed at how many names are taken\n; \n; do not remove the import yet, however\n; as that would cause the editor to\n; throw macro errors, which could be annoying\n; \n\n; \n; To integrate the compactor in your AI\n; you will need 2 systems\n; \n; a system that activates your spells\n; a timer system\n; \n\n; \n; the timer system is already taken care of\n; for you, as Spell Compactor resources\n; defines the timer macros\n; {timer}, {timer.get}, {timer.set()}\n; and {timer.add()}\n; \n; these are\n; the timer variable name\n; get the timer variable value\n; set the timer variable value\n; add this ammount to the timer variable\n; \n; to get the timer, you\n; need a basic winemast ticker\n; \n\n; \n; The spell activation system requires\n; a pointer variable\n; \n; as you've seen in the blueprint AI caller\n; you have the macros {pointer}\n; {pointer.get} and {pointer.set()}\n; at your disposal, and for the most part\n; that's all you need, but thanks to\n; how the compactor cycling system works\n; you can define pointer.increment like \n; \n\n#pointer.increment {pointer.set(\\\n  ({pointer.get} + 1) % spells_count\\\n)}\n\n; \n; as this will go through every spell inside\n; the string `actives`\n; \n; if you don't want it to loop forever, you can\n; simply remove the (% spells_count) part\n; \n"],["Compactor tick",":import integrated compactor lib\n:name Compactor tick\n\n; \n; This is a script designed for\n; keeping time in towertesting\n; \n; this is a valuable script\n; as all module activations depend on\n; this timer\n; \n\n{timer.set(time.delta() * 2.0)}\n\n; \n; to have an accurate timer\n; we need to multiply the time.delta() by 2\n; \n; if this happens and time.delta() = 0, we\n; don't really care, but if it's a non 0 value\n; this multiplication ensures our timer is\n; synchronized to the ingame timer\n; \n\n:budget_cap -1\n\n; \n; we set the budget cap to\n; max so that the timer runs as\n; fast as possible\n; \n\nloop:\nwaitframe()\n{timer.add(time.delta())}\ngoto(loop)\n\n; \n; and we make the loop\n; this is an infinite loop\n; that will update the timer\n; until the script is stopped\n; by the main handler\n; \n\n"],["Compactor sync",":import integrated compactor lib\n:name {package(Compactor sync)}\n\n; \n; This is the sync script\n; if you are sure you want\n; to integrate the compactor sync\n; to your AI, please make sure\n; you understand how the sync works\n; \n\n#actives.displace(sync, timer, positions) position + (\\\n  {sync} * sync_precision + \\\n  {timer} * time_precision + \\\n  {positions} * placement_precision\\\n)\n\n#actives.substring(sync, timer, positions, length) sub(\\\n  actives,\\\n  {actives.displace({sync}, {timer}, {positions})},\\\n  {length}\\\n)\n\n#actives.index(sync, timer, positions) index(\\\n  actives,\\\n  text_end_character,\\\n  {actives.displace({sync}, {timer}, {positions})}\\\n) - ({actives.displace({sync}, {timer}, {positions})})\n\n; \n; These are the same functions\n; you will find inside of Spell Compactor lib\n; but they've been modified to use\n; the const values at the bottom of\n; your Spell Config\n; instead of internal macros\n; \n\n\n:budget_cap 50\n\n; \n; We set a budget of 50 just\n; so we're going through this fast\n; \n; \n; order it's memorised internally for \n; easier updates and convenience\n; \n; sync + timer + coord_x + coord_y + name\n\n; \n; helper consts for control\n; const string for sync check\n; sync_precision is unlikely to reach 50\n; in execution\n; \n; const double threshold for time keeping\n; \n:const string sync_needed '{lua(return string.rep(\"0\", 50))}'\n:const double threshold 50.0\n\n; \n; local helper values to \n; relieve the system of stress\n; \n:local int position\n:local int synchronize_copies\n:local bool copy_activator\n:local double timer\n\n; check if we're a copy\n; \ncopy_activator = contains(impulse(), \"{package(sync)}\")\n\n; main loop\n; we assign position our curent position\n; and increment our pointer\n; \ncheck:\nposition = {pointer.get}\n\n; \n; Then, check if we're being used\n; if not, we exit, otherwise\n; check if our helper const string\n; contains our sync\n; if it doesn't, we don't have any copies\n; so se can skip synchronization\n; otherwise, if we're not a copy, we enter\n; synchronization\n; \n\ngoto(if(\\\n  health(false) > 0.0,\\\n  if(\\\n    copy_activator || not(contains(\\\n      sync_needed, \\\n      {actives.substring(0, 0, 0, sync_precision)}\\\n    )),\\\n    skip,\\\n    synchronize\\\n  ),\\\n  99\\\n))\n\n; we set our timer, and wait to activate it\n; we don't let false passes through if\n; our {timer.get} is smaller than our\n; spell timer\n; and finally, we use both instand and grounded\n; spells of that\n; \n; you cannot activate an instant\n; spell with useposition, and you cannot\n; activate a position spell with useinstant\n; \nskip:\n{pointer.increment}\n\ntimer = s2d(\\\n  {actives.substring(1, 0, 0, time_precision)},\\\n  0.0\\\n)\nwaitwhile({timer.get} % timer > threshold || {timer.get} < timer)\nuseinstant(active.index(\\\n  {actives.substring(\\\n    1, 1, 2, \\\n    {actives.index(1, 1, 2)}\\\n  )}\\\n))\nuseposition(\\\n  active.index(\\\n    {actives.substring(\\\n      1, 1, 2, \\\n      {actives.index(1, 1, 2)}\\\n    )}\\\n  ), vec(\\\n    s2d({actives.substring(1, 1, 0, placement_precision)}, 0.0),\\\n    s2d({actives.substring(1, 1, 1, placement_precision)}, 0.0)\\\n  )\\\n)\n\n; we then return to check only if\n; we're the root pointer\ngoto(if(copy_activator, 99, check))\n\n; if there's copies to be made\n; we keep them in synchronize_copies\n; and create copies of sync as long as\n; there's copies to be made\n; \n; we end this by having our root position\n; at the final spell\n; \n\nsynchronize:\nsynchronize_copies = s2i(\\\n  {actives.substring(0, 0, 0, sync_precision)},\\\n  0\\\n)\n\ncopy:\nsynchronize_copies = synchronize_copies - 1\nexecute(\"{package(Compactor sync)}\")\ngoto(if(synchronize_copies < 0, check, copy))\n"]]}}
```
