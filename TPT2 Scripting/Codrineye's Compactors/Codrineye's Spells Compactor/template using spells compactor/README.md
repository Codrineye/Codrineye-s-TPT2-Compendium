This source import gives you a skeleton build of a blueprint AI that uses the compactor.<br>
There is no game import code because to communicate with the compactor you need to be in the external editor. Looking at a compactor output ingame is also just plain confusing.

If you want an example that also produces an export code, check out the [unofficial winAI](/TPT2%20Scripting/Codrineye's%20Compactors/Codrineye's%20Spells%20Compactor/Unofficial%20winAI4/README.md) that doesn't have as many comments, but does produce an example you can look at and use.

```
{"workspaces":{"blueprint AI using the compactor":[["Software Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Software Config\n\n; Modify the value sent to the macro\n; \n; This is the ordinairy Watercat security system\n; it's just slightly easier to modify the security level\n; \n; The macro prevents you from setting security values\n; to the same software more than once, if you think this is a limitation\n; please use the discord post/make a github issue and suggest the change\n; \n\n{auto_skip(0)}\n{wave_streaming(0)}\n{wave_surge(0)}\n{critical_wave_jump(0)}\n{wave_momentum(0)}\n{wave_storm(0)}\n{wave_persistence(0)}\n{wave_instability(0)}\n{wave_vortex(0)}\n{wave_catalyst(0)}\n{wave_endurance(0)}\n{new_bounds(0)}\n{wave_marathon(0)}\n{wave_compression(0)}\n{era_surge(0)}\n{era_burst(0)}\n{era_swirl(0)}\n{wave_horizon(0)}\n{no_bounds(0)}\n{era_tunneling(0)}\n{wave_breach(0)}\n{wave_floor(0)}\n{era_floor(0)}\n{era_horizon(0)}\n{wave_restart(0)}\n{infinity_horizon(0)}\n\n; These constants are used to create the 2 lists used in watercat\n:const string software_list {software.concat(software_list)}\n:const string software_secure {software.concat(software_secure)}\n; \n; and this is the length of both of the lists\n; this is done through adding whitespace to the security levels so that\n; index(software_list) is the same as index(software_secures)\n:const int software_len {len({software.concat(software_list)})}\n\n:const string Wcat \"w#|\"\n\n#watercat_line1(secure_level) \\\nsoftware_toggle_loop:\\\nsoftware.toggle(\\\n  sub(\\\n    software_list, \\\n    lig(Wcat), \\\n    index(software_list, \"|\", lig(Wcat)) - lig(Wcat)\\\n  ),\\\n  {secure_level} == s2i(\\\n    sub(\\\n      software_secure, \\\n      lig(Wcat), \\\n      index(software_secure, \"|\", lig(Wcat)) - Wcat\\\n    ),\\\n    0\\\n  )\\\n)\n; sub = 3\n; lig = 1\n; a.i = 3\n; index = 3\n; c.i = 3\n; s2i = 2\n; software.toggle = 2\n; sub + lig + a.i + index + lig + lig = 3 + 1 + 3 + 3 + 1 + 1 = 12\n; c.i + lig + s2i + sub + lig + a.i + index + lig + lig \n; = 3 + 1 + 2 + 3 + 1 + 3 + 3 + 1 + 1\n; = 4 + 5 + 4 + 4 + 1 = 9 + 8 + 1 = 18\n; \n; 2 + 12 + 18 = 32\n\n#watercat_line2 lis(Wcat, 1 + index(security_list, \"|\", lig(Wcat)))\n; lis + c.i + index + lig = 2 + 3 + 3 + 1 = 9\n\n#watercat_line3 gotoif(software_toggle_loop, lig(Wcat) < software_len)\n; gotoif + c.i + lig = 2 + 3 + 1 = 6\n; \n; 31 + 9 + 6 = 46\n"],["Secure Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Security Config\n\n; \n; Welcome to security config, where you define\n; what modules you want to secure and in what order\n; \n; Since securing isn't very complicated, logging and halting\n; has not been added, as there's not much for you to keep track of\n; \n; You have 2 macros at your disposal\n; add_secure(secure_name) is the name ID that you want to be secured\n; recorded_secures(secures_name) will return a const int called\n; secures_<secures_name> which holds the ammount of space your secures\n; have taken up\n; \n; your compacted secures are in the const string recorded_secures\n; and the total size of your recorded_secures is in the\n; const int secures_space\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n{add_secure(barrier.temporal)}\n; tells the compactor you want to secure barrier.temporal\n{add_secure(spell.void)}\n; means that you want to secure spell.void\n; after you've secured barrier.temporal\n\n{recorded_secures(blue)}\n; Gets you the constant secures_blue, which you can use to\n; isolate this secures sequence by using\n; sub(recorded_secures, 0, secures_blue)\n; \n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n:const string recorded_secures \"{lua(\\\n  return table.concat(BP.comp.secure);\\\n)}\"\n:const int secures_space {lua(return BP.misc.space.secure)}\n"],["Spell Config_blueprint AI using the compactor",":import Cods Blueprint Compactor\n:name Spell Config\n; \n; Welcome to the configuration\n; This script has macros that allow you to\n; communicate with the compactor and its debugger\n; \n{spell_debug.log(false)}\n; Set to true if you want to get a log of your recording\n; \n{spell_debug.can_halt(false)}\n; Set to true if you want to create a 'breakpoint'\n; Setting it to true also enables logging implicitly\n; \n{spell_debug.recordings_before_halt(2)}\n; Set the number of spells you can record\n; before the recording system halts.\n; It does nothing if can_halt is false \n; \n{spell_debug.display_spells(false)}\n; Set to true if you want to display your spells\n; You will see them as an error message to the right\n; \n{spell_debug.display_format('\\n|')}\n; Set the string that'll be used to format your spells\n; This is only used if display_spells is set to true\n; \n; Lastly <spell_debug.add_breakpoint>\n; as its name implies, you use it to add a breakpoint\n; it sets display_spells to true and halts the program at that point\n; so that you can see the current state of the script\n\n; \n; For recording a blueprint, you have the following\n; 4 macros\n; \n; recorded_blueprint(blueprint_name, loopable_blueprint)\n; Is used after a recording sequence to define a blueprint\n; \n; It returns a const int variable\n; called \"blueprint_<blueprint_name>\"\n; that holds an index for you to use in a substring to extract\n; the desired blueprint\n; \n; blueprint_name is just any string. You do not include the double quotes\n; loopable_blueprint is a true/false value\n; if true, it makes the compactor execute the recording sequence on loop\n; \n; synchronize(spell_ammount) \n; it makes the following spell_ammount recordings\n; get used on the same gametick\n; \n; onto the add_spell.<spell_type> functions\n; they all require the spell ID, which you can obtain\n; by importing a script that uses the modules you want\n; \n; These functions also return a const int spell_<spell_number>\n; holding the current ammount of space in your recording after\n; the addition of the new spell\n; \n; add_spell.instant(spell_name, timer)\n; spell_name is the active modules ID.\n; timer is the time at which you'd like the spell to be used\n; \n; add_spell.grounded(spell_name, timer, coord_x, coord_y);\n; Same as add_spell.instant but you now define the x/y coordinates\n; you want the spell to be cast at\n; \n; There's a little wrinkle with add_spell.instant\n; that treates instant spells as grounded spells\n; that are placed at position 0.0 0.0\n; \n\n; All recorded spells get concatenated into the const string\n; `recorded_actives` with its length being stored in the const int\n; `recording_size`\n\n; ===================================================================== ; \n; -------------------------> START RECORDING <------------------------- ; \n; ===================================================================== ; \n\n\n{add_spell.instant(barrier.temporal, 0.0)}\n; adds the instant spell `temporal barrier` to be used when t >= 0.0\n\n{add_spell.grounded(spell.void, 0.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t >= 0.0\n\n{recorded_blueprint(start, false)}\n; defines the blueprint called \"blueprint_start\" that doesn't loop\n; the spell activation sequence when it executes the last spell\n\n{synchronize(2)}\n; makes the next 2 recordings happen on the same game_tick\n\n{add_spell.instant(spell.response.neutral, 0.0)}\n; adds the instant spell `neutral response` to be used when t >= 0.0\n{add_spell.grounded(spell.void, 10.0, 0.0, 0.0)}\n; adds the grounded spell `void` to be used\n; at position 0.0, 0.0 on the map when t is a multiple of 10.0\n\n{recorded_blueprint(loop, true)}\n; defines the blueprint called \"blueprint_loop\" that loops\n\n{add_spell.instant(spell.snapOfDestiny, 28.0)}\n; adds the instant spell `snap of destiny` to be used\n; when t is a multiple of 28.0\n\n; \n; If you just sent the sequence `recorded_actives` to the compactor\n; you'd execute\n; temporal barier, void, neutral response, void\n; and loop back to using temporal barrier\n; \n; Notice that, since blueprint_loop has the loop property\n; snap of destiny will never be executed\n\n; \n; To execute just blueprint_start, you can cut that sequence\n; by using sub(recorded_actives, 0, blueprint_start)\n; \n; If you want to isolate blueprint_loop, you cut it using\n; sub(recorded_actives, blueprint_start, blueprint_loop - blueprint_start)\n; \n; and if you want to use snap of destiny every 28 seconds you use\n; sub(recored_actives, blueprint_loop, recording_size)\n; The last spell always gets the looping tag\n\n; ===================================================================== ; \n; ----------------------------END RECORDING---------------------------- ;\n; ===================================================================== ; \n\n{spell_debug}\n\n; \n; String holding the recorded spell data\n:const string recorded_actives {lua(return BP.comp.concat_actives())}\n\n; \n; Int holding the size of the recorded string\n; value is the same as return #Spell.comp.concat_actives() but\n; the function version runs the function one more time, which\n; can get very slow if you have a big recording sequence\n\n:const int recoring_size {lua(return BP.misc.space.active)}\n"],["example_text library",":import Secure Config_blueprint AI using the compactor\n:import Spell Config_blueprint AI using the compactor\n:import Blueprint Compactor resources\n\n; \n; A blueprint AI most of the time\n; has a library for convenience\n; \n; Here, we import the Spell Config you just made\n; and Spell Compactor resources\n; \n; if you get an error saying\n; 'Import failed: Script \"Spell Compactor resources\" does not exist!'\n; Please make sure you have Codrineye's Spell Compactor imported\n; \n\n#package(name) example_text:{name}\n\n; \n; this package macro is kept for use in the\n; :name function for consistent naming and\n; to easily detect if you were called by a\n; scrit of your own\n; \n; As of game update 0.49.0, you no longer\n; need to include the package name when executing\n; as it will automaticall execute the script of the\n; same name inside of your package\n; if none are found, it will try to execute a script\n; of that name, that is not included in a package\n; \n; My recommendation is that you keep the execute format\n; execute(\"package:name\")\n; so that it's easier to understand what you're looking at\n; when making a source project\n; \n\n#identifier \"example_text\"\n\n; \n; identifier is a string used when creating\n; global variables that ensures your variable\n; is unique to your AI\n; \n; This identifier should preferably\n; be the package name to ensure you're\n; the only one who can access it\n"],["blueprint AI caller",":import example_text library\n:name {package(blueprint AI caller)}\n\n; \n; this is a caller script, it\n; can be integrated into any\n; part of your script, but\n; so that you don't have to read\n; a novel, and so I don't have to write a novel\n; this is what you have to do\n; for your blueprint to be executed\n; by the spell compactor\n; \n; \n; the macro names you see here\n; have been declaired inside of\n; Spell Compactor Resources\n; \n\n{pointer.set({pointer.get})}\n\n; \n; Set a hiding block for your script, this prevents\n; the recording string from being shown on the user interface\n; as this string is usually rather large\n\n{comp_active.set(recorded_actives)}\n{comp_secure.set(recorded_secures)}\n\n; \n; If your AI already has a block hider, you\n; could simply remove creating the hide blocker\n; If you do not want to close the hide blocker\n; you should probably redesign your interface values\n; as the block hider is ended in the compactor itself\n; \n\n"],["blueprint handler",":import Software Config_blueprint AI using the compactor\n:import example_text library\n\n{set_priority(fire)}\n{set_priority(water)}\n{set_priority(earth)}\n{set_priority(air)}\n{set_priority(nature)}\n{set_priority(light)}\n{set_priority(darkness)}\n{set_priority(electricity)}\n{set_priority(universal)}\n{set_priority(neutral)}\n\ndisable.era({disable.era})"]]}}
```

This workspace does not contain an integrated compactor, as having more than just 1 would be wasting script space and very computationally demanding.
