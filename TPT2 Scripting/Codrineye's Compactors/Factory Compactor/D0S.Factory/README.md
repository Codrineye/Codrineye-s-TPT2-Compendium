# Factory Automation Source Code

This is the source directory for the factory automation. This document explains how to make changes, as well as a change history.
To download and use the package, [go up a level](/README.md#factory-automation).

## Making changes

Modifying the code requires the enchanced editor at https://d0sboots.github.io/perfect-tower, because it makes heavy use of the `lua()` macro to do data and code generation in Lua. It also `:import`s four files that are never part of the bundle import:
`factory_constants.tpt2`, `factory_macros.tpt2`, `worker_storage_lib.tpt2` and `recipes.tpt2`.

The editor has a source-import feature, used the same way you import scripts.
The following will set up a new workspace for the factory:

```
{"workspaces":{"D0S.Factory":[["factory constants",":import factory macros\n\n#version v3.2.3\n\n; Everything in the list below is a valid target for automation, and\n; can be assigned to the \"target_type\" variable in \"lanuch factory craft\".\n; For example, \"make(oven, 10, \"machine.oven\")\" indicates that \"oven\"\n; is a valid item, usable from tiers 1-10, with the internal\n; game name of \"machine.oven\" (which you don't need to worry about.)\n; Thus you can enter \"oven\" in the box in the in-game editor\n; (without the quotes).\n\n; If you add or change this list, mind this constraint:\n; * All the crafted items have to come before the rest of the items.\n; * All the item-groups must be in a single block.\n; * Prefer keeping things in alphabetical order within categories, because\n;   they are ordered the same way when presented in-game.\n\n; ===== VALID IDS =====\n\n; ***\n; To reiterate, just use the name part (i.e. \"white_producer\"),\n; not the whole thing!\n; ***\n\n; ----- CRAFTED ITEMS -----\n\n; Producers, named by building, tiers 1-5\n{make(arcade_producer, 5, \"producer.arcade\")}\n{make(construction_firm_producer, 5, \"producer.constructionFirm\")}\n{make(exotic_producer, 1, \"producer.exoticgems\")}\n{make(factory_producer, 5, \"producer.factory\")}\n{make(gem_producer, 1, \"producer.gems\")}\n{make(headquarters_producer, 5, \"producer.headquarters\")}\n{make(laboratory_producer, 5, \"producer.laboratory\")}\n{make(mine_producer, 5, \"producer.mine\")}\n{make(museum_producer, 5, \"producer.museum\")}\n{make(powerplant_producer, 5, \"producer.powerplant\")}\n{make(pumpkin_producer, 1, \"pumpkin.producer\")}\n{make(shipyard_producer, 5, \"producer.shipyard\")}\n{make(statue_of_cubos_producer, 5, \"producer.statueofcubos\")}\n{make(town_producer, 5, \"producer.town\")}\n{make(tradingpost_producer, 5, \"producer.tradingpost\")}\n{make(workshop_producer, 5, \"producer.workshop\")}\n\n; Boosters, tiers 1-3\n{make(acceleration_booster, 3, \"booster.acceleration\")}\n{make(machine_booster, 3, \"booster.machines\")}\n{make(production_booster, 3, \"booster.production.regular\")}\n{make(resource_booster, 3, \"booster.resource.drops\")}\n{make(tree_booster, 3, \"booster.trees\")}\n\n{category(prod, town_producer, arcade_producer, resource_booster)}\n\n; Machines, tiers 1-10\n{make(assembly, 10, \"machine.assembler\")}\n{make(belt, 10, \"machine.transportbelt\")}\n{make(boiler, 10, \"machine.boiler\")}\n{make(crusher, 10, \"machine.crusher\")}\n{make(cutter, 10, \"machine.cutter\")}\n{make(mixer, 10, \"machine.mixer\")}\n{make(oven, 10, \"machine.oven\")}\n{make(presser, 10, \"machine.presser\")}\n{make(refiner, 10, \"machine.refinery\")}\n{make(shaper, 10, \"machine.shaper\")}\n\n{category(mach, belt, assembly, shaper)}\n\n; Various crafted parts\n{make(block, 10, \"block\")}\n{make(chip, 5, \"chip\")}\n{make(hammer, 1, \"hammer\")}\n{make(lump, 9, \"lump\")}\n{make(insul_cable, 10, \"cable.insulated\")}\n{make(motor, 10, \"motor\")}\n{make(pump, 10, \"pump\")}\n{make(rainbow_dust, 1, \"dust.rainbow\")}\n{make(rubber_sapling, 1, \"sapling.rubber\")}\n{make(stacked_plate, 10, \"plate.stack\")}\n{make(stacked_pumpkin, 1, \"pumpkin.stack\")}\n{make(void_sapling, 1, \"sapling.void\")}\n\n{category(crft, chip, block, void_sapling)}\n\n; Transforms ore into dust, tiers 1-10\n; Because of an implementation detail, this must come before any\n; scannable items.\n; This doesn't show up in any category in the UI.\n{special(ore, 10, \"ore\")}\n{special(crushable_ore, 10, \"ore\")}\n{special(mixable_lump, 9, \"lump\")}\n\n; ----- SCANNABLE ITEM GROUPS -----\n; These are not real items, but rather groups of items that will be made\n; together if you select one of these names. They are meant for use with\n; the Crafter, to crank out sets of items to scan quickly.\n; You will want to set the quantity to 1000.\n\n; Notes on using item groups:\n; * SCAN YOUR ORES FIRST! The factory can and will consume your ore\n;     to make stuff, and it takes a long time to get 1000 T10 ore.\n; * The quantity works a little differently than normal items. Instead\n;     of making 1000 items each time, running it again will top off\n;     everything to be *at* the quantity of 1000 items.\n; * If you craft a higher tier after a lower tier, it will consume the\n;     results of the first craft to make the higher tier.\n;     Scan all the items first, before moving on to the next tier!\n; * None of these groups include Gem Producers or Exotic Producers. They\n;     are too expensive in comparison to other things, craft them on your\n;     own when you judge the time is right.\n\n; Makes *everything* (expect special producers and lumps)\n; of the given tier. This is the combination of\n; \"chips_and_prods\", \"machines\", and \"parts\".\n; Requires x10 and high processing speed to have a hope of completing in a\n; reasonable amount of time for T5 and T10.\n; You need Quantum Warehouse to have enough space\n; for this at higher tiers!\n{group(all, 10)}\n\n; All the tiers of chips. Warning: Expensive. Input this as tier 1.\n{group(chips, 1)}\n\n; Producers + the chip of the corresponding tier. This is everything that\n; exists in tier range 1-5, for convenience.\n{group(chip_and_prods, 5)}\n\n; All machines. Tiers 1-10\n{group(machines, 10)}\n\n; All ingredients and parts. Tiers 1-10. Doesn't include ore\n; (scan that before starting) or lumps (due to technical limitations).\n; Lumps aren't required for anything currently though.\n; Includes rubber plates at tier 1 and hammers at tier *2*.\n; Rubber trees are at tier 9 because of their ore.\n{group(parts, 10)}\n\n; All producers, except for special producers. Tiers 1-5\n{group(producers, 5)}\n\n{category(grup, all, all, producers)}\n\n; ----- INGREDIENTS AND PRODUCED PARTS -----\n\n; Parts, tiers 1-10\n{item(anti_pumpkin, 1, \"pumpkin.anti\")}\n{item(board, 10, \"plate.circuit\")}\n{item(cable, 10, \"cable\")}\n{item(carved_pumpkin, 1, \"pumpkin.carved\")}\n{item(circuit, 10, \"circuit\")}\n{item(dense_block, 10, \"block.dense\")}\n{item(dense_plate, 10, \"plate.dense\")}\n{item(dust, 10, \"dust\")}\n{item(ingot, 10, \"ingot\")}\n{item(pipe, 10, \"pipe\")}\n{item(plate, 10, \"plate\")}\n{item(pumpkin_plate, 1, \"pumpkin.plate\")}\n{item(rainbow_ingot, 1, \"ingot.rainbow\")}\n{item(rainbow_plate, 1, \"plate.rainbow\")}\n{item(ring, 10, \"ring\")}\n{item(rod, 10, \"rod\")}\n{item(rubber_plate, 1, \"plate.rubber\")}\n{item(screw, 10, \"screw\")}\n{item(wire, 10, \"wire\")}\n\n{category(part, circuit, anti_pumpkin, wire)}\n\n; Can only be made from saplings\n; Doesn't appear in the UI\n{item(void_essence, 1, \"essence.void\")}\n\n; Can only be gotten through the Halloween event\n; Doesn't appear in the UI\n{item(pumpkin, 1, \"pumpkin\")}\n\n; Rubber, tier 1 only\n; Doesn't appear in the UI\n{item(rubber, 1, \"rubber\")}\n\n; ===== END OF VALID IDS =====\n"],["factory macros","; Infrastructure for producing all the constants in the factory package.\n; Since this is :imported, it can't produce any instructions.\n\n#script_name(name) D0S.factory {version}:{name}\n\n; Key assignments. You can edit these here, or you can edit them later\n; in the generated script (but you will have more places to modify).\n#up w\n#down s\n#left a\n#right d\n#start f\n\n; Shared hidden variables for the UI\n:const string action \"<size=0>fa#\"\n#action.get global.string.get(action)\n#action.set(value) global.string.set(action, {value})\n\n:const string status \"fs#\"\n#status.get global.string.get(status)\n#status.set(value) global.string.set(status, {value})\n\n; Produces the name of the queue variable for the given tier and item.\n#queue_str \"cq\"\n#queue(tier, item) 10 * ({item}) + {tier} - 1\n\n; Raw access to the queue. Not preferred, but better than using \"queue\"\n; directly. Use for low-level optimization.\n#raw_name(name) {queue_str} . ({name})\n#get_raw(raw_item) global.double.get({raw_name(100 + {raw_item})})\n#set_raw(raw_item, value) global.double.set(\\\n  {raw_name(100 + {raw_item})}, \\\n  {value}\\\n)\n\n; Helper macros for operating on the craft_queue. These should be\n; used instead of direct access whenever possible.\n#get_queue(tier, item) {get_raw({queue({tier}, {item})})}\n#set_queue(tier, item, value) {set_raw({queue({tier}, {item})}, {value})}\n\n; Add/subtract a value from the queue. Although it expands to the\n; same thing, it saves a lot of boilerplate in the source and makes it\n; easier to understand what's going on.\n#add_queue(tier, item, value) {set_queue(\\\n  {tier}, {item},\\\n  {get_queue({tier}, {item})} + {value}\\\n)}\n#subtract_queue(tier, item, value) {set_queue(\\\n  {tier}, {item},\\\n  {get_queue({tier}, {item})} - ({value})\\\n)}\n\n; obtain the factory value of this name\n#get_factory.val(factory) {lua(return Factory.{factory})}\n#get_factory.len(factory) {lua(return #Factory.{factory})}\n\n; Used with factory.composite_string to extract the name from the\n; returned data.\n#get_name sub(itemdata, 0, index(itemdata, \" \", 0))\n\n; These macros can only be called *after* factory.composite_string,\n; i.e. later on in the script.\n#tiers_char sub(itemdata, {get_factory.val(entry_size)} - 1, 1)\n\n{lua(\\\n  local factory_item_limit = 89;\\\n  \\\n  Factory = {};\\\n  Factory.items = {};\\\n  Factory.item_names = {};\\\n  \\\n  Factory.prods = {};\\\n  Factory.prod_machines = {};\\\n  \\\n  Factory.categories = {};\\\n  Factory.group_map = {};\\\n  Factory.group_map.item = 0;\\\n  Factory.group_map.craft = 1;\\\n  Factory.group_map.group = 2;\\\n  Factory.group_map.special = 2; --[[Intentionally the same]]\\\n  \\\n  Factory.name_max_size = 0;\\\n  Factory.game_name_sizes = {};\\\n  Factory.game_name_sizes.item = 0;\\\n  Factory.game_name_sizes.craft = 0;\\\n  Factory.game_name_sizes.group = 0;\\\n  Factory.game_name_sizes.special = 0;\\\n  \\\n  function Factory.add_item(name, tiers, game_name, craft_type)\\\n    local item = {};\\\n    item.id = 1 + #Factory.items;\\\n    if item.id > factory_item_limit then\\\n      --[[throw an error if we got more items than we permit]]\\\n      error(string.format(\\\n        \"Too many items: cannot add more than %s items\", \\\n        factory_item_limit\\\n      ));\\\n    elseif tiers == 0 then \\\n      error(\"Items cannot have tier 0\");\\\n      --[[minimum tiers value we can manage is 1]]\\\n    end\\\n    local params = table.pack(name, game_name, tiers, craft_type);\\\n    local item_names = table.pack(\\\n      \"name\", \"game_name\", \\\n      \"tier\", \"craft_type\"\\\n    );\\\n    for i = 1, #params do\\\n      local val = params[i];\\\n      local val_name = item_names[i];\\\n      if val == nil then\\\n        error(string.format(\\\n          \"Trying to add an empty value '%s'\",\\\n          val_name\\\n        ));\\\n      end\\\n      item[val_name] = val;\\\n    end\\\n    Factory.items[item.id] = item;\\\n    Factory.item_names[name] = item;\\\n    \\\n    if #name > Factory.name_max_size then\\\n      Factory.max_name_size = #name;\\\n    end\\\n    if #game_name > Factory.game_name_sizes[craft_type] then\\\n      Factory.game_name_sizes[craft_type] = #game_name;\\\n    end\\\n    local const = \":const int factory.\" .. name .. \" \" .. item.id;\\\n    return const;\\\n  end\\\n  \\\n  function Factory.add_category(name, ...)\\\n    local category = {};\\\n    category.name = name;\\\n    local names = table.pack(\"default\", \"first\", \"last\");\\\n    local args = table.pack(...);\\\n    for i = 1, 3 do\\\n      local trimmed = args[i]:gsub(\"^ +\", \"\");\\\n      local item = Factory.item_names[trimmed];\\\n      if not item then\\\n        error(string.format(\"Can't find item '%s'\", trimmed));\\\n      end\\\n      category[names[i]] = item.id;\\\n    end\\\n    Factory.categories[1 + #Factory.categories] = category;\\\n  end\\\n  function Factory.composite_string(var, filter, use_group_info)\\\n    local acc = {};\\\n    local size = 0;\\\n    local first = #Factory.items;\\\n    local last = 0;\\\n    local group_map = Factory.group_map;\\\n    \\\n    if filter == nil then\\\n      size = math.max(\\\n        Factory.game_name_sizes[\"item\"], \\\n        Factory.game_name_sizes[\"craft\"]\\\n      );\\\n    else\\\n      size = Factory.game_name_sizes[filter];\\\n    end\\\n    size = size + 1;\\\n    local fmt = \"%-\" .. size .. \"s%d\";\\\n    size = size + 1;\\\n    acc[1] = 'sub(\"';\\\n    for items = 1, #Factory.items do\\\n      local item = Factory.items[items];\\\n      if filter == nil or item.craft_type == filter then\\\n        if use_group_info then\\\n          acc[1 + #acc] = string.format(\\\n            fmt,\\\n            item.game_name, group_map[item.craft_type]);\\\n        else\\\n          acc[1 + #acc] = fmt:format(item.game_name, item.tier - 1);\\\n        end\\\n        if items < first then first = items; end\\\n        if items > last then last = items; end\\\n      end\\\n    end\\\n    acc[#acc + 1] = '\", ' .. size .. \" * (\" .. var .. \"), \" .. size \\\n      .. ')';\\\n    Factory.items_count = last - first + 1;\\\n    Factory.entry_size = size;\\\n    return table.concat(acc);\\\n  end\\\n)}\n\n; Define a new production item with name \"name\", craftable\n; from tiers 1-\"tiers\".\n; The string passed to produce() is \"game_name\".\n; It will take the next available id, starting from 1.\n#item(name, tiers, game_name) {lua(\\\n  return Factory.add_item(\"{name}\", {tiers}, {game_name}, \"item\")\\\n)}\n\n; Define a new production item with name \"name\", craftable\n; from tiers 1-\"tiers\".\n; The string passed to craft() is \"game_name\".\n; It will take the next available id, starting from 1.\n#make(name, tiers, game_name) {lua(\\\n  return Factory.add_item(\"{name}\", {tiers}, {game_name}, \"craft\")\\\n)}\n\n; Define a new item group, i.e. a set of items designed to be scanned in\n; the crafter. Because items need a valid game_name to be\n; passed to count() in various places (or else there will be spurious\n; logging), we use \"ore\".\n; (The value returned from count() will always be ignored.)\n#group(name, tiers) {lua(\\\n  return Factory.add_item(\"{name}\", {tiers}, \"ore\", \"group\")\\\n)}\n\n; Defines a \"special\" item. This has a real name, like an item, but acts\n; like an item-group in other ways. This is used for lumps and ore, which\n; require special-case handling.\n#special(name, tiers, game_name) {lua(\\\n  return Factory.add_item(\"{name}\", {tiers}, {game_name}, \"special\")\\\n)}\n\n; Defines a category grouping for the UI. \"First\" and \"last\" are the span\n; of the group (inclusive), in item names.\n; Must be called *after* the relevant items are defined.\n#category(name, default, first, last) {lua(\\\n  Factory.add_category(\"{name}\", \"{default}\", \"{first}\", \"{last}\")\\\n)}\n"],["worker_storage_lib","; This library will find a slot in the pool of workers to use as\n; \"permanent storage\". If one doesn't already exist with the given tag,\n; a new one will be allocated, *but* it will avoid overwriting other\n; worker names using the same sytem of tags for storage.\n; Thus, scripts can use this to cooperate without having to\n; explicitly assign worker slot numbers.\n;\n; The scheme is that a name will be prefixed with \"[TOKEN]\", where \"TOKEN\"\n; is some short, unique word that will identify the script in question.\n; For instance, the factory might use the word \"factory\".\n;\n; This library does not actually store anything in the worker name.\n; Instead, it sets the variable \"worker_slot\", which you must declare in\n; your code. If worker_slot < 100, then it found a valid slot with the\n; worker_prefix. If 100 <= worker_slot < 200, then there was no existing\n; slot, but new data can be initialized at (worker_slot - 100).\n; If worker_slot == 200, then there are no available slots at all, and\n; you should show an error message or take approriate action.\n;\n; A complete example looks like this\n; (replace angle brackets with curlies):\n;\n; :local int worker_slot\n; <worker_lib_line_1([TOKEN])>\n; <worker_lib_line_2>\n\n; =======================================================================\n\n#worker_prefix {lua(return worker_lib_prefix)}\n#worker_lacks_prefix sub(\\\n  worker.name(worker_slot), \\\n  0, \\\n  {len({worker_prefix})}\\\n) != \"{worker_prefix}\"\n\n; The first macro, which defines the first line and the loop variable\n; that we jump to. We also store the worker_prefix with Lua, so that\n; we don't need to repeat it on the 2nd macro.\n; We don't want to skip slot 0. Doing it like this saves a line.\n#worker_lib_line_1(worker_prefix_arg) {lua(\\\n  worker_lib_prefix = \"{worker_prefix_arg}\"\\\n)}\\\nfind_worker_slot_loop: \\\nworker_slot = worker_slot + if({worker_lacks_prefix}, 1, 0)\n\n; The second macro, which iterates until we're done.\n; The test against worker.group() checks for non-existant workers.\n; They would otherwise show as acceptable candidates, and we need to\n; keep iterating to 200 in that case.\n#worker_lib_line_2 gotoif(\\\n  find_worker_slot_loop,\\\n  worker_slot < 100 && {worker_lacks_prefix} ||\\\n  worker_slot >= 100 && worker_slot < 200 && (\\\n    worker.group(worker_slot - 100) == -1 || \\\n    contains(sub(worker.name(worker_slot - 100), 0, 1), \"[\")\\\n  )\\\n)\n"],["recipes",":import factory constants\n\n{lua(\\\n  Factory.recipes = {};\\\n  Factory.recipe_item = {};\\\n)}\n\n; Infrastructure for defining the recipe list.\n{lua(\\\n  function Factory.recipe(item)\\\n    local recipe_item = Factory.item_names[item];\\\n    \\\n    if recipe_item == nil then\\\n      error(string.format(\"Unknown item '%s'\", item));\\\n    elseif recipe_item.recipes ~= nil then\\\n      error(string.format(\"Duplicate recipe for '%s'\", item));\\\n    end\\\n    \\\n    Factory.recipe_item = recipe_item;\\\n    local offset = 10 * recipe_item.id;\\\n    --[[/*\\\n        * There are two types of recipe list that we store:\\\n        * A \"forward\" list stored on the item itself, which records what\\\n        * items are needed to *make* that item, and a \"reverse\" list\\\n        * stored on the main factory object and indexed by queue id,\\\n        * which records what items can be *made from* the item.\\\n        * The forward list is used by the item group system, while the \\\n        * reverse list is used by the recipe system proper.\\\n       */]]\\\n    for i = offset, offset + recipe_item.tier - 1 do\\\n      if Factory.recipes[i] == nil then\\\n        Factory.recipes[i] = {};\\\n      end\\\n    end\\\n    recipe_item.recipes = {};\\\n    for i = 1, recipe_item.tier do \\\n      recipe_item.recipes[i] = {};\\\n    end\\\n  end\\\n  \\\n  function Factory.component(tiers, item_name, counts)\\\n    local recipe_item = Factory.recipe_item;\\\n    if recipe_item == nil then\\\n      error(\"Tried to define a component before calling recipe!\", 0);\\\n    end\\\n    local name = item_name:gsub(\" \", \"\");\\\n    local item = Factory.item_names[name];\\\n    if not item then\\\n      error(string.format(\"Unknown item '%s'\", name))\\\n    end\\\n    \\\n    if item.craft_type == \"group\" then\\\n      error(string.format(\\\n        [[Cannot add item \"%s\" because it is a group]],\\\n        item.name\\\n      ));\\\n    end\\\n    local tier_tmp = {};\\\n    for word in tiers:gmatch(\"%S+\") do\\\n      local tier = tonumber(word);\\\n      if tier == nil then error(string.format(\"Bad tier '%s'\", word)) end\\\n      tier_tmp[1 + #tier_tmp] = tier;\\\n    end\\\n    if #tier_tmp ~= 1 and #tier_tmp ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Tiers list has wrong size, item %s has %s tiers\",\\\n        recipe_item.name, recipe_item.tier\\\n      ));\\\n    end\\\n    local base_tier;\\\n    for tier = 1, recipe_item.tier do\\\n      base_tier = tier_tmp[tier] or base_tier;\\\n      local tmp_tier = base_tier;\\\n      tier_tmp[tier] = tmp_tier < 1 and (tmp_tier + tier) or tmp_tier;\\\n    end\\\n    \\\n    local counts_tmp = {};\\\n    for word in counts:gmatch(\"%S+\") do\\\n      local count = tonumber(word);\\\n      if count == nil then\\\n        error(string.format(\"Bad count '%s'\", word));\\\n      end\\\n      counts_tmp[1 + #counts_tmp] = count;\\\n    end\\\n    \\\n    if #counts_tmp ~= 1 and #counts_tmp ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Counts ist has wrong size, item %s has %s tiers\",\\\n        recipe_item.name, recipe_item.tier\\\n      ));\\\n    end\\\n    \\\n    for i = 1 + #counts_tmp, recipe_item.tier do\\\n      counts_tmp[i] = counts_tmp[i - 1];\\\n    end\\\n    --[[/*\\\n        * Finally, merge the two expanded lists and distribute\\\n        * the results across the recipes for each tier. These recipes are\\\n        * \"reversed\", in the sense that they don't describe how to make\\\n        * each item, but rather all the items that this one can be used\\\n        * to help make.\\\n        * It's this reversed list that is needed for computing\\\n        * the material needs when crafting.\\\n       */]]\\\n    local recipes = Factory.recipes;\\\n    local offset = recipe_item.id * 10 - 1;\\\n    \\\n    local function tier_n_count_merge(item_tier)\\\n      local tier = tier_tmp[item_tier];\\\n      local count = counts_tmp[item_tier];\\\n      if count <= 0 or tier <= 0 then return; end\\\n      --[[/*\\\n          * Tiers less than 1 can happen naturally, due to the negative\\\n          * tier convention, so they are silently dropped.\\\n          * Tiers greater than the maximum number of tiers are an error\\\n         */]]\\\n      if tier > item.tier then\\\n        error(string.format(\\\n          \"Tier %s > item max tier %s\", \\\n          tier, item.tier\\\n        ));\\\n      end\\\n      local idx = item.id * 10 + tier - 1;\\\n      local comp = recipes[idx];\\\n      if comp == nil then\\\n        comp = {};\\\n        recipes[idx] = comp;\\\n      end\\\n      \\\n      comp[1 + #comp] = offset + item_tier;\\\n      comp[1 + #comp] = count;\\\n      local item_recipe = recipe_item.recipes[item_tier];\\\n      item_recipe[1 + #item_recipe] = idx;\\\n      item_recipe[1 + #item_recipe] = count;\\\n    end\\\n    \\\n    for i = 1, recipe_item.tier do \\\n      tier_n_count_merge(i);\\\n    end\\\n  end\\\n  \\\n  function Factory.produce(item, source, mult, machine)\\\n    local recipe_item = Factory.item_names[item];\\\n    \\\n    if not recipe_item then\\\n      error(string.format(\"Unknown item '%s'\", item));\\\n    elseif recipe_item.recipes ~= nil then\\\n      error(string.format(\"Duplicate recipe for '%s'\", item));\\\n    end\\\n    \\\n    local source_item = Factory.item_names[source];\\\n    if not source_item then\\\n      error(string.format(\"Unknown item '%s'\", source));\\\n    elseif source_item.tier ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Tier mismatch: %s(%s) vs %s (%s)\",\\\n        source, source_item.tier, item, recipe_item.tier\\\n      ));\\\n    end\\\n    do\\\n      local prods = Factory.prods;\\\n      if #prods == 0 or prods[#prods].machine ~= machine then\\\n        if Factory.prod_machines[machine] ~= nil then\\\n          error(\"Found 2nd group for machine '\" .. machine .. \"'\", 0);\\\n        end\\\n        Factory.prod_machines[machine] = 1 + #prods;\\\n        Factory.prod_machines[1 + #Factory.prod_machines] = machine;\\\n      end\\\n    end\\\n    local prod = {};\\\n    prod.item = recipe_item;\\\n    prod.source = source_item;\\\n    prod.mult = mult;\\\n    prod.machine = machine;\\\n    Factory.prods[1 + #Factory.prods] = prod;\\\n    \\\n    local offset = 10 * source_item.id;\\\n    local count = 1 / mult;\\\n    for i = offset, offset + recipe_item.tier - 1 do\\\n      if Factory.recipes[i] == nil then\\\n        Factory.recipes[i] = {};\\\n      end\\\n      local recipe = Factory.recipes[i];\\\n      recipe[1 + #recipe] = 10 * recipe_item.id - offset + i;\\\n      recipe[1 + #recipe] = count;\\\n    end\\\n    recipe_item.recipes = {};\\\n    for i = 1, recipe_item.tier do\\\n      local recipe = {};\\\n      recipe[1] = offset + i - 1;\\\n      recipe[2] = count;\\\n      recipe_item.recipes[i] = recipe;\\\n    end\\\n  end\\\n)}\n\n; Every recipe begins with this line. There must be one (and only one)\n; recipe declaration for each item, even if there is no way to make it\n; (like for rubber).\n#recipe(item) {lua(Factory.recipe([[{item}]]))}\n\n; After starting a recipe, list its components with this. A component\n; declares a single item that is used, and the the tiers and counts of\n; that item for each tier of the recipe_item that's being made.\n; The list on the left side is the tiers, the list on the right is\n; the counts.\n;\n; For instance:\n;  recipe(white_producer)\n;  component(2 3 5 7 9, screw, 2 4 4 4 4)\n; Means that\n; - T1 white_producer needs 2 T2 screws,\n; - T2 white_producer needs 4 T3 screws,\n; - T3 requires 4 T5 screws, etc.\n; \n; There are additional space-saving wrinkles. Instead of repeating\n; a number for every tier or every count when it's always the same, you\n; can list it once. This is all-or-nothing: It must be exactly once, or\n; listed once for every tier in the recipe.\n; Also, in the tier list you can use numbers less than 1. This means that\n; the position in the list will be added to the number. I.e. a value of\n; 0 becomes equal to \"current_tier\", -1 becomes \"current_tier - 1\", etc.\n#component(tiers, item, counts) {lua(Factory.component(\\\n  [[{tiers}]],\\\n  [[{item}]],\\\n  [[{counts}]]\\\n))}\n\n; For items that are made in machines, use this macro instead.\n; This defines the needed recipe automatically. The third argument is the\n; \"multiplier\", which says how many multiples of the item are made from\n; a single source input.\n; It is assumed that the production happens for all tiers of the item,\n; from the same source tier; things like mixing or boiling dust aren't\n; handled through this system. (Boiling isn't handled at all.)\n#produce(item, source, mult, machine) {lua(Factory.produce(\\\n  [[{item}]],\\\n  string.gsub([[{source}]], \" \", \"\"),\\\n  {mult},\\\n  string.gsub([[{machine}]], \" \", \"\")\\\n))}\n\n; ===== BEGIN RECIPES =====\n\n{recipe(town_producer)}\n{component(2 3 5 7 9, screw, 2 4 4 4 4)}\n{component(2 0 0 0 0, plate, 2 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 2 2 2 6)}\n{component(-1, chip, 0 2 2 2 4)}\n{component(-1, town_producer, 1)}\n\n{recipe(factory_producer)}\n{component(1 3 5 7 9, wire, 1 4 4 4 4)}\n{component(2 0 0 0 0, screw, 1 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 1 1 1 3)}\n{component(2 3 5 0 0, plate, 2 2 2 0 0)}\n{component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}\n{component(1 1 2 3 4, chip, 2 1 1 1 3)}\n{component(-1, factory_producer, 1)}\n\n{recipe(mine_producer)}\n{component(2 3 5 7 9, screw, 2 2 2 4 4)}\n{component(1 2 4 6 8, wire, 2 3 2 5 5)}\n{component(2 0 5 7 9, plate, 1 0 1 2 2)}\n{component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}\n{component(1 1 2 3 4, chip, 1)}\n{component(-1, mine_producer, 1)}\n\n{recipe(workshop_producer)}\n{component(0 2 4 6 8, wire, 0 4 2 8 8)}\n{component(1 3 5 7 9, wire, 4 2 2 2 2)}\n{component(2 3 5 7 9, plate, 1 2 2 2 2)}\n{component(1 0 2 3 4, chip, 1 0 2 2 2)}\n{component(-1, workshop_producer, 1)}\n\n{recipe(construction_firm_producer)}\n{component(2 4 6 8 10, rod, 3 4 10 10 10)}\n{component(2 4 6 8 10, plate, 2)}\n{component(1 1 2 3 4, chip, 1 2 2 2 2)}\n{component(-1, construction_firm_producer, 1)}\n\n{recipe(laboratory_producer)}\n{component(0 3 5 7 9, pipe, 0 3 5 10 14)}\n{component(2 4 6 8 10, motor, 1)}\n{component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, laboratory_producer, 1)}\n\n{recipe(headquarters_producer)}\n{component(1 3 5 7 9, wire, 2 4 8 8 12)}\n{component(2 4 6 8 10, motor, 1 2 2 2 2)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, headquarters_producer, 1)}\n\n{recipe(powerplant_producer)}\n{component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}\n{component(2 4 6 8 10, motor, 1)}\n{component(0 3 5 7 9, block, 0 3 5 5 14)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, powerplant_producer, 1)}\n\n{recipe(arcade_producer)}\n{component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}\n{component(2 4 6 8 10, pipe, 4 4 4 4 8)}\n{component(0, chip, 4 4 4 4 6)}\n{component(-1, arcade_producer, 1)}\n\n{recipe(tradingpost_producer)}\n{component(2 4 6 8 10, ring, 6 8 8 8 12)}\n{component(2 4 6 8 10, plate, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, tradingpost_producer, 1)}\n\n{recipe(shipyard_producer)}\n{component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}\n{component(1 3 5 7 9, block, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, shipyard_producer, 1)}\n\n{recipe(museum_producer)}\n{component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}\n{component(2 4 6 8 10, block, 4 5 5 5 7)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, museum_producer, 1)}\n\n{recipe(statue_of_cubos_producer)}\n{component(1 3 5 7 9, dense_block, 4 5 5 5 7)}\n{component(2 4 6 8 10, motor, 2)}\n{component(2 4 6 8 10, pipe, 2)}\n{component(2 4 6 8 10, pump, 2 3 3 3 5)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, statue_of_cubos_producer, 1)}\n\n{recipe(gem_producer)}\n{component(5, chip, 10)}\n{component(4, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(1, dense_block, 1)}\n{component(2, dense_block, 1)}\n{component(3, dense_block, 1)}\n{component(4, dense_block, 1)}\n{component(5, dense_block, 1)}\n{component(6, dense_block, 1)}\n{component(7, dense_block, 1)}\n{component(8, dense_block, 1)}\n{component(9, dense_block, 1)}\n{component(10, dense_block, 1)}\n\n{recipe(exotic_producer)}\n{component(5, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(10, dense_block, 10)}\n{component(10, assembly, 1)}\n{component(10, boiler, 1)}\n{component(10, crusher, 1)}\n{component(10, cutter, 1)}\n{component(10, mixer, 1)}\n{component(10, oven, 1)}\n{component(10, presser, 1)}\n{component(10, refiner, 1)}\n{component(10, shaper, 1)}\n{component(10, belt, 1)}\n\n{recipe(acceleration_booster)}\n{component(2 3 5, chip, 1 4 6)}\n{component(4, plate, 4 0 0)}\n{component(1, rainbow_plate, 0 2 4)}\n{component(4 8 0, circuit, 4 8 0)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, acceleration_booster, 2)}\n\n{recipe(machine_booster)}\n{component(2 3 5, chip, 2)}\n{component(4 7 10, pipe, 4)}\n{component(4, wire, 2 0 0)}\n{component(0 7 10, dense_block, 0 2 2)}\n{component(8, dense_plate, 0 6 0)}\n{component(1, rainbow_plate, 0 0 4)}\n{component(1, void_essence, 0 0 2)}\n{component(4, circuit, 1 0 0)}\n{component(-1, machine_booster, 1)}\n\n{recipe(production_booster)}\n{component(1 3 0, chip, 4 4 0)}\n{component(2 7 0, plate, 4 6 0)}\n{component(2 7 10, circuit, 1 4 4)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, production_booster, 0 1 4)}\n\n{recipe(resource_booster)}\n{component(3, plate, 6 0 0)}\n{component(1, rainbow_plate, 0 0 2)}\n{component(1 3 4, chip, 2 2 6)}\n{component(4 8 0, circuit, 1 2 0)}\n{component(0 7 10, block, 0 4 4)}\n{component(1, void_essence, 0 0 1)}\n{component(-1, resource_booster, 0 1 2)}\n\n{recipe(tree_booster)}\n{component(7, block, 0 2 0)}\n{component(2 0 5, chip, 1 0 2)}\n{component(5 7 0, screw, 6 2 0)}\n{component(5, ring, 2 0 0)}\n{component(7, plate, 0 2 0)}\n{component(7, pipe, 0 2 0)}\n{component(1, rainbow_plate, 0 0 2)}\n{component(1, rubber_sapling, 6 0 0)}\n{component(1, void_sapling, 0 0 6)}\n{component(1, void_essence, 0 0 10)}\n{component(-1, tree_booster, 1)}\n\n{recipe(pumpkin_producer)}\n{component(0, carved_pumpkin, 6)}\n{component(0, anti_pumpkin, 6)}\n{component(0, pumpkin_plate, 20)}\n\n{recipe(oven)}\n{component(0, plate, 4 6 8 8 8 8 8 8 8 8)}\n{component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}\n{component(0, block, 0 0 0 0 0 2 2 2 2 2)}\n{component(-1, oven, 1)}\n\n{recipe(presser)}\n{component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}\n{component(0, plate, 4 5 7 7 7 9 9 9 9 9)}\n{component(0, wire, 1 1 2 2 2 3 3 3 3 3)}\n{component(0, block, 0 0 0 0 4 5 5 5 5 5)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 2)}\n{component(-1, presser, 1)}\n\n{recipe(assembly)}\n{component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}\n{component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}\n{component(0, motor, 1 1 1 1 1 1 1 1 2 2)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}\n{component(-1, assembly, 1)}\n\n{recipe(refiner)}\n{component(0, block, 0 0 0 0 0 0 5 5 5 7)}\n{component(0, dense_plate, 4)}\n{component(0, motor, 1 1 1 1 2 2 2 2 2 4)}\n{component(0, ring, 1 2 2 2 3 3 3 3 3 5)}\n{component(0, pump, 1 2 2 2 3 3 3 3 3 5)}\n{component(1 1 2 2 2 2 3 4 4 5, chip, 2)}\n{component(-1, refiner, 1)}\n\n{recipe(mixer)}\n{component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}\n{component(0, motor, 2)}\n{component(0, pump, 1 1 1 2 2 3 3 3 3 3)}\n{component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}\n{component(-1, mixer, 1)}\n\n{recipe(crusher)}\n{component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}\n{component(0, motor, 1 1 1 1 1 1 1 2 2 2)}\n{component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}\n{component(-1, crusher, 1)}\n\n{recipe(belt)}\n{component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}\n{component(0, motor, 3 3 3 3 3 3 4 4 4 4)}\n{component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}\n{component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}\n{component(-1, belt, 1)}\n\n{recipe(cutter)}\n{component(0, plate, 2 2 2 2 2 2 2 0 0 0)}\n{component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}\n{component(0, block, 0 0 0 0 0 0 0 4 4 6)}\n{component(0, motor, 3 4 4 4 4 5 5 5 5 7)}\n{component(-1, cutter, 1)}\n\n{recipe(shaper)}\n{component(0, plate, 4 4 4 4 4 4 4 4 4 0)}\n{component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}\n{component(0, screw, 1 2 2 2 2 3 3 3 3 3)}\n{component(0, block, 1 2 2 2 2 3 3 3 3 0)}\n{component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}\n{component(0, motor, 2)}\n{component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}\n{component(-1, shaper, 1)}\n\n{recipe(boiler)}\n{component(0, wire, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, block, 4 7 7 8 8 8 8 8 9 10)}\n{component(0, motor, 1 1 1 2 2 2 2 2 3 4)}\n{component(0, screw, 2)}\n{component(0, pump, 1)}\n{component(-1, boiler, 1)}\n\n{recipe(rainbow_dust)}\n{component(1, dust, 1)}\n{component(2, dust, 1)}\n{component(3, dust, 1)}\n{component(4, dust, 1)}\n{component(5, dust, 1)}\n{component(6, dust, 1)}\n{component(7, dust, 1)}\n{component(8, dust, 1)}\n{component(9, dust, 1)}\n{component(10, dust, 1)}\n\n{recipe(chip)}\n{component(1 3 5 7 9, circuit, 2)}\n{component(2 4 6 8 10, circuit, 2 4 4 2 2)}\n{component(1 3 5 7 9, board, 1 4 4 6 8)}\n{component(2 4 6 8 10, board, 1 2 2 6 8)}\n{component(-1, chip, 0 4 8 12 12)}\n\n{recipe(insul_cable)}\n{component(0, cable, 1 1 1 2 3 4 5 10 12 16)}\n{component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}\n\n{recipe(stacked_plate)}\n{component(0, plate, 9)}\n\n{recipe(stacked_pumpkin)}\n{component(0, pumpkin, 9)}\n\n{recipe(motor)}\n{component(0, plate, 4)}\n{component(0, screw, 1)}\n{component(0, rod, 2)}\n{component(0, wire, 1)}\n{component(1, rubber, 1)}\n\n{recipe(pump)}\n{component(0, plate, 2)}\n{component(0, motor, 1)}\n{component(0, ring, 2)}\n{component(1, rubber_plate, 4)}\n\n{recipe(hammer)}\n{component(2, ingot, 6)}\n{component(2, rod, 1)}\n\n{recipe(block)}\n{component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}\n\n{recipe(rubber_sapling)}\n{component(0, rubber, 8)}\n{component(9, ore, 1)}\n\n{recipe(void_sapling)}\n{component(1, rainbow_dust, 8)}\n{component(1, rubber_sapling, 1)}\n\n{recipe(producers)}\n#recipe_producers(x) \\\n{component(0, town_producer, {x})}\\\n{component(0, factory_producer, {x})}\\\n{component(0, mine_producer, {x})}\\\n{component(0, workshop_producer, {x})}\\\n{component(0, construction_firm_producer, {x})}\\\n{component(0, laboratory_producer, {x})}\\\n{component(0, headquarters_producer, {x})}\\\n{component(0, powerplant_producer, {x})}\\\n{component(0, arcade_producer, {x})}\\\n{component(0, tradingpost_producer, {x})}\\\n{component(0, shipyard_producer, {x})}\\\n{component(0, museum_producer, {x})}\\\n{component(0, statue_of_cubos_producer, {x})}\n{recipe_producers(1)}\n\n{recipe(machines)}\n{component(0, oven, 1)}\n{component(0, presser, 1)}\n{component(0, assembly, 1)}\n{component(0, refiner, 1)}\n{component(0, mixer, 1)}\n{component(0, crusher, 1)}\n{component(0, belt, 1)}\n{component(0, cutter, 1)}\n{component(0, shaper, 1)}\n{component(0, boiler, 1)}\n\n{recipe(parts)}\n#recipe_parts \\\n{component(0, insul_cable, 1)}\\\n{component(0, stacked_plate, 1)}\\\n{component(0, motor, 1)}\\\n{component(0, pump, 1)}\\\n{component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, block, 1)}\\\n{component(0, ingot, 1)}\\\n{component(0, plate, 1)}\\\n{component(0, dense_plate, 1)}\\\n{component(0, dense_block, 1)}\\\n{component(0, pipe, 1)}\\\n{component(0, cable, 1)}\\\n{component(0, wire, 1)}\\\n{component(0, rod, 1)}\\\n{component(0, ring, 1)}\\\n{component(0, screw, 1)}\\\n{component(0, board, 1)}\\\n{component(0, circuit, 1)}\\\n{component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\\\n{component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}\n{recipe_parts}\n\n{recipe(chips)}\n{component(1, chip, 1)}\n{component(2, chip, 1)}\n{component(3, chip, 1)}\n{component(4, chip, 1)}\n{component(5, chip, 1)}\n\n{recipe(chip_and_prods)}\n{component(0, chip, 1)}\n{recipe_producers(1)}\n\n#recipe_machines_and_parts \\\n{component(0, oven, 1)}\\\n{component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\\\n{component(0, assembly, 1)}\\\n{component(0, refiner, 1)}\\\n{component(0, mixer, 1)}\\\n{component(0, crusher, 1)}\\\n{component(0, belt, 1)}\\\n{component(0, cutter, 1)}\\\n{component(0, shaper, 1)}\\\n{component(0, boiler, 1)}\\\n{recipe_parts}\n\n{recipe(all)}\n{component(0, chip, 1 1 1 1 1 0 0 0 0 0)}\n{recipe_producers(1 1 1 1 1 0 0 0 0 0)}\n{recipe_machines_and_parts}\n\n; Machine-produced items\n{produce(rainbow_ingot, rainbow_dust, 1, oven)}\n\n{produce(plate, ingot, 1, presser)}\n{produce(rainbow_plate, rainbow_ingot, 1, presser)}\n{produce(dense_plate, stacked_plate, 1, presser)}\n{produce(rubber_plate, rubber, 1, presser)}\n{produce(pumpkin_plate, stacked_pumpkin, 1, presser)}\n\n{produce(dense_block, block, 1, boiler)}\n{produce(anti_pumpkin, pumpkin, 1, boiler)}\n\n{produce(rod, ingot, 2, shaper)}\n{produce(pipe, plate, 1, shaper)}\n{produce(ring, rod, 1, shaper)}\n\n{produce(cable, ingot, 2, refinery)}\n{produce(board, plate, 1, refinery)}\n{produce(wire, cable, 1, refinery)}\n\n{produce(screw, rod, 4, cutter)}\n{produce(carved_pumpkin, pumpkin, 1, cutter)}\n\n{produce(circuit, cable, 1, assembler)}\n\n; These recipes have special-case code to handle them,\n; because of the complexities involved with choosing\n; between ore and lumps for making dust.\n{recipe(dust)}\n{recipe(lump)}\n{recipe(ingot)}\n\n; Terminal items, unable to be crafted.\n{recipe(ore)}\n{recipe(crushable_ore)}\n{recipe(mixable_lump)}\n{recipe(rubber)}\n{recipe(void_essence)}\n{recipe(pumpkin)}\n\n; ===== END RECIPES =====\n\n; Check every item to make sure each one has a recipe\n{lua(\\\n  for i = 1, #Factory.items do\\\n    if not Factory.items[i].recipes then\\\n      local item = Factory.items[i];\\\n      error(string.format(\\\n        \"%s(%s) has no assigned recipe!\", \\\n        item.name, item.id\\\n      ));\\\n    end\\\n  end\\\n)}\n"],["run_recipes",":import recipes\n:name {script_name(run_recipes)}\n:budget_cap 1\n; script only has atomic functions,\n; no infinite loop is possible\n\n; Debugging function, kept in case of future problems.\n; enable by changing the `if true then` to `if false then`\n{lua(\\\n  if true then return; end\\\n  local acc = {};\\\n  acc[1] = \"\\n\";\\\n  for i = 1, #Factory.items do\\\n    local item = Factory.items[i];\\\n    acc[1 + #acc] = string.format(\"%02d %-25s [\", i, item.name);\\\n    for tier = 1, item.tier do\\\n      acc[#acc + 1] = string.format(\"\\n%5s\", \"\");\\\n      acc[1 + #acc] = \"(\";\\\n      local recipes = Factory.recipes[i * 10 + tier - 1];\\\n      assert(recipes, table.concat(acc));\\\n      for recipe = 1, #recipes do\\\n        if recipe ~= 1 then acc[1 + #acc] = \" \"; end\\\n        acc[1 + #acc] = string.format(\"%03f\", recipes[recipe]);\\\n      end\\\n      acc[1 + #acc] = \")\";\\\n    end\\\n    acc[1 + #acc] = \"\\n]\\n\";\\\n  end\\\n  if true then return; end\\\n  error(table.concat(acc), 0);\\\n)}\n\n; Now that all the recipes are defined, we have to put them in a\n; valid order. We do this with a modified breadth-first-search, optimized\n; around the structure of our data. Each item (which in this context is\n; a type-tier pair, identified by the formula type * 10 + tier) is\n; sequentially checked against a graph that is incrementally being formed.\n; If all its recipe-items have already been satisfied (or it has none),\n; then it is also satisfied, and (as long as it has recipe-items) it's put\n; on a queue to be output. Otherwise, a count is kept of how many\n; unsatisfied recipes it has, and an entry is made in each blocking recipe\n; pointing back to this item. After each item, the queue is processed.\n; The head of the queue is popped and gets the next sequential id\n; this is how the recipes get their order. Also, any items blocked on it\n; will have their tallies decremented by one. If these go to zero,\n; they are now satisfied and will be added to the queue to be output,\n; as well.\n{lua(\\\n  local recipes_list = {};\\\n  Factory.recipes_list = recipes_list;\\\n  local items = Factory.items;\\\n  local recipes = Factory.recipes;\\\n  local graph = {};\\\n  local queue = {};\\\n  \\\n  local function analyze(id)\\\n    local recipe = recipes[id];\\\n    \\\n    --[[stop analyzing item if it doesn't have a recipe]]\\\n    if not recipe then return; end\\\n    \\\n    local entry = graph[id];\\\n    if not entry then\\\n      entry = {};\\\n      entry.blocking = {};\\\n      graph[id] = entry;\\\n    end\\\n    local blockers = 0;\\\n    \\\n    for i = 1, #recipe, 2 do\\\n      local other = graph[recipe[i]];\\\n      if not other then\\\n        other = {};\\\n        other.blocking = {};\\\n        other.blockers = -1;\\\n        graph[recipe[i]] = other;\\\n      end\\\n      if other.blockers ~= 0 then\\\n        blockers = blockers + 1;\\\n        other.blocking[#other.blocking + 1] = id;\\\n      end\\\n    end\\\n    entry.blockers = blockers;\\\n    if blockers == 0 then\\\n      queue[1 + #queue] = id;\\\n    end\\\n    \\\n    local q_front = 1;\\\n    while q_front <= #queue do\\\n      local id = queue[q_front];\\\n      entry = graph[id];\\\n      recipes_list[1 + #recipes_list] = id;\\\n      for i = 1, #entry.blocking do\\\n        local other = graph[entry.blocking[i]];\\\n        other.blockers = other.blockers - 1;\\\n        if other.blockers == 0 then\\\n          queue[1 + #queue] = entry.blocking[i];\\\n        end\\\n      end\\\n      q_front = 1 + q_front;\\\n    end\\\n    queue = {};\\\n  end\\\n  \\\n  for tier = 10, 1, -1 do\\\n    for i = 1, #items do\\\n      analyze(10 * i + tier - 1);\\\n    end\\\n  end\\\n)}\n\n; Debugging function, kept in case of future problems.\n; enable by changing the `if true then` to `if false then`\n{lua(\\\n  if true then return; end\\\n  local acc = {};\\\n  acc[1] = \"\\n\";\\\n  for list = 1, #Factory.recipes_list do\\\n    local id = Factory.recipes_list[list];\\\n    acc[1 + #acc] = string.format(\"%03d:\", id);\\\n    local recipes = Factory.recipes[id];\\\n    for i = 1, #recipes do\\\n      acc[1 + #acc] = string.format(\" %03f\", recipes[i]);\\\n    end\\\n    acc[1 + #acc] = \"\\n\";\\\n  end\\\n  if true then return; end\\\n  \\\n  error(table.concat(acc), 0);\\\n)}\n\n; Constructs the data table that is used to create loop_data. See below\n; for the format of this string. One difference is that in loop_data, \n; the previous item/current item index data is at the beginning and end\n; of the string. Here, that is actually only stored once, and the sub()\n; read window is expanded to overlap consequetive sections to pick up\n; the previous item when reading the next.\n#get_data(num_terms) {lua(\\\n  local num_terms = tonumber({num_terms});\\\n  assert(num_terms, \"Inputed num_terms of get_data is not a number\");\\\n  local num_terms_2 = num_terms * 2;\\\n  local recipe_limit = 0;\\\n  local acc_main = {};\\\n  \\\n  local multipliers = \"0123a   b   c   d   e   f   g   h   i   j   k\\\n   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z\";\\\n  --[[letters from a to z with 3 spaces inbetween]]\\\n  \\\n  local mult_max = {};\\\n  for i = 1, num_terms do\\\n    mult_max[i] = 0;\\\n  end\\\n  acc_main[1] = [[\"___]];\\\n  \\\n  for list = 1, #Factory.recipes_list do\\\n    local id = Factory.recipes_list[list];\\\n    local recipes = Factory.recipes[id];\\\n    local item_id = id // 10;\\\n    local limit = math.max(0, (#recipes - 1) // num_terms_2);\\\n    for i = 1, num_terms_2 * (limit + 1), 2 do\\\n      if i < #recipes then\\\n        acc_main[1 + #acc_main] = recipes[i] + 100;\\\n      else\\\n        acc_main[1 + #acc_main] = \"   \";\\\n        --[[3 spaces to mark the end of a list of recipes]]\\\n      end\\\n      local mod = 1 + (i // 2) % num_terms;\\\n      local mult = (i < #recipes) and 4 * recipes[i + 1] or 0;\\\n      if mult > mult_max[mod] then mult_max[mod] = mult; end\\\n      \\\n      acc_main[1 + #acc_main] = multipliers:sub(mult + 1, mult + 1);\\\n      --[[extract just 1 character]]\\\n      if mod == num_terms then\\\n        acc_main[1 + #acc_main] = id + 100;\\\n        recipe_limit = 1 + recipe_limit;\\\n      end\\\n    end\\\n  end\\\n  \\\n  Factory.main_size = 4 * num_terms + 3;\\\n  acc_main[#acc_main + 1] = [[\"]];\\\n  Factory.multipliers = {};\\\n  Factory.num_terms = num_terms;\\\n  Factory.recipe_limit = recipe_limit;\\\n  for i = 1, num_terms do\\\n    if mult_max[i] >= #multipliers then\\\n      return \"Multiplier limit exceeded at \" .. i;\\\n    end\\\n    Factory.multipliers[i] = multipliers:sub(1, mult_max[i] + 1);\\\n  end;\\\n  return table.concat(acc_main);\\\n)}\n\n#lookup_item {lua(\\\n  return Factory.composite_string(\\\n    string.format(\\\n      [[s2i(sub(gsg(data_name), %d * (i + 1), 2), -1) - 11]],\\\n      Factory.main_size\\\n    ),\\\n    nil,\\\n    true --[[Get craft type info instead of tiers]]\\\n  );\\\n)}\n\n; Returns the set of lookup/multiplier terms that will be added\n; in to form the base of the value.\n; Most of the data for this is pre-comupted by get_data().\n#recipe_terms {lua(\\\n  acc = {};\\\n  for i = 1, Factory.num_terms do\\\n    if i ~= 1 then\\\n      acc[#acc + 1] = \" + \";\\\n    end\\\n    acc[#acc + 1] = string.format(\\\n      [[max(0.0, ceil(gdg({raw_name(sub(loop_data, %d, 3))}) *\\\n        i2d(index(\"%s\", sub(loop_data, %d, 1), 0)) * 0.25))]],\\\n      Factory.entry_size + 4 * i - 1,\\\n      Factory.multipliers[i],\\\n      Factory.entry_size + 4 * i + 2\\\n    );\\\n  end\\\n  return table.concat(acc);\\\n)}\n\n; This macro is used to test the type of an item, in order to efficiently\n; disable the count. Item groups don't have a single real item associated,\n; but the count() still has to count something real to avoid a spurious\n; log line. Ore and lumps are also classified as groups so that they won't\n; be counted, because they're treated specially.\n#item_type sub(loop_data, {get_factory.val(entry_size)} - 1, 1)\n\n; These macros are used to test if the item is a dust.\n; Dust gets its queue value inflated by one, which has the effect\n; of always ending up with 1 at the end.\n; (Although it doesn't prevent temporarily using all dust.)\n#recipe_item_trunc sub(\\\n  loop_data, \\\n  {get_factory.val(entry_size)} + {get_factory.val(main_size)}, \\\n  2\\\n)\n#item_trunc(item) \"{get_factory.val(item_names[\"{item}\"].id + 10)}\"\n\n#prev_item sub(loop_data, {get_factory.val(entry_size)}, 3)\n#recipe_item sub(\\\n  loop_data, \\\n  {get_factory.val(entry_size)} + {get_factory.val(main_size)}, \\\n  3\\\n)\n; The tier value is just the last digit of recipe_item\n#tier_value sub(\\\n  loop_data, \\\n  2 + {get_factory.val(entry_size)} + {get_factory.val(main_size)}, \\\n  1\\\n)\n#recipe_item_name sub(loop_data, 0, index(loop_data, \" \", 0))\n\n:global int factory_target\n:global double factory_target_amount\n\n; We use the name of the data variable to pull double-duty as a\n; hider for all the craft-queue variables.\n; This gives a prettier name for the global data string.\n:const string data_name \"<size=0><line-height=0>fdata\"\n\n:local int i\n:local string loop_data\n\n; Uncomment this for debugging. It needs to be before\n; the data-hiding block.\n; Also uncomment the line below.\ngss(\"debug\", \"\")\n\ngss(data_name, {get_data(4)})\nloop:\n\n; Evaluates to an expression that results in an string containing\n; encoded data for this recipe. The first entry_size-1 characters are the\n; in-game item name, space-padded. Then comes the item type info:\n; 0 is a regular item, 1 is a crafted item, and 2 is an item-group.\n; After that is a series of 3-number strings, each of which is\n; a craft-queue index.\n; The first is the index for the previous item, which is used to\n; determine if this is a continuation from a previous line.\n; The next `num_terms` terms are index values for queue values to add.\n; After each term is a single character which is a multiplier value.\n; Following that is an index for the current item, which is used as\n; the index to set, and possibly also as an index to read from.\n;\n; All of this is pulled from reading the appropriate sections of \"data\",\n; mostly as-is. However, there is a secondary lookup for the item name.\nloop_data = {lookup_item} . sub(\\\n  global.string.get(data_name),\\\n  i * {get_factory.val(main_size)},\\\n  3 + {get_factory.val(main_size)}\\\n)\n\n; The core expression that does all the work. If this item is the\n; target item, then set the queue value to factory_target_amount\n; - this ensures that the target is always made,\n; even if it already exists. Otherwise, we set it to the sum of\n; all of its recipe terms, minus the existing count. This core value is\n; the \"queue value\", and equals how many must be\n; crafted (if positive) or how many extra we have (if negative).\n; Since we are hardcoding the number of recipe terms that are handled\n; in each loop iteration to a small constant (4), there are additional\n; wrinkles because we may need to process the same item multiple times to\n; get all the recipe terms in. This means that if we're seeing\n; the same item again, we add the previous value of the variable\n; and skip subtracting the count. We also skip the count if the item\n; is a group, since those don't have valid items to count anyway.\n; In this way, we efficiently encode a sum that requires multiple passes.\nglobal.double.set({queue_str} . {recipe_item}, if(\\\n  {recipe_item} == i2s(factory_target + 100),\\\n  factory_target_amount,\\\n  if(\\\n    {prev_item} == {recipe_item}, \\\n    global.double.get({queue_str} . {recipe_item}),\\\n    0.0\\\n  ) + {recipe_terms} - if(\\\n    {item_type} == \"2\" || {prev_item} == {recipe_item},\\\n    0.0,\\\n    count({recipe_item_name}, index(\" 0123456789\", {tier_value}, 0))\\\n    - if({recipe_item_trunc} == {item_trunc(dust)}, 1.0, 0.0)\\\n  )\\\n))\ni = i + 1\n\n; Uncomment this line for debugging.\n; It will show the quantities and ids of all items\n; that need to be produced.\n; (The ids will be +100, because of internal reasons.)\n; You will also need to enable another line above.\ngss(\"debug\", if(\\\n  gdg({queue_str} . {recipe_item}) <= 0.0, \\\n  gsg(\"debug\"), \\\n  gsg(\"debug\") . \"<br>\" . {recipe_item} . \" \" \\\n  . gdg({queue_str} . {recipe_item})\\\n))\ngotoif(loop, i < {get_factory.val(recipe_limit)})\n\n; inv_tier = 10 - tier.\n; Represented this way so we can use the fact that locals\n; automatically start at 0.\n:local int inv_tier\n\ntierloop:\n{add_queue(10 - inv_tier, factory.dust, max(\\\n  0.0, \\\n  4.0 * (\\\n    {get_queue(10 - inv_tier, factory.mixable_lump)} - \\\n    count(\"lump\", 10 - inv_tier)\\\n  )\\\n))}\n{add_queue(10 - inv_tier, factory.crushable_ore, max(\\\n  0.0, \\\n  min(\\\n    count(\"ore\", 10 - inv_tier), \\\n    ceil({get_queue(10 - inv_tier, factory.dust)} / 2.0)\\\n  )\\\n))}\n\ngotoif(\\\n  nolumps, \\\n  inv_tier == 9 || \\\n  0.0 == count(\"ore\", 10 - inv_tier) + count(\"dust\", 10 - inv_tier)\\\n)\n{add_queue(9 - inv_tier, factory.mixable_lump, max(\\\n  0.0, \\\n  {get_queue(10 - inv_tier, factory.dust)} - \\\n  2.0 * {get_queue(10 - inv_tier, factory.crushable_ore)}\\\n))}\nnolumps:\n\ninv_tier += 1\ngotoif(tierloop, inv_tier < 10)\n\n; If we're missing the resources needed to complete the recipe, set error.\n:const string error_start \"<color=#FB3>Missing \"\n{action.set(if(\\\n  2.0 * {get_queue(1, factory.crushable_ore)} < \\\n  {get_queue(1, factory.dust)},\\\n  error_start . (\\\n    {get_queue(1, factory.dust)} \\\n    - 2.0 * {get_queue(1, factory.crushable_ore)}\\\n  ). \" T1 dust<br>and/or higher tier dust/ore!</color>\",\\\n  if(\\\n    {get_queue(1, factory.rubber)} > 0.0,\\\n    error_start . {get_queue(1, factory.rubber)} . \" rubber!</color>\",\\\n    if(\\\n      {get_queue(1, factory.void_essence)} > 0.0,\\\n      error_start . {queue(1, factory.void_essence)} \\\n      . \" void essence!</color>\",\\\n      if(\\\n        {get_queue(1, factory.pumpkin)} > 0.0,\\\n        error_start . {get_queue(1, factory.pumpkin)} \\\n        . \" pumpkin(s)!</color>\",\\\n        \"\"\\\n      )\\\n    )\\\n  )\\\n))}\n\n:local int k\nunset_loop:\n; If there's an error, clear the queue. We take advantage of initial value\n; being 0 to cut down on lines. The first item is (raw) id 110,\n; corresponding to 100 offset + 1 * 10, so we start at 109 as a no-op.\n; We don't use unset here to avoid reordering issues with other scripts\n; all the global variables we will ever need to hide will have been set by\n; this point, and we don't want to leave holes.\n\n; Note that it is important to skip setting variables that are 0, since\n; those might be tiers that are never calculated\n; - in those cases, they would be new variables outside the hiding block\n; if we set them here (after the first run of the factory).\n{set_raw(9 + k, 0.0)}\n\nskip_unset:\nk += 1\ngotoif(\\\n  if(0.0 == {get_raw(9 + k)}, skip_unset, unset_loop),\\\n  contains({action.get}, \"<\") && \\\n  k < {get_factory.len(items)} * 10 + 1\\\n)\ngss(\"fhide2\", \"</line-height></size>\")\n"],["produce",":import recipes\n:name {script_name(produce)}\n:budget_cap 4000\n; I can't count, so I'll just take your turbo value\n\n:local int i\n:local int machine_idx\n:local string machine_chunk\n:local string machine_name\n:local string produce_data\n:local string source_name_raw\n\n; ================== BEGIN MACROS + LUA ==================\n; The data for producing is defined in a single string, stored in\n; produce_data. Each entry in the string is a \"produce_chunk\", defined\n; in the following format:\n; MULT SOURCE_CHAR DEST_ITEM\n; DEST_ITEM is a 3-byte number, denoting the raw queue value for the item.\n; (I.e. after the +100 addition.) SOURCE_CHAR is a single character that\n; is used for indexing a separate lookup table of the source item names.\n; (The source tier will be the same as the tier of DEST_ITEM.) The MULT\n; is a single number used when items produce multiple output copies.\n#produce_chunk_size 5\n\n; Here we precompute all our data tables. There are three tables:\n; produce_data, which stores the produce chunks described above.\n; item_names, which stores destination item names only, and\n; machine_data, which stores a combination of machine name\n; and offset into produce_data.\n;\n; We also compute the character lookup table that is used\n; to convert DEST_ITEM to/from numbers for use with item_names.\n{lua(\\\n  local function pad_strings(args)\\\n    local max = 0;\\\n    for arg = 1, #args do\\\n      max = math.max(max, #args[arg]);\\\n    end\\\n    max = max + 1;\\\n    local fmt_str = string.format(\"%%-%ds\", max);\\\n    local res = {};\\\n    for arg = 1, #args do\\\n      res[arg] = fmt_str:format(args[arg]);\\\n    end\\\n    return res, max;\\\n  end\\\n  \\\n  local trans_table = \"0123456789abcdefghijklmnopqrstuvwxyz\";\\\n  local machine_acc = {};\\\n  local item_acc = {};\\\n  local prod_acc = {};\\\n  local prods_offset = 1;\\\n  local offsets = {};\\\n  \\\n  local function analyze_tiers(tier, prod)\\\n    if prod.source.tier < tier then return; end\\\n    \\\n    local source_name = prod.source.game_name;\\\n    if item_acc[source_name] == nil then\\\n      item_acc[1 + #item_acc] = source_name;\\\n      item_acc[source_name] = #item_acc;\\\n    end\\\n    prod_acc[1 + #prod_acc] = prod.mult\\\n      .. trans_table:sub(item_acc[source_name], item_acc[source_name])\\\n      .. 100 + tier - 1 + prod.item.id * 10;\\\n  end\\\n  \\\n  Factory.prod_machines[#Factory.prod_machines + 1] = \"end\";\\\n  Factory.prod_machines[\"end\"] = #Factory.prods + 1;\\\n  \\\n  for machines = 1, #Factory.prod_machines do\\\n    local machine = Factory.prod_machines[machines];\\\n    machine_acc[machines] = machine;\\\n    local next_offset = Factory.prod_machines[machine];\\\n    for tier = 1, 10 do\\\n      for k = prods_offset, next_offset - 1 do\\\n        local prod = Factory.prods[k];\\\n        analyze_tiers(tier, prod);\\\n      end\\\n    end\\\n    offsets[machines] = string.format(\"%03d\", #prod_acc * 5);\\\n    prods_offset = next_offset;\\\n  end\\\n  if #prod_acc * 5 >= 1000 then\\\n    error(string.format(\\\n      \"Offset overflows three digits: '%s'\",\\\n      table.concat(offsets, \" \")\\\n    ));\\\n  end\\\n  \\\n  machine_acc, Factory.machine_chunk_size = pad_strings(machine_acc);\\\n  for i = 1, #machine_acc do\\\n    machine_acc[i] = offsets[i] .. machine_acc[i];\\\n  end\\\n  \\\n  Factory.machine_data = table.concat(machine_acc);\\\n  Factory.machine_chunk_size = Factory.machine_chunk_size + 3;\\\n  Factory.item_acc, Factory.item_names_size = pad_strings(item_acc);\\\n  Factory.item_names = table.concat(item_acc);\\\n  Factory.trans_table = trans_table:sub(1, #item_acc);\\\n  Factory.produce_data = table.concat(prod_acc);\\\n  \\\n  --[[Debug functions, set to true if needed]]\\\n  if true then return; end\\\n  error(string.format(\"\\n.\\n%s\", table.concat(prod_acc, \",\")));\\\n)}\n\n; Uncomment if debug functions if needed\n;{get_factory.val(produce_data)}_\n;{get_factory.val(machine_data)}\n;{get_factory.val(item_names)}\n;{get_factory.val(trans_table)}_\n\n; When it is loaded from produce_data, the value in produce_data is\n; processed from the raw produce_chunk to lookup the SOURCE_CHAR from the\n; secondary lookup table. This still needs extra processing to trim the\n; trailing spaces, which is why the source_name macro exists.\n#dest_offset 2\n#source_char_offset 1\n#mult_offset 0\n#get_source_tier index(\\\n  \" 0123456789\", \\\n  sub(produce_data, {dest_offset} + 2, 1), \\\n  0\\\n)\n#source_name sub(source_name_raw, 0, index(source_name_raw, \" \", 0))\n#mult s2d(sub(produce_data, {mult_offset}, 1), 0.)\n\n#next_offset s2i(\\\n  sub(machine_chunk, {get_factory.val(machine_chunk_size)}, 3), \\\n  0\\\n)\n\n; Raw access to the queue. This is even more direct than\n; get_raw, because we're using queue strings directly.\n#raw_dest sub(produce_data, {dest_offset}, 3)\n#get_dest global.double.get({raw_name({raw_dest})})\n#set_dest(value) global.double.set({raw_name({raw_dest})}, {value})\n; ================== END MACROS + LUA ==================\n\nexecutesync(\"{script_name(produce dust)}\")\nstop(\"{script_name(produce dust)}\")\n\nmachine_loop:\n; Setup machine data variables and set the produce index to the proper\n; place. We break this out into separate variables because we don't run\n; through this section as much (only once per machine, so ~8 times), and\n; it makes the later expressions more efficient.\n; Also, we have lines to spare.\n; We get 3 extra characters after the machine chunk so that we have\n; the next offset available as well, which we use to determine\n; when to finish the produce_loop below and procede to the next machine.\n\nmachine_chunk = sub(\\\n  \"{get_factory.val(machine_data)}\", \\\n  machine_idx, \\\n  3 + {get_factory.val(machine_chunk_size)}\\\n)\n\nmachine_name = sub(machine_chunk, 3, index(machine_chunk, \" \", 0) - 3)\ni = s2i(sub(machine_chunk, 0, 3), 0)\nmachine_idx += {get_factory.val(machine_chunk_size)}\n\n; We need to setup the production data anyway, so we branch there.\n; This is one instruction less efficient than other methods,\n; but it lets us reuse a lot of code so it's worth it.\ngoto(if(machine_name == \"end\", end, set_data))\n\nproduce_loop:\nsource_name_raw = sub(\\\n  \"{get_factory.val(item_names)}\",\\\n  index(\\\n    \"{get_factory.val(trans_table)}\",\\\n    sub(produce_data, {source_char_offset}, 1),\\\n    0\\\n  ) * {get_factory.val(item_names_size)},\\\n  {get_factory.val(item_names_size)}\\\n)\n\n; Uncomment this line for runtime production debugging.\n; You will also need to uncomment the line in run_recipes that\n; unhides debug.\n;gss(\"debug\", gsg(\"debug\") . \"<br>\" . {source_name} . {get_source_tier} .\\\n  \"_\" . min(\\\n    ceil({get_dest} / {mult}), \\\n    count({source_name}, {get_source_tier})\\\n  ) . machine_name\\\n)\n\n; Just try to produce. There is a wrinkle here not present when crafting:\n; we take the minimum with the source count, so that we can use items as\n; quickly as they become available. We only craft the entire quantity, to\n; avoid needlessly filling the inventory.\nproduce(\\\n  {source_name},\\\n  {get_source_tier},\\\n  min(\\\n    ceil({get_dest} / {mult}), \\\n    count({source_name}, {get_source_tier})\\\n  ),\\\n  machine_name\\\n)\n\n; We can blindly subtract the number of items in the machine, because\n; we've guaranteed via the guards on our loop that we exit as soon as the\n; machine is active. This means the item in there *must* be\n; the correct one, if the count is > 0.\n{set_dest({get_dest} - {mult} * machine.item.count(machine_name))}\n\nnext_item:\ni += {produce_chunk_size}\nset_data:\nproduce_data = sub(\\\n  \"{get_factory.val(produce_data)}\", \\\n  i, \\\n  {produce_chunk_size}\\\n)\n\n; Go to the next machine if we're done with this set of machines,\n; or the machine has become active. Otherwise, either produce\n; the next item, or skip it if the quantity is <= 0.\ngoto(if(i >= {next_offset}, machine_loop, if(\\\n  active(machine_name),\\\n  machine_loop,\\\n  if({get_dest} <= 0.0, next_item, produce_loop)\\\n)))\n\nend:\n"],["produce dust",":import factory constants\n:name {script_name(produce dust)}\n:budget_cap 5001\n; 5 actions that take 100\n; happening 10 times\n; 5 * 10 * 100 = 50 * 100 = 5000\n\n:local int _tier\n:local double previous_amount\n\n_tier = _tier + 1\nprevious_amount = count(\"ore\", _tier)\nproduce(\\\n  \"ore\", \\\n  _tier, \\\n  {get_queue(_tier, factory.crushable_ore)}, \\\n  \"crusher\"\\\n)\n; produce the needed dust of tier `_tier`\n\n{subtract_queue(\\\n  _tier, \\\n  factory.dust, \\\n  2.0 * (previous_amount - count(\"ore\", _tier))\\\n)}\n; Remove from queue the ammount of dust we just made\n{subtract_queue(\\\n  _tier, \\\n  factory.crushable_ore, \\\n  previous_amount - count(\"ore\", _tier)\\\n)}\n; Remove from queue the ammount of ore we had to use\n; \ngotoif(\\\n  no_tier_up_dust, \\\n  _tier >= 10 || active(\"mixer\") \\\n  || {get_queue(_tier, factory.mixable_lump)} <= 0.0\\\n)\n; skip tiering up dust if the mixer is active,\n; tier >= 10 or if we don't need lumps of that type\n\ncraft(\"lump\", _tier, min(\\\n  {get_queue(_tier, factory.mixable_lump)} - count(\"lump\", _tier),\\\n  min(\\\n    (count(\"dust\", _tier) - 1.0) / 4.0,\\\n    count(\"dust\", _tier + 1)\\\n  )\\\n))\n; Craft any requested lumps\nprevious_amount = count(\"lump\", _tier)\nproduce(\\\n  \"lump\", \\\n  _tier, \\\n  min(previous_amount, {get_queue(_tier, factory.mixable_lump)}), \\\n  \"mixer\"\\\n)\n; and convert the lumps into dust\n\n{subtract_queue(\\\n  _tier, \\\n  factory.dust, \\\n  previous_amount - count(\"lump\", _tier)\\\n)}\n{subtract_queue(\\\n  _tier, \\\n  factory.mixable_lump, \\\n  previous_amount - count(\"lump\", _tier)\\\n)}\n; update our queues to reflect what we just did\nno_tier_up_dust:\n\ngotoif(\\\n  no_produce_ingot, \\\n  active(\"oven\") || (\\\n    count(\"dust\", _tier) < 2.0 * {get_queue(_tier, factory.ingot)} && \\\n    2.0 * min(\\\n      0.0, \\\n      count(\"dust\", _tier) - {get_queue(_tier, factory.ingot)}\\\n    ) > if(\\\n      _tier == 10, \\\n      0.0, \\\n      ({get_queue(_tier, factory.mixable_lump)} - count(\"lump\", _tier))\\\n      * 4.0\\\n    )\\\n  )\\\n)\n\nprevious_amount = count(\"dust\", _tier)\nproduce(\\\n  \"dust\", \\\n  _tier, \\\n  min(previous_amount - 1.0, {get_queue(_tier, factory.ingot)}), \\\n  \"oven\"\\\n)\n{subtract_queue(\\\n  _tier, \\\n  factory.ingot, \\\n  previous_amount - count(\"dust\", _tier)\\\n)}\nno_produce_ingot:\n\ngotoif(0, _tier < 10)\n"],["craft",":import recipes\n:name {script_name(craft)}\n:budget_cap 4000\n; I can't count, so I'll just take your default turbo value\n\n:local double previous_amount\n\n:local int i\n:local string itemdata\n:local string group_data\n\n:global int factory_target\n\n; Craft all the items.\ncraftItems_loop:\nitemdata = {get_factory.val(composite_string(\"i/10\", \"craft\"))}\n; gets the maximum tier - 1 for this item.\n; Items have a string of length 27 and character 28 is the tier \n\ndo_craft:\n; Because items and tiers start at 1, but i is zero-based, we have to\n; add 1 or (pre-multiplying, 10) in these expressions.\n; \n; However, our internal encoding is zero-based, so we don't add it here\n; However, tier is zero-based inside our indexing representation, so\n; we don't add it there.\nprevious_amount = count({get_name}, i % 10 + 1)\n\ncraft({get_name}, i % 10 + 1, {get_raw(10 + i)})\n{set_raw(\\\n  10 + i, \\\n  previous_amount - {get_raw(10 + i)} - count({get_name}, i % 10 + 1)\\\n)}\n\ninc:\n; This skips over tiers that don't exist for the given item, by using the\n; tier data embedded in \"itemdata\".\ni += if(contains({tiers_char}, i2s(i % 10)), 10 - i % 10, 1)\ngoto(if(\\\n  i % 10 != 0,\\\n  if({get_raw(10 + i)} > 0.0, do_craft, inc),\\\n  if(\\\n    i < 10 * {get_factory.val(items_count)}, \\\n    craftItems_loop, \\\n    crafting_done\\\n  )\\\n))\ncrafting_done:\n\n; Uncomment these lines for runtime item quantity debugging.\n; You will also need to uncomment the line in run_recipes that\n; unhides debug.\n;i = 10\n;debug_loop:\n;gss(\"debug\", if(i == 10, \"\", if(\\\n  {get_raw(i)} <= 0.0, \\\n  gsg(\"debug\"), \\\n  gsg(\"debug\") . \"<br>\" . i . \" \" . {get_raw(i)}\\\n)))\n;i += 1\n;gotoif(debug_loop, i < {get_factory.len(items)} * 10 + 10)\n\ngroup_data = \"{lua(\\\n  local acc = {};\\\n  for i = 1, #Factory.items do\\\n    local item = Factory.items[i];\\\n    if item.craft_type == \"group\" then\\\n      for tier = 1, item.tier do\\\n        acc[1 + #acc] = \"|\";\\\n        acc[1 + #acc] = (i * 10 + tier + 99);\\\n        local recipes = item.recipes[tier];\\\n        for recipe = 1, #recipes do\\\n          acc[1 + #acc] = recipes[recipe] + 100;\\\n        end\\\n      end\\\n    end\\\n  end\\\n  acc[#acc+1] = \"|\";\\\n  return table.concat(acc);\\\n)}\"\n\ni = 1 + index(group_data, \"|\" . (factory_target + 100), 0)\n\ncheck_group_loop:\ni += 3\ngoto(if(i < 4, group_abort, if(\\\n  \"|\" == sub(group_data, i, 1), \\\n  group_complete,\\\n  if(\\\n    global.double.get({raw_name(sub(group_data, i, 3))}) > 0.0,\\\n    group_abort,\\\n    check_group_loop\\\n  )\\\n)))\n\ngroup_complete:\n{set_raw(factory_target, 0.0)}\n\ngroup_abort:\n"],["init",":import factory constants\n:name {script_name(init)}\n:budget_cap 401\n; budget_cap so that we can get to the waitframe() fast\n; executesync, when successful, refreshes the budget cap\n; when unsuccseful, just takes 100, same as stop\n\nwakeup()\nopen.factory()\n\nisopen(\"factory\")\n\n:global double factory_target_amount\n:global int factory_target\n\n:local double target_value\n\n; Run the UI, to display the current pending item.\nexecute(\"{script_name(ui)}\")\n\n; Initial dispatch on entering the factory to determine if we are\n; resuming a crafting operation or waiting to launch a new one. This is\n; done outside of turbo, so that we never invoke turbo\n; if we don't need to.\ngotoif(wait_loop, {get_raw(factory_target)} == 0.0)\n\n; The core factory cycle. We do each loop of factory production within\n; one call of nested turbo start/stop, which executes within one frame.\n;\n; This loop handles both calculating recipes via \"run_recipes\"\n; and crafting via \"craft\". This is done with conditional execution,\n; in order to save lines for future possible features.\nbegin_cycle:\n\n; Here we up the number of cycles so that it will be enough to\n; calculate the recipes or produce items. We intentionally have a\n; frame break between the recipe calculation and the beginning of crafting\n; to prevent jarring lag on startup.\n; This formula ensures that we don't accidentally step on another script\n; that needs more cycles, and also that we get the full amount of cycles\n; even if something else started turbo before us.\n\n; We would up the number here.\n\n; We have to save this value, because it can change as a result\n; of executing later scripts.\ntarget_value = {get_raw(factory_target)}\n\n; All conditional execution in the loop is behind this condition.\n; If it is true, then we're here because of `ui`.\n; Otherwise, this is a regular crafting iteration.\n\nexecutesync(if(\\\n  target_value > 0.0, \\\n  \"{script_name(produce)}\", \\\n  \"{script_name(run_recipes)}\"\\\n))\nstop(if(\\\n  target_value > 0.0, \\\n  \"{script_name(produce)}\", \\\n  \"{script_name(run_recipes)}\"\\\n))\nexecutesync(if(\\\n  target_value > 0.0,\\\n  \"{script_name(craft)}\",\\\n  \"###badname###\"\\\n))\nstop(\"{script_name(craft)}\")\n\n; Clear factory_target to indicate that crafting is done,\n; if it is, in fact, done.\nfactory_target = if({get_raw(factory_target)} > 0.0, factory_target, 0)\n; \n; Re-display the UI when crafting is done.\nexecute(if(factory_target == 0, \"{script_name(ui)}\", \"###badname###\"))\n\n; Clear this (unconditionally), to signal that we're not starting\n; a new crafting pass.\nfactory_target_amount = 0.0\n\n; Here we either return to the next iteration of the production loop,\n; or stall on this instruction until we need to launch the factory.\n; Because there is always 1 extra cycle of turbo after \"TE2.2:stop,\" there\n; is enough time to execute this goto and have only a single frame break\n; before starting turbo again at the top of the loop.\nwait_loop:\nwaitframe()\ngotoif(\\\n  if(\\\n    0.0 < max(factory_target_amount, {get_raw(factory_target)}),\\\n    begin_cycle, \\\n    wait_loop\\\n  ),\\\n  isopen(\"factory\")\\\n)\n\n; Remove the UI status so it doesn't clutter the variables when\n; we're outside the factory. This is safe to repeat,\n; when turbo is looping at the end of the script.\n{status.set(\"</size>\")}\n"],["ui",":import factory constants\n:import worker_storage_lib\n:budget_cap 200\n; 2 actions that take 100\n; final action is at the end of the script\n; so no need to make it 201\n\n:name {script_name(ui)}\n\n:local int visible_tier\n:local int tier\n:local int category\n:local int item\n\n:local int cursor\n:const string impulse.cursor \"key.{left}key.{right}\"\n\n:local double count\n:const string impulse.count \"key.{up}key.{down}\"\n\n:local string action_ud\n\n#contains.group(group) contains(impulse.{group}, impulse())\n\n:global int factory_target\n:global double factory_target_amount\n\n#get_key sub(impulse(), {len(key.)}, 1)\n; key.{up}/{left} = 1\n; key.{down}/{right} = -1\n:const string keys \"|{up}|{left}\"\n\nkey.{up}()\nkey.{down}()\nkey.{left}()\nkey.{right}()\n; UI interaction impulses\n\nkey.{start}()\n; Start the AI\n\nisopen(\"factory\")\n\n; Use worker_storage_lib to find a worker_slot to use\n; for permanent storage.\n:local int worker_slot\n{worker_lib_line_1([factory])}\n{worker_lib_line_2}\n\n; Split out the worker data into separate variables. We take advantage\n; of this time to also perform increment/decrement, since we can easily\n; combine it in this stage. We don't bother checking if we've got a valid\n; slot, because if we don't, we'll simply fail to parse\n; and get the fallback value.\n\n#action_num (index(keys, {get_key}, 0) % 2)\n; Is the u/d action valid for this position?\n; Using contains() instead of == and chained compares saves a\n; lot of import space.\n; \n; cursor values of importance are:\n; 0 = change name\n; 1 = change category\n; 2 = change tier\n; 3+ = change ammount\n#is_ud(pos) contains(\"{up}{pos}{down}{pos}\", action_ud)\n\n:const int prefix_len {len({worker_prefix})}\n\n#worker_data(offset, size) sub(\\\n  worker.name(worker_slot),\\\n  prefix_len + {offset},\\\n  {size}\\\n)\n\ncursor = min(9, max(0, if(\\\n  {contains.group(cursor)},\\\n  s2i({worker_data(11, 1)}, 0) + {action_num},\\\n  s2i({worker_data(11, 1)}, 0)\\\n)))\n\naction_ud = concat({get_key}, i2s(cursor))\n\ncount = min(1e7 - 1, max(1.0, if(\\\n  {contains.group(count)},\\\n  s2d({worker_data(0, 7)}, 1.0) + i2d({action_num} * 10 ^ (cursor - 3)),\\\n  s2d({worker_data(0, 7)}, 1.0)\\\n)))\n\n:const int num_categories {get_factory.len(categories)}\ncategory = if(\\\n  {is_ud(1)},\\\n  s2i({worker_data(8, 1)}, 0) + num_categories - {action_num},\\\n  s2i({worker_data(8, 1)}, 0)\\\n) % num_categories\n\n; Because math expressions are so expensive, in terms of import space,\n; it's best to just pre-compute tables of the next/previous item to go to\n; for every item. To avoid duplicating expressions, we also make a no-op\n; table for the case where we're not incrementing or decrementing.\n{lua(\\\n  local categories = Factory.categories;\\\n  Factory.default_cat = categories[1].default - 1;\\\n  \\\n  function Factory.item_inc_table(inc)\\\n    local acc = {};\\\n    for category = 1, #categories do\\\n      local cat = categories[category];\\\n      local cat_size = 1 + cat.last - cat.first;\\\n      for i = cat.first, cat.last do\\\n        acc[i] = (inc + i - cat.first) % cat_size + cat.first - 1;\\\n      end\\\n    end\\\n    for i = 1, #Factory.items do\\\n      acc[i] = string.format(\\\n        \"%02d\", \\\n        acc[i] or Factory.default_cat\\\n      );\\\n    end\\\n    return table.concat(acc);\\\n  end\\\n)}\n\n#item_inc_table(inc) {get_factory.val(item_inc_table({inc}))}\n#category_defaults {lua(\\\n  local acc = {}\\\n  for i = 1, #Factory.categories do\\\n    local category = Factory.categories[i];\\\n    acc[i] = string.format(\"%02d\", category.default - 1);\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Items in this variable are zero-indexed, as opposed to\n; their regular ids, which start from 1.\n; We increment the items in the opposite direction from the action,\n; because pressing {up} (action 1) *increments* numerical values but\n; *decrements* elements in an alphabetically sorted list.\n\n#change_item if(\\\n  impulse() == \"key.{down}\", \\\n  \"{item_inc_table(1)}\", \\\n  \"{item_inc_table(-1)}\"\\\n)\n\nitem = if(\\\n  {is_ud(1)},\\\n  s2i(sub(\"{category_defaults}\", 2 * category, 2), 0),\\\n  s2i(\\\n    sub(\\\n      if({is_ud(0)}, {change_item}, \"{item_inc_table(0)}\"),\\\n      2 * s2i({worker_data(9, 2)}, {get_factory.val(default_cat)}),\\\n      2\\\n    ),\\\n    0\\\n  )\\\n)\n; The distinction between \"tier\" and \"visible_tier\" has to do with\n; the fact that items have different tier maximums. When a user is\n; scrolling through different items, if the \"tier\" is T10\n; (represented as \"9\" in our zero-indexed scheme), then the \"visible_tier\"\n; will change to fit the maximum tier for the item, while\n; the tier remains at T10. However, if the item is a producer (max of T5),\n; and the user moves the cursor to the tier field and presses {up}, the\n; attempt to increment \"tier\" will fix it at a new value of T5 (4).\n#tier_data {lua(\\\n  local acc = {};\\\n  for i = 1, #Factory.items do\\\n    local item = Factory.items[i];\\\n    acc[i] = string.format(\"%d\", item.tier - 1);\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Expression to load the saved tier data from the worker name, including\n; a default value when there is no data.\n#saved_worker_tier s2i({worker_data(7, 1)}, 0)\n\n; It makes the most sense to set visible_tier first.\n; There is a complication when adjusting the tier down; in this case,\n; we reduce the maximum bounds by one, so that (for instance) if the\n; max tier is T5, and the current tier is T10, we'll properly clip the\n; visible_tier to T4 after subtracting 1 to get T9.\n; This type of adjustment isn't needed (or wanted) in the other direction,\n; or when the tier isn't changing.\nvisible_tier = max(0, min(\\\n  if(\\\n    {is_ud(2)}, \\\n    {saved_worker_tier} + {action_num}, \\\n    {saved_worker_tier}\\\n  ),\\\n  if(\\\n    impulse() . cursor == \"key.{down}2\",\\\n    s2i(sub(\"{tier_data}\", item, 1), 9) - 1,\\\n    s2i(sub(\"{tier_data}\", item, 1), 9)\\\n  )\\\n))\ntier = if({is_ud(2)}, visible_tier, {saved_worker_tier})\n\n; Finally, construct the visible name for use in the variable.\n{lua(\\\n  local names = {}\\\n  local name_starts = {}\\\n  local name_sizes = {}\\\n  local name_len = 0\\\n  \\\n  for item = 1, #Factory.items do\\\n    names[item] = Factory.items[item].name;\\\n    name_starts[item] = string.format(\"%03d\", name_len);\\\n    name_len = name_len + #names[item];\\\n    name_sizes[item] = string.format(\"%02d\", #names[item]);\\\n  end\\\n  Factory.name_data = table.concat(names)\\\n  Factory.name_starts = table.concat(name_starts)\\\n  Factory.name_sizes = table.concat(name_sizes)\\\n  Factory.items_count = #Factory.items\\\n\\\n  local category_names = {};\\\n  for category = 1, #Factory.categories do\\\n    category_names[category] = Factory.categories[category].name;\\\n  end\\\n  Factory.category_names = table.concat(category_names)\\\n)}\n\n; Set this variable in order to begin a variable-hiding block.\n; It looks like a no-op, but really we're ensuring that it has a slot\n; in the globals table, even if its value empty - in this case, what we\n; care about is the *name*, which starts with \"<size=0>\".\n; Do this *after* all the other work, to give turbo register time to\n; set its variables, in case we're doing this right at startup.\n{action.set({action.get})}\n\n; Do conditional stuff, depending on if we're launching the factory.\n; We set all these variables always, so that they'll have a consistent\n; order, and also to save lines instead of jumping over this block.\n\n#valid_start factory_target . impulse() == \"0key.{start}\"\n; This (maybe) launches the factory. We need to do it soon enough to not\n; interrupt turbo, see the comment on \"TE2.2:stop\", below.\n{lua(\\\n  for category = 1, #Factory.categories do\\\n    if Factory.categories[category].name == \"grup\" then\\\n      Factory.grup_cat = category - 1;\\\n      return;\\\n    end\\\n  end\\\n  error(\"Couldn't find grup\");\\\n)}\nfactory_target_amount = if({valid_start}, count, factory_target_amount)\n\n; Only set factory_target if it's zero, which indicates that the factory\n; is idle. This prevents repeated keypresses from messing things up.\nfactory_target = if(\\\n  {valid_start}, \\\n  (item + 1) * 10 + visible_tier, \\\n  factory_target\\\n)\n\n; Construct the status line. There's a *lot* that goes into this.\n;\n; For starters, we fake the variable - it's not really \"make\", but rather\n; a totally different variable that's less likely to collide. The true\n; variable name is never seen, because it's still part of the <size=0>\n; block. We put our fake variable name after. We do all this so that we\n; can \"unset\" the variable by just changing its value - this way, it's not\n; truly unset, and we don't have issues with\n; variable ordering as a result.\n;\n; This also means we can change the variable name to something else, like\n; \"error\", if we need to, all without actually creating a new variable or\n; changing ordering.\n;\n; All the clauses are dynamically created on the fly here. We also create\n; the \"cursor\" by highlighting a specific part of the result in green.\n; This involves a great deal more complexity.\n#curs_col 2F4\n#err_col FB3\n; For later - scanning rework\n;count_string if(\\\n  category == {get_factory.val(grup_cat)}, \\\n  \"  -SCAN-\", \\\n  d2s(1e7.0 + count)\\\n)\n#count_string d2s(1e7 + count)\n\n{status.set(if(\\\n  worker_slot == 200,\\\n  \"</size>error=<color=#{err_col}>No available workers!</color>\",\\\n\\\n  \"</size>make=<color=#FFF>\" . sub({count_string}, 1, 9 - cursor) .\\\n  \"</color><color=#{curs_col}>\" . sub({count_string}, 10 - cursor, 1) .\\\n  \"</color><color=#FFF>\" . sub({count_string}, 11 - cursor, 10) . if(\\\n    cursor == 2, \\\n    \"<smallcaps>x</smallcaps><color=#{curs_col}>T\", \\\n    \"<smallcaps>x</smallcaps><color=#FFF>T\"\\\n  ) . (visible_tier + 1) . if(\\\n    cursor == 1, \\\n    \"</color> <color=#{curs_col}>\", \\\n    \"</color> <color=#FFF>\"\\\n  ) . sub(\"{get_factory.val(category_names)}\", 4 * category, 4) . if(\\\n    cursor == 0, \\\n    \"</color> ...<br><color=#{curs_col}>\",\\\n    \"</color> ...<br><color=#FFF>\"\\\n  ) . sub(\\\n    \"{get_factory.val(name_data)}\", \\\n    s2i(sub(\"{get_factory.val(name_starts)}\", 3 * item, 3), 0), \\\n    s2i(sub(\"{get_factory.val(name_sizes)}\", 2 * item, 2), 0)\\\n  ) . \"<br></color></color>\" . if(\\\n    contains(impulse() . {action.get}, \":init<\"),\\\n    {action.get},\\\n    if(\\\n      factory_target != 0,\\\n      \"<color=#FF0>Crafting...</color>\",\\\n      \"<color=#0DF>{up}{left}{down}{right} moves, \" .\\\n      \"{start} crafts</color>\"\\\n    )\\\n  )\\\n))}\n\n; Pause/unpause a dissolve worker, if it occupies our data slot.\n; If it's a different type of worker, leave it alone by dummying\n; out the name.\nworker.pauseName(\\\n  if(\\\n    worker.task(worker.name(worker_slot))==\"factory.dissolveManagement\",\\\n    worker.name(worker_slot),\\\n    \"![@#nosuchtask#@]!\"\\\n  ),\\\n  contains({status.get}, \"Crafting\")\\\n)\n\n; Setting the data back in the worker is moved way down to the bottom, to\n; function as the \"filler\" action that can be repeated while the script is\n; waiting for the frame to end. We can't make use of the actions that set\n; global variables for this, because they may need to be modified later in\n; the frame, and thus setting them here in a loop\n; would overwrite the value.\nworker.setName(\\\n  if(worker_slot < 100, worker_slot, worker_slot - 100),\\\n  \"{worker_prefix}\" . sub(d2s(1e7 + count), 1, 7) . tier \\\n  . category . sub(i2s(100 + item), 1, 2) . cursor\\\n)\n"]]}}
```

The workspace should have the following scripts, in this order:

`factory constants 0 0 0`<br>
`factory macros 0 0 0`<br>
`worker_storage_lib 0 0 0`<br>
`recipes 0 0 0`<br>
`run_recipes 0 0 15`<br>
`produce 2 1 16`<br>
`produce dust 0 0 16`<br>
`craft 2 1 14`<br>
`init 2 1 15`<br>
`ui 1 1 16`<br>

## Changelog

### V3.2.3

Fix a long-standing minor bug where switching items/counts after failing to
build due to not-enough resources would sometimes produce "extra" items when
successfully crafting later, if you didn't reset the AI after the failure.
This was due to leftovers in the crafting queue.

```
Bundle size: 22092  (70165 uncompressed)   Scripts: 6   Max lines: 16
```

### V3.2.2

Add machine speed boosters.

```
Bundle size: 21932  (69765 uncompressed)   Scripts: 6   Max lines: 16
```

### V3.2.1

Fix a minor recipe bug that led to overproduction of high-tech chips when
making T3 production boosters.

```
Bundle size: 21544  (69505 uncompressed)   Scripts: 6   Max lines: 16
```

### V3.2.0

- Add pumpkin producers and other Halloween items
- Reduce number of scripts to 6!
- Change producers to be named by building instead of by color
- Reverse the direction of W/S when selecting items and categories, "up" was going "down".
- Reduce import size through better coding

```
Bundle size: 69529   Scripts: 6   Max lines: 16
```

### V3.1.2

Add resource producers

```
Bundle size: 78924   Scripts: 9   Max lines: 16
```

### V3.1.1

Minor fix for Void-Rock Sapling recipe (it would produce an extra dust)

```
Bundle size: 78772   Scripts: 9   Max lines: 16
```

### V3.1.0

Add a large number of new items (rainbow dust, boosters, etc.) for 0.16.0.

```
Bundle size: 78772   Scripts: 9   Max lines: 16
```

### V3.0.5

Add auto-disabling of disolve worker.

```
Bundle size: 75952   Scripts: 9   Max lines: 16
```

### V3.0.4

Change to requiring Turbo Exec v2.2.

```
Bundle size: 75596   Scripts: 9   Max lines: 16
```

### V3.0.3

Bugfix: Work around a game bug with executing empty scripts. This could
formerly cause your logs to become huge while using the factory, if you had an
empty script named "" (empty string).

```
Bundle size: 75596   Scripts: 9   Max lines: 16
```

### V3.0.2

Bugfix: Fix script getting stuck (and having multiple copies) when exiting
during crafting.

```
Bundle size: 75528   Scripts: 9   Max lines: 16
```

### V3.0.1

Bugfix: Crafting should only be enabled in the Factory.

```
Bundle size: 75364   Scripts: 9   Max lines: 16
```

### V3.0.0

The UI rewrite.

- Editing "launch factory craft" is gone. (That whole script is gone.)
- There is now a shiny new UI, which is navigated with WASD. Items, tiers, and
  quantities are selected on-screen dynamically. The selections are remembered
  across AI restarts by using worker-name storage.
- More robust checking for when Turbo Exec isn't functioning.

```
Bundle size: 75316   Scripts: 9   Max lines: 16
```

### V2.2.0

The "more helpful errors" release.

- Add spell-check support (contributed by cl1694) to suggest correct item-name
  spellings when the item can't be found.
- Add error-handling for if target_type is changed by name instead of by value,
  as well as running without modifying target_type.
- Finally add checking for insufficient ore/rubber at startup, and show errors
  instead of uptiering needlessly.

Also group everything into a package, for convenience and orginazation.

```
Bundle size: 81073   Scripts: 10   Max lines: 16
```

### V2.1.1

Fix a bug where trying to produce ore made producers instead.

```
Bundle size: 68768   Scripts: 9   Max lines: 16
```

### V2.1.0

**_I forgot to update the version number in the script, it will show as v2.0.1_**

Fix a bug with crushing and mixing dust that would cause various issues
if you were low on dust.

Add "line-height=0" so that there isn't a big blank space in the variables list.

```
Bundle size: 68768   Scripts: 9   Max lines: 16
```

### V2.0.1

Add rubber saplings.

```
Bundle size: 68700   Scripts: 9   Max lines: 16
```

### V2.0.0

Change to using Turbo Exec V2.

All global variables are now hidden internally, instead of relying on turbo
exec to do it (since V2 no longer messes with the variable display).

```
Bundle size: 68517   Scripts: 9   Max lines: 16
```

### V1.0.1

This moves hammers and T1 pressers to tier 2, so that when you craft the item groups you can
immediately scan the entire group, instead of needing to wait on items in the next group.

Also, implement a versioning scheme that shows up in the script names.

```
Bundle size: 69146   Scripts: 10   Max lines: 16
```

### V1.0.0

Initial release. This release is identifiable with plain names, because I hadn't thought to do versioning yet.

The main feature is the much smaller size, compared to Xenos', which it was evolved from.
Xenos' bundle is 309696 bytes, taking more than a minute to import and often causing people to close the program due to the "not responding dialog".
It is also 32 scripts big, and requires 22 lines.

The other feature is built-in item groups, instead of needing them added as a separate download.

```
Bundle size: 69142   Scripts: 10   Max lines: 16
```
