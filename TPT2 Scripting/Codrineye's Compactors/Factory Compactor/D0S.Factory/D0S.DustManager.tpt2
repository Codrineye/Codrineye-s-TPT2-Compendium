:import Editor_actions lib
; Importing this library lets me use a lua macro to create actions
; that the editor can parse

:budget_cap 101
; Set budget_cap to 101 so that everything before producing lumps is
; done in the same frame

:local string dust_multipliers
; 
:local double ore_buffer
; 
:local int state
:local int i

wakeup()
open.factory()

isopen("factory")

; Amount of ore to save at each tier. Ore will only be saved if there is
; more dust than ore, otherwise it will be crushed anyway (so that saving
; ore doesn't prevent you from progressing.) This function exists to allow
; for scanning ore with the Crafter.
ore_buffer = 1000.0

; Initialize multipliers from a string. This used to be much worse, but is
; easy now that there is native s2d().
dust_multipliers = "1 1 .625 .5 .07872 .06312 .01 .01 .0021"

:const int dust_mult_limit 10000
; "i" combines the position in the string with the tier currently being
; initialized. The encoding is pos + tier * dust_mult_limit.
; (I.e. dust_multipliers can only be dust_mult_limit characters long.)
#pos (i%dust_mult_limit)
#tier (i/dust_mult_limit)
; 
; We add a final space here to prevent index() from returning -1
; index() returns -1 if it can't find the string you're looking for
#nextspace index(dust_multipliers . " ", " ", {pos})

; This is a simple loop: Each iteration converts one number and advances
; both the read position "pos" and the "tier" appropriately. The only subtle
; wrinkle is that once it gets to the end of the list, it will keep reading
; the same entry to fill in the remaining tiers.
; 
init_multipliers:
local.double.set("buffer" . ({tier} + 1), s2d(\
  sub(dust_multipliers, {pos}, {nextspace} - {pos}),\
  0.0 / 0.0\
))
; Set the buffer to the multiplier or NaN if it fails
; 
i += dust_mult_limit + if(\
  index(dust_multipliers, " ", {pos}) == -1, \
  0, \
  {nextspace} + 1 - {pos}\
)

gotoif(init_multipliers, i < 10 * dust_mult_limit)
; There are 10 tiers of dust in total, this is why we multiply
; dust_mult_limit by 10. If 9 was the max, it would be multiplying by 9

; now that we've created our buffers,
; this helper macro lets us easily access it
#buffer(tier) local.double.get("buffer" . ({tier}))

; The overall plan is to count down through the ores, so that the best ones
; (with the least count) get processed first, and to count down through
; the lumps as well. We process lumps in "packets" that are based on a
; power of the stack size, which ensures that uptiering
; doesn't consume too much dust while processing but also allows
; for the chunks to process for a considerable time.
; This also makes for a simple expression that equals 0 when the size
; is 1 (so that we don't use the last dust), and 1 when the size is 2
; (so that we do start immediately after that point.)

; The tier variable is a local, so the process can be restarted from
; the top if it's taking too long.
top:

{lua(\
  local active = Editor_isMachineActive;\
  --[[/*\
      * Shorten the active("machine") call by assigning the "memory address"\
      * of our Editor_action to the variable "active"\
     */]]\
  local function orecount_cond(tier)\
    --[[/*\
        * Counts the ammount of ore and dust we have of the requested tier\
        * The min operation ensures we never process more dust than ore_buffer\
        * permits\
       */]]\
    local count = Editor_factoryCountItems;\
    local ore = [["ore"]];\
    local dust = [["dust"]]\
    local ore_count = count(ore, tier);\
    local dust_count = count(dust, tier);\
    local ore_buffer = "ore_buffer";\
    local min = Editor_min(ore_buffer, dust_count);\
    return Editor_math(ore_count, "<=", min);\
  end\
  local function orestate_nest(value, rest)\
    --[[Creates an if statement to make it easier to calculate orestate]]\
    local tier = math.tointeger(value);\
    local condition = orecount_cond(tier);\
    return Editor_if(condition, rest, tier);\
  end\
  local dust_inc = [[if(active("mixer"), 0, 11)]];\
  function Orestate()\
    local crusher = [["crusher"]];\
    local condition = active(crusher);\
    local ore_nest = dust_inc;\
    for i = 1, 10 do\
      --[[/*\
          * Create the nested if for all tiers\
          * starting from 1 and ending with 10.\
          * \
          * Because the expression uses ore_nest as the last\
          * parameter, tier 10 is processed before tier 9\
         */]]\
      ore_nest = orestate_nest(i, ore_nest);\
    end\
    return Editor_if(condition, dust_inc, ore_nest);\
  end\
)}

#orestate {lua(return Orestate())}
; 
; The main state calculation. We first calculate whether
; ore needs to be crushed, and if it does not, we possibly
; increment the current dust that is being mixed.

; The dust_tier for mixing and ore_tier for crushing are stored together in state.
; Mixing will only occur if ore_tier is 0, since crushing takes priority.
; (Generally the mixing will happen in the next iteration.)

#raw_dust_tier (state / 11)
#prev_dust_tier ({raw_dust_tier} + 8) % 9
#curr_dust_tier 1 + ({prev_dust_tier})
#next_dust_tier 2 + ({prev_dust_tier})

; The reason for the max() here is so that ore_tier never returns 0.
; That way, we never try to count() something with a tier of 0, even in
; if() branches that aren't used.

#ore_tier max(1, state % 11)
#has_ore (state % 11 != 0)
#no_ore (state % 11 == 0)

; state = floor(state / 11) * 11 because state is int
state = ((state / 11) * 11 + {orestate}) % 99

; These expressions calculate how much dust to uptier. It used to be a more
; complicated expression that calculated everything in T1-equivilant units,
; (i.e. if you down-converted it all), but that isn't actually needed: Everything
; works (better actually) if you just make local decisions based on the ratios
; between the current and next tier.
; In both cases, Ore Lumps are also counted as dust, so that unmixed lumps don't
; throw off the calculations. We know that currently processing lumps won't be
; an issue, because we only craft when the mixer is empty.

{lua(\
  local function factory_count(machine, tier)\
    local name = Editor_stringify_value(machine);\
    return Editor_factoryCountItems(name, tier);\
  end\
  local function count_dust_n_lumps(dust_tier)\
    local condition = Editor_math(dust_tier, "==", 1);\
    \
    local dust_count = factory_count("dust", dust_tier);\
    local lump_tier = "max(1, -1 + %s)";\
    local lump_count = factory_count("lump", lump_tier:format(dust_tier));\
    \
    local case_true = dust_count;\
    local case_false = Editor_math(dust_count, "+", lump_count);\
    return Editor_if(condition, case_true, case_false);\
  end\
  \
  local function buffer(tier)\
    local encased_tier = Editor_encase_value(tier);\
    local buffer = [["buffer"]];\
    buffer = Editor_math(buffer, ".", encased_tier);\
    return Editor_get_localVar("double", buffer);\
  end\
  \
  function Needed_by_ratio(dust_tier)\
    local buffer_tier = buffer(dust_tier);\
    local count_dust = count_dust_n_lumps(dust_tier);\
    \
    local next_tier = Editor_math(1, "+", dust_tier);\
    local buffer_next_tier = buffer(next_tier);\
    local count_next_tier_dust = count_dust_n_lumps(next_tier);\
    \
    --[[/*\
        * As this is a mathematical expression, the ending\
        * expression will be a little bit hard to understand.\
        * \
        * This is why, in addition to Editor_ syntax, I will be\
        * using string.format to better visualize what's going on\
       */]]\
    local count_fmt = "%s * %s";\
    local curr_count = count_fmt:format(count_dust, buffer_next_tier);\
    local next_count = count_fmt:format(count_next_tier_dust, buffer_tier);\
    \
    local needed_dust = Editor_math(curr_count, "-", next_count);\
    needed_dust = Editor_encase_value(needed_dust);\
    --[[/*\
        * This subtraction tells us how much dust we have to use\
        * to get the next tier of dust in the desired ratio\
       */]]\
    local lump_cost = count_fmt:format(8.0, buffer_next_tier);\
    lump_cost = Editor_math(buffer_tier, "+", lump_cost);\
    lump_cost = Editor_encase_value(lump_cost);\
    --[[/*\
        * This calculates how much dust we're using to\
        * make the lumps. Multiplying 8.0 by our next buffer\
        * tells us how much dust we'd be using to reach the\
        * ratio in the next buffer. Adding the current buffer\
        * prevents us from using so much dust that our previous\
        * tier exits its ratio.\
       */]]\
    return Editor_math(needed_dust, "/", lump_cost);\
  end\
)}

#needed_by_ratio(dust_tier) {lua(\
  return Needed_by_ratio([[{dust_tier}]])\
)}

; We always save one dust on the producing side, so that dust ordering doesn't
; get messed up in the inventory.
; We produce lumps in chunks. We consume up to 5% of the destination;
; this allows for large-ish mixing regardless of stack size, and
; dynamically adjusts well.
; Not adding more to the mixer when it's running greatly reduces
; complications. We just move on to the next tier when it's done,
; and come back around soon enough.
; The "+ 0.5" on the consuming side is to adjust for Chemical Lumps.
; That way, in the terminal case it'll hit the safety target exactly. If you
; don't have lumps, you'll be up to 3 under the target. However, we always
; ensure that you'll leave one leftover no matter what.

craft(\
  "lump", \
  {curr_dust_tier}, \
  if(\
    active("mixer") || {has_ore}, \
    0.0, \
    min(\
      0.999 * count("dust", {next_dust_tier}) ^ 0.84, \
      {needed_by_ratio({curr_dust_tier})} + 0.5\
    )\
  )\
)

produce(\
  if({has_ore}, "ore", "lump"),\
  if({has_ore}, {ore_tier}, {curr_dust_tier}),\
  if(\
    {no_ore},\
    count("lump", {curr_dust_tier}),\
    max(\
      count("ore", {ore_tier}) - ore_buffer, \
      1.0 + (count("ore", {ore_tier}) - count("dust", {ore_tier})) / 3.0\
    )\
  ),\
  if({has_ore}, "crusher", "mixer")\
)

gotoif(top, isopen("factory"))
