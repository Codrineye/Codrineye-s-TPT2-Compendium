# Factory Compactor

The factory compactor is a reworking of how Factory AI stores its data<br>
The purpose of this reworking is to convert the recording mechanism into a system whose inner-workings are easier to follow

D0S.Factory is a horifying system.<br>
I'm finally good enough to study it.

```
{"workspaces":{"Factory Compactor":[["factory constants",":import factory macros\n\n#version v3.2.3\n\n; Everything in the list below is a valid target for automation, and can be\n; assigned to the \"target_type\" variable in \"lanuch factory craft\".\n; For example, \"make(oven, 10, \"machine.oven\")\" indicates that \"oven\" is a valid\n; item, usable from tiers 1-10, with the internal game name of \"machine.oven\"\n; (which you don't need to worry about.)\n; Thus you can enter \"oven\" in the box in the in-game editor (without the quotes).\n\n; If you add or change this list, mind this constraint:\n; * All the crafted items have to come before the rest of the items.\n; * All the item-groups must be in a single block.\n; * Prefer keeping things in alphabetical order within categories, because\n;   they are ordered the same way when presented in-game.\n\n; ===== VALID IDS =====\n\n; ----- CRAFTED ITEMS -----\n\n; Producers, named by building, tiers 1-5\n{make(arcade_producer, 5, \"producer.arcade\")}\n{make(construction_firm_producer, 5, \"producer.constructionFirm\")}\n{make(exotic_producer, 1, \"producer.exoticgems\")}\n{make(factory_producer, 5, \"producer.factory\")}\n{make(gem_producer, 1, \"producer.gems\")}\n{make(headquarters_producer, 5, \"producer.headquarters\")}\n{make(laboratory_producer, 5, \"producer.laboratory\")}\n{make(mine_producer, 5, \"producer.mine\")}\n{make(museum_producer, 5, \"producer.museum\")}\n{make(powerplant_producer, 5, \"producer.powerplant\")}\n{make(pumpkin_producer, 1, \"pumpkin.producer\")}\n{make(shipyard_producer, 5, \"producer.shipyard\")}\n{make(statue_of_cubos_producer, 5, \"producer.statueofcubos\")}\n{make(town_producer, 5, \"producer.town\")}\n{make(tradingpost_producer, 5, \"producer.tradingpost\")}\n{make(workshop_producer, 5, \"producer.workshop\")}\n\n; Boosters, tiers 1-3\n{make(acceleration_booster, 3, \"booster.acceleration\")}\n{make(machine_booster, 3, \"booster.machines\")}\n{make(production_booster, 3, \"booster.production.regular\")}\n{make(resource_booster, 3, \"booster.resource.drops\")}\n\n{category(prod, town_producer, arcade_producer, resource_booster)}\n\n; Machines, tiers 1-10\n{make(assembly, 10, \"machine.assembler\")}\n{make(belt, 10, \"machine.transportbelt\")}\n{make(boiler, 10, \"machine.boiler\")}\n{make(crusher, 10, \"machine.crusher\")}\n{make(cutter, 10, \"machine.cutter\")}\n{make(mixer, 10, \"machine.mixer\")}\n{make(oven, 10, \"machine.oven\")}\n{make(presser, 10, \"machine.presser\")}\n{make(refiner, 10, \"machine.refinery\")}\n{make(shaper, 10, \"machine.shaper\")}\n\n{category(mach, belt, assembly, shaper)}\n\n; Various crafted parts\n{make(block, 10, \"block\")}\n{make(chip, 5, \"chip\")}\n{make(hammer, 1, \"hammer\")}\n{make(insul_cable, 10, \"cable.insulated\")}\n{make(motor, 10, \"motor\")}\n{make(pump, 10, \"pump\")}\n{make(rainbow_dust, 1, \"dust.rainbow\")}\n{make(rubber_sapling, 1, \"sapling.rubber\")}\n{make(stacked_plate, 10, \"plate.stack\")}\n{make(stacked_pumpkin, 1, \"pumpkin.stack\")}\n{make(void_sapling, 1, \"sapling.void\")}\n\n{category(crft, chip, block, void_sapling)}\n\n; Transforms ore into dust, tiers 1-10\n; Because of an implementation detail, this must come before any\n; scannable items.\n; This doesn't show up in any category in the UI.\n{special(ore, 10, \"ore\")}\n\n; ----- SCANNABLE ITEM GROUPS -----\n; These are not real items, but rather groups of items that will be made together\n; if you select one of these names. They are meant for use with the Crafter, to\n; crank out sets of items to scan quickly. You will want to set the quantity to 1000.\n\n; Notes on using item groups:\n; * SCAN YOUR ORES FIRST! The factory can and will consume your ore to make stuff,\n;     and it takes a long time to get 1000 T10 ore.\n; * The quantity works a little differently than normal items. Instead of making\n;     1000 items each time, running it again will top off everything to be\n;     *at* the quantity of 1000 items.\n; * If you craft a higher tier after a lower tier, it will consume the results\n;     of the first craft to make the higher tier. Scan all the items first, before\n;     moving on to the next tier!\n; * None of these groups include Gem Producers or Exotic Producers. They are too\n;     expensive in comparison to other things, craft them on your own when you\n;     judge the time is right.\n\n; Makes *everything* (expect special producers and lumps) of the given tier.\n; This is the combination of \"chips_and_prods\", \"machines\", and \"parts\".\n; Requires x10 and high processing speed to have a hope of completing in a\n; reasonable amount of time for T5 and T10.\n; You need Quantum Warehouse to have enough space for this at higher tiers!\n{group(all, 10)}\n\n; All the tiers of chips. Warning: Expensive. Input this as tier 1.\n{group(chips, 1)}\n\n; Producers + the chip of the corresponding tier. This is everything that\n; exists in tier range 1-5, for convenience.\n{group(chip_and_prods, 5)}\n\n; All machines. Tiers 1-10\n{group(machines, 10)}\n\n; All ingredients and parts. Tiers 1-10. Doesn't include ore (scan that before\n; starting) or lumps (due to technical limitations). Lumps aren't required\n; for anything currently though.\n; Includes rubber plates at tier 1 and hammers at tier *2*.\n; Rubber trees are at tier 9 because of their ore.\n{group(parts, 10)}\n\n; All producers, except for special producers. Tiers 1-5\n{group(producers, 5)}\n\n{category(grup, all, all, producers)}\n\n; ----- INGREDIENTS AND PRODUCED PARTS -----\n\n; Parts, tiers 1-10\n{item(anti_pumpkin, 1, \"pumpkin.anti\")}\n{item(board, 10, \"plate.circuit\")}\n{item(cable, 10, \"cable\")}\n{item(carved_pumpkin, 1, \"pumpkin.carved\")}\n{item(circuit, 10, \"circuit\")}\n{item(dense_block, 10, \"block.dense\")}\n{item(dense_plate, 10, \"plate.dense\")}\n{item(ingot, 10, \"ingot\")}\n{item(pipe, 10, \"pipe\")}\n{item(plate, 10, \"plate\")}\n{item(pumpkin_plate, 1, \"pumpkin.plate\")}\n{item(rainbow_ingot, 1, \"ingot.rainbow\")}\n{item(rainbow_plate, 1, \"plate.rainbow\")}\n{item(ring, 10, \"ring\")}\n{item(rod, 10, \"rod\")}\n{item(rubber_plate, 1, \"plate.rubber\")}\n{item(screw, 10, \"screw\")}\n{item(wire, 10, \"wire\")}\n\n{category(part, circuit, anti_pumpkin, wire)}\n\n;Tries to make dust from ores and lower-tier dusts, tiers 1-10\n; Doesn't appear in the UI\n{item(dust, 10, \"dust\")}\n\n; Tiers up dust, tiers 1-9\n; These are ore lumps, plus putting them into the mixer.\n; There is no \"only make ore lumps, without mixing them\" option right now.\n; Doesn't appear in the UI\n{special(lump, 9, \"lump\")}\n\n; Can only be made from saplings\n; Doesn't appear in the UI\n{item(void_essence, 1, \"essence.void\")}\n\n; Can only be gotten through the Halloween event\n; Doesn't appear in the UI\n{item(pumpkin, 1, \"pumpkin\")}\n\n; Rubber, tier 1 only\n; Doesn't appear in the UI\n{item(rubber, 1, \"rubber\")}\n\n; ===== END OF VALID IDS =====\n"],["factory macros","; Infrastructure for producing all the constants in the factory package.\n; Since this is :imported, it can't produce any instructions.\n\n#script_name(name) D0S.factory {version}:{name}\n\n; Key assignments.\n; You can edit these here,\n; or you can edit them later in the generated script\n; (but you will have more places to modify).\n#up w\n#down s\n#left a\n#right d\n#start f\n\n; Shared hidden variables for the UI\n#action \"<size=0>fa#\"\n#status \"fs#\"\n\n; Produces the name of the queue variable for the given tier and item.\n#queue_str \"cq\"\n#queue(tier, item) -1 + 10 * ({item}) + {tier}\n\n; Raw access to the queue. Not preferred, but better than using \"queue\"\n; directly. Use for low-level optimization.\n#raw_name(raw_item) {queue_str} . (100 + {raw_item})\n#get_raw(raw_item) global.double.get({raw_name({raw_item})})\n#set_raw(raw_item, val) global.double.set({raw_name({raw_item})}, {val})\n\n; Helper macros for operating on the craft_queue. These should be\n; used instead of direct access whenever possible.\n#get_queue(tier, item) {get_raw({queue({tier},{item})})}\n#set_queue(tier, item, value) {set_raw({queue({tier},{item})},{value})}\n\n; Add/subtract a value from the queue. Although it expands to\n; the same thing, it saves a lot of boilerplate in the source and makes it\n; easier to understand\n; what's going on.\n#add_queue(tier, item, value) {set_queue(\\\n  {tier}, \\\n  {item}, \\\n  {get_queue({tier},{item})} + {value}\\\n)}\n#subtract_queue(tier, item, value) {set_queue(\\\n  {tier}, \\\n  {item}, \\\n  {get_queue({tier},{item})} - ({value})\\\n)}\n\n; Used with factory.composite_string to\n; extract the name from the returned data.\n#get_name sub(itemdata, 0, index(itemdata, \" \", 0))\n\n; These macros can only be called *after* factory.composite_string,\n; i.e. later on in the script.\n#items_count {lua(return factory.items_count)}\n#tiers_char sub(itemdata, {lua(return factory.entry_size - 1)}, 1)\n\n{lua(\\\n  factory = {};\\\n  factory.items = {};\\\n  factory.item_names = {};\\\n  factory.categories = {};\\\n  factory.prods = {};\\\n  factory.prod_machines = {};\\\n  factory.name_max_size = 0;\\\n  factory.game_name_sizes = {};\\\n  factory.game_name_sizes.item = 0;\\\n  factory.game_name_sizes.craft = 0;\\\n  factory.game_name_sizes.group = 0;\\\n  factory.game_name_sizes.special = 0;\\\n  factory.group_map = {};\\\n  factory.group_map.item = 0;\\\n  factory.group_map.craft = 1;\\\n  factory.group_map.group = 2;\\\n  factory.group_map.special = 2; --[[Intentionally the same]]\\\n\\\n  function factory.add_item(name, tiers, game_name, craft_type)\\\n    local item = {};\\\n    item.id = #factory.items + 1;\\\n    if item.id > 89 then\\\n      return \"Too many items: Over the limit while adding \" .. name;\\\n    end\\\n    item.name = name;\\\n    item.game_name = game_name;\\\n    item.tier = tiers;\\\n    item.craft_type = craft_type;\\\n    factory.items[item.id] = item;\\\n    factory.item_names[name] = item;\\\n    if #name > factory.name_max_size then\\\n      factory.name_max_size = #name;\\\n    end\\\n    if #game_name > factory.game_name_sizes[craft_type] then\\\n      factory.game_name_sizes[craft_type] = #game_name;\\\n    end\\\n    return \":const int \" .. name .. \" \" .. #factory.items;\\\n  end\\\n\\\n  function factory.composite_string(var, filter, use_group_info)\\\n    local acc = {};\\\n    local size = 0;\\\n    local first = #factory.items;\\\n    local last = 0;\\\n    local group_map = factory.group_map;\\\n    \\\n    if filter == nil then\\\n      size = math.max(\\\n        factory.game_name_sizes[\"item\"], \\\n        factory.game_name_sizes[\"craft\"]\\\n      );\\\n    else\\\n      size = factory.game_name_sizes[filter];\\\n    end\\\n    size = size + 1;\\\n    local fmt = \"%-\" .. size .. \"s%d\";\\\n    size = size + 1;\\\n    acc[1] = 'sub(\"';\\\n    for i = 1, #factory.items do\\\n      local item = factory.items[i];\\\n      if filter == nil or item.craft_type == filter then\\\n        if use_group_info then\\\n          acc[#acc + 1] = string.format(\\\n            fmt, \\\n            item.game_name, group_map[item.craft_type]\\\n          );\\\n        else\\\n          acc[#acc + 1] = string.format(\\\n            fmt, \\\n            item.game_name, item.tier - 1\\\n          );\\\n        end\\\n        if i < first then first = i end\\\n        if i > last then last = i end\\\n      end\\\n    end\\\n    acc[#acc + 1] = '\", ' .. size .. \" * (\" .. var .. \"), \" .. size .. ')';\\\n    factory.items_count = last - first + 1;\\\n    factory.entry_size = size;\\\n    return table.concat(acc);\\\n  end\\\n\\\n  function factory.add_category(name, ...)\\\n    local category = {}\\\n    factory.categories[#factory.categories + 1] = category\\\n    category.name = name\\\n    local name1, name2, name3 = \"default\", \"first\", \"last\"\\\n    local arg1, arg2, arg3 = ...\\\n    for i = 1, 3 do\\\n      local trimmed = arg1:gsub(\"^ +\", \"\")\\\n      local item = factory.item_names[trimmed]\\\n      if not item then\\\n        error(string.format(\"Can't find %s\", trimmed));\\\n      end\\\n      category[name1] = item.id\\\n      name1, name2, name3 = name2, name3\\\n      arg1, arg2, arg3 = arg2, arg3\\\n    end\\\n  end\\\n)}\n\n; Define a new production item with name \"name\", craftable from tiers 1-\"tiers\".\n; The string passed to produce() is \"game_name\".\n; It will take the next available id, starting from 1.\n#item(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"item\")\\\n)}\n\n; Define a new production item with name \"name\", craftable from tiers 1-\"tiers\".\n; The string passed to craft() is \"game_name\".\n; It will take the next available id, starting from 1.\n#make(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"craft\")\\\n)}\n\n; Define a new item group, i.e. a set of items designed to be scanned in the\n; crafter. Because items need a valid game_name to be passed to count() in\n; various places (or else there will be spurious logging), we use \"ore\".\n; (The value returned from count() will always be ignored.)\n#group(name, tiers) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, \"{name}.group\", \"group\")\\\n)}\n\n; Defines a \"special\" item. This has a real name, like an item, but acts\n; like an item-group in other ways. This is used for lumps and ore, which\n; require special-case handling.\n#special(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"special\")\\\n)}\n\n; Defines a category grouping for the UI. \"First\" and \"last\" are the span of\n; the group (inclusive), in item names. Must be called *after* the relevant items\n; are defined.\n#category(name, default, first, last) {lua(\\\n  return factory.add_category(\"{name}\", \"{default}\", \"{first}\", \"{last}\")\\\n)}\n"],["worker_storage_lib","; This library will find a slot in the pool of workers to use as \"permanent storage\".\n; If one doesn't already exist with the given tag, a new one will be allocated,\n; *but* it will avoid overwriting other worker names using the same sytem of tags\n; for storage. Thus, scripts can use this to cooperate without having to\n; explicitly assign worker slot numbers.\n;\n; The scheme is that a name will be prefixed with \"[TOKEN]\", where \"TOKEN\" is\n; some short, unique word that will identify the script in question. For instance,\n; the factory might use the word \"factory\".\n;\n; This library does not actually store anything in the worker name. Instead, it\n; sets the variable \"worker_slot\", which you must declare in your code.\n; If worker_slot < 100, then it found a valid slot with the worker_prefix.\n; If 100 <= worker_slot < 200, then there was no existing slot, but new data\n; can be initialized at (worker_slot - 100). If worker_slot == 200, then there\n; are no available slots at all, and you should show an error message or take\n; approriate action.\n;\n; A complete example looks like this (replace angle brackets with curlies):\n;\n; :local int worker_slot\n; <worker_lib_line_1([TOKEN])>\n; <worker_lib_line_2>\n\n; =================================================================================\n\n#worker_prefix {lua(return worker_lib_prefix)}\n#worker_lacks_prefix sub(worker.name(worker_slot), 0, {len({worker_prefix})}) != \"{worker_prefix}\"\n\n; The first macro, which defines the first line and the loop variable that we\n; jump to. We also store the worker_prefix with Lua, so that we don't need to\n; repeat it on the 2nd macro.\n; We don't want to skip slot 0. Doing it like this saves a line.\n#worker_lib_line_1(worker_prefix_arg) {lua(\\\n  worker_lib_prefix = \"{worker_prefix_arg}\"\\\n)}\\\nfind_worker_slot_loop: worker_slot = worker_slot + if({worker_lacks_prefix}, 1, 0)\n\n; The second macro, which iterates until we're done.\n; The test against worker.group() checks for non-existant workers. They would\n; otherwise show as acceptable candidates, and we need to keep iterating to 200\n; in that case.\n#worker_lib_line_2 gotoif(find_worker_slot_loop,\\\n  worker_slot < 100 && {worker_lacks_prefix} ||\\\n  worker_slot >= 100 && worker_slot < 200 && (worker.group(worker_slot - 100) == -1 || contains(sub(worker.name(worker_slot - 100), 0, 1), \"[\")))\n"],["recipes",":import factory constants\n\n{lua(\\\n  factory.recipes = {};\\\n)}\n\n; Infrastructure for defining the recipe list.\n{lua(\\\n  function factory.recipe(item)\\\n    local recipe_item = factory.item_names[item];\\\n    if not recipe_item then\\\n      error(string.format(\"Unknowon item '%s'\", item));\\\n    elseif recipe_item.recipes then\\\n      error(string.format(\"Duplicate recipe for '%s'\"), item);\\\n    end\\\n    factory.recipe_item = recipe_item;\\\n    local offset = 10 * recipe_item.id;\\\n    --[[/*\\\n        * There are two types of recipe list that we store:\\\n        * * A \"forward\" list stored on the item itself, which records\\\n        * * what items are needed to *make* that item,\\\n        * * and a \"reverse\" list stored on the main\\\n        * * factory object and indexed by queue id,\\\n        * * which records what items can be *made from* the item.\\\n        * \\\n        * The forward list is used by the item group system,\\\n        * * while the reverse list is used by the recipe system proper.\\\n       */]]\\\n    for i = offset, offset + recipe_item.tier - 1 do\\\n      if not factory.recipes[i] then\\\n        factory.recipes[i] = {};\\\n      end\\\n    end\\\n    recipe_item.recipes = {};\\\n    for i = 1, recipe_item.tier do\\\n      recipe_item.recipes[i] = {};\\\n    end\\\n  end\\\n\\\n  function factory.component(tiers, item_name, counts)\\\n    local recipe_item = factory.recipe_item;\\\n    if not recipe_item then\\\n      error(\"Tried to define a component before calling recipe!\");\\\n    end\\\n    local item_name = item_name:gsub(\" \", \"\");\\\n    local item = factory.item_names[item_name];\\\n    if not item then\\\n      error(string.format(\"Unknown item '%s'\", item_name))\\\n    end\\\n    if item.craft_type == \"group\" then\\\n      error(string.format(\\\n        [[Cannot add item \"%s\" because it is a group]],\\\n        item.name,\\\n        recipe_item.name,\\\n        recipe_item.craft_type\\\n      ));\\\n    end\\\n    local tier_tmp = {};\\\n    for word in tiers:gmatch(\"%S+\") do\\\n      local tier = tonumber(word);\\\n      if not tier then\\\n        error(string.format(\"Bad tier %s\", word));\\\n      end\\\n      tier_tmp[#tier_tmp + 1] = tier;\\\n    end\\\n    if #tier_tmp ~= 1 and #tier_tmp ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Tier list has wrong size, item %s has %s tiers\",\\\n        recipe_item.name, recipe_item.tier\\\n      ));\\\n    end\\\n    \\\n    local base_tier;\\\n    for i = 1, recipe_item.tier do\\\n      base_tier = tier_tmp[i] or base_tier;\\\n      local tier = base_tier;\\\n      if tier < 1 then\\\n        tier = tier + i;\\\n      end\\\n      tier_tmp[i] = tier;\\\n    end\\\n    \\\n    local counts_tmp = {};\\\n    for word in counts:gmatch(\"%S+\") do\\\n      local count = tonumber(word);\\\n      if not count then\\\n        error(string.format(\"Bad count %s\", word))\\\n      end\\\n      counts_tmp[#counts_tmp + 1] = count;\\\n    end\\\n    if #counts_tmp ~= 1 and #counts_tmp ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Count list has wrong size, item %s has %s tiers\",\\\n        recipe_item.name, recipe_item.tier\\\n      ));\\\n    end\\\n    for i = #counts_tmp + 1, recipe_item.tier do\\\n      counts_tmp[i] = counts_tmp[i-1];\\\n    end\\\n    --[[/*\\\n        * Finally, merge the two expanded lists and\\\n        * * distribute the results across the recipes for each tier.\\\n        * * These recipes are \"reversed,\" in the sense that\\\n        * * they don't describe how to make each item, but\\\n        * * rather all the items that this one can be used to help make.\\\n        * \\\n        * It's this reversed list that is needed for\\\n        * * computing the material needs when crafting.\\\n       */]]\\\n    local recipes = factory.recipes;\\\n    local offset = recipe_item.id * 10 - 1;\\\n    for i = 1, recipe_item.tier do\\\n      local tier = tier_tmp[i];\\\n      local count = counts_tmp[i];\\\n      if count > 0 and tier > 0 then\\\n        --[[/*\\\n            * Tiers less than 1 can happen naturally, due to the negative\\\n            * * tier convention, so they are silently dropped.\\\n            * \\\n            * Tiers greater than the the maximum number of tiers\\\n            * * are errors.\\\n           */]]\\\n        if tier > item.tier then\\\n          error(string.format(\\\n            \"Tier %s > item max tier %s\", \\\n            tier, item.tier\\\n          ))\\\n        end\\\n        local idx = item.id * 10 + tier - 1;\\\n        local comp = recipes[idx];\\\n        if comp == nil then\\\n          comp = {};\\\n          recipes[idx] = comp;\\\n        end\\\n        comp[#comp + 1] = offset + i;\\\n        comp[#comp + 1] = count;\\\n        local item_recipe = recipe_item.recipes[i];\\\n        item_recipe[#item_recipe + 1] = idx;\\\n        item_recipe[#item_recipe + 1] = count;\\\n      end\\\n    end\\\n  end\\\n\\\n  function factory.produce(item, source, mult, machine)\\\n    local recipe_item = factory.item_names[item];\\\n    if not recipe_item then\\\n      error(string.format(\"Unknowin item '%s'\", item));\\\n    elseif recipe_item.recies then\\\n      error(string.format(\"Duplicate recipe for '%s'\", item));\\\n    end\\\n    \\\n    local source_item = factory.item_names[source];\\\n    if not source_item then\\\n      error(string.format(\"Unknown item '%s'\", source));\\\n    elseif source_item.tier ~= recipe_item.tier then\\\n      error(string.format(\\\n        \"Tier mismatch: %s (%s) vs %s (%s)\",\\\n        source, source_item.tier,\\\n        item, recipe_item.tier\\\n      ));\\\n    end\\\n    if #factory.prods == 0 or \\\n       factory.prods[#factory.prods].machine ~= machine then\\\n      \\\n      if factory.prod_machines[machine] then\\\n        error(string.format(\"Found 2nd group of machine '%s'\", machine));\\\n      end\\\n      factory.prod_machines[machine] = #factory.prods + 1;\\\n      factory.prod_machines[#factory.prod_machines + 1] = machine;\\\n    end\\\n    local prod = {};\\\n    prod.item = recipe_item;\\\n    prod.source = source_item;\\\n    prod.mult = mult;\\\n    prod.machine = machine;\\\n    factory.prods[#factory.prods + 1] = prod;\\\n\\\n    local offset = 10 * source_item.id;\\\n    local count = 1 / mult;\\\n    for i = offset, offset + recipe_item.tier - 1 do\\\n      if not factory.recipes[i] then\\\n        factory.recipes[i] = {};\\\n      end\\\n      local recipe = factory.recipes[i];\\\n      recipe[#recipe + 1] = 10 * recipe_item.id - offset + i;\\\n      recipe[#recipe + 1] = count;\\\n    end\\\n    recipe_item.recipes = {};\\\n    for i = 1, recipe_item.tier do\\\n      local recipe = {};\\\n      recipe[1] = offset + i - 1;\\\n      recipe[2] = count;\\\n      recipe_item.recipes[i] = recipe;\\\n    end\\\n  end\\\n\\\n  function factory.check_recipes()\\\n    for i = 1, #factory.items do\\\n      local item = factory.items[i];\\\n      if not item.recipes then\\\n        error(string.format(\\\n          \"%s(%s) has no assigned recipe!\",\\\n          item.name, item.id\\\n        ));\\\n      end\\\n    end\\\n  end\\\n)}\n\n; Every recipe begins with this line. There must be one (and only one)\n; recipe declaration for each item, even if there is no way to make it\n; (like for rubber).\n#recipe(item) {lua(return factory.recipe([[{item}]]))}\n\n; After starting a recipe, list its components with this.\n; A component declares a single item that is used, and\n; the tiers and counts of that item for each tier of the recipe_item\n; that's being made. The list on the left side is the tiers,\n; the list on the right is the counts.\n;\n; For instance:\n;  recipe(white_producer)\n;  component(2 3 5 7 9, screw, 2 4 4 4 4)\n; Means that\n; a T1 white_producer needs 2 T2 screws,\n; a T2 white_producer needs 4 T3 screws,\n; a T3 white_producer needs 4 T5 screws,\n; etc.\n; \n; There are additional space-saving wrinkles. Instead of repeating\n; a number for every tier or every count when it's always the same,\n; you can list it once. This is all-or-nothing: It must be exactly once,\n; or listed once for every tier in the recipe. Also, in the tier list you\n; can use numbers less than 1. This means that the position in the list\n; will be added to the number. I.e. a value of 0 becomes equal\n; to \"current_tier\", -1 becomes \"current_tier - 1\", etc.\n#component(tiers, item, counts) {lua(\\\n  return factory.component([[{tiers}]],[[{item}]],[[{counts}]]);\\\n)}\n\n; For items that are made in machines, use this macro instead.\n; This defines the needed recipe automatically.\n; The third argument is the \"multiplier\", which says how many\n; multiples of the item are made from a single source input.\n; It is assumed that the production happens for all tiers of the item,\n; from the same source tier\n; things like mixing or boiling dust aren't handled\n; through this system. (Boiling isn't handled at all.)\n#produce(item, source, mult, machine) {lua(\\\n  return factory.produce(\\\n    [[{item}]],\\\n    string.gsub([[{source}]], \" \", \"\"),\\\n    {mult},\\\n    string.gsub([[{machine}]], \" \", \"\")\\\n  );\\\n)}\n\n; ===== BEGIN RECIPES =====\n\n{recipe(town_producer)}\n{component(2 3 5 7 9, screw, 2 4 4 4 4)}\n{component(2 0 0 0 0, plate, 2 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 2 2 2 6)}\n{component(-1, chip, 0 2 2 2 4)}\n{component(-1, town_producer, 1)}\n\n{recipe(factory_producer)}\n{component(1 3 5 7 9, wire, 1 4 4 4 4)}\n{component(2 0 0 0 0, screw, 1 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 1 1 1 3)}\n{component(2 3 5 0 0, plate, 2 2 2 0 0)}\n{component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}\n{component(1 1 2 3 4, chip, 2 1 1 1 3)}\n{component(-1, factory_producer, 1)}\n\n{recipe(mine_producer)}\n{component(2 3 5 7 9, screw, 2 2 2 4 4)}\n{component(1 2 4 6 8, wire, 2 3 2 5 5)}\n{component(2 0 5 7 9, plate, 1 0 1 2 2)}\n{component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}\n{component(1 1 2 3 4, chip, 1)}\n{component(-1, mine_producer, 1)}\n\n{recipe(workshop_producer)}\n{component(0 2 4 6 8, wire, 0 4 2 8 8)}\n{component(1 3 5 7 9, wire, 4 2 2 2 2)}\n{component(2 3 5 7 9, plate, 1 2 2 2 2)}\n{component(1 0 2 3 4, chip, 1 0 2 2 2)}\n{component(-1, workshop_producer, 1)}\n\n{recipe(construction_firm_producer)}\n{component(2 4 6 8 10, rod, 3 4 10 10 10)}\n{component(2 4 6 8 10, plate, 2)}\n{component(1 1 2 3 4, chip, 1 2 2 2 2)}\n{component(-1, construction_firm_producer, 1)}\n\n{recipe(laboratory_producer)}\n{component(0 3 5 7 9, pipe, 0 3 5 10 14)}\n{component(2 4 6 8 10, motor, 1)}\n{component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, laboratory_producer, 1)}\n\n{recipe(headquarters_producer)}\n{component(1 3 5 7 9, wire, 2 4 8 8 12)}\n{component(2 4 6 8 10, motor, 1 2 2 2 2)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, headquarters_producer, 1)}\n\n{recipe(powerplant_producer)}\n{component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}\n{component(2 4 6 8 10, motor, 1)}\n{component(0 3 5 7 9, block, 0 3 5 5 14)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, powerplant_producer, 1)}\n\n{recipe(arcade_producer)}\n{component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}\n{component(2 4 6 8 10, pipe, 4 4 4 4 8)}\n{component(0, chip, 4 4 4 4 6)}\n{component(-1, arcade_producer, 1)}\n\n{recipe(tradingpost_producer)}\n{component(2 4 6 8 10, ring, 6 8 8 8 12)}\n{component(2 4 6 8 10, plate, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, tradingpost_producer, 1)}\n\n{recipe(shipyard_producer)}\n{component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}\n{component(1 3 5 7 9, block, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, shipyard_producer, 1)}\n\n{recipe(museum_producer)}\n{component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}\n{component(2 4 6 8 10, block, 4 5 5 5 7)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, museum_producer, 1)}\n\n{recipe(statue_of_cubos_producer)}\n{component(1 3 5 7 9, dense_block, 4 5 5 5 7)}\n{component(2 4 6 8 10, motor, 2)}\n{component(2 4 6 8 10, pipe, 2)}\n{component(2 4 6 8 10, pump, 2 3 3 3 5)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, statue_of_cubos_producer, 1)}\n\n{recipe(gem_producer)}\n{component(5, chip, 10)}\n{component(4, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(1, dense_block, 1)}\n{component(2, dense_block, 1)}\n{component(3, dense_block, 1)}\n{component(4, dense_block, 1)}\n{component(5, dense_block, 1)}\n{component(6, dense_block, 1)}\n{component(7, dense_block, 1)}\n{component(8, dense_block, 1)}\n{component(9, dense_block, 1)}\n{component(10, dense_block, 1)}\n\n{recipe(exotic_producer)}\n{component(5, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(10, dense_block, 10)}\n{component(10, assembly, 1)}\n{component(10, boiler, 1)}\n{component(10, crusher, 1)}\n{component(10, cutter, 1)}\n{component(10, mixer, 1)}\n{component(10, oven, 1)}\n{component(10, presser, 1)}\n{component(10, refiner, 1)}\n{component(10, shaper, 1)}\n{component(10, belt, 1)}\n\n{recipe(acceleration_booster)}\n{component(2 3 5, chip, 1 4 6)}\n{component(4, plate, 4 0 0)}\n{component(1, rainbow_plate, 0 2 4)}\n{component(4 8 0, circuit, 4 8 0)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, acceleration_booster, 2)}\n\n{recipe(machine_booster)}\n{component(2 3 5, chip, 2)}\n{component(4 7 10, pipe, 4)}\n{component(4, wire, 2 0 0)}\n{component(0 7 10, dense_block, 0 2 2)}\n{component(8, dense_plate, 0 6 0)}\n{component(1, rainbow_plate, 0 0 4)}\n{component(1, void_essence, 0 0 2)}\n{component(4, circuit, 1 0 0)}\n{component(-1, machine_booster, 1)}\n\n{recipe(production_booster)}\n{component(1 3 0, chip, 4 4 0)}\n{component(2 7 0, plate, 4 6 0)}\n{component(2 7 10, circuit, 1 4 4)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, production_booster, 0 1 4)}\n\n{recipe(resource_booster)}\n{component(3, plate, 6 0 0)}\n{component(1, rainbow_plate, 0 0 2)}\n{component(1 3 4, chip, 2 2 6)}\n{component(4 8 0, circuit, 1 2 0)}\n{component(0 7 10, block, 0 4 4)}\n{component(1, void_essence, 0 0 1)}\n{component(-1, resource_booster, 0 1 2)}\n\n{recipe(pumpkin_producer)}\n{component(0, carved_pumpkin, 6)}\n{component(0, anti_pumpkin, 6)}\n{component(0, pumpkin_plate, 20)}\n\n{recipe(oven)}\n{component(0, plate, 4 6 8 8 8 8 8 8 8 8)}\n{component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}\n{component(0, block, 0 0 0 0 0 2 2 2 2 2)}\n{component(-1, oven, 1)}\n\n{recipe(presser)}\n{component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}\n{component(0, plate, 4 5 7 7 7 9 9 9 9 9)}\n{component(0, wire, 1 1 2 2 2 3 3 3 3 3)}\n{component(0, block, 0 0 0 0 4 5 5 5 5 5)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 2)}\n{component(-1, presser, 1)}\n\n{recipe(assembly)}\n{component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}\n{component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}\n{component(0, motor, 1 1 1 1 1 1 1 1 2 2)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}\n{component(-1, assembly, 1)}\n\n{recipe(refiner)}\n{component(0, block, 0 0 0 0 0 0 5 5 5 7)}\n{component(0, dense_plate, 4)}\n{component(0, motor, 1 1 1 1 2 2 2 2 2 4)}\n{component(0, ring, 1 2 2 2 3 3 3 3 3 5)}\n{component(0, pump, 1 2 2 2 3 3 3 3 3 5)}\n{component(1 1 2 2 2 2 3 4 4 5, chip, 2)}\n{component(-1, refiner, 1)}\n\n{recipe(mixer)}\n{component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}\n{component(0, motor, 2)}\n{component(0, pump, 1 1 1 2 2 3 3 3 3 3)}\n{component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}\n{component(-1, mixer, 1)}\n\n{recipe(crusher)}\n{component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}\n{component(0, motor, 1 1 1 1 1 1 1 2 2 2)}\n{component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}\n{component(-1, crusher, 1)}\n\n{recipe(belt)}\n{component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}\n{component(0, motor, 3 3 3 3 3 3 4 4 4 4)}\n{component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}\n{component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}\n{component(-1, belt, 1)}\n\n{recipe(cutter)}\n{component(0, plate, 2 2 2 2 2 2 2 0 0 0)}\n{component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}\n{component(0, block, 0 0 0 0 0 0 0 4 4 6)}\n{component(0, motor, 3 4 4 4 4 5 5 5 5 7)}\n{component(-1, cutter, 1)}\n\n{recipe(shaper)}\n{component(0, plate, 4 4 4 4 4 4 4 4 4 0)}\n{component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}\n{component(0, screw, 1 2 2 2 2 3 3 3 3 3)}\n{component(0, block, 1 2 2 2 2 3 3 3 3 0)}\n{component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}\n{component(0, motor, 2)}\n{component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}\n{component(-1, shaper, 1)}\n\n{recipe(boiler)}\n{component(0, wire, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, block, 4 7 7 8 8 8 8 8 9 10)}\n{component(0, motor, 1 1 1 2 2 2 2 2 3 4)}\n{component(0, screw, 2)}\n{component(0, pump, 1)}\n{component(-1, boiler, 1)}\n\n{recipe(rainbow_dust)}\n{component(1, dust, 1)}\n{component(2, dust, 1)}\n{component(3, dust, 1)}\n{component(4, dust, 1)}\n{component(5, dust, 1)}\n{component(6, dust, 1)}\n{component(7, dust, 1)}\n{component(8, dust, 1)}\n{component(9, dust, 1)}\n{component(10, dust, 1)}\n\n{recipe(chip)}\n{component(1 3 5 7 9, circuit, 2)}\n{component(2 4 6 8 10, circuit, 2 4 4 2 2)}\n{component(1 3 5 7 9, board, 1 4 4 6 8)}\n{component(2 4 6 8 10, board, 1 2 2 6 8)}\n{component(-1, chip, 0 4 8 12 12)}\n\n{recipe(insul_cable)}\n{component(0, cable, 1 1 1 2 3 4 5 10 12 16)}\n{component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}\n\n{recipe(stacked_plate)}\n{component(0, plate, 9)}\n\n{recipe(stacked_pumpkin)}\n{component(0, pumpkin, 9)}\n\n{recipe(motor)}\n{component(0, plate, 4)}\n{component(0, screw, 1)}\n{component(0, rod, 2)}\n{component(0, wire, 1)}\n{component(1, rubber, 1)}\n\n{recipe(pump)}\n{component(0, plate, 2)}\n{component(0, motor, 1)}\n{component(0, ring, 2)}\n{component(1, rubber_plate, 4)}\n\n{recipe(hammer)}\n{component(2, ingot, 6)}\n{component(2, rod, 1)}\n\n{recipe(block)}\n{component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}\n\n{recipe(rubber_sapling)}\n{component(0, rubber, 8)}\n{component(9, ore, 1)}\n\n{recipe(void_sapling)}\n{component(1, rainbow_dust, 8)}\n{component(1, rubber_sapling, 1)}\n\n{recipe(producers)}\n#recipe_producers(x) \\\n{component(0, town_producer, {x})}\\\n{component(0, factory_producer, {x})}\\\n{component(0, mine_producer, {x})}\\\n{component(0, workshop_producer, {x})}\\\n{component(0, construction_firm_producer, {x})}\\\n{component(0, laboratory_producer, {x})}\\\n{component(0, headquarters_producer, {x})}\\\n{component(0, powerplant_producer, {x})}\\\n{component(0, arcade_producer, {x})}\\\n{component(0, tradingpost_producer, {x})}\\\n{component(0, shipyard_producer, {x})}\\\n{component(0, museum_producer, {x})}\\\n{component(0, statue_of_cubos_producer, {x})}\n{recipe_producers(1)}\n\n{recipe(machines)}\n{component(0, oven, 1)}\n{component(0, presser, 1)}\n{component(0, assembly, 1)}\n{component(0, refiner, 1)}\n{component(0, mixer, 1)}\n{component(0, crusher, 1)}\n{component(0, belt, 1)}\n{component(0, cutter, 1)}\n{component(0, shaper, 1)}\n{component(0, boiler, 1)}\n\n{recipe(parts)}\n#recipe_parts \\\n{component(0, insul_cable, 1)}\\\n{component(0, stacked_plate, 1)}\\\n{component(0, motor, 1)}\\\n{component(0, pump, 1)}\\\n{component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, block, 1)}\\\n{component(0, ingot, 1)}\\\n{component(0, plate, 1)}\\\n{component(0, dense_plate, 1)}\\\n{component(0, dense_block, 1)}\\\n{component(0, pipe, 1)}\\\n{component(0, cable, 1)}\\\n{component(0, wire, 1)}\\\n{component(0, rod, 1)}\\\n{component(0, ring, 1)}\\\n{component(0, screw, 1)}\\\n{component(0, board, 1)}\\\n{component(0, circuit, 1)}\\\n{component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\\\n{component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}\n{recipe_parts}\n\n{recipe(chips)}\n{component(1, chip, 1)}\n{component(2, chip, 1)}\n{component(3, chip, 1)}\n{component(4, chip, 1)}\n{component(5, chip, 1)}\n\n{recipe(chip_and_prods)}\n{component(0, chip, 1)}\n{recipe_producers(1)}\n\n#recipe_machines_and_parts \\\n{component(0, oven, 1)}\\\n{component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\\\n{component(0, assembly, 1)}\\\n{component(0, refiner, 1)}\\\n{component(0, mixer, 1)}\\\n{component(0, crusher, 1)}\\\n{component(0, belt, 1)}\\\n{component(0, cutter, 1)}\\\n{component(0, shaper, 1)}\\\n{component(0, boiler, 1)}\\\n{recipe_parts}\n\n{recipe(all)}\n{component(0, chip, 1 1 1 1 1 0 0 0 0 0)}\n{recipe_producers(1 1 1 1 1 0 0 0 0 0)}\n{recipe_machines_and_parts}\n\n; Machine-produced items\n{recipe(ingot)} ; Has special-case producing code\n{component(0, dust, 1)}\n\n{produce(rainbow_ingot, rainbow_dust, 1, oven)}\n\n{produce(plate, ingot, 1, presser)}\n{produce(rainbow_plate, rainbow_ingot, 1, presser)}\n{produce(dense_plate, stacked_plate, 1, presser)}\n{produce(rubber_plate, rubber, 1, presser)}\n{produce(pumpkin_plate, stacked_pumpkin, 1, presser)}\n\n{produce(dense_block, block, 1, boiler)}\n{produce(anti_pumpkin, pumpkin, 1, boiler)}\n\n{produce(rod, ingot, 2, shaper)}\n{produce(pipe, plate, 1, shaper)}\n{produce(ring, rod, 1, shaper)}\n\n{produce(cable, ingot, 2, refinery)}\n{produce(board, plate, 1, refinery)}\n{produce(wire, cable, 1, refinery)}\n\n{produce(screw, rod, 4, cutter)}\n{produce(carved_pumpkin, pumpkin, 1, cutter)}\n\n{produce(circuit, cable, 1, assembler)}\n\n; These recipes have special-case code to handle them, because of the\n; complexities involved with choosing between ore and lumps\n; for making dust.\n{recipe(lump)}\n{recipe(dust)}\n\n; Terminal items, unable to be crafted.\n{recipe(ore)}\n{recipe(rubber)}\n{recipe(void_essence)}\n{recipe(pumpkin)}\n\n; ===== END RECIPES =====\n\n{lua(return factory.check_recipes())}\n"],["run_recipes",":import factory constants\n:import recipes\n\n:name {script_name(run_recipes)}\n\n; Debugging function, kept in case of future problems.\n{lua(\\\n  --[[Change to false to see output]]\\\n  if true then return end\\\n  local acc = {};\\\n  acc[1] = \"\\n\";\\\n  for i, item in ipairs(factory.items) do\\\n    acc[1 + #acc] = string.format(\"%02s %-28s [\", i, item.name);\\\n    for j = 1, item.tier do\\\n      local start = 2 + #acc;\\\n      acc[1 + #acc] = \"\\n  \";\\\n      local recipes = factory.recipes[i * 10 + j - 1];\\\n      for _, recipe in ipairs(recipes) do\\\n        acc[1 + #acc] = recipe;\\\n        acc[1 + #acc] = \" \";\\\n      end\\\n      table.insert(acc, start, \"(\");\\\n      acc[#acc] = \")\";\\\n    end\\\n    acc[1 + #acc] = \"\\n]\\n\";\\\n  end\\\n  error(table.concat(acc));\\\n)}\n\n; Now that all the recipes are defined, we have to put them in\n; a valid order. We do this with a modified breadth-first-search,\n; optimized around the structure of our data.\n; Each item (which in this context is a type-tier pair, identified by\n; the formula type * 10 + tier) is sequentially checked against a graph\n; that is incrementally being formed. If all its recipe-items have already\n; been satisfied (or it has none), then it is also satisfied, and\n; (as long as it has recipe-items) it's put on a queue to be output.\n; Otherwise, a count is kept of how many unsatisfied recipes it has,\n; and an entry is made in each blocking recipe pointing back to this item.\n; After each item, the queue is processed. The head of the queue is popped\n; and gets the next sequential id; this is how the recipes\n; get their order. Also, any items blocked on it will have their tallies\n; decremented by one. If these go to zero, they are now satisfied\n; and will be added to the queue to be output, as well.\n{lua(\\\n  local recipes_list = {};\\\n  factory.recipes_list = recipes_list;\\\n  local items = factory.items;\\\n  local recipes = factory.recipes;\\\n  local graph = {};\\\n  local queue = {};\\\n  for tier = 10, 1, -1 do\\\n    for item_id = 1, #items do\\\n      local item = items[item_id];\\\n      local id = 10 * item_id + tier - 1;\\\n      local recipe = recipes[id];\\\n      if not recipe then\\\n        goto continue;\\\n      end\\\n      local entry = graph[id];\\\n      if not entry then\\\n        entry = {};\\\n        entry.blocking = {};\\\n        graph[id] = entry;\\\n      end\\\n      local blockers = 0;\\\n      if recipe then\\\n        for i = 1, #recipe, 2 do\\\n          local other = graph[recipe[i]];\\\n          if not other then\\\n            other = {};\\\n            other.blocking = {};\\\n            other.blockers = -1;\\\n            graph[recipe[i]] = other;\\\n          end\\\n          if other.blockers ~= 0 then\\\n            blockers = blockers + 1;\\\n            other.blocking[#other.blocking + 1] = id;\\\n          end\\\n        end\\\n      end\\\n      entry.blockers = blockers;\\\n      \\\n      if blockers == 0 then\\\n        queue[#queue + 1] = id;\\\n      end\\\n      \\\n      local q_front = 1;\\\n      while q_front <= #queue do\\\n        id = queue[q_front];\\\n        entry = graph[id];\\\n        recipes_list[#recipes_list + 1] = id;\\\n        for i = 1, #entry.blocking do\\\n          local other = graph[entry.blocking[i]];\\\n          other.blockers = other.blockers - 1;\\\n          if other.blockers == 0 then;\\\n            queue[#queue + 1] = entry.blocking[i];\\\n          end;\\\n        end\\\n        q_front = q_front + 1\\\n      end\\\n      queue = {};\\\n      ::continue::\\\n    end\\\n  end\\\n)}\n\n; Debugging function, kept in case of future problems.\n{lua(\\\n  --[[Set to false or any character to see data]]\\\n  if true then return; end\\\n  local acc = {};\\\n  for _, id in ipairs(factory.recipes_list) do\\\n    acc[1 + #acc] = \"\\n\";\\\n    local recipes = factory.recipes[id];\\\n    if #recipes > 15 then\\\n      acc[1 + #acc] = \"|\\n\";\\\n    end\\\n    acc[1 + #acc] = string.format(\"%03d:\", id)\\\n    for _, recipe in ipairs(recipes) do\\\n      acc[1 + #acc] = string.format(\" %3f\", recipe);\\\n    end\\\n    if #recipes > 15 then\\\n      acc[1 + #acc] = \"\\n|\";\\\n    end\\\n  end\\\n  error(table.concat(acc));\\\n)}\n\n; Constructs the data table that is used to create loop_data. See below\n; for the format of this string. One difference is that in loop_data, \n; the previous item/current item index data is at the beginning and end\n; of the string. Here, that is actually only stored once, and the sub()\n; read window is expanded to overlap consequetive sections to pick up the\n; previous item when reading the next.\n#get_data(num_terms) {lua(\\\n  local num_terms = {num_terms};\\\n  local num_terms_2 = num_terms * 2;\\\n  local recipe_limit = 0;\\\n  local acc_main = {};\\\n  \\\n  local multipliers = \"\";\\\n  do\\\n    local mult = {};\\\n    mult[1] = \"0123\";\\\n    --[[characters from a-z]]\\\n    for i = 97, 122 do\\\n      mult[1 + #mult] = string.char(i, 32, 32, 32);\\\n      --[[string.char(32) is space]]\\\n    end\\\n    mult[#mult] = string.char(122);\\\n    multipliers = table.concat(mult);\\\n  end\\\n  local mult_max = {};\\\n  for i = 1, num_terms do\\\n    mult_max[i] = 0;\\\n  end\\\n  acc_main[1] = [[\"___]];\\\n  for _, id in ipairs(factory.recipes_list) do\\\n    local recipe = factory.recipes[id];\\\n    local item_id = id // 10;\\\n    local limit = math.max(0, (#recipe - 1) // num_terms_2);\\\n    for i = 1, (limit + 1) * num_terms_2, 2 do\\\n      local less_rec = i < #recipe;\\\n      acc_main[1 + #acc_main] = less_rec and recipe[i] + 100 or \"   \";\\\n      local mult = less_rec and recipe[i + 1] * 4 or 0;\\\n      local mod = (i // 2) % num_terms + 1;\\\n      if mult_max[mod] < mult then mult_max[mod] = mult end\\\n      acc_main[1 + #acc_main] = multipliers:sub(mult + 1, mult + 1);\\\n      if mod == num_terms then\\\n        acc_main[1 + #acc_main] = id + 100;\\\n        recipe_limit = recipe_limit + 1;\\\n      end\\\n    end\\\n  end\\\n  \\\n  factory.main_size = 4 * num_terms + 3;\\\n  acc_main[1 + #acc_main] = '\"';\\\n  factory.multipliers = {};\\\n  factory.num_terms = num_terms;\\\n  factory.recipe_limit = recipe_limit;\\\n  for i = 1, num_terms do\\\n    if mult_max[i] >= #multipliers then\\\n      error(string.format(\"Multiplier limit exceeded at %s\", i));\\\n    end\\\n    factory.multipliers[i] = multipliers:sub(1, mult_max[i] + 1);\\\n  end;\\\n  return table.concat(acc_main);\\\n)}\n\n#lookup_item {lua(\\\n  return factory.composite_string(\\\n    string.format(\\\n      [[s2i(sub(gsg({data_name}), %d * (i + 1), 2), -1) - 11]],\\\n      factory.main_size\\\n    ),\\\n    nil,\\\n    true --[[Get craft type info instead of tiers]]\\\n  );\\\n)}\n\n; Returns the set of lookup/multiplier terms that will be added\n; in to form the base of the value.\n; Most of the data for this is pre-comupted by get_data().\n#recipe_terms {lua(\\\n  acc = {};\\\n  for i = 1, factory.num_terms do\\\n    if i ~= 1 then\\\n      acc[#acc + 1] = \" + \";\\\n    end\\\n    acc[#acc + 1] = string.format(\\\n      [[max(0., ceil(gdg({queue_str} . sub(loop_data, %d, 3)) *\\\n        i2d(index(\"%s\", sub(loop_data, %d, 1), 0)) * 0.25))]],\\\n      factory.entry_size + 4 * i - 1,\\\n      factory.multipliers[i],\\\n      factory.entry_size + 4 * i + 2\\\n    );\\\n  end\\\n  return table.concat(acc);\\\n)}\n\n; This macro is used to test the type of an item, in order to efficiently\n; disable the count. Item groups don't have a single real item associated,\n; but the count() still has to count something real to avoid\n; a spurious log line. Ore and lumps are also classified as groups\n; so that they won't be counted, because they're treated specially.\n#item_type sub(loop_data, {lua(return factory.entry_size - 1)}, 1)\n\n; These macros are used to test if the item is a dust. Dust gets its queue\n; value inflated by one, which has the effect of always ending up with 1\n; at the end. (Although it doesn't prevent temporarily using all dust.)\n#recipe_item_trunc sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size;\\\n)}, 2)\n#item_trunc(item) \"{lua(return factory.item_names[\"{item}\"].id + 10)}\"\n\n#prev_item sub(loop_data, {lua(return factory.entry_size)}, 3)\n#recipe_item sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size;\\\n)}, 3)\n; The tier value is just the last digit of recipe_item\n#tier_value sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size + 2;\\\n)}, 1)\n#recipe_item_name sub(loop_data, 0, index(loop_data, \" \", 0))\n#recipe_limit {lua(return factory.recipe_limit)}\n\n:global int factory_target\n:global double factory_target_amount\n\n; We use the name of the data variable to pull double-duty as a\n; hider for all the craft-queue variables.\n; This macro gives a prettier name for the global data string.\n#data_name \"<size=0><line-height=0>fdata\"\n\n:local int i\n:local string loop_data\n\n; Uncomment this for debugging. It needs to be before the\n; data-hiding block. Also uncomment the line below.\n;gss(\"debug\", \"\")\n\ngss({data_name}, {get_data(4)})\nloop:\n\n; Evaluates to an expression that results in an string containing\n; encoded data for this recipe. The first entry_size-1 characters are the\n; in-game item name, space-padded. Then comes the item type info:\n; 0 is a regular item, 1 is a crafted item, and 2 is an item-group. After\n; that is a series of 3-number strings, each of which is\n; a craft-queue index.\n; \n; The first is the index for the previous item, which is used to determine\n; if this is a continuation from a previous line. The next `num_terms`\n; terms are index values for queue values to add. After each term is\n; a single character which is a multiplier value. Following that is an\n; index for the current item, which is used as the index to set,\n; and possibly also as an index to read from.\n;\n; All of this is pulled from reading the appropriate sections of \"data\",\n; mostly as-is. However, there is a secondary lookup for the item name.\nloop_data = {lookup_item} . sub(\\\n  gsg({data_name}),\\\n  i * {lua(return factory.main_size)},\\\n  {lua(return factory.main_size + 3)}\\\n)\n\n; The core expression that does all the work. If this item is the target\n; item, then set the queue value to factory_target_amount - this ensures\n; that the target is always made, even if it already exists.\n; Otherwise, we set it to the sum of all of its recipe terms,\n; minus the existing count. This core value is the \"queue value\",\n; and equals how many must be crafted (if positive) or how many extra\n; we have (if negative). Since we are hardcoding the number of\n; recipe terms that are handled in each loop iteration to\n; a small constant (4), there are additional wrinkles because\n; we may need to process the same item multiple times to get all\n; the recipe terms in. This means that if we're seeing\n; the same item again, we add the previous value of the variable and skip\n; subtracting the count. We also skip the count if the item is a group,\n; since those don't have valid items to count anyway.\n; \n; In this way, we efficiently encode a sum that requires multiple passes.\nglobal.double.set({queue_str} . {recipe_item}, if(\\\n  {recipe_item} == i2s(factory_target + 100),\\\n  factory_target_amount,\\\n  (\\\n      if(\\\n        {prev_item} == {recipe_item}, \\\n        global.double.get({queue_str} . {recipe_item}), \\\n        0.0\\\n      ) + {recipe_terms} - if(\\\n        {prev_item} == {recipe_item} || {item_type} == \"2\",\\\n        0.0,\\\n        if({recipe_item_trunc} == {item_trunc(dust)}, -1.0, 0.0) \\\n        + count(\\\n          {recipe_item_name}, \\\n          index(\" 0123456789\", {tier_value}, 0)\\\n        )\\\n      )\\\n    )\\\n  )\\\n)\ni = i + 1\n; Uncomment this line for debugging. It will show the quantities and ids\n; of all items that need to be produced.\n; (The ids will be +100, because of internal reasons.)\n; You will also need to enable another line above.\n;gss(\"debug\", gsg(\"debug\") . if(gdg({queue_str} . {recipe_item}) > 0., \"<br>\" . {recipe_item} . \" \" . gdg({queue_str} . {recipe_item}), \"\"))\ngotoif(loop, i < {recipe_limit})\n\n; inv_tier = 10 - tier. Represented this way so we can use the fact that\n; locals automatically start at 0.\n:local int inv_tier\n\ntierloop:\n\n{add_queue(10 - inv_tier, dust, max(0., ({get_queue(10 - inv_tier, lump)} - count(\"lump\", 10 - inv_tier)) * 4.0))}\n{add_queue(10 - inv_tier, ore, max(0., min(count(\"ore\", 10 - inv_tier), ceil({get_queue(10 - inv_tier, dust)} / 2.))))}\n\ngotoif(nolumps, inv_tier == 9 || count(\"ore\", 10 - inv_tier) + count(\"dust\", 10 - inv_tier) == 0.0)\n{add_queue(9 - inv_tier, lump, max(0., {get_queue(10 - inv_tier, dust)} - {get_queue(10 - inv_tier, ore)} * 2.))}\nnolumps:\n\ninv_tier += 1\ngotoif(tierloop, inv_tier < 10)\n\n; If we're missing the resources needed to complete the recipe, set error.\ngss(\\\n  {action},\\\n  if(\\\n    {get_queue(1, ore)} * 2. < {get_queue(1, dust)},\\\n    \"<color=#fb3>Missing \" . ({get_queue(1, dust)} - {get_queue(1, ore)} * 2.) . \" T1 dust<br>and/or higher tier dust/ore!</color>\",\\\n    if(\\\n      {get_queue(1, rubber)} > 0.,\\\n      \"<color=#fb3>Missing \" . {get_queue(1, rubber)} . \" rubber!</color>\",\\\n      if(\\\n        {get_queue(1, void_essence)} > 0.,\\\n        \"<color=#fb3>Missing \" . {get_queue(1, void_essence)} . \" void essence!</color>\",\\\n        if(\\\n          {get_queue(1, pumpkin)} > 0.,\\\n          \"<color=#fb3>Missing \" . {get_queue(1, pumpkin)} . \" pumpkin(s)!</color>\",\\\n          \"\"\\\n        )\\\n      )\\\n    )\\\n  )\\\n)\n\n:local int k\nunset_loop:\n; If there's an error, clear the queue. We take advantage of initial\n; value being 0 to cut down on lines. The first item is (raw) id 110,\n; corresponding to 100 offset + 1 * 10, so we start at 109 as a no-op.\n; We don't use unset here to avoid reordering issues with other scripts\n; all the global variables we will ever need to hide will have been\n; set by this point, and we don't want to leave holes.\n\n; Note that it is important to skip setting variables that are 0, since\n; those might be tiers that are never calculated - in those cases,\n; they would be new variables outside the hiding block if we set them\n; here (after the first run of the factory).\nglobal.double.set({queue_str} . (109 + k), 0.0)\nskip_unset:\nk += 1\ngotoif(\\\n  if(global.double.get({queue_str} . (109 + k)) == 0., skip_unset, unset_loop),\\\n  contains(gsg({action}), \"<\") && k < {lua(return #factory.items * 10 + 1)}\\\n)\n\ngss(\"fhide2\", \"</line-height></size>\")\n"],["produce",":import factory constants\n:import recipes\n\n:name {script_name(produce)}\n\n:local int i\n:local int machine_idx\n:local double previous_amount\n:local string machine_chunk\n:local string machine_name\n:local string produce_data\n:local string source_name_raw\n\nkey.{left}()\nkey.{right}()\n\nisopen(\"factory\")\n\n; If we were launched via key impulse, invoke the UI immediately to start turbo,\n; and set action to signal which key was pressed. Otherwise, we're being called\n; as a produce script.\nexecute(if(contains(impulse(), \"key.\"), \"{script_name(ui)}\", \"###badname###\"))\ngotoif(end, contains(impulse(), \"key.\"))\n\n; ================== BEGIN MACROS + LUA ==================\n; The data for producing is defined in a single string, stored in\n; produce_data. Each entry in the string is a \"produce_chunk\", defined\n; in the following format:\n; MULT SOURCE_CHAR DEST_ITEM\n; DEST_ITEM is a 3-byte number, denoting the raw queue value for the item.\n; (I.e. after the +100 addition.) SOURCE_CHAR is a single character that\n; is used for indexing a separate lookup table of the source item names.\n; (The source tier will be the same as the tier of DEST_ITEM.) The MULT\n; is a single number used when items produce multiple output copies.\n#produce_chunk_size 5\n\n; Here we precompute all our data tables. There are three tables:\n; produce_data, which stores the produce chunks described above.\n; item_names, which stores destination item names only, and\n; machine_data, which stores a combination of machine name and offset into produce_data.\n;\n; We also compute the character lookup table that is used to convert DEST_ITEM to/from\n; numbers for use with item_names.\n{lua(\\\n  local format = string.format\\\n\\\n  machine_chunk_size = nil\\\n  machine_data = nil\\\n  item_names = nil\\\n  item_names_size = nil\\\n  trans_table = \"0123456789abcdefghijklmnopqrstuvwxyz\"\\\n  produce_data = nil\\\n\\\n  local function pad_strings(arr)\\\n    local max = 0\\\n    for i = 1, #arr do\\\n      max = max >= #arr[i] and max or #arr[i]\\\n    end\\\n    max = max + 1\\\n    local fmt_str = format(\"%%%ds\", -max)\\\n    local res = {}\\\n    for i = 1, #arr do\\\n      res[i] = format(fmt_str, arr[i])\\\n    end\\\n    return res, max\\\n  end\\\n\\\n  local machine_acc = {}\\\n  local item_acc = {}\\\n  local prod_acc = {}\\\n  local prods_offset = 1\\\n  local offsets = {}\\\n  factory.prod_machines[#factory.prod_machines + 1] = \"end\"\\\n  factory.prod_machines[\"end\"] = #factory.prods + 1\\\n  for i = 1, #factory.prod_machines do\\\n    local machine = factory.prod_machines[i]\\\n    machine_acc[i] = machine\\\n    local next_offset = factory.prod_machines[machine]\\\n    for j = 1, 10 do\\\n      for k = prods_offset, next_offset - 1 do\\\n        local prod = factory.prods[k]\\\n        if prod.source.tier < j then goto continue end\\\n        local source_name = prod.source.game_name\\\n        if not item_acc[source_name] then\\\n          item_acc[#item_acc + 1] = source_name\\\n          item_acc[source_name] = #item_acc\\\n        end\\\n        prod_acc[#prod_acc + 1] = prod.mult ..\\\n          string.sub(trans_table, item_acc[source_name], item_acc[source_name]) ..\\\n          prod.item.id * 10 + 100 + j - 1\\\n        ::continue::\\\n      end\\\n    end\\\n    offsets[i] = format(\"%03d\", #prod_acc * 5)\\\n    prods_offset = next_offset\\\n  end\\\n  if #prod_acc * 5 > 999 then\\\n    return \"Offset overflows three digits: \" .. table.concat(offsets, \" \")\\\n  end\\\n  machine_acc, machine_chunk_size = pad_strings(machine_acc)\\\n  for i = 1, #machine_acc do\\\n    machine_acc[i] = offsets[i] .. machine_acc[i]\\\n  end\\\n\\\n  machine_data = table.concat(machine_acc)\\\n  machine_chunk_size = machine_chunk_size + 3\\\n  item_acc, item_names_size = pad_strings(item_acc)\\\n  item_names = table.concat(item_acc)\\\n  trans_table = string.sub(trans_table, 1, #item_acc)\\\n  produce_data = table.concat(prod_acc)\\\n\\\n--[[Debug functions, uncomment as needed]]\\\n  if true then\\\n    return;\\\n  end\\\n  return table.concat(prod_acc, \",\")\\\n)}\n\n;{lua(return produce_data)}_\n;{lua(return machine_data)}\n;{lua(return item_names)}\n;{lua(return trans_table)}_\n\n; When it is loaded from produce_data, the value in produce_data is\n; processed from the raw produce_chunk to lookup the SOURCE_CHAR from the\n; secondary lookup table. This still needs extra processing to trim the\n; trailing spaces, which is why the source_name macro exists.\n#dest_offset 2\n#source_char_offset 1\n#mult_offset 0\n#get_source_tier index(\" 0123456789\", sub(produce_data, {dest_offset} + 2, 1), 0)\n#source_name sub(source_name_raw, 0, index(source_name_raw, \" \", 0))\n#mult s2d(sub(produce_data, {mult_offset}, 1), 0.)\n\n#next_offset s2i(sub(machine_chunk, {lua(return machine_chunk_size)}, 3), 0)\n\n; Raw access to the queue. This is even more direct than\n; get_raw, because we're using queue strings directly.\n#raw_dest sub(produce_data, {dest_offset}, 3)\n#get_dest global.double.get({queue_str} . {raw_dest})\n#set_dest(value) global.double.set({queue_str} . {raw_dest}, {value})\n; ================== END MACROS + LUA ==================\n\nexecutesync(\"{script_name(produce dust)}\")\nstop(\"{script_name(produce dust)}\")\n\nmachine_loop:\n; Setup machine data variables and set the produce index to the proper place.\n; We break this out into separate variables because we don't run through this\n; section as much (only once per machine, so ~8 times), and it makes the later\n; expressions more efficient. Also, we have lines to spare.\n; We get 3 extra characters after the machine chunk so that we have the next\n; offset available as well, which we use to determine when to finish the produce_loop\n; below and procede to the next machine.\nmachine_chunk = sub(\"{lua(return machine_data)}\", machine_idx, {lua(return machine_chunk_size)} + 3)\nmachine_name = sub(machine_chunk, 3, index(machine_chunk, \" \", 0) - 3)\ni = s2i(sub(machine_chunk, 0, 3), 0)\nmachine_idx += {lua(return machine_chunk_size)}\n\n; We need to setup the production data anyway, so we branch there. This is\n; one instruction less efficient than other methods, but it lets us\n; reuse a lot of code so it's worth it.\ngoto(if(\\\n  contains(\"end\", machine_name),\\\n  end,\\\n  set_data\\\n))\n\nproduce_loop:\nsource_name_raw = sub(\\\n  \"{lua(return item_names)}\",\\\n  index(\\\n    \"{lua(return trans_table)}\",\\\n    sub(produce_data, {source_char_offset}, 1),\\\n    0\\\n  ) * {lua(return item_names_size)},\\\n  {lua(return item_names_size)}\\\n)\n\n; Uncomment this line for runtime production debugging.\n; You will also need to uncomment the line in run_recipes that unhides debug.\n;gss(\"debug\", gsg(\"debug\") . \"<br>\" . {source_name} . {get_source_tier} . \"_\" . min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})) . machine_name)\n\n; Just try to produce. There is a wrinkle here not present when crafting:\n; we take the minimum with the source count, so that we can use items as\n; quickly as they become available. We only craft the entire quantity, to\n; avoid needlessly filling the inventory.\nproduce(\\\n  {source_name},\\\n  {get_source_tier},\\\n  min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})),\\\n  machine_name\\\n)\n\n; We can blindly subtract the number of items in the machine, because we've\n; guaranteed via the guards on our loop that we exit as soon as the machine\n; is active. This means the item in there *must* be the correct one, if the\n; count is > 0.\n{set_dest({get_dest} - {mult} * machine.item.count(machine_name))}\n\nnext_item:\ni += {produce_chunk_size}\nset_data:\nproduce_data = sub(\"{lua(return produce_data)}\", i, {produce_chunk_size})\n\n; Go to the next machine if we're done with this set of machines, or the machine\n; has become active. Otherwise, either produce the next item, or skip it if\n; the quantity is <= 0.\ngoto(if(\\\n  i >= {next_offset},\\\n  machine_loop,\\\n  if(\\\n    active(machine_name),\\\n    machine_loop,\\\n    if(\\\n      {get_dest} <= 0.,\\\n      next_item,\\\n      produce_loop\\\n    )\\\n  )\\\n))\n\nend:\ngss({action}, if(\\\n contains(impulse(), \"key.\"),\\\n if(\\\n   contains(impulse(), \"key.{left}\"),\\\n   \"1\",\\\n   \"-1\"\\\n ),\\\n gsg({action})\\\n))\n"],["produce dust",":import factory constants\n\n:name {script_name(produce dust)}\n\n:local int _tier\n:local double previous_amount\n\n_tier = _tier + 1\nprevious_amount = count(\"ore\", _tier)\nproduce(\"ore\", _tier, {get_queue(_tier, ore)}, \"crusher\")\n{subtract_queue(_tier, dust, (previous_amount - count(\"ore\", _tier)) * 2.)}\n{subtract_queue(_tier, ore, previous_amount - count(\"ore\", _tier))}\n\ngotoif(notierupdust, _tier >= 10 || {get_queue(_tier, lump)} <= 0. || active(\"mixer\"))\ncraft(\"lump\", _tier, min(\\\n  min(\\\n    (count(\"dust\", _tier) - 1.) / 4.,\\\n    count(\"dust\", _tier + 1)\\\n  ),\\\n  {get_queue(_tier, lump)} - count(\"lump\", _tier)\\\n))\nprevious_amount = count(\"lump\", _tier)\nproduce(\"lump\", _tier, min(previous_amount, {get_queue(_tier, lump)}), \"mixer\")\n{subtract_queue(_tier, dust, previous_amount - count(\"lump\", _tier))}\n{subtract_queue(_tier, lump, previous_amount - count(\"lump\", _tier))}\nnotierupdust:\n\ngotoif(noproduceingot, active(\"oven\") | (if(_tier == 10, 0., ({get_queue(_tier, lump)} - count(\"lump\", min(_tier, 9)))) * 4. > 2. * min(0., count(\"dust\", _tier) - ({get_queue(_tier, ingot)})) & count(\"dust\", _tier) < 2. * ({get_queue(_tier, ingot)})))\nprevious_amount = count(\"dust\", _tier)\nproduce(\"dust\", _tier, min(previous_amount - 1., {get_queue(_tier, ingot)}), \"oven\")\n{subtract_queue(_tier, ingot, previous_amount - count(\"dust\", _tier))}\nnoproduceingot:\n\ngoto(if(_tier >= 10, 99, 1))\n"],["craft",":import factory constants\n:import recipes\n\n:name {script_name(craft)}\n\n:local double previous_amount\n:local int i\n:local string itemdata\n:local string group_data\n\n:global int factory_target\n\nkey.{up}()\nkey.{down}()\n\nisopen(\"factory\")\n\n; If we were launched via key impulse, invoke the UI immediately\n; to start turbo, and set action to signal which key was pressed.\n; Otherwise, we're being called as a produce script.\nexecute(if(\\\n  contains(impulse(), \"key.\"), \\\n  \"{script_name(ui)}\", \\\n  \"###badname###\"\\\n))\ngotoif(group_abort, contains(impulse(), \"key.\"))\n\n; Craft all the items.\ncraftitems_loop:\nitemdata = {lua(return factory.composite_string(\"i/10\", \"craft\"))}\n\ndo_craft:\n; Because items and tiers start at 1, but i is zero-based,\n; we have to add 1 or (pre-multiplying, 10) in these expressions.\n; However, tier is zero-based inside our indexing representation,\n; so we don't add it there.\nprevious_amount = count({get_name}, i%10 + 1)\ncraft({get_name}, i%10 + 1, {get_raw(10 + i)})\n{set_raw(10 + i, {get_raw(10 + i)} - (count({get_name}, i%10 + 1) - previous_amount))}\ninc:\n; This skips over tiers that don't exist for the given item, by using the\n; tier data embedded in \"itemdata\".\ni = i + if(i2s(i%10) == {tiers_char}, 10 - i%10, 1)\ngoto(if(i%10 != 0,\\\n     if({get_raw(10 + i)} > 0., do_craft, inc),\\\n     if(i < {items_count} * 10, craftitems_loop, crafting_done)))\ncrafting_done:\n\n; Uncomment these lines for runtime item quantity debugging.\n; You will also need to uncomment the line in run_recipes that unhides debug.\n;i = 10\n;debug_loop:\n;gss(\"debug\", if(i == 10, \"\", gsg(\"debug\") . if({get_raw(i)} > 0., \"<br>\" . i . \" \" . {get_raw(i)}, \"\")))\n;i += 1\n;gotoif(debug_loop, i < {lua(return #factory.items)} * 10 + 10)\n\ngroup_data = \"{lua(\\\n  acc = {}\\\n  for i = 1, #factory.items do\\\n    local item = factory.items[i];\\\n    if item.craft_type ~= \"group\" then goto continue end\\\n    for j = 1, item.tier do\\\n      acc[#acc+1] = \"|\" .. (i * 10 + j + 99);\\\n      local recipe = item.recipes[j];\\\n      for k = 1, #recipe, 2 do\\\n        acc[#acc+1] = recipe[k] + 100;\\\n      end\\\n    end\\\n    ::continue::\\\n  end\\\n  acc[#acc+1] = \"|\";\\\n  return table.concat(acc);\\\n)}\"\n\ni = index(group_data, \"|\" . (factory_target + 100), 0) + 1\ncheck_group_loop:\ni += 3\ngoto(if(\\\n  i < 4, group_abort,\\\n  if(\\\n    sub(group_data, i, 1) == \"|\", group_complete,\\\n    if(\\\n      gdg({queue_str} . sub(group_data, i, 3)) > 0., group_abort,\\\n      check_group_loop\\\n    )\\\n  )\\\n))\n\ngroup_complete:\n{set_raw(factory_target, 0.)}\ngroup_abort:\ngss({action}, if(\\\n contains(impulse(), \"key.\"),\\\n if(\\\n   contains(impulse(), \"key.{up}\"),\\\n   \"1\",\\\n   \"-1\"\\\n ),\\\n gsg({action})\\\n))\n"],["init",":import factory constants\n\n:name {script_name(init)}\n\nwakeup()\nopen.factory()\n\nisopen(\"factory\")\n\n:global double factory_target_amount\n:global int factory_target\n\n:global int turbo.cycles\n:global int turbo.cycles.max\n\n:local double target_value\n\n; Run the UI, to display the current pending item.\nexecute(\"{script_name(ui)}\")\n\n; Initial dispatch on entering the factory to determine\n; if we are resuming a crafting operation or waiting to launch a new one.\n; This is done outside of turbo, so that we never invoke turbo\n; if we don't need to.\ngotoif(wait_loop, {get_raw(factory_target)} == 0.0)\n\n; The core factory cycle.\n; We do each loop of factory production within one call\n; of nested turbo start/stop, which executes within one frame.\n;\n; This loop handles both\n; * calculating recipes via \"run_recipes\"\n; * crafting via \"craft\".\n; This is done with conditional execution,\n; in order to save lines for future possible features.\nbegin_cycle:\nexecutesync(\"TE2.2:start\")\n\n; Here we up the number of cycles so that it will be enough\n; to calculate the recipes or produce items.\n; We intentionally have a frame break between the recipe calculation\n; and the beginning of crafting to prevent jarring lag on startup.\n; \n; This formula ensures that we don't accidentally step on another script\n; that needs more cycles, and also that we get the full amount of cycles\n; even if something else started turbo before us.\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\n\n; We have to save this, because the value can change\n; as a result of executing later scripts.\ntarget_value = {get_raw(factory_target)}\n\n; All conditional execution in the loop is behind this condition.\n; If it is true, then we're here because of `ui`.\n; Otherwise, this is a regular crafting iteration.\n; \n; There are extra checks for isopen(\"factory\") here.\n; The main check is at the bottom of the loop,\n; but that happens before the end of the frame, so\n; there will be one more frame where we have exited the factory,\n; but the loop still runs.\n; Normally, this wouldn't be an issue\n; (all of the scripts will perform no actions and leave\n; the variables in the same state),\n; but \"produce\" and \"craft\" have a startup condition of isopen(\"factory\"),\n; since they do double-duty as UI impulse scripts as well.\n; So, we have to protect them, otherwise executesync() will hang\n; when it hits the false condition, leading to a stuck script.\nexecutesync(if(isopen(\"factory\"), \\\n  if(\\\n    target_value > 0.0, \\\n    \"{script_name(produce)}\", \\\n    \"{script_name(run_recipes)}\"\\\n  ),\\\n  \"###badname###\"\\\n))\nstop(if(\\\n  target_value > 0.0, \\\n  \"{script_name(produce)}\", \\\n  \"{script_name(run_recipes)}\"\\\n))\nexecutesync(if(\\\n  target_value > 0.0 && isopen(\"factory\"),\\\n  \"{script_name(craft)}\",\\\n  \"###badname###\"\\\n))\nstop(if(\\\n  target_value > 0.0, \\\n  \"{script_name(craft)}\", \\\n  \"###badname###\"\\\n))\n\n; Clear factory_target to indicate that crafting is done,\n; if it is, in fact, done.\nfactory_target = if({get_raw(factory_target)} > 0.0, factory_target, 0)\n\n; Re-display the UI when crafting is done.\nexecute(if(factory_target == 0, \"{script_name(ui)}\", \"###badname###\"))\n\n; Clear this (unconditionally), to signal that we're not starting\n; a new crafting pass.\nfactory_target_amount = 0.\n\nexecutesync(\"TE2.2:stop\")\n\n; Here we either return to the next iteration of the production loop,\n; or stall on this instruction until we need to launch the factory.\n; Because there is always 1 extra cycle of turbo after \"TE2.2:stop,\"\n; there is enough time to execute this goto and have only\n; a single frame break before starting turbo again at the top of the loop.\nwait_loop:\ngotoif(\\\n  if(max(factory_target_amount, {get_raw(factory_target)}) > 0.,\\\n    begin_cycle, wait_loop\\\n  ),\\\n  isopen(\"factory\")\\\n)\n\n; Remove the UI status so it doesn't clutter the variables\n; when we're outside the factory.\n; This is safe to repeat, when turbo is looping at the end of the script.\ngss({status}, \"</size>\")\n"],["ui",":import factory constants\n:import worker_storage_lib\n\n:name {script_name(ui)}\n\n:local double count\n:local int visible_tier\n:local int tier\n:local int category\n:local int item\n:local int cursor\n\n:global int turbo.cycles\n:global int turbo.register\n:global int factory_target\n:global double factory_target_amount\n\nkey.{start}()\n\nisopen(\"factory\")\n\n; Because of how turbo exec works,\n; we can't launch turbo on the frame the script starts\n; by calling \"TE2.2:start\", if we are being called from another script.\n; We can only do it by changing turbo.register directly,\n; saving a layer of script execution.\n; (This is because of the relative positioning of TE.turbo vs our script\n; usually we would be before, but when we are first launched our script\n; is after.)\nturbo.register += 1\n\n; Use worker_storage_lib to find a worker_slot\n; to use for permanent storage.\n:local int worker_slot\n{worker_lib_line_1([factory])}\n{worker_lib_line_2}\n\n; Split out the worker data into separate variables.\n; We take advantage of this time to also perform increment/decrement,\n; since we can easily combine it in this stage.\n; We don't bother checking if we've got a valid slot, because if we\n; don't, we'll simply fail to parse and get the fallback value.\n\n#action_num s2i(gsg({action}), 0)\n; \n; Is the u/d action valid for this position?\n; Using contains() instead of == and chained compares saves\n; a lot of import space.\n#is_ud(pos) contains(impulse() . cursor, \":craft{pos}\")\n\n; helper macro to shorten\n; data collection out of worker storage\n\n#worker_data.extract(offset, size) sub(\\\n  worker.name(worker_slot), \\\n  {len({worker_prefix})} + {offset}, \\\n  {size}\\\n)\n\ncursor = min(9, max(\\\n  0, \\\n  s2i({worker_data.extract(11, 1)}, 0) + if(\\\n    contains(impulse(), \":produce\"), \\\n    {action_num}, \\\n    0\\\n  )\\\n))\ncount = min(9999999.0, max(1.0,\\\n  s2d({worker_data.extract(0, 7)}, 1.) + if(\\\n    contains(impulse(), \":craft\"), \\\n    i2d({action_num} * 10 ^ (cursor - 3)), \\\n    0.0\\\n  )\\\n))\n\n#num_categories {lua(return #factory.categories)}\ncategory = (\\\n  s2i({worker_data.extract(8, 1)}, 0) - if(\\\n    {is_ud(1)}, {action_num}, 0\\\n  ) + {num_categories}\\\n) % {num_categories}\n\n; Because math expressions are so expensive, in terms of import space,\n; it's best to just pre-compute tables\n; of the next/previous item to go to for every item.\n; To avoid duplicating expressions, we also make a no-op table\n; for the case where we're not incrementing or decrementing.\n{lua(\\\n  function factory.item_inc_table(inc)\\\n    local acc = {};\\\n    local default = string.format(\\\n      \"%02d\",\\\n      factory.categories[1].default - 1\\\n    );\\\n    for i = 1, #factory.categories do\\\n      local cat = factory.categories[i];\\\n      local cat_size = cat.last - cat.first + 1;\\\n      for j = cat.first, cat.last do\\\n        acc[j] = string.format(\\\n          \"%02d\", \\\n          (j + inc - cat.first) % cat_size + cat.first - 1)\\\n      end\\\n    end\\\n    for i = 1, #factory.items do\\\n      acc[i] = acc[i] or default\\\n    end\\\n    return table.concat(acc)\\\n  end\\\n)}\n#item_inc_table(inc) {lua(return factory.item_inc_table({inc}))}\n#category_defaults {lua(\\\n  local acc = {};\\\n  for i = 1, #factory.categories do\\\n    acc[i] = string.format(\"%02d\", factory.categories[i].default - 1);\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Items in this variable are zero-indexed, as opposed\n; to their regular ids, which start from 1.\n; We increment the items in the opposite direction from the action,\n; because pressing up (action 1) *increments* numerical values\n; but *decrements* elements in an alphabetically sorted list.\nitem = s2i(if(\\\n  {is_ud(1)}, \\\n  sub(\"{category_defaults}\", category * 2, 2), \\\n  sub(\\\n    if({is_ud(0)}, if(\\\n        contains(gsg({action}), \"-1\"), \\\n        \"{item_inc_table(1)}\", \\\n        \"{item_inc_table(-1)}\"\\\n      ), \\\n      \"{item_inc_table(0)}\"\\\n    ), \\\n    s2i(\\\n      {worker_data.extract(9, 2)}, \\\n      {lua(return factory.categories[1].default - 1)}\\\n    ) * 2,\\\n    2\\\n  )\\\n), 0)\n\n; The distinction between \"tier\" and \"visible_tier\" has\n; to do with the fact that items have different tier maximums.\n; When a user is scrolling through different items, if the \"tier\" is T10\n; (represented as \"9\" in our zero-indexed scheme),\n; then the \"visible_tier\" will change to fit\n; the maximum tier for the item, while the tier remains at T10.\n; However, if the item is a producer (max of T5), and\n; the user moves the cursor to the tier field and presses \"W\",\n; the attempt to increment \"tier\" will fix it at a new value of T5 (4).\n#tier_data {lua(\\\n  local acc = {};\\\n  for i = 1, #factory.items do\\\n    local item = factory.items[i];\\\n    acc[i] = string.format(\"%d\", item.tier - 1);\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Expression to load the saved tier data from the worker name, including\n; a default value when there is no data.\n#saved_worker_tier s2i({worker_data.extract(7, 1)}, 0)\n\n; It makes the most sense to set visible_tier first.\n; There is a complication when adjusting the tier down\n; in this case, we reduce the maximum bounds by one, so that\n; (for instance) if the max tier is T5, and the current tier is T10,\n; we'll properly clip the visible_tier to T4\n; after subtracting 1 to get T9.\n; This type of adjustment isn't needed (or wanted) in the other direction,\n; or when the tier isn't changing.\n\n\nvisible_tier = max(0, min(\\\n  {saved_worker_tier} + if({is_ud(2)}, {action_num}, 0), \\\n  s2i(sub(\"{tier_data}\", item, 1), 9) + if(\\\n    {is_ud(2)} && gsg({action}) == \"-1\", \\\n    -1, \\\n    0\\\n  )\\\n))\ntier = if({is_ud(2)}, visible_tier, {saved_worker_tier})\n\n; Finally, construct the visible name for use in the variable.\n{lua(\\\n  local names = {}\\\n  local name_starts = {}\\\n  local name_sizes = {}\\\n  local name_len = 0\\\n\\\n  for i = 1, #factory.items do\\\n    local name = factory.items[i].name\\\n    names[i] = name\\\n    name_starts[i] = string.format(\"%03d\", name_len)\\\n    name_len = name_len + #name\\\n    name_sizes[i] = string.format(\"%02d\", #name)\\\n  end\\\n  factory.name_data = table.concat(names)\\\n  factory.name_starts = table.concat(name_starts)\\\n  factory.name_sizes = table.concat(name_sizes)\\\n  factory.items_count = #factory.items\\\n\\\n  names = {}\\\n  for i = 1, #factory.categories do\\\n    names[i] = factory.categories[i].name\\\n  end\\\n  factory.category_names = table.concat(names)\\\n)}\n#name_data {lua(return factory.name_data)}\n#name_starts {lua(return factory.name_starts)}\n#name_sizes {lua(return factory.name_sizes)}\n#category_names {lua(return factory.category_names)}\n\n; Set this variable in order to begin a variable-hiding block.\n; It looks like a no-op, but really we're ensuring that\n; it has a slot in the globals table, even if its value empty -\n; in this case, what we care about\n; is the *name*, which starts with \"<size=0>\".\n; Do this *after* all the other work, to give turbo register time to\n; set its variables, in case we're doing this right at startup.\ngss({action}, gsg({action}))\n\n; Do conditional stuff, depending on if we're launching the factory.\n; We set all these variables always, so that they'll have\n; a consistent order, and also to save lines\n; instead of jumping over this block.\n\n#valid_start contains(factory_target . impulse(), \"0key.\")\n; This (maybe) launches the factory. We need to do it soon enough to not\n; interrupt turbo, see the comment on \"TE2.2:stop\", below.\n{lua(\\\n  for i = 1, #factory.categories do\\\n    if factory.categories[i].name == \"grup\" then\\\n      grup_cat = i - 1;\\\n      return;\\\n    end\\\n  end\\\n  return \"Couldn't find grup\"\\\n)}\nfactory_target_amount = if({valid_start}, count, factory_target_amount)\n\n; Only set factory_target if it's zero,\n; which indicates that the factory is idle.\n; This prevents repeated keypresses from messing things up.\nfactory_target = if(\\\n  {valid_start}, \\\n  (item + 1) * 10 + visible_tier, \\\n  factory_target\\\n)\n\n; Construct the status line. There's a *lot* that goes into this.\n;\n; For starters, we fake the variable - it's not really \"make\",\n; but rather a totally different variable that's less likely to collide.\n; The true variable name is never seen, because it's still\n; part of the <size=0> block.\n; We put our fake variable name after.\n; We do all this so that we can \"unset\" the variable by\n; just changing its value -\n; this way, it's not truly unset, and\n; we don't have issues with variable ordering as a result.\n;\n; This also means we can change the variable name to something else, like\n; \"error\", if we need to, all without actually creating a new variable or\n; changing ordering.\n;\n; All the clauses are dynamically created on the fly here.\n; We also create the \"cursor\" by highlighting a specific part\n; of the result in green.\n; This involves a great deal more complexity.\n\n#curs_col 2f4\n; For later - scanning rework\n; instr1: category == {lua(return grup_cat)}\n; instr2: \"  -SCAN-\"\n; instr3: d2s(10000000.0 + count)\n;count_string if(\\\n  category == {lua(return grup_cat)}, \\\n  \"  -SCAN-\", \\\n  d2s(10000000.0 + count)\\\n)\n#count_string d2s(10000000.0 + count)\n\n#show_error \"</size>error=<collor=#fb3>\"\n#show_default \"{up}{left}{down}{right} moves, {start} crafts\"\n\n#count_string.extract(offset, size) sub(\\\n  {count_string}, \\\n  {offset}, \\\n  {size}\\\n)\n\ngss({status}, if(\\\n  worker_slot == 200,\\\n  {show_error} . \"No available workers!\" . \"</color>\",\\\n  if(\\\n    turbo.cycles == 0,\\\n    {show_error} . \"Turbo exec is not working\" . \"</color>\",\\\n    \"</size>make=<color=#fff>\" . \\\n    {count_string.extract(1, 9 - cursor)} . \\\n    \"</color><color=#{curs_col}>\". \\\n    {count_string.extract(10 - cursor, 1)} . \\\n    \"</color><color=#fff>\". \\\n    {count_string.extract(11 - cursor, 10)} . \\\n    \"<smallcaps>x</smallcaps><color=#\" . \\\n    if(cursor == 2, \"{curs_col}>T\", \"fff>T\") . \\\n    (visible_tier + 1) . \"</color>\" . ' ' . \\\n    if(cursor == 1, \"<color=#{curs_col}>\", \"<color=#fff>\") . \\\n    sub(\"{category_names}\", category * 4, 4) . \"</color> ...<br>\" . \\\n    if(cursor == 0, \"<color=#{curs_col}>\", \"<color=#fff>\") . \\\n    sub(\\\n      \"{name_data}\", \\\n      s2i(sub(\"{name_starts}\", item * 3, 3), 0), \\\n      s2i(sub(\"{name_sizes}\", item * 2, 2), 0)\\\n    ) . \"<br></color></color>\" . if(\\\n      contains(impulse() . gsg({action}), \":init<\"), \\\n      gsg({action}), \\\n      if(\\\n        factory_target == 0, \\\n        \"<color=#0df>\" . {show_default} .  \"</color> \",\\\n        \"<color=#ff0>Crafting...</color>\"\\\n      )\\\n    )\\\n  )\\\n))\n\n#dissolve_task \"factory.dissolveManagement\"\n; Pause/unpause a dissolve worker, if it occupies our data slot.\n; If it's a different type of worker,\n; leave it alone by dummying out the name.\nworker.pauseName(\\\n  if(\\\n    contains(worker.task(worker.name(worker_slot)), {dissolve_task}),\\\n    worker.name(worker_slot),\\\n    \"![@#nosuchtask#@]!\"\\\n  ),\\\n  contains(gsg({status}), \"Crafting\")\\\n)\n\n; \"init\" will take over as soon as\n; factory_target_amount gets set 4 lines above\n; it will call its own \"TE2.2:start\" and thus prevent\n; the frame from ending before this line takes effect.\n; We need two cycles in-between to have a seamless transition.\n; We change the variable directly, instead of calling \"TE2.2:stop\",\n; for parity with the way we start:\n; This avoids some edge cases when turbo is incorrectly installed.\n; It also is fine in this case, because we don't need to wait for\n; the end of the frame.\nturbo.register -= 1\n\n; Setting the data back in the worker is moved way down to the bottom,\n; to function as the \"filler\" action that can be repeated while\n; the script is waiting for the frame to end.\n; We can't make use of the actions that set global variables for this,\n; because they may need to be modified later in the frame,\n; and thus setting them here in a loop would overwrite the value.\nworker.setName(\\\n  if(worker_slot < 100, worker_slot, worker_slot - 100), \\\n  \"{worker_prefix}\" . sub(d2s(10000000.0 + count), 1, 7) . tier \\\n  . category . sub(i2s(100 + item), 1, 2) . cursor\\\n)\n"],["Factory Recipes",":import Factory Compactor\n:import Factory Items\n\n\n{recipe(town_producer)}\n{component(2 3 5 7 9, screw, 2 4 4 4 4)}\n{component(2 0 0 0 0, plate, 2 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 2 2 2 6)}\n{component(-1, chip, 0 2 2 2 4)}\n{component(-1, town_producer, 1)}\n\n{recipe(factory_producer)}\n{component(1 3 5 7 9, wire, 1 4 4 4 4)}\n{component(2 0 0 0 0, screw, 1 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 1 1 1 3)}\n{component(2 3 5 0 0, plate, 2 2 2 0 0)}\n{component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}\n{component(1 1 2 3 4, chip, 2 1 1 1 3)}\n{component(-1, factory_producer, 1)}\n\n{recipe(mine_producer)}\n{component(2 3 5 7 9, screw, 2 2 2 4 4)}\n{component(1 2 4 6 8, wire, 2 3 2 5 5)}\n{component(2 0 5 7 9, plate, 1 0 1 2 2)}\n{component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}\n{component(1 1 2 3 4, chip, 1)}\n{component(-1, mine_producer, 1)}\n\n{recipe(workshop_producer)}\n{component(0 2 4 6 8, wire, 0 4 2 8 8)}\n{component(1 3 5 7 9, wire, 4 2 2 2 2)}\n{component(2 3 5 7 9, plate, 1 2 2 2 2)}\n{component(1 0 2 3 4, chip, 1 0 2 2 2)}\n{component(-1, workshop_producer, 1)}\n\n{recipe(construction_firm_producer)}\n{component(2 4 6 8 10, rod, 3 4 10 10 10)}\n{component(2 4 6 8 10, plate, 2)}\n{component(1 1 2 3 4, chip, 1 2 2 2 2)}\n{component(-1, construction_firm_producer, 1)}\n\n{recipe(laboratory_producer)}\n{component(0 3 5 7 9, pipe, 0 3 5 10 14)}\n{component(2 4 6 8 10, motor, 1)}\n{component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, laboratory_producer, 1)}\n\n{recipe(headquarters_producer)}\n{component(1 3 5 7 9, wire, 2 4 8 8 12)}\n{component(2 4 6 8 10, motor, 1 2 2 2 2)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, headquarters_producer, 1)}\n\n{recipe(powerplant_producer)}\n{component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}\n{component(2 4 6 8 10, motor, 1)}\n{component(0 3 5 7 9, block, 0 3 5 5 14)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, powerplant_producer, 1)}\n\n{recipe(arcade_producer)}\n{component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}\n{component(2 4 6 8 10, pipe, 4 4 4 4 8)}\n{component(0, chip, 4 4 4 4 6)}\n{component(-1, arcade_producer, 1)}\n\n{recipe(tradingpost_producer)}\n{component(2 4 6 8 10, ring, 6 8 8 8 12)}\n{component(2 4 6 8 10, plate, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, tradingpost_producer, 1)}\n\n{recipe(shipyard_producer)}\n{component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}\n{component(1 3 5 7 9, block, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, shipyard_producer, 1)}\n\n{recipe(museum_producer)}\n{component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}\n{component(2 4 6 8 10, block, 4 5 5 5 7)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, museum_producer, 1)}\n\n{recipe(statue_of_cubos_producer)}\n{component(1 3 5 7 9, dense_block, 4 5 5 5 7)}\n{component(2 4 6 8 10, motor, 2)}\n{component(2 4 6 8 10, pipe, 2)}\n{component(2 4 6 8 10, pump, 2 3 3 3 5)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, statue_of_cubos_producer, 1)}\n\n{recipe(gem_producer)}\n{component(5, chip, 10)}\n{component(4, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(1, dense_block, 1)}\n{component(2, dense_block, 1)}\n{component(3, dense_block, 1)}\n{component(4, dense_block, 1)}\n{component(5, dense_block, 1)}\n{component(6, dense_block, 1)}\n{component(7, dense_block, 1)}\n{component(8, dense_block, 1)}\n{component(9, dense_block, 1)}\n{component(10, dense_block, 1)}\n\n{recipe(exotic_producer)}\n{component(5, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(10, dense_block, 10)}\n{component(10, assembly, 1)}\n{component(10, boiler, 1)}\n{component(10, crusher, 1)}\n{component(10, cutter, 1)}\n{component(10, mixer, 1)}\n{component(10, oven, 1)}\n{component(10, presser, 1)}\n{component(10, refiner, 1)}\n{component(10, shaper, 1)}\n{component(10, belt, 1)}\n\n{recipe(acceleration_booster)}\n{component(2 3 5, chip, 1 4 6)}\n{component(4, plate, 4 0 0)}\n{component(1, rainbow_plate, 0 2 4)}\n{component(4 8 0, circuit, 4 8 0)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, acceleration_booster, 2)}\n\n{recipe(machine_booster)}\n{component(2 3 5, chip, 2)}\n{component(4 7 10, pipe, 4)}\n{component(4, wire, 2 0 0)}\n{component(0 7 10, dense_block, 0 2 2)}\n{component(8, dense_plate, 0 6 0)}\n{component(1, rainbow_plate, 0 0 4)}\n{component(1, void_essence, 0 0 2)}\n{component(4, circuit, 1 0 0)}\n{component(-1, machine_booster, 1)}\n\n{recipe(production_booster)}\n{component(1 3 0, chip, 4 4 0)}\n{component(2 7 0, plate, 4 6 0)}\n{component(2 7 10, circuit, 1 4 4)}\n{component(10, dense_block, 0 0 12)}\n{component(1, void_essence, 0 0 4)}\n{component(-1, production_booster, 0 1 4)}\n\n{recipe(resource_booster)}\n{component(3, plate, 6 0 0)}\n{component(1, rainbow_plate, 0 0 2)}\n{component(1 3 4, chip, 2 2 6)}\n{component(4 8 0, circuit, 1 2 0)}\n{component(0 7 10, block, 0 4 4)}\n{component(1, void_essence, 0 0 1)}\n{component(-1, resource_booster, 0 1 2)}\n\n{recipe(pumpkin_producer)}\n{component(0, carved_pumpkin, 6)}\n{component(0, anti_pumpkin, 6)}\n{component(0, pumpkin_plate, 20)}\n\n{recipe(oven)}\n{component(0, plate, 4 6 8 8 8 8 8 8 8 8)}\n{component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}\n{component(0, block, 0 0 0 0 0 2 2 2 2 2)}\n{component(-1, oven, 1)}\n\n{recipe(presser)}\n{component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}\n{component(0, plate, 4 5 7 7 7 9 9 9 9 9)}\n{component(0, wire, 1 1 2 2 2 3 3 3 3 3)}\n{component(0, block, 0 0 0 0 4 5 5 5 5 5)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 2)}\n{component(-1, presser, 1)}\n\n{recipe(assembly)}\n{component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}\n{component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}\n{component(0, motor, 1 1 1 1 1 1 1 1 2 2)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}\n{component(-1, assembly, 1)}\n\n{recipe(refiner)}\n{component(0, block, 0 0 0 0 0 0 5 5 5 7)}\n{component(0, dense_plate, 4)}\n{component(0, motor, 1 1 1 1 2 2 2 2 2 4)}\n{component(0, ring, 1 2 2 2 3 3 3 3 3 5)}\n{component(0, pump, 1 2 2 2 3 3 3 3 3 5)}\n{component(1 1 2 2 2 2 3 4 4 5, chip, 2)}\n{component(-1, refiner, 1)}\n\n{recipe(mixer)}\n{component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}\n{component(0, motor, 2)}\n{component(0, pump, 1 1 1 2 2 3 3 3 3 3)}\n{component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}\n{component(-1, mixer, 1)}\n\n{recipe(crusher)}\n{component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}\n{component(0, motor, 1 1 1 1 1 1 1 2 2 2)}\n{component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}\n{component(-1, crusher, 1)}\n\n{recipe(belt)}\n{component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}\n{component(0, motor, 3 3 3 3 3 3 4 4 4 4)}\n{component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}\n{component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}\n{component(-1, belt, 1)}\n\n{recipe(cutter)}\n{component(0, plate, 2 2 2 2 2 2 2 0 0 0)}\n{component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}\n{component(0, block, 0 0 0 0 0 0 0 4 4 6)}\n{component(0, motor, 3 4 4 4 4 5 5 5 5 7)}\n{component(-1, cutter, 1)}\n\n{recipe(shaper)}\n{component(0, plate, 4 4 4 4 4 4 4 4 4 0)}\n{component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}\n{component(0, screw, 1 2 2 2 2 3 3 3 3 3)}\n{component(0, block, 1 2 2 2 2 3 3 3 3 0)}\n{component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}\n{component(0, motor, 2)}\n{component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}\n{component(-1, shaper, 1)}\n\n{recipe(boiler)}\n{component(0, wire, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, block, 4 7 7 8 8 8 8 8 9 10)}\n{component(0, motor, 1 1 1 2 2 2 2 2 3 4)}\n{component(0, screw, 2)}\n{component(0, pump, 1)}\n{component(-1, boiler, 1)}\n\n{recipe(rainbow_dust)}\n{component(1, dust, 1)}\n{component(2, dust, 1)}\n{component(3, dust, 1)}\n{component(4, dust, 1)}\n{component(5, dust, 1)}\n{component(6, dust, 1)}\n{component(7, dust, 1)}\n{component(8, dust, 1)}\n{component(9, dust, 1)}\n{component(10, dust, 1)}\n\n{recipe(chip)}\n{component(1 3 5 7 9, circuit, 2)}\n{component(2 4 6 8 10, circuit, 2 4 4 2 2)}\n{component(1 3 5 7 9, board, 1 4 4 6 8)}\n{component(2 4 6 8 10, board, 1 2 2 6 8)}\n{component(-1, chip, 0 4 8 12 12)}\n\n{recipe(insul_cable)}\n{component(0, cable, 1 1 1 2 3 4 5 10 12 16)}\n{component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}\n\n{recipe(stacked_plate)}\n{component(0, plate, 9)}\n\n{recipe(stacked_pumpkin)}\n{component(0, pumpkin, 9)}\n\n{recipe(motor)}\n{component(0, plate, 4)}\n{component(0, screw, 1)}\n{component(0, rod, 2)}\n{component(0, wire, 1)}\n{component(1, rubber, 1)}\n\n{recipe(pump)}\n{component(0, plate, 2)}\n{component(0, motor, 1)}\n{component(0, ring, 2)}\n{component(1, rubber_plate, 4)}\n\n{recipe(hammer)}\n{component(2, ingot, 6)}\n{component(2, rod, 1)}\n\n{recipe(block)}\n{component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}\n\n{recipe(rubber_sapling)}\n{component(0, rubber, 8)}\n{component(9, ore, 1)}\n\n{recipe(void_sapling)}\n{component(1, rainbow_dust, 8)}\n{component(1, rubber_sapling, 1)}\n\n{recipe(producers)}\n#recipe_producers(x) \\\n{component(0, town_producer, {x})}\\\n{component(0, factory_producer, {x})}\\\n{component(0, mine_producer, {x})}\\\n{component(0, workshop_producer, {x})}\\\n{component(0, construction_firm_producer, {x})}\\\n{component(0, laboratory_producer, {x})}\\\n{component(0, headquarters_producer, {x})}\\\n{component(0, powerplant_producer, {x})}\\\n{component(0, arcade_producer, {x})}\\\n{component(0, tradingpost_producer, {x})}\\\n{component(0, shipyard_producer, {x})}\\\n{component(0, museum_producer, {x})}\\\n{component(0, statue_of_cubos_producer, {x})}\n{recipe_producers(1)}\n\n{recipe(machines)}\n{component(0, oven, 1)}\n{component(0, presser, 1)}\n{component(0, assembly, 1)}\n{component(0, refiner, 1)}\n{component(0, mixer, 1)}\n{component(0, crusher, 1)}\n{component(0, belt, 1)}\n{component(0, cutter, 1)}\n{component(0, shaper, 1)}\n{component(0, boiler, 1)}\n\n{recipe(parts)}\n#recipe_parts \\\n{component(0, insul_cable, 1)}\\\n{component(0, stacked_plate, 1)}\\\n{component(0, motor, 1)}\\\n{component(0, pump, 1)}\\\n{component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, block, 1)}\\\n{component(0, ingot, 1)}\\\n{component(0, plate, 1)}\\\n{component(0, dense_plate, 1)}\\\n{component(0, dense_block, 1)}\\\n{component(0, pipe, 1)}\\\n{component(0, cable, 1)}\\\n{component(0, wire, 1)}\\\n{component(0, rod, 1)}\\\n{component(0, ring, 1)}\\\n{component(0, screw, 1)}\\\n{component(0, board, 1)}\\\n{component(0, circuit, 1)}\\\n{component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\\\n{component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}\n{recipe_parts}\n\n{recipe(chips)}\n{component(1, chip, 1)}\n{component(2, chip, 1)}\n{component(3, chip, 1)}\n{component(4, chip, 1)}\n{component(5, chip, 1)}\n\n{recipe(chip_and_prods)}\n{component(0, chip, 1)}\n{recipe_producers(1)}\n\n#recipe_machines_and_parts \\\n{component(0, oven, 1)}\\\n{component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\\\n{component(0, assembly, 1)}\\\n{component(0, refiner, 1)}\\\n{component(0, mixer, 1)}\\\n{component(0, crusher, 1)}\\\n{component(0, belt, 1)}\\\n{component(0, cutter, 1)}\\\n{component(0, shaper, 1)}\\\n{component(0, boiler, 1)}\\\n{recipe_parts}\n\n{recipe(all)}\n{component(0, chip, 1 1 1 1 1 0 0 0 0 0)}\n{recipe_producers(1 1 1 1 1 0 0 0 0 0)}\n{recipe_machines_and_parts}\n\n; Machine-produced items\n; Has special-case producing code\n{recipe(ingot)}\n{component(0, dust, 1)}\n\n{produce(rainbow_ingot, rainbow_dust, 1, oven)}\n\n{produce(plate, ingot, 1, presser)}\n{produce(rainbow_plate, rainbow_ingot, 1, presser)}\n{produce(dense_plate, stacked_plate, 1, presser)}\n{produce(rubber_plate, rubber, 1, presser)}\n{produce(pumpkin_plate, stacked_pumpkin, 1, presser)}\n\n{produce(dense_block, block, 1, boiler)}\n{produce(anti_pumpkin, pumpkin, 1, boiler)}\n\n{produce(rod, ingot, 2, shaper)}\n{produce(pipe, plate, 1, shaper)}\n{produce(ring, rod, 1, shaper)}\n\n{produce(cable, ingot, 2, refinery)}\n{produce(board, plate, 1, refinery)}\n{produce(wire, cable, 1, refinery)}\n\n{produce(screw, rod, 4, cutter)}\n{produce(carved_pumpkin, pumpkin, 1, cutter)}\n\n{produce(circuit, cable, 1, assembler)}\n; These recipes have special-case code to handle them, because of the\n; complexities involved with choosing between ore and lumps\n; for making dust.\n{recipe(lump)}\n{recipe(dust)}\n\n; Terminal items, unable to be crafted.\n{recipe(ore)}\n{recipe(rubber)}\n{recipe(void_essence)}\n{recipe(pumpkin)}\n"],["Factory Items",":import Factory Compactor\n\n; \n; Everything in the list below is a valid target for automation,\n; and can be assigned to the \"target_type\" variable in\n; \"lanuch factory crafted\".\n; For example, \"crafted(oven, 10, \"machine.oven\")\" indicates that\n; \"oven\" is a valid item, usable from tiers 1-10, with the\n; internal game name of \"machine.oven\"\n; (which you don't need to worry about.)\n; Thus you can enter \"oven\" in the box in the in-game editor\n; (without the quotes).\n; \n\n; \n; If you add or change this list, mind these constraints:\n; * All the crafted items have to come before the rest of the items.\n; * All the item-groups must be in a single block.\n; * Prefer keeping things in alphabetical order within categories,\n;   because they are ordered the same way when presented in-game.\n; \n\n; ===== VALID IDS =====\n\n; ----- CRAFTED ITEMS -----\n\n; Producers, named by building, tiers 1-5\n{craft(arcade_producer, 5, \"producer.arcade\")}\n{craft(construction_firm_producer, 5, \"producer.constructionFirm\")}\n{craft(exotic_producer, 1, \"producer.exoticgems\")}\n{craft(factory_producer, 5, \"producer.factory\")}\n{craft(gem_producer, 1, \"producer.gems\")}\n{craft(headquarters_producer, 5, \"producer.headquarters\")}\n{craft(laboratory_producer, 5, \"producer.laboratory\")}\n{craft(mine_producer, 5, \"producer.mine\")}\n{craft(museum_producer, 5, \"producer.museum\")}\n{craft(powerplant_producer, 5, \"producer.powerplant\")}\n{craft(pumpkin_producer, 1, \"pumpkin.producer\")}\n{craft(shipyard_producer, 5, \"producer.shipyard\")}\n{craft(statue_of_cubos_producer, 5, \"producer.statueofcubos\")}\n{craft(town_producer, 5, \"producer.town\")}\n{craft(tradingpost_producer, 5, \"producer.tradingpost\")}\n{craft(workshop_producer, 5, \"producer.workshop\")}\n\n; Boosters, tiers 1-3\n{craft(acceleration_booster, 3, \"booster.acceleration\")}\n{craft(machine_booster, 3, \"booster.machines\")}\n{craft(production_booster, 3, \"booster.production.regular\")}\n{craft(resource_booster, 3, \"booster.resource.drops\")}\n\n{category(prod, town_producer, arcade_producer, resource_booster)}\n\n; Machines, tiers 1-10\n{craft(assembly, 10, \"machine.assembler\")}\n{craft(belt, 10, \"machine.transportbelt\")}\n{craft(boiler, 10, \"machine.boiler\")}\n{craft(crusher, 10, \"machine.crusher\")}\n{craft(cutter, 10, \"machine.cutter\")}\n{craft(mixer, 10, \"machine.mixer\")}\n{craft(oven, 10, \"machine.oven\")}\n{craft(presser, 10, \"machine.presser\")}\n{craft(refiner, 10, \"machine.refinery\")}\n{craft(shaper, 10, \"machine.shaper\")}\n\n{category(mach, belt, assembly, shaper)}\n\n; Various crafted parts\n{craft(block, 10, \"block\")}\n{craft(chip, 5, \"chip\")}\n{craft(hammer, 1, \"hammer\")}\n{craft(insul_cable, 10, \"cable.insulated\")}\n{craft(motor, 10, \"motor\")}\n{craft(pump, 10, \"pump\")}\n{craft(rainbow_dust, 1, \"dust.rainbow\")}\n{craft(rubber_sapling, 1, \"sapling.rubber\")}\n{craft(stacked_plate, 10, \"plate.stack\")}\n{craft(stacked_pumpkin, 1, \"pumpkin.stack\")}\n{craft(void_sapling, 1, \"sapling.void\")}\n\n{category(crft, chip, block, void_sapling)}\n\n; Transforms ore into dust, tiers 1-10\n; Because of an implementation detail, this must come before any\n; scannable items.\n; This doesn't show up in any category in the UI.\n{special(ore, 10, \"ore\")}\n\n; ----- SCANNABLE ITEM GROUPS -----\n; These are not real items, but rather groups of items that\n; will be made together if you select one of these names.\n; They are meant for use with the Crafter, to crank out\n; sets of items to scan quickly.\n; You will want to set the quantity to 1000.\n\n; Notes on using item groups:\n; * SCAN YOUR ORES FIRST! The factory can and will\n; * * consume your ore to make stuff,\n; * * and it takes a long time to get 1000 T10 ore.\n; * The quantity works a little differently than normal items.\n; * * Instead of making 1000 items each time, running it again\n; * * will top off everything to be *at* the quantity of 1000 items.\n; * If you craft a higher tier after a lower tier,\n; * * it will consume the results of the first craft to\n; * * make the higher tier. Scan all the items first,\n; * * before moving on to the next tier!\n; * None of these groups include Gem Producers or Exotic Producers.\n; * * They are too expensive in comparison to other things,\n; * * craft them on your own when you judge the time is right.\n; \n; Makes *everything* (expect special producers and lumps)\n; of the given tier. This is the combination of \"chips_and_prods\",\n; \"machines\", and \"parts\". Requires x10 and high processing speed\n; to have a hope of completing in a reasonable amount of time\n; for T5 and T10. You need Quantum Warehouse to have enough space for this\n; at higher tiers!\n{group(all, 10)}\n\n; All the tiers of chips. Warning: Expensive. Input this as tier 1.\n{group(chips, 1)}\n\n; Producers + the chip of the corresponding tier. This is everything that\n; exists in tier range 1-5, for convenience.\n{group(chip_and_prods, 5)}\n\n; All machines. Tiers 1-10\n{group(machines, 10)}\n\n; All ingredients and parts. Tiers 1-10.\n; Doesn't include ore (scan that before starting)\n; or lumps (due to technical limitations). Lumps aren't required\n; for anything currently though. Includes rubber plates at tier 1\n; and hammers at tier *2*.\n; Rubber trees are at tier 9 because of their ore.\n{group(parts, 10)}\n\n; All producers, except for special producers. Tiers 1-5\n{group(producers, 5)}\n\n{category(grup, all, all, producers)}\n\n; ----- INGREDIENTS AND PRODUCED PARTS -----\n\n; Parts, tiers 1-10\n{item(anti_pumpkin, 1, \"pumpkin.anti\")}\n{item(board, 10, \"plate.circuit\")}\n{item(cable, 10, \"cable\")}\n{item(carved_pumpkin, 1, \"pumpkin.carved\")}\n{item(circuit, 10, \"circuit\")}\n{item(dense_block, 10, \"block.dense\")}\n{item(dense_plate, 10, \"plate.dense\")}\n{item(ingot, 10, \"ingot\")}\n{item(pipe, 10, \"pipe\")}\n{item(plate, 10, \"plate\")}\n{item(pumpkin_plate, 1, \"pumpkin.plate\")}\n{item(rainbow_ingot, 1, \"ingot.rainbow\")}\n{item(rainbow_plate, 1, \"plate.rainbow\")}\n{item(ring, 10, \"ring\")}\n{item(rod, 10, \"rod\")}\n{item(rubber_plate, 1, \"plate.rubber\")}\n{item(screw, 10, \"screw\")}\n{item(wire, 10, \"wire\")}\n\n{category(part, circuit, anti_pumpkin, wire)}\n\n;Tries to make dust from ores and lower-tier dusts, tiers 1-10\n; Doesn't appear in the UI\n{item(dust, 10, \"dust\")}\n\n; Tiers up dust, tiers 1-9\n; These are ore lumps, plus putting them into the mixer.\n; There is no \"only make ore lumps, without mixing them\" option right now.\n; Doesn't appear in the UI\n{special(lump, 9, \"lump\")}\n\n; Can only be made from saplings\n; Doesn't appear in the UI\n{item(void_essence, 1, \"essence.void\")}\n\n; Can only be gotten through the Halloween event\n; Doesn't appear in the UI\n{item(pumpkin, 1, \"pumpkin\")}\n\n; Rubber, tier 1 only\n; Doesn't appear in the UI\n{item(rubber, 1, \"rubber\")}\n\n; ===== END OF VALID IDS =====\n"],["Factory Compactor",":import Factory Compactor Utilities\n\n; \n; Factory variable definitions\n; \n\n{lua(\\\n  factory = {};\\\n  factory.items = {};\\\n  factory.item_names = {};\\\n  factory.item_types = {};\\\n  factory.categories = {};\\\n  \\\n  factory.recipes = {};\\\n  factory.recipe_list = {};\\\n  factory.recipe_target = {};\\\n  \\\n  factory.target = {};\\\n  factory.target.item_name = \"\";\\\n  factory.target.type = 0;\\\n  factory.target.tiers = {};\\\n  factory.target.counts = {};\\\n  factory.target.machine = \"\";\\\n  \\\n  factory.prods = {};\\\n  factory.prod_machines = {};\\\n  \\\n  factory.max_length = {};\\\n)}\n\n; \n; Core Program\n; \n; Important things to note\n; factory.items is the same as factory[\"items\"]\n; items has to be string for this operation\n; \n; If you define factory but not factory.items\n; checking (factory.items == nil) is the same as\n; checking (not factory.items)\n; \n\n{lua(\\\n  function factory.add_item(name, tiers, game_name, game_type)\\\n    local new_item = {};\\\n    new_item.id = 1 + #factory.items;\\\n    new_item.name = name:gsub(\" \", \"\");\\\n    \\\n    if factory.item_names[new_item.name] ~= nil then\\\n      return \"Item already added\";\\\n    end\\\n    \\\n    new_item.game_name = game_name:gsub(\" \", \"\");\\\n    new_item.game_type = game_type:gsub(\" \", \"\");\\\n    new_item.tiers = tonumber(tiers);\\\n    \\\n      --[[/*\\\n          * We call our error function\\\n          * if the items tier is invalid\\\n          * this means if it's nil or\\\n          * it goes under/over our alowed limit\\\n          * minimum of 1, because ingame items can't be tier 0\\\n          * maximum of 10, because ingame items can't surpass tier 10\\\n         */]]\\\n    \\\n    if not new_item.tiers then\\\n      util.error.name = \"tiers\";\\\n      return util.print_error();\\\n    end\\\n    if 1 > new_item.tiers or new_item.tiers > 10 then\\\n      util.error.name = \"tiers\";\\\n      util.error.compare = true;\\\n      util.error.compare_min = 1;\\\n      util.error.compare_max = 10;\\\n      return util.print_error();\\\n    end\\\n  \\\n    factory.items[new_item.id] = new_item;\\\n    factory.item_names[new_item.name] = new_item.id;\\\n    factory.item_types[new_item.name] = new_item.game_type;\\\n    \\\n    \\\n      --[[/*\\\n          * Utility function that makes adding\\\n          * max_length recordings easier and pretties up\\\n          * the variable declarations a little\\\n         */]]\\\n    \\\n    local function factory_max_length(name)\\\n      local max_length = factory.max_length;\\\n      if not max_length[name] then\\\n        max_length[name] = 0;\\\n      end\\\n      max_length[name] = math.max(max_length[name], #new_item.name);\\\n    end\\\n    \\\n    factory_max_length(\"item_name\");\\\n    factory_max_length(new_item.game_type);\\\n    \\\n     --[[/*\\\n         * Now that we've recorded a new item,\\\n         * we can create its instance inside of our recipes list\\\n         * this is done here so that the item fields aren't \\\n         * modified outside our recorder\\\n         * \\\n         * We start by determening what data to copy from our new_item\\\n         * and then, just like in d0s.factory, create 2 lists\\\n        */]]\\\n    \\\n    local new_item_copy = {};\\\n    new_item_copy[1 + #new_item_copy] = \"id\";\\\n    new_item_copy[1 + #new_item_copy] = \"name\";\\\n    new_item_copy[1 + #new_item_copy] = \"tiers\";\\\n    new_item_copy[1 + #new_item_copy] = \"game_name\";\\\n    new_item_copy[1 + #new_item_copy] = \"game_type\";\\\n    \\\n    local recipe_item = {};\\\n    for i = 1, #new_item_copy do\\\n      local var = new_item_copy[i];\\\n      recipe_item[var] = new_item[var];\\\n    end\\\n    \\\n     --[[/*\\\n         * list 1 is a forward facing list\\\n         * This list is stored inside of factory.recipe_list\\\n         * and records what recipes require this item\\\n        */]]\\\n    \\\n    recipe_item.recipe = {};\\\n    for i = 1, recipe_item.tiers do\\\n      recipe_item.recipe[i] = {};\\\n    end\\\n    factory.recipe_list[recipe_item.name] = recipe_item;\\\n    \\\n     --[[/*\\\n         * list 2 is a reversed list\\\n         * This list is stored in factory.recipes\\\n         * and is used to determine what items\\\n         * are needed to make the item\\\n        */]]\\\n    \\\n    local offset = 10 * recipe_item.id;\\\n    local internal_tiers = recipe_item.tiers - 1;\\\n    for i = offset, offset + internal_tiers do\\\n      factory.recipes[i] = {};\\\n    end\\\n    \\\n    util.text.const = true;\\\n    util.text.type = \"int\";\\\n    util.text.name = new_item.name;\\\n    util.text.const_data = tostring(new_item.id);\\\n    return util.print_text();\\\n  end\\\n  \\\n  function factory.add_recipe()\\\n    \\\n     --[[/*\\\n         * Function for a generalized recipe processing sequence\\\n         * Since recipes can either be produced or crafted, which have\\\n         * similar processing sequences, funneling them down through\\\n         * here should make everything easier to write out\\\n         * \\\n         * It uses external parameters stored in factory.target\\\n         * to get the items name, determine which operation\\\n         * to perform and parameters needed for multiple different\\\n         * \\\n         * \\\n        */]]\\\n    \\\n  end\\\n  \\\n  function factory.produce(item_name, source, gain, machine)\\\n  \\\n   --[[/*\\\n       * Function to declair that we're difining\\\n       * the requirements to produce the item \"item_name\"\\\n       * Throw an error if the item_name doesn't exist\\\n       * \\\n       * output a const to prevent multiple definitions\\\n       * of the same item\\\n      */]]\\\n  \\\n    local prod = {};\\\n    local input = item_name:gsub(\" \", \"\");\\\n    prod.item = factory.recipe_list[input];\\\n    if not prod.item then\\\n      util.error.name = \"production\";\\\n      return util.print_error();\\\n    end\\\n    input = source:gsub(\" \", \"\");\\\n    prod.source = factory.recipe_list[input];\\\n    if not prod.source then\\\n      util.error.name = \"source\";\\\n      return util.print_error();\\\n    end\\\n    if prod.item.tiers ~= prod.source.tiers then\\\n      util.error.name = \"source item\";\\\n      util.error.component_mismatch = true;\\\n      util.error.mismatch_element = \"tiers\";\\\n      util.error.target_elements = production_item.tiers;\\\n      util.error.obtained_elements = source_item.tiers;\\\n      return util.print_error();\\\n    end\\\n    prod.gain = gain;\\\n    prod.machine = machine;\\\n    local cond = #factory.prods == 0;\\\n    cond = cond or factory.prods[#factory.prods].machine ~= machine;\\\n    if cond then\\\n      if factory.prod_machines[machine] ~= nil then\\\n        return \"error\";\\\n      end\\\n      factory.prod_machines[machine] = 1 + #factory.prods;\\\n      factory.prod_machines[1 + #factory.prod_machines] = machine;\\\n    end\\\n    factory.prods[1 + #factory.prods] = prod;\\\n    \\\n    local offset = prod.source.id * 10;\\\n    local count = 1 / prod.gain;\\\n    for i = offset, offset + prod.item.id - 1 do\\\n      if not factory.recipes[i] then\\\n        factory.recipes[i] = {};\\\n      end\\\n      local recipe = factory.recipes[i];\\\n      recipe[1 + #recipe] = 10 * prod.item.id - offset + i;\\\n      recipe[1 + #recipe] = count;\\\n    end\\\n    prod.item.recipes = {};\\\n    for i = 1, prod.item.tiers do\\\n      local recipe = {};\\\n      recipe[1] = offset + i - 1;\\\n      recipe[2] = count;\\\n      prod.item.recipes[i] = recipe;\\\n    end\\\n  end\\\n  \\\n  function factory.define_recipe(item_name)\\\n    \\\n     --[[/*\\\n         * Function to declair that we're defining\\\n         * the recipe for the item `item_name`\\\n         * Throw an error if the item_name doesn't exist\\\n         * \\\n         * output a const to prevent multiple definitions\\\n         * of the same item\\\n        */]]\\\n    \\\n    local recipe_item = factory.recipe_list[item_name];\\\n    if not recipe_item then\\\n      util.error.name = \"recipe\";\\\n      util.error.recipe = true;\\\n      return util.print_error();\\\n    end\\\n    factory.recipe_target = recipe_item;\\\n    \\\n    util.text.const = true;\\\n    util.text.type = \"int\";\\\n    util.text.name = \"recipe.\" .. recipe_item.name;\\\n    util.text.const_data = recipe_item.id;\\\n    return util.print_text();\\\n  end\\\n  \\\n  function factory.add_component(tiers, name, counts)\\\n    local recipe_target = factory.recipe_target;\\\n    if not recipe_target.id then\\\n      util.error.name = \"recipe component\";\\\n      util.error.no_recipe = true;\\\n      return util.print_error();\\\n    end\\\n    local comp_name = name:gsub(\" \", \"\");\\\n    local component = factory.recipe_list[comp_name];\\\n    if not component then\\\n      util.error.name = \"component\";\\\n      return util.print_error();\\\n    end\\\n    if component.game_type == \"group\" then\\\n      util.error.name = \"component\";\\\n      util.error.component_is_group = true;\\\n      return util.print_error();\\\n    end\\\n    local temp_tiers = {};\\\n    for input in tiers:gmatch(\"%S+\") do\\\n      local tier = tonumber(input);\\\n      if not tier then\\\n        util.error.name = \"component tier\";\\\n        return util.print_error();\\\n      end\\\n      temp_tiers[1 + #temp_tiers] = tier;\\\n    end\\\n    if #temp_tiers ~= 1 and #temp_tiers ~= recipe_target.tiers then\\\n      util.error.name = \"component_tiers\";\\\n      util.error.component_mismatch = true;\\\n      util.error.mismatched_element = \"tiers\";\\\n      util.error.target_elements = recipe_target.tiers;\\\n      util.error.obtained_elements = #temp_tiers;\\\n      return util.print_error();\\\n    end\\\n    \\\n    local base_tier;\\\n    for i = 1, recipe_target.tiers do\\\n      if temp_tiers[i] ~= nil then\\\n        base_tier = temp_tiers[i];\\\n      end\\\n      local tier = base_tier;\\\n      if tier < 1 then\\\n        tier = tier + i;\\\n      end\\\n      temp_tiers[i] = tier;\\\n    end\\\n    \\\n    local temp_counts = {};\\\n    for input in counts:gmatch(\"%S+\") do\\\n      local count = tonumber(input);\\\n      if not count then\\\n        util.error.name = \"component count\";\\\n        return util.print_error();\\\n      end\\\n      temp_counts[1 + #temp_counts] = count;\\\n    end\\\n    if #temp_counts ~= 1 and #temp_counts ~= recipe_target.tiers then\\\n      util.error.name = \"component_counts\";\\\n      util.error.component_mismatch = true;\\\n      util.error.mismatched_element = \"counts\"\\\n      util.error.target_elements = recipe_target.tiers;\\\n      util.error.obtained_elements = #temp_counts;\\\n      return util.print_error();\\\n    end\\\n    for i = #temp_counts + 1, recipe_target.tiers do\\\n      temp_counts[i] = temp_counts[i - 1];\\\n    end\\\n    \\\n     --[[/*\\\n         * Finally, merge the two expanded lists and distribute\\\n         * the results across the recipes for each tier.\\\n         * \\\n         * These recipes are \"reversed\", in the sense that\\\n         * they don't describe how to make each item, but rather\\\n         * all the items that this one can be used to help make.\\\n         * \\\n         * This is the list needed for computing\\\n         * the materials needed for crafting.\\\n        */]]\\\n    \\\n    local recipes = factory.recipes;\\\n    local offset = recipe_target.id * 10 - 1;\\\n    for i = 1, recipe_target.tiers do\\\n      local tier = temp_tiers[i];\\\n      local count = temp_counts[i];\\\n       --[[/*\\\n           * Due to the negative tier convention by d0sboots\\\n           * tiers smaller than 1 can happen naturally\\\n           */]]\\\n      if count > 0 and tier > 0 then\\\n        \\\n         --[[/*\\\n             * This check ensures only tiers from 1 to 10 are\\\n             * computed, as negative tiers do not exist\\\n             * \\\n             * now, we make sure our temp_tier isn't bigger\\\n             * than what the component can manage\\\n            */]]\\\n        \\\n        if tier > component.tiers then\\\n          util.error.name = \"component tier\";\\\n          util.error.compare = true;\\\n          util.error.compare_min = -1;\\\n          util.error.compare_max = component.tiers;\\\n          return util.print_error();\\\n        end\\\n        local index = component.id * 10 + tier - 1;\\\n        local comp = recipes[index];\\\n        if not comp then\\\n          comp = {};\\\n          recipes[index] = comp;\\\n        end\\\n        comp[1 + #comp] = offset + i;\\\n        comp[1 + #comp] = count;\\\n        local recipe_item = recipe_target.recipe[i];\\\n        recipe_item[1 + #recipe_item] = index;\\\n        recipe_item[1 + #recipe_item] = count;\\\n      end\\\n    end\\\n  end\\\n \\\n  \\\n  function factory.add_category(name, default, first, last)\\\n    local category = {};\\\n    \\\n    category.id = 1 + #factory.categories;\\\n    local fields = table.pack(\"default\", \"first\", \"last\");\\\n    local args = table.pack(default, first, last);\\\n    category.name = name:gsub(\" \", \"\");\\\n    \\\n    for i = 1, #fields do\\\n      local trimmed = args[i]:gsub(\" \", \"\");\\\n      local item = factory.item_names[trimmed];\\\n      if not item then\\\n        util.error.name = \"category parameter\"\\\n        util.error.category = true;\\\n        util.error.category_field = trimmed\\\n        return util.print_error();\\\n      end\\\n      local field = fields[i];\\\n      category[field] = item;\\\n    end\\\n    factory.categories[category.id] = category;\\\n  end\\\n)}\n\n; \n; Helper Macros\n; \n\n; \n; Mathod to communicate with the compactor to add an item\n; Used by other macros for easier definitions\n#add_item(name, tiers, game_name, type) {lua(return factory.add_item(\\\n  \"{name}\",\\\n  {tiers},\\\n  {game_name},\\\n  {type}\\\n))}\n\n; \n; Mathod to add an item that's inside of the craft function\n#craft(name, tiers, game_name) {add_item(\\\n  {name},\\\n  {tiers},\\\n  {game_name},\\\n  \"craft\"\\\n)}\n\n; \n; Mathod to add an item that's inside of the produce function\n#item(name, tiers, game_name) {add_item(\\\n  {name},\\\n  {tiers},\\\n  {game_name},\\\n  \"produce\"\\\n)}\n\n; \n; Method to group items together\n; this items game_name doesn't exist so\n; for ease of understanding, it's marked as\n; the items name .group\n; \n; in d0s's factory AI, this was ore because of\n; a game bug that has since been fixed\n#group(name, tiers) {add_item({name}, {tiers}, \"{name}.group\", \"group\")}\n\n; \n; Mathod to add a *special* item\n; special items are for internal use, and do not show on UI\n#special(name, tiers, game_name) {add_item(\\\n  {name},\\\n  {tiers},\\\n  {game_name},\\\n  \"special\"\\\n)}\n\n; \n; Method to declair a recipe target\n#recipe(name) {lua(return factory.define_recipe([[{name}]]))}\n\n; \n; Method to declair a component for the targeted recipe\n; for making an item defined as craft\n#component(tiers, name, count) {lua(return factory.add_component(\\\n  [[{tiers}]],\\\n  [[{name}]],\\\n  [[{count}]]\\\n))}\n\n; \n; Method to declair the requirements of\n; making an item defined as produce\n#produce(item, source, cost, machine) {lua(return factory.produce(\\\n  \"{item}\",\\\n  \"{source}\",\\\n  {cost},\\\n  \"{machine}\"\\\n))}\n\n; \n; Method to add a category\n#category(name, default, first, last) {lua(return factory.add_category(\\\n  \"{name}\",\\\n  \"{default}\",\\\n  \"{first}\",\\\n  \"{last}\"\\\n))}\n\n"],["Factory Compactor Utilities","\n; \n; Utility variable definitions\n; \n\n{lua(\\\n  util = {};\\\n  util.text = {};\\\n  util.text.name = \"\";\\\n  util.text.type = \"\";\\\n  util.text.const = false;\\\n  util.text.const_data = \"\";\\\n  util.error = {};\\\n  util.error.name = \"\";\\\n  util.error.recipe = false;\\\n  util.error.component = false;\\\n  util.error.no_recipe = false;\\\n  util.error.component_is_group = false;\\\n  util.error.component_mismatch = false;\\\n  util.error.mismatched_element = \"\";\\\n  util.error.target_elements = 0;\\\n  util.error.obtained_elements = 0;\\\n  util.error.category = false;\\\n  util.category_field = \"\";\\\n  util.error.compare = false;\\\n  util.error.compare_min = 0;\\\n  util.error.compare_max = 0;\\\n)}\n\n; \n; Code\n; \n\n{lua(\\\n  function util.table_assign(target, target_field, value, type)\\\n    local assign_target = target;\\\n    if not target[target_field] then\\\n      target[target_field] = 0;\\\n    end\\\n    local math_type = math[type];\\\n    target[target_field] = math_type(target[target_field], value);\\\n  end\\\n  function util.pack_assign(target, value_to_assign, ...)\\\n    \\\n     --[[/*\\\n         * Function that permits setting multiple variables to\\\n         * a desired value without the need of piling them all\\\n         * in multiple lines\\\n         * \\\n         * set the group we're targetting, the value to assign\\\n         * and then the variables you want to update\\\n        */]]\\\n    \\\n    local variables = table.pack(...);\\\n    local pack_target = target;\\\n    for i = 1, #variables do\\\n      local name = variables[i];\\\n      pack_target[name] = value_to_assign;\\\n    end\\\n  end\\\n  \\\n  function util.print_text()\\\n    local text = util.text;\\\n    local printer = {};\\\n    if text.const then\\\n      printer[1 + #printer] = \":const\" .. ' ';\\\n      printer[1 + #printer] = text.type;\\\n      printer[1 + #printer] = ' ';\\\n      printer[1 + #printer] = text.name;\\\n      printer[1 + #printer] = ' ';\\\n      printer[1 + #printer] = text.const_data\\\n    end\\\n    util.pack_assign(text, \"\", \"name\", \"type\", \"const_data\");\\\n    util.pack_assign(text, false, \"const\");\\\n    return table.concat(printer);\\\n  end\\\n  \\\n  function util.print_error()\\\n    local special_error = false;\\\n    local error = util.error;\\\n    error.component = error.component or error.no_recipe;\\\n    error.component = error.component or error.component_is_group;\\\n    error.component = error.component or error.component_mismatch;\\\n    local exception = {};\\\n    exception[1 + #exception] = \"Invalid\" .. ' ';\\\n    exception[1 + #exception] = error.name;\\\n    exception[1 + #exception] = ' ';\\\n    exception[1 + #exception] = \"input\" .. '\\n';\\\n    exception[1 + #exception] = \"Inputed\" .. \" \";\\\n    exception[1 + #exception] = error.name;\\\n    exception[1 + #exception] = \" \";\\\n    \\\n     --[[/*\\\n          * Printer functionality\\\n          * broken up in multiple\\\n          * functions for easier\\\n          * modification\\\n         */]]\\\n    \\\n    local function compare_error()\\\n      if not error.compare then\\\n        return;\\\n      end\\\n      special_error = true;\\\n      exception[1 + #exception] = \"cannot be smaller than\" .. ' ';\\\n      exception[1 + #exception] = error.compare_min;\\\n      exception[1 + #exception] = ' ';\\\n      exception[1 + #exception] = \"or bigger than\" .. ' ';\\\n      exception[1 + #exception] = error.compare_max;\\\n      exception[1 + #exception] = ' ';\\\n    end\\\n    local function recipe_error()\\\n      if not error.recipe then\\\n        return;\\\n      end\\\n      special_error = true;\\\n      exception[1 + #exception] = \"has already\" .. ' ';\\\n      exception[1 + #exception] = \"been created\" .. ' ';\\\n    end\\\n    local function component_error()\\\n      if not error.component then\\\n        return;\\\n      end\\\n      special_error = true;\\\n      local function no_recipe()\\\n        if not error.no_recipe then\\\n          return;\\\n        end\\\n        exception[1 + #exception] = \"has no recipe\" .. ' ';\\\n        exception[1 + #exception] = \"to be part of\" .. '\\n';\\\n        exception[1 + #exception] = \"Component defined\" .. ' ';\\\n        exception[1 + #exception] = \"before specifying\" .. ' ';\\\n        exception[1 + #exception] = \"target recipe\" .. ' ';\\\n      end\\\n      local function is_group()\\\n        if not error.component_is_group then\\\n          return;\\\n        end\\\n        exception[1 + #exception] = \"is defined as group\" .. '\\n';\\\n        exception[1 + #exception] = \"Group items are\" .. ' ';\\\n        exception[1 + #exception] = \"not components\" .. ' ';\\\n      end\\\n      local function component_mismatch()\\\n        if not error.component_mismatch then\\\n          return;\\\n        end\\\n        exception[1 + #exception] = \"do not match\" .. ' ';\\\n        exception[1 + #exception] = \"tiers of\" .. ' ';\\\n        exception[1 + #exception] = \"targeted recipe\" .. '\\n';\\\n        exception[1 + #exception] = \"Target number of\" .. ' ';\\\n        exception[1 + #exception] = error.mismatched_element;\\\n        exception[1 + #exception] = \" is \";\\\n        exception[1 + #exception] = error.target_elements;\\\n        exception[1 + #exception] = \", \";\\\n        exception[1 + #exception] = \"obtained number of\" .. ' ';\\\n        exception[1 + #exception] = error.mismatched_element;\\\n        exception[1 + #exception] = \" is \";\\\n        exception[1 + #exception] = error.obtained_elements;\\\n        exception[1 + #exception] = ' ';\\\n      end\\\n      no_recipe();\\\n      is_group();\\\n      component_mismatch();\\\n    end\\\n    local function category_error()\\\n      if not error.category then\\\n        return;\\\n      end\\\n      special_error = true;\\\n      exception[1 + #exception] = \"in field '\";\\\n      exception[1 + #exception] = error.category_field;\\\n      exception[1 + #exception] = \"' \";\\\n    end\\\n    local function special_exception()\\\n      if special_error then\\\n        return;\\\n      end\\\n      exception[1 + #exception] = \"returned nil\";\\\n    end\\\n    compare_error();\\\n    recipe_error();\\\n    component_error();\\\n    category_error();\\\n    special_exception();\\\n    \\\n    util.pack_assign(error, \"\", \\\n      \"name\",\\\n      \"mismatched_element\",\\\n      \"category_field\"\\\n    );\\\n    util.pack_assign(error, false, \\\n      \"recipe\",\\\n      \"no_recipe\",\\\n      \"component_is_group\",\\\n      \"component_mismatch\",\\\n      \"category\",\\\n      \"compare\"\\\n    );\\\n    util.pack_assign(error, 0, \\\n      \"target_elements\",\\\n      \"obtained_elements\",\\\n      \"compare_min\",\\\n      \"compare_max\"\\\n    );\\\n    return table.concat(exception);\\\n  end\\\n)}\n\n; \n; Helper Macros\n; \n\n\n"],["factory lib",":import Factory Recipes\n\n; Infrastructure for producing all the constants in the factory package.\n; Since this is :imported, it can't produce any instructions.\n\n#version 3.2.3\n\n#script_name(name) D0S.factory {version}:{name}\n#identifier \"D0S.factory {version} identifier\"\n\n; \n; guide for size\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n\n; Key assignments.\n; You can edit these here, or you can edit them later in the\n; generated script (but you will have more places to modify).\n#up w\n#down s\n#left a\n#right d\n#start f\n\n; Now that all the recipes are defined,\n; we have to put them in a valid order.\n; We do this with a modified breadth-first-search,\n; optimized around the structure of our data.\n; Items are a type-tier pair identified by the formula type * 10 + tier\n; They are sequentially checked against a graph\n; that is incrementally being formed.\n; If all its recipe-items have already been satisfied or it has none,\n; then it is also satisfied, and as long as it has recipe-items entry,\n; it's put on a queue to be outputed.\n; Otherwise, a count is kept of how many unsatisfied recipes it has,\n; and an entry is made in each blocking recipe pointing back to this item.\n; After each item, the queue is processed.\n; The head of the queue is popped and gets the next sequential id\n; this is how the recipes get their order.\n; Also, any items blocked on it will have\n; their tallies decremented by one.\n; If these go to zero, they are now satisfied\n; and will be added to the queue to be output as well.\n\n{lua(\\\n  local recipes_list = {};\\\n  factory.recipes_list = recipes_list;\\\n  local items = factory.items;\\\n  local recipes = factory.recipes;\\\n  local graph = {};\\\n  local queue = {};\\\n  for tier = 10, 1, -1 do\\\n    for item_id = 1, #items do\\\n      local item = items[item_id];\\\n      local id = 10 * item_id + tier - 1;\\\n      local recipe = recipes[id];\\\n      if not recipe then\\\n        goto continue;\\\n      end\\\n      local entry = graph[id];\\\n      if not entry then\\\n        entry = {};\\\n        entry.blocking = {};\\\n        graph[id] = entry;\\\n      end\\\n      local blockers = 0;\\\n      if recipe then\\\n        for i = 1, #recipe, 2 do\\\n          local other = graph[recipe[i]];\\\n          if not other then\\\n            other = {};\\\n            other.blocking = {};\\\n            other.blockers = -1;\\\n            graph[recipe[i]] = other;\\\n          end\\\n          if other.blockers ~= 0 then\\\n            blockers = blockers + 1;\\\n            other.blocking[#other.blocking + 1] = id;\\\n          end\\\n        end\\\n      end\\\n      entry.blockers = blockers;\\\n      \\\n      if blockers == 0 then\\\n        queue[#queue + 1] = id;\\\n      end\\\n      \\\n      local q_front = 1;\\\n      while q_front <= #queue do\\\n        id = queue[q_front];\\\n        entry = graph[id];\\\n        recipes_list[#recipes_list + 1] = id;\\\n        for i = 1, #entry.blocking do\\\n          local other = graph[entry.blocking[i]];\\\n          other.blockers = other.blockers - 1;\\\n          if other.blockers == 0 then;\\\n            queue[#queue + 1] = entry.blocking[i];\\\n          end;\\\n        end\\\n        q_front = q_front + 1\\\n      end\\\n      queue = {};\\\n      ::continue::\\\n    end\\\n  end\\\n)}\n"]]}}
```

The import code is purely d0s.factory, at this moment, as it would be a lot harder to remake it from scratch
