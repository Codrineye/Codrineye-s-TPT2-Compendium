:import Factory Compactor Debugger

; 
; Factory variable definitions
; 

{lua(\
  factory = {};\
  factory.items = {};\
  factory.item_names = {};\
  factory.item_types = {};\
  factory.categories = {};\
  \
  factory.recipes = {};\
  factory.recipe_list = {};\
  factory.recipe_target = {};\
  \
  factory.max_length = {};\
)}

; 
; Core Program
; 
; Important thing to note
; factory.items is the same as factory["items"]
; I was confused about this for a while so
; it's for the best to mention it here
; 

{lua(\
  function factory.add_item(name, tiers, game_name, game_type)\
    local new_item = {};\
    new_item.id = 1 + #factory.items;\
    new_item.name = name:gsub(" ", "");\
    new_item.tiers = tonumber(tiers);\
    \
      --[[/*\
          * We call our debugging function\
          * if the items tier is invalid\
          * this meaning if it's nil or if\
          * it goes under/over our alowed limit\
         */]]\
    \
    if not new_item.tiers then\
      debug.error.name = "tiers";\
      return debug.print_error();\
    end\
    if 10 < new_item.tiers or new_item.tiers < 1 then\
      debug.error.name = "tiers";\
      debug.error.comp = true;\
      debug.error.comp_min = 0;\
      debug.error.comp_max = 10;\
      return debug.print_error();\
    end\
    \
    new_item.game_name = game_name:gsub(" ", "");\
    new_item.game_type = game_type:gsub(" ", "");\
  \
    factory.items[new_item.id] = new_item;\
    factory.item_names[new_item.name] = new_item.id;\
    factory.item_types[new_item.name] = new_item.game_type;\
    \
      --[[/*\
          * Helper function that makes adding\
          * max_length recordings easier and\
          * pretties up the variable declarations\
         */]]\
    \
    local function factory_max_length(name)\
      local max_length = factory.max_length;\
      if max_length[name] == nil then\
        max_length[name] = 0;\
      end\
      max_length[name] = math.max(max_length[name], #new_item.name);\
    end\
    \
    factory_max_length("item_name");\
    factory_max_length(new_item.game_type);\
    \
     --[[/*\
         * Now that we've recorded a new item,\
         * we can create its instance inside of our recipes list\
         * this is done here so that there's only one function\
         * that handles item recording\
        */]]\
    \
    local new_item_copy = {};\
    table.insert(new_item_copy, "id");\
    table.insert(new_item_copy, "name");\
    table.insert(new_item_copy, "tiers");\
    table.insert(new_item_copy, "game_name");\
    table.insert(new_item_copy, "game_type");\
    \
    local recipe_item = {};\
    for i, var in new_item_copy do\
      recipe_item[var] = new_item[var];\
    end\
    \
    local offset = 10 * recipe_item.id;\
    local internal_tiers = recipe_item.tiers - 1;\
    for i = offset, offset + internal_tiers do\
      factory.recipes[i] = {};\
    end\
    \
    recipe_item.accessed = false;\
    recipe_item.recipe = {};\
    for i = 1, recipe_item.tiers do\
      recipe_item.recipe[i] = {};\
    end\
    \
    factory.recipe_list[recipe_item.name] = recipe_item;\
    \
    debug.text.const = true;\
    debug.text.type = "int";\
    debug.text.name = new_item.name;\
    debug.text.const_data = tostring(new_item.id);\
    return debug.print_text();\
  end\
  \
 \
  function factory.define_recipe(name)\
    local recipe_item = factory.recipe_list[name];\
    if not recipe_item then\
      debug.error.name = "recipe";\
      return debug.print_error();\
    end\
    if recipe_item.accessed then\
      debug.error.name = "recipe";\
      debug.error.recipe = true;\
      return debug.print_error();\
    end\
    recipe_item.accessed = true;\
    factory.recipe_target = recipe_item;\
  end\
  function factory.add_component(tiers, name, counts)\
    \
  end\
 \
  \
  function factory.add_category(name, default, first, last)\
    local category = {};\
    \
    category.id = 1 + #factory.categories;\
    local names = table.pack("default", "first", "last");\
    local args = table.pack(default, first, last);\
    category.name = name:gsub(" ", "");\
    \
    for i = 1, #names do\
      local trimmed = args[i]:gsub(" ", "");\
      local item = factory.item_names[trimmed];\
      if item == nil then\
        printer = {};\
        printer[1 + #printer] = "Invalid item" .. ' ';\
        printer[1 + #printer] = "in field" .. ' ';\
        printer[1 + #printer] = "'";\
        printer[1 + #printer] = trimmed;\
        printer[1 + #printer] = "'";\
        return table.concat(printer);\
      end\
      local name = names[i];\
      category[name] = item;\
    end\
    factory.categories[category.id] = category;\
  end\
)}

; 
; Helper Macros
; 

; 
; Core item macro
; Mathod to communicate with the compactor to add an item
#item(name, tiers, game_name, type) {lua(return factory.add_item(\
  "{name}",\
  {tiers},\
  {game_name},\
  {type}\
))}

; 
; Mathod to add an item that's inside of the craft function
#craft(name, tiers, game_name) {item(\
  {name},\
  {tiers},\
  {game_name},\
  "craft"\
)}

; 
; Mathod to add an item that's inside of the produce function
#produce(name, tiers, game_name) {item(\
  {name},\
  {tiers},\
  {game_name},\
  "produce"\
)}

; 
; Method to group items together
; this items game_name doesn't exist so
; for ease of understanding, it's marked as
; the items name .group
; 
; in d0s's factory AI, this was ore because of
; a game bug that has since been fixed
#group(name, tiers) {item(\
  {name},\
  {tiers},\
  "{name}.group",\
  "group"\
)}

; 
; Mathod to add a *special* item
; special items are for internal use, and do not show on UI
#special(name, tiers, game_name) {item(\
  {name},\
  {tiers},\
  {game_name},\
  "special"\
)}

; 
; Method to declair a recipe
#recipe(name) {lua(return factory.define_recipe([[{name}]]))}

; 
; Method to declair a recipe component
#component(tiers, name, count) {lua(return add_component(\
  [[{tiers}]],\
  [[{name}]],\
  [[{count}]]\
))}

; 
; Method to add a category
#category(name, default, first, last) {lua(return factory.add_category(\
  "{name}",\
  "{default}",\
  "{first}",\
  "{last}"\
))}
