# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)

Source code of Codrineye's TowerTesting<br>
You can import it if you want to customise the impulses, change your additional_cond or switch the difficulty cycling direction.<br>
The impulse definition is found close to the top of [Codrineye's TowerTesting_lib](Codrineye's%20TowerTesting_lib.tpt2), if you're changing the impulse for "stats" make sure it's the same as the keybind that opens the stats menu ingame.

The source also has comments explaining what you're looking at.

```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap 600\n\n; Variable definitions\n;\n; Const string to define the direction in which difficulties are cycles through\n; false = Easy to Impossible\n; true = Impossible to Easy\n:const string order1 {diff_list(true)}\n:const string order2 {diff_list(false)}\n\n:local bool additional_cond\n; add an additional condition that can lead to exiting\n;\n; Timer variables\n:local double game_time\n:local double end_time\n:local double seconds\n:local double minutes\n:local double hours\n;\n:local int instance\n;\n:local string difficulty_list\n;\n; Macros for configuration in source\n#additional_cond global.bool.get(\"Pokota:Stop\")\n\nkey.{start}()\nkey.{cycling}()\nkey.{mode}()\nkey.{difficulty}()\n;\nkey.{exit}()\nkey.{stats}()\nkey.{restart}()\n\nclose.headquarters()\n; Attempt to hide the UI when leaving HQ\n\n; Attempt to \ngame.newround()\n;\n; Detects if any of the invalid buildings are open\n#opened_building {lua(\\\n  local acc = {};\\\n  local isOpen = [[isopen(\"%s\")]];\\\n  local buildings = table.pack(\\\n    \"tradingpost\", \"powerplant\",\\\n    \"factory\", \"laboratory\", \"shipyard\",\\\n    \"workshop\", \"arcade\", \"museum\",\\\n    \"constructionfirm\", \"statueofcubos\", \"mine\"\\\n  );\\\n  for i = 1, #buildings do\\\n    acc[1 + #acc] = isOpen:format(buildings[i]);\\\n  end\\\n  return table.concat(acc, \" || \");\\\n)}\n\n; If the impulse is exit, stats or restart, it must be done in towertesting\ncontains(\\\n  \"key.{start}|key.{mode}|key.{cycling}|key.{difficulty}|close.headquarters\",\\\n  impulse()\\\n) || isTowerTesting()\n;\n; Prevent multiple exit() instances being created\n; Only 1 should be made\nimpulse() != \"key.{exit}\" ||\\\n{job.get} != \"</size><color=#0AFF00>Exit caused by pressing key.{exit}\"\n\n;\n; We can only interact with the script if we're in a game of TowerTesting\n; inside of the HQ, in TowerTesting or in of town. Unfortunately, there's no way to ensure\n; we're activated outside of the game Perfect Space.\nisTowerTesting() || not(isBossFight() || {opened_building})\n\n\n; Condition that specifies the line number of the action the user might want to modify\n#condition_comment.info {lua(\\\n  local msg = table.pack(\\\n    \"</size><br>\",\\\n      \"additional_cond adds an additional condition \",\\\n      \"that could be met to exit tower testing<br>\",\\\n      \"<br>seconds, minutes and hours reprezent how much time \",\\\n      \"you want to pass in real world seconds before exiting tower testing\",\\\n      \"<br>Leave all at 0 if you don't want this\",\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg)\\\n)}\n\ncontains(\\\n  concat(\"click here for line info!<size=0>\", \"{condition_comment.info}\"),\\\n  \"\"\\\n)\n#condition_comment.line {lua(\\\n  local msg = table.pack(\\\n    \"</size><br>\",\\\n      \"<br>additional_cond is found on line \",\\\n      [[\" . additional_cond_pos . \"]],\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg);\\\n)}\n\ncontains(\\\n  concat(\"click here for line numbers!<size=0>\", \"{condition_comment.line}\"),\\\n  \"\"\\\n)\n\n; Start of code\n\n; Set the seconds, minutes and hours\n; After this time has elapsed, you'll exit towertesting\nseconds = 0.0\nminutes = arithmetic.double(0.0, \"*\", 60.0)\nhours = arithmetic.double(0.0, \"*\", 60.0 * 60.0)\n\n; Don't change the difficulty list if diff_mode is set and user didn't request a difficulty change\n; If the user did request a change, only change it if we're in config mode or if we're active\ndifficulty_list = if(\\\n  {diff_mode.get} != \"\" && (\\\n    impulse() != \"key.{difficulty}\" ||\\\n    not(isopen(\"headquarters\") ||({status.get} != (impulse() == \"key.{start}\")))\\\n  ),\\\n  {diff_mode.get},\\\n  if({diff_mode.get} == order2, order1, order2)\\\n)\n\n; Determine our instance number\ninstance = s2i(sub({hider.get}, 0, 1), 0) + 1\n\n; Begin the block hider\n; This variable holds the number of instances currently running and the game time\n; There shouldn't ever be more than 2 instances, but this gives room for a max of 90\n{hider.set(instance . if(\\\n  impulse() == \"game.newround\",\\\n  \"0.0\",\\\n  sub({hider.get}, 1, 99)\\\n))}\n;\n; The difficulty variable holds a counter and the current coordinate\n; The counter is used to decide what we're doing based on the mode.\n; It uses index(\"ABCDEFGHIJKLMN\", sub(diff, 0, 1), 0) + 1 to count up\n; A = 0, B = 1 and N = 14. Thus, I can determine what to do by simply using a contains()\n;\n; How changing difficulty is determined:\n; If we're in mode1, we're always moving to the next difficulty. If we're in mode2, we only move\n; to the next difficulty after we've counted up to 15\n;\n; How changing region is determined:\n; If mode1, we only change the region when our counter is at A. If mode2, we always move to the\n; next region\n;\n:const string counting_string \"ABCDEFGHIJKLMN\"\n;\n; The hider is shut off with a </size> block if the script is running\n; or if start/cycling/mode were pressed while inside the headquarters/towertesting menu\n{diff.set(\\\n  if(\\\n    {diff.get} != \"\" && {status.get} != (impulse() == \"key.{start}\")\\\n    && not(contains(\"key.{difficulty}|key.{mode}|game.newround\", impulse())),\\\n    sub({diff.get}, 0, 8),\\\n    sub(\\\n      counting_string,\\\n      arithmetic.int(\\\n        index(counting_string, sub({diff.get}, 0, 1), 0) +\\\n        if(impulse() == \"game.newround\", 1, 0),\\\n        if({status.get}, \"mod\", \"\"),\\\n        if(\\\n          {curent_mode.get} == mode1 ||\\\n          (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2), 5, 14)\\\n      ),\\\n      1\\\n    ) . sub(\\\n      {lua(--[[Determine if we change the difficulty or not]])}\\\n      if(\\\n        impulse() == \"key.{difficulty}\" || {diff.get} == \"\" ||\\\n        {curent_mode.get} == mode1 || \\\n        (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2) ||\\\n        contains({diff.get}, \"N\"),\\\n        difficulty_list,\\\n        {diff.get}\\\n      ),\\\n      {lua(--[[/*\\\n        * Determine the index.\\\n        * We change nothing if our impulse is\\\n      */]])}\\\n      if(\\\n        impulse() == \"key.{difficulty}\" || {diff.get} == \"\" ||\\\n        {curent_mode.get} == mode1 || \\\n        (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2) ||\\\n        contains({diff.get}, \"N\"),\\\n        if(\\\n          impulse() == \"game.newround\",\\\n          s2i(sub({diff.get}, 1, 2), 0),\\\n          index(difficulty_list, sub({diff.get}, 1, 2), 0)\\\n        ),\\\n        1\\\n      ),\\\n      7\\\n    )\\\n  ) . if(\\\n    isopen(\"headquarters\") || isopen(\"towertesting\")\\\n    || ({status.get} != (impulse() == \"key.{start}\")),\\\n    \"</size>\",\\\n    \"{if_debugging(<line-height=0>)}\"\\\n  )\\\n)}\n\n;\n{status.set({status.get} != (impulse() == \"key.{start}\"))}\n;\n; Only toggle the region_cycling switch if we're running or we're in the HQ\n{region_cycling.set({region_cycling.get} != (\\\n  ({status.get} || isopen(\"headquarters\")) &&\\\n  (impulse() == \"key.{cycling}\")\\\n))}\n\n; Keep the mode unchanged if we're initialized and the user\n{curent_mode.set(if(\\\n  {curent_mode.get} != \"\" && (\\\n    impulse() != \"key.{mode}\" ||\\\n    not(isopen(\"headquarters\") || {status.get})\\\n  ),\\\n  {curent_mode.get},\\\n  if({curent_mode.get} == mode2, mode1, mode2)\\\n))}\n\n{diff_mode.set(difficulty_list)}\n\n; Set the job status\n; If we're shut down, stop the hiding block\n; If we're running and the user requested an exit, set the `Exit caused` message\n; otherwise, don't change the value\n{job.set(if(\\\n  {status.get},\\\n  if(\\\n    impulse() != \"key.{exit}\",\\\n    {job.get},\\\n    \"</size><color=#0AFF00>Exit caused by pressing key.{exit}</color>\"\\\n  ),\\\n  \"</size>{if_debugging(</line-height>)}</size>\"\\\n))}\n\n; Determine where we're going\n; If we're the first instance and we've just started up, we enter the loop\n; Otherwise, we're called for a qol or an irelevant impulse\n; If this is a qol impulse, we must be in towertesting to perform it\ngoto(if(\\\n  {status.get} && impulse() == \"key.{start}\" && instance == 1,\\\n  if(isTowerTesting(), loop, movement_manager),\\\n  if(\\\n    contains(\"key.{exit}|key.{stats}|key.{restart}\", impulse()) && isTowerTesting(),\\\n    if(\\\n      impulse() == \"key.{exit}\",\\\n      exit,\\\n      if(impulse() == \"key.{stats}\", stats, restart)\\\n    ),\\\n    end\\\n  )\\\n))\n\nquit:\n; We're here only if we shut down. This can't softlock us, because\n; movement_manager ensures we've started a new round\n; This waitwhile is in place to slow us down (intentionally) so that we can exit towertesting\nwaitwhile(isopen(\"towertesting\"))\n\nloop:\nend_time = now() + 1e7 * (seconds + minutes + hours)\n; Set our end time. If this is just now(), it'll get ignored\n;\n; Update our job\n{job.set(if(\\\n  {status.get},\\\n  \"</size><color=#0AFF00>Waiting to exit Tower Testing</color>\",\\\n  \"</size>{if_debugging(</line-height>)}</size>\"\\\n))}\n\nin_towertesting:\nwaitframe()\n\ngame_time = s2d(sub({hider.get}, 1, 99), 0.0) + time.delta()\n; Update our game time. The hider stores it after the instance count\n; Do not lose the instance count\n{hider.set(sub({hider.get}, 0, 1) . d2s(game_time))}\n\nadditional_cond_pos:\nadditional_cond = {additional_cond}\n\n; Rather complicated gotoif\n; We stay in towertesting for as long as we're running, not dead and\n; we haven't meat our additional condition\n; If the end_time offset is 0.0 (default), then our end_time will be ignored\n; Otherwise, we'll exit once the time of seconds, minutes and hours summed together is elapsed\ngotoif(\\\n  in_towertesting,\\\n  {status.get} && health(false) > 0.0 && not(additional_cond) && (\\\n    seconds + minutes + hours == 0.0 ||\\\n    now() <= end_time\\\n  )\\\n)\n\n; Don't modify the job if we exited because of key.exit\n; Otherwise, mention the reason we ended the run\n{job.set(if(\\\n  contains({job.get}, \"Exit caused by\") || not({status.get}),\\\n  {job.get},\\\n  \"</size><color=#0AFF00>Exit caused by \" . if(\\\n    additional_cond,\\\n    \"additional_cond\",\\\n    if(isTowerTesting(), \"tower death\", \"an external cause\")\\\n  ) . \"</color>\"\\\n))}\n\nexit:\nwait(time.unscaled() * 1.5)\n; We try to exit.\n; This isn't a fixed value because it depends on the device\n; I've found that this operation results in the best amount of time\n;\n; A waitframe() is too quick and it causes lag\nexit()\n\n; Keep trying to exit if we're in towertesting.\n; Then, we continue over to the movement manager if we're still running\ngoto(if(\\\n  isTowerTesting(),\\\n  exit,\\\n  if({status.get} && impulse() == \"key.{start}\", movement_manager, end)\\\n))\n\nmovement_manager:\n{job.set(if(\\\n  {status.get},\\\n  \"</size><color=#FAA00F>User must \" . if(\\\n    isopen(\"headquarters\"),\\\n    \"exit the headquarters\",\\\n    \"close the window opened in town\"\\\n  ) . \"</color>\",\\\n  {job.get}\\\n))}\n;\n; We can only be activated if in the HQ, town or TT menu\n; The only places where show(\"towertesting\", true) won't work are\n; if we're inside hq, town/infinity perks menus\n; Thus, we must give a warning if we're in HQ or assume that town has an opened window\n\nwaitwhile(not(isopen(\"towertesting\")) && anyopen() && {status.get})\n; This will make us wait for as long as we're running and we're not in towertesting and\n; a window is open. \n\nshow(\"towertesting\", true)\n; Enter the TT menu\n;\n; Determine if we're able to change regions\n; \ngoto(if(\\\n  {status.get},\\\n  if(\\\n    {region_cycling.get} && (\\\n      ({curent_mode.get} == mode1 && contains({diff.get}, \"A\")) ||\\\n      ({curent_mode.get} == mode2 && not(contains({diff.get}, \"A\")))\\\n    ) && end_time > 0.0,\\\n    change_region,\\\n    enter_towertesting\\\n  ),\\\n  end\\\n))\n\nchange_region:\nwaitframe()\n\n; click on the arrow to change region\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\nenter_towertesting:\n; Click on the difficulty\n; diff.get has a 1-character counter, a length-2 position and a 5 character \n{click.relative(395.0/800.0, s2d(sub({diff.get}, 3, 5), 0.0)/450.0, 0.0, 1.0)}\n\n; Launch a round of towertesting\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\ngotoif(if({status.get}, loop, end), isTowerTesting() || not({status.get}))\n\nwaitframe()\ngoto(enter_towertesting)\n\n; The user requested a restart\nrestart:\nrestart()\ngoto(end)\n\n; The user requested the stats be shown\n; This clicks in the general area of the button where\n; resource/sec, xp/sec and frags obtained are seen\nstats:\nwaitframe()\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n\nend:\n; Subtract 1 from the number of instances, as we've just removed an instance\n{hider.set(i2s(s2i(sub({hider.get}, 0, 1), 0) - 1) . sub({hider.get}, 1, 99))}"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; impulse key macros for easy customization\n#start x\n#mode q\n#cycling w\n;\n#difficulty d\n;\n; qol impulses\n#restart r\n#exit e\n#stats t\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.debug = tru;\\\n  --[[Set to true for debugging, set to anything else besides TowerTest for not debugging]]\\\n  TowerTest.impulse = {};\\\n  \\\n  --[[/*\\\n    * Go through all impulse keys and\\\n    * prevent compilation if there's duplicate keys\\\n  */]]\\\n  local impulse = {};\\\n  local keys = table.pack(\\\n    \"{start}\", \"{mode}\", \"{cycling}\", \"{difficulty}\",\\\n    \"{restart}\", \"{exit}\", \"{stats}\"\\\n  );\\\n  for i = 1, #keys do\\\n    if impulse[keys[i]] ~= nil then\\\n      error(\"every key impulse must mean a different key\", 0);\\\n    end\\\n    impulse[keys[i]] = true;\\\n  end\\\n)}\n\n; variable macros for improved visibility in the source code\n; a display var hides the script identifier to make it less likely\n; that the var gets changed by another script\n;\n{lua(\\\n  local security_prefix = \"<size=0>C^t@t</size>\";\\\n  \\\n  --[[/*\\\n    * Used to add an impulse to the display_var\\\n    * value in `impulse` has no whitespace and is never empty\\\n    * Throws an error if the same impulse controls multiple vars\\\n    * \\\n    * Returns the impulse as an uppercase string encased in\\\n    * parenthesies ()\\\n    * add_impulse(a) returns `(A)`\\\n  */]]\\\n  local function add_impulse(impulse)\\\n    if TowerTest.impulse[impulse] == true then\\\n      local err_msg = table.pack(\\\n        \"Variables cannot be controlled by the same impulse\\n\",\\\n        \"Impulse '\", impulse, \"' has been used before!\"\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    TowerTest.impulse[impulse] = true;\\\n    return string.format(\"(%s)\", string.upper(impulse));\\\n  end\\\n  \\\n  --[[/*\\\n    * Used to create the name of a global variable\\\n    * meant to be visible in the global variables overlay.\\\n    * \\\n    * security_toggle is a bool that determinse if\\\n    * this variable gets the security prefix or not.\\\n    * \\\n    * var_name is the string that represents this variable\\\n    * \\\n    * impulse is the triggered impulse for this variable\\\n    * if it doesn't have one, nothing will be added\\\n  */]]\\\n  function TowerTest.display_var(var_name, security_toggle, impulse)\\\n    local var = {};\\\n    var[1] = security_toggle and security_prefix or \"\";\\\n    var[2] = var_name;\\\n    local impulse_val = impulse:gsub(\" \", \"\");\\\n    if impulse_val ~= \"\" then\\\n      var[3] = add_impulse(impulse_val);\\\n    end\\\n    return string.format([[\"%s\"]], table.concat(var));\\\n  end\\\n)}\n\n#display_var(name, secured, impulse) {lua(\\\n  return TowerTest.display_var([[{name}]], {secured}, [[{impulse}]]);\\\n)}\n\n; Returns empty or blank or case false\n#if_debugging(case_false) {lua(\\\n  return TowerTest.debug and \"\" or [[{case_false}]];\\\n)}\n\n; block hider\n; used to control when the global variables are shown or hidden \n#hider concat(\"{if_debugging(<size=0>)}C^t@t\", \"Variable hider\")\n#hider.get global.string.get({hider})\n#hider.set(value) global.string.set({hider}, {value})\n;\n:const string diff {display_var(Diff, true,)}\n#diff.get global.string.get(diff)\n#diff.set(diff) global.string.set(diff, {diff})\n\n; the state of the script\n:const string status_var {display_var(Active, true, {start})}\n#status.get global.bool.get(status_var)\n#status.set(value) global.bool.set(status_var, {value})\n\n; if region cycling is enabled or not\n:const string cycle_var {display_var(Region Cycling, true, {cycling})}\n#region_cycling.get global.bool.get(cycle_var)\n#region_cycling.set(value) global.bool.set(cycle_var, {value})\n\n; which mode is selected\n:const string mode_var {display_var(Curent Mode, true, {mode})}\n#curent_mode.get global.string.get(mode_var)\n#curent_mode.set(mode) global.string.set(mode_var, {mode})\n\n; mode values, so it's easy to edit\n:const string mode1 \"Difficulty>Region\"\n:const string mode2 \"Region>Difficulty\"\n\n; Which direction do I select difficulties in?\n:const string diff_mode \"<size=0>C^t@tD$m\"\n#diff_mode.get global.string.get(diff_mode)\n#diff_mode.set(mode) global.string.set(diff_mode, {mode})\n\n; Variable used to tell the user what the AI is doing\n:const string job_status \"<size=0>C^t@tJ$S\"\n#job.get global.string.get(job_status)\n#job.set(job) global.string.set(job_status, {job})\n; job_status starts a hiding block, which is ended by the first </size>\n; and then, it ends the hiding block started by {hider} with the final\n; </size>\n\n; lua macro used to process coordinates and output a difficulty list\n{lua(\\\n  --[[y coordinate of all 6 difficulties]]\\\n  local difficulties = table.pack(\\\n    \"290.0\", \"256.0\", \"217.0\",\\\n    \"182.0\", \"145.0\", \"112.0\"\\\n  );\\\n  \\\n  function TowerTest.diff_list(switch)\\\n    if switch == nil or type(switch) ~= \"boolean\" then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nSwitch in macro diff_list must be true or false\",\\\n        \"\\nValue recieved was \", switch or \"nil\"\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local diff = {};\\\n    --[[true = keep order, false = reverse order]]\\\n    if switch then\\\n      diff = difficulties;\\\n    else\\\n      for i = #difficulties, 1, -1 do\\\n        diff[#diff + 1] = difficulties[i];\\\n      end\\\n    end\\\n    local acc = {};\\\n    local pos = 0;\\\n    for i = 1, #diff do\\\n      local offset = i * 2;\\\n      if i == #diff then\\\n        pos = 0;\\\n      else\\\n        pos = pos + 2 + #diff[i]\\\n      end\\\n      --[[/*\\\n        * Encode our coordinates\\\n        * We have a length-2 position and the difficulty coord\\\n        * the position = where in the list we are\\\n        * coord = what y value do we want\\\n      */]]\\\n      acc[offset - 1] = string.format(\"%02d\", pos);\\\n      acc[offset] = diff[i];\\\n    end\\\n    acc[#acc + 1] = \"</size>Diff Order(\" .. string.upper(\"{difficulty}\") .. \")=\"\\\n    if switch then\\\n      acc[#acc + 1] = \"Easy -> Impossible\";\\\n    else\\\n      acc[#acc + 1] = \"Impossible -> Easy\";\\\n    end\\\n    return table.concat(acc);\\\n  end\\\n)}\n\n#diff_list(switch) \"{lua(return TowerTest.diff_list({switch}))}\""],["Codrineye's TowerTesting_src","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; impulse key macros for easy customization\n#start x\n#mode q\n#cycling w\n;\n#difficulty d\n;\n; qol impulses\n#exit e\n#stats t\n#restart r\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.impulse = {};\\\n  \\\n  --[[/*\\\n    * Go through all impulse keys and\\\n    * prevent compilation if there's duplicate keys\\\n  */]]\\\n  local impulse = {};\\\n  local names = table.pack(\\\n    \"start\", \"mode\", \"cycling\", \"difficulty\",\\\n    \"restart\", \"exit\", \"stats\"\\\n  );\\\n  local keys = table.pack(\\\n    \"{start}\", \"{mode}\", \"{cycling}\", \"{difficulty}\",\\\n    \"{restart}\", \"{exit}\", \"{stats}\"\\\n  );\\\n  for i = 1, #names do\\\n    if impulse[keys[i]] ~= nil then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nEvery key impulse must mean a different key!\",\\\n        \"\\nkey.\", keys[i], \" was first assigned to \", impulse[keys[i]],\\\n        \" but is now getting assigned to \" .. names[i]\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    impulse[keys[i]] = names[i];\\\n  end\\\n)}\n\n\n\n; mode values, so it's easy to edit\n:const string mode1 \"Difficulty>Region\"\n:const string mode2 \"Region>Difficulty\"\n\n\n; lua macro used to process coordinates and output a difficulty list\n{lua(\\\n  --[[y coordinate of all 6 difficulties]]\\\n  local difficulties = table.pack(\\\n    \"290.0\", \"256.0\", \"217.0\",\\\n    \"182.0\", \"145.0\", \"112.0\"\\\n  );\\\n  \\\n  function TowerTest.diff_list(switch)\\\n    if switch == nil or type(switch) ~= \"boolean\" then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nSwitch in macro diff_list must be true or false\",\\\n        \"\\nValue recieved was \", switch or \"nil\"\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local diff = {};\\\n    --[[true = keep order, false = reverse order]]\\\n    if switch then\\\n      diff = difficulties;\\\n    else\\\n      for i = #difficulties, 1, -1 do\\\n        diff[#diff + 1] = difficulties[i];\\\n      end\\\n    end\\\n    local acc = {};\\\n    local pos = 0;\\\n    for i = 1, #diff do\\\n      local offset = i * 2;\\\n      if i == #diff then\\\n        pos = 0;\\\n      else\\\n        pos = pos + 2 + #diff[i]\\\n      end\\\n      --[[/*\\\n        * Encode our coordinates\\\n        * We have a length-2 position and the difficulty coord\\\n        * the position = where in the list we are\\\n        * coord = what y value do we want\\\n      */]]\\\n      acc[offset - 1] = string.format(\"%02d\", pos);\\\n      acc[offset] = diff[i];\\\n    end\\\n    acc[#acc + 1] = \"</size>Diff Order(\" .. string.upper(\"{difficulty}\") .. \")=\"\\\n    if switch then\\\n      acc[#acc + 1] = \"Easy -> Impossible\";\\\n    else\\\n      acc[#acc + 1] = \"Impossible -> Easy\";\\\n    end\\\n    return table.concat(acc);\\\n  end\\\n)}\n\n#diff_list(switch) \"{lua(return TowerTest.diff_list({switch}))}\""],["Codrineye's TowerTesting_hdr","; Header file for Codrineye's TowerTesting\n; Implements an ID system to determine variable names\n;\n{lua(\\\n  TowerTest = {}; --[[root global table everything is part of]]\\\n  TowerTest.cache = {}; --[[code cache so that we don't have to re-define every variable]]\\\n  function TowerTest.define(id, append)\\\n  end\\\n)}\n; All variable names are defined internally. ID system is just used to retrieve the cached value\n; The define_variable function will get re-defined in the source code\n;\n#status {lua(TowerTest.define(\"status\"))}\n#cycling {lua(TowerTest.define(\"cycling\"))}\n#mode {lua(TowerTest.define(\"mode\"))}\n#diff_mode {lua(TowerTest.define(\"diff_mode\"))}\n;\n; This makes use of the append parameter\n; Since there's 1 sole variable that holds the UI, I need to use contains() to determine\n; what needs to be updated. This `append` lets me add a value ontop of the variable\n#appened(parent, child) {lua(return TowerTest.define(\"{parent}\", \"{child}\"))}\n;\n; For instance, {status} is a toggle"],["Codrineye's TowerTesting test",":name Codrineye's TowerTesting test\n:import Codrineye's TowerTesting_src\n"],["Codrineye's TowerTesting",":name Codrineye's TowerTesting\n:budget_cap 600\n\n:local double seconds\n:local double minutes\n:local double hours\n:global string difficulty_list\n:local int instance\n:local double end_time\n:local double game_time\n:local bool additional_cond\n\nkey.x()\nkey.w()\nkey.q()\nkey.d()\nkey.e()\nkey.t()\nkey.r()\nclose.headquarters()\ngame.newround()\n\ncontains(\"key.x|key.q|key.w|key.d|close.headquarters\", impulse()) || isTowerTesting()\n(impulse() != \"key.e\") || (gsg(\"<size=0>C^t@tJ$S\") != \"</size><color=#0AFF00>Exit caused by pressing key.e\")\nisTowerTesting() || not(((((((((((isBossFight() || isopen(\"tradingpost\")) || isopen(\"powerplant\")) || isopen(\"factory\")) || isopen(\"laboratory\")) || isopen(\"shipyard\")) || isopen(\"workshop\")) || isopen(\"arcade\")) || isopen(\"museum\")) || isopen(\"constructionfirm\")) || isopen(\"statueofcubos\")) || isopen(\"mine\"))\ncontains(\"click here for line info!<size=0>\" . \"</size><br>additional_cond adds an additional condition that could be met to exit tower testing<br><br>seconds, minutes and hours reprezent how much time you want to pass in real world seconds before exiting tower testing<br>Leave all at 0 if you don't want this<size=0>\", \"\")\ncontains(\"click here for line numbers!<size=0>\" . ((\"</size><br><br>additional_cond is found on line \" . i2s(20)) . \"<size=0>\"), \"\")\n\nseconds = 0.0\nminutes = 0.0 * 60.0\nhours = 0.0 * 3600.0\ndifficulty_list = if(((gsg(\"<size=0>C^t@tD$m\") != \"\") && (impulse() != \"key.d\")) && (isopen(\"headquarters\") || (gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\"))), gsg(\"<size=0>C^t@tD$m\"), if(gsg(\"<size=0>C^t@tD$m\") == \"Region>Difficulty\", \"Difficulty>Region\", \"Region>Difficulty\"))\ninstance = s2i(sub(gsg(\"C^t@t\" . \"Variable hider\"), 0, 1), 0) + 1\ngss(\"C^t@t\" . \"Variable hider\", i2s(instance) . if(impulse() == \"game.newround\", \"0.0\", sub(gsg(\"C^t@t\" . \"Variable hider\"), 1, 99)))\ngss(\"<size=0>C^t@t</size>Diff\", if(((gsg(\"<size=0>C^t@t</size>Diff\") != \"\") && (gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\"))) && not(contains(\"key.d|game.newround\", impulse())), sub(gsg(\"<size=0>C^t@t</size>Diff\"), 0, 8), sub(\"ABCDEFGHIJKLMN\", a.i(index(\"ABCDEFGHIJKLMN\", sub(gsg(\"<size=0>C^t@t</size>Diff\"), 0, 1), 0) + 1, if(gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\"), \"mod\", \"\"), if(gsg(\"<size=0>C^t@t</size>Curent Mode(Q)\") == \"Difficulty>Region\", 6, 15)), 1) . if(((gsg(\"<size=0>C^t@t</size>Diff\") == \"\") || (gsg(\"<size=0>C^t@t</size>Curent Mode(Q)\") == \"Difficulty>Region\")) || contains(gsg(\"<size=0>C^t@t</size>Diff\"), \"N\"), sub(difficulty_list, if(gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\"), s2i(sub(gsg(\"<size=0>C^t@t</size>Diff\"), 1, 2), 0), 0), 7), sub(gsg(\"<size=0>C^t@t</size>Diff\"), 1, 7))) . if((isopen(\"headquarters\") || isopen(\"towertesting\")) || (gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\")), \"</size>\", \"\"))\ngbs(\"<size=0>C^t@t</size>Active(X)\", gbg(\"<size=0>C^t@t</size>Active(X)\") != (impulse() == \"key.x\"))\ngbs(\"<size=0>C^t@t</size>Region Cycling(W)\", gbg(\"<size=0>C^t@t</size>Region Cycling(W)\") != ((gbg(\"<size=0>C^t@t</size>Active(X)\") || isopen(\"headquarters\")) && (impulse() == \"key.w\")))\ngss(\"<size=0>C^t@t</size>Curent Mode(Q)\", if((gsg(\"<size=0>C^t@t</size>Curent Mode(Q)\") == \"Region>Difficulty\") && (gbg(\"<size=0>C^t@t</size>Active(X)\") || isopen(\"headquarters\")), if(impulse() == \"key.q\", \"Difficulty>Region\", \"Region>Difficulty\"), if(impulse() == \"key.q\", \"Region>Difficulty\", \"Difficulty>Region\")))\ngss(\"<size=0>C^t@tD$m\", difficulty_list)\ngss(\"<size=0>C^t@tJ$S\", if(gbg(\"<size=0>C^t@t</size>Active(X)\"), if(impulse() != \"key.e\", gsg(\"<size=0>C^t@tJ$S\"), \"</size><color=#0AFF00>Exit caused by pressing key.e\"), \"</size></size>\"))\ngoto(if((gbg(\"<size=0>C^t@t</size>Active(X)\") && (impulse() == \"key.x\")) && (instance == 1), if(isTowerTesting(), 15, 26), if(contains(\"key.e|key.t|key.r\", impulse()) && isTowerTesting(), if(impulse() == \"key.e\", 23, if(impulse() == \"key.t\", 39, 37)), 41)))\nwaitwhile(isopen(\"towertesting\"))\nend_time = now() + (10000000.0 * ((seconds + minutes) + hours))\ngss(\"<size=0>C^t@tJ$S\", if(gbg(\"<size=0>C^t@t</size>Active(X)\"), \"</size><color=#0AFF00>Waiting to exit Tower Testing</color>\", \"</size></size>\"))\nwaitframe()\ngame_time = s2d(sub(gsg(\"C^t@t\" . \"Variable hider\"), 1, 99), 0.0) + time.delta()\ngss(\"C^t@t\" . \"Variable hider\", sub(gsg(\"C^t@t\" . \"Variable hider\"), 0, 2) . d2s(game_time))\nadditional_cond = false\ngotoif(17, ((gbg(\"<size=0>C^t@t</size>Active(X)\") && (health(false) > 0.0)) && not(additional_cond)) && ((((seconds + minutes) + hours) == 0.0) || (now() <= end_time)))\ngss(\"<size=0>C^t@tJ$S\", if(contains(gsg(\"<size=0>C^t@tJ$S\"), \"Exit caused by\") || not(gbg(\"<size=0>C^t@t</size>Active(X)\")), gsg(\"<size=0>C^t@tJ$S\"), (\"</size><color=#0AFF00>Exit caused by \" . if(additional_cond, \"additional_cond\", if(isTowerTesting(), \"tower death\", \"an external cause\"))) . \"</color>\"))\nwait(time.unscaled() * 1.5)\nexit()\ngoto(if(isTowerTesting(), 23, if(gbg(\"<size=0>C^t@t</size>Active(X)\") && (impulse() == \"key.x\"), 26, 41)))\ngss(\"<size=0>C^t@tJ$S\", if(gbg(\"<size=0>C^t@t</size>Active(X)\"), (\"</size><color=#FAA00F>User must \" . if(isopen(\"headquarters\"), \"exit the headquarters\", \"close the window opened in town\")) . \"</color>\", gsg(\"<size=0>C^t@tJ$S\")))\nwaitwhile((not(isopen(\"towertesting\")) && anyopen()) && gbg(\"<size=0>C^t@t</size>Active(X)\"))\nshow(\"towertesting\", true)\ngoto(if(gbg(\"<size=0>C^t@t</size>Active(X)\"), if((gbg(\"<size=0>C^t@t</size>Region Cycling(W)\") && (((gsg(\"<size=0>C^t@t</size>Curent Mode(Q)\") == \"Difficulty>Region\") && contains(gsg(\"<size=0>C^t@t</size>Diff\"), \"A\")) || ((gsg(\"<size=0>C^t@t</size>Curent Mode(Q)\") == \"Region>Difficulty\") && not(contains(gsg(\"<size=0>C^t@t</size>Diff\"), \"A\"))))) && (end_time > 0.0), 30, 32), 41))\nwaitframe()\nclick(vec((min(width.d(), 1.7777777777778 * height.d()) * ui.size()) * 0.3625, ((min(height.d(), 0.5625 * width.d()) * ui.size()) * -0.55333333333333) + height.d()))\nclick(vec((min(width.d(), 1.7777777777778 * height.d()) * ui.size()) * 0.49375, ((min(height.d(), 0.5625 * width.d()) * ui.size()) * ((s2d(sub(gsg(\"<size=0>C^t@t</size>Diff\"), 3, 5), 290.0) / 450.0) - 1.0)) + height.d()))\nclick(vec((min(width.d(), 1.7777777777778 * height.d()) * ui.size()) * 0.2025, ((min(height.d(), 0.5625 * width.d()) * ui.size()) * -0.78444444444444) + height.d()))\ngotoif(if(gbg(\"<size=0>C^t@t</size>Active(X)\"), 15, 41), isTowerTesting() || not(gbg(\"<size=0>C^t@t</size>Active(X)\")))\nwaitframe()\ngoto(32)\nrestart()\ngoto(41)\nwaitframe()\nclick(vec(((min(width.d(), 1.7777777777778 * height.d()) * ui.size()) * -0.175) + (width.d() * 0.5), ((min(height.d(), 0.5625 * width.d()) * ui.size()) * 0.11111111111111) + (height.d() * 0.5)))\ngss(\"C^t@t\" . \"Variable hider\", i2s(s2i(sub(gsg(\"C^t@t\" . \"Variable hider\"), 0, 1), 0) - 1) . sub(gsg(\"C^t@t\" . \"Variable hider\"), 1, 99))"]]}}
```

# Changelog

### version 2.2.3

Fixed a bug where the difficulty held in `diff` would get eaten away. (I was treating the string as if it was indexed by 1 not by 0).<br>
Fixed still being able to edit some variables outside of their context.<br>
Fixed a leaking color block in job status.

### version 2.2.3

Full system has been rebuilt.<br>

Added new impulse `key.difficulty(D)` that lets people switch the difficulty list direction.<br>
New UI variable `mode_switch` that holds the direction string followed by `Diff Order(D)=`, look at the bottom of [library](./Codrineye's%20TowerTesting_lib.tpt2).

Hider has been repurposed to now hold the number of instances and the timer for `game_time`.<br>
`time.real` has been renamed to `end_time` and is always active. This adds the local variables `seconds`, `minutes` and `hours` which are used to define how long a run should last in real time. If the sum of these times is 0.0, end_time is ignored.

New hidden variable `diff` holds a counter and the y coordinate for the target difficulty. This gets reset to default when the script is shut off.<br>
Changed the script identifier to be a lot shorter.

The script now only has 1 instance of itself running, the instances counter ensures that only 1 script is in the loop.<br>
Additionally, it makes use of script conditions to prevent activation outside of its context (expanded uppon later) and to make sure only 1 instances made by `key.exit` is running to prevent lag.<br>
Improved the comment that outlines what line to modify by using lua macros and `<size=0></size>` blocks.

Added context-based activation.<br>
The script can only be interacted with when inside of a game of towertesting, the towertesting menu, in town or in headquarters.<br>
If the user is in HeadQuarters and interacts with the script, the UI will be shown. If they exit the HQ while the script is shut down, it will hide the UI.

### version 2.1.1

- Fixed the scripts overlay getting hidden when game.newround() activated even if the script is running

### version 2.1.0

- Fixed a trailing hiding block that was caused by pressing key.{restart} key.{stats} or key.{exit} before starting up the script.
- Improved the second condition by using contains() instead of string comparison.
- Removed unnecesary macros defined early on.

### version 2.0.9

- Added job macros `job.get`, `job.set` and `job_message` to work with the job_status variable
- `job_status` now tells you 4 different reasons that tower testing exited:
- 1. key.{exit} was pressed results in "Exit caused by pressing key.{exit}"
- 2. additional_cond is true results in "Exit caused by additional_cond"
- 3. we're still in towertesting means "Exit caused by tower death"
- 4. we aren't in towertesting means "Exit caused by an external source"

### version 2.0.8

- Changed all `contains.key` style checks with a simple `impulse() == "key."` check
- Made `display_var` macro more competent
- Script is now more resistant to key smashing. It's now a lot harder to create multiple copies of itself.

### version 2.0.7

- Normal mode is no longer supported out of the box. It must be added as an additional_cond by the user.
- Current_mode is no longer in charge of ending the block hider.
- Added new global variable `job_status` that is now in charge of ending the block hider.

### version 2.0.6

- `time.game` and `time.real` are now global values.
- `time.real` now also gets reset by `game.newround()`
- macro `{hider}` is agan the variable that starts the block hider 
- added variable `stop_hider` that's in charge of stopping the block hider

### version 2.0.5

- Added `time.game` so users can end the round after 10 ingame seconds.
- Added `time.real` so users can end the round after 10 real time seconds.
- Added support for use in normal mode. It can now exit once you have killed all enemies and it doesn't get confused when resetting the run.
- Refactored comments in the main script, too many unneeded comments.
- Refactored a coupple goto(if())'s to gotoif's.
- Changed the hider to no longer start the hiding blocker, that's the role of the global timer now.

### version 2.0.1

- Updated internal macro display_var to be a lua macro that adds both the identifier and the triggered impulse to the var, instead of there needing to be 2 macros.
- Variable names are now :const strings instead of macros.
- Global variables in lua now start with a capitalized letter. All global lua variables are now in the table `TowerTest`.
- Decided that this package should include a version history too.
