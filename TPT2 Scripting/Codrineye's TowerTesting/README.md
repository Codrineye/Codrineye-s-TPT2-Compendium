# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)

Source code of Codrineye's TowerTesting<br>
You can import it if you want to customise the impulses, change your additional_cond or switch the difficulty cycling direction.<br>
The impulse definition is found close to the top of [Codrineye's TowerTesting_lib](Codrineye's%20TowerTesting_lib.tpt2), if you're changing the impulse for "stats" make sure it's the same as the keybind that opens the stats menu ingame.

The source also has comments explaining what you're looking at.

```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap max\n\n; store the y coordinate for the difficulty button\n:local double difficulty\n\n; keep a timer so that the user can make additional_cond exit\n; after a certain ammount of time has passed\n:global double time.real\n:global double time.game\n\n; const string that define in which direction the script can\n; cycle through difficulties\n; Positive number = Easy to Impossible\n; Negative number = Impossible to Easy\n:const string forwards_diff_list {diff_list(1)}\n:const string reversed_diff_list {diff_list(-1)}\n\n; QOL macro to determine the direction via the source\n#difficulty_list forwards_diff_list\n\n:local int difficulty_index\n:local int counting\n:local bool can_switch\n:local bool additional_cond\n; \n; QOL macro that lets you add the additional cond from the source\n#additional_cond false\n\ngame.newround()\nkey.{state_switch}()\nkey.{mode_switch}()\nkey.{cycling}()\nkey.{restart}()\nkey.{exit}()\nkey.{stats}()\n\n; conditions for user convenience\n; \n; you get to chose the direction the difficulties are cycled in\n; start with easy and move on to impossible, or\n; start with impossible and move on to easy\nconcat(\"Easy -> Impossible\", forwards_diff_list) != \\\nconcat(\"Impossible -> Easy\", reversed_diff_list)\n\n; helper macros containing the components of our second condition\n; telling the user at what line they input the difficulty direction string\n; or at which line they input their additional cond\n\n#instruct.change_direction \"To change the difficulty direction you must\"\n#goto_line.change_direction \"go to line \" . difficulty_list_pos\n\n#instruct.additional_cond \"To use additional_cond you must\"\n#goto_line.additional_cond \"go to line \" . additional_cond_pos\n\nconcat({instruct.change_direction}, {goto_line.change_direction}) != \\\nconcat({instruct.additional_cond}, {goto_line.additional_cond})\n\n#contains.key(impulse) contains(impulse(), \"key.{impulse}\")\n#contains.mode(mode) contains({curent_mode.get}, {mode})\n\n#impulse.qol \"key.{restart}key.{exit}key.{stats}game.newround\"\n#impulse.toggles \"key.{mode_switch}key.{cycling}\"\n#impulse.state \"key.{state_switch}\" . {impulse.toggles}\n\n; Start of code\n\n; I could use this for a jump table if I wanted to\n; local.int.set(\"restart_lable\", restart)\n; local.int.set(\"exit_lable\", exit)\n; local.int.set(\"stats_lable\", stats)\n\ngotoif(\\\n  if({state.get}, movement_manager, 99), \\\n  contains(\"{script_name}\", impulse())\\\n)\n\n; caller macros that determine what the hide blocker should do\n; \n; .toggles always stop the hide block, no matter the scripts state\n; .state stops the hider if we're starting up else frees the hider\n; .qol doesn't interfere with the blockers state\n\n#caller.toggles contains({impulse.toggles}, impulse())\n#caller.state not({state.get}) && {contains.key({state_switch})}\n#caller.qol {state.get} && contains({impulse.qol}, impulse())\n\ninit:\nglobal.string.set({hider}, \"Start hiding values\")\n; makes sure the timers are kept hidden\n\ntime.real = if(contains(impulse(), \"key.\"), time.real, 0.0)\ntime.game = if(contains(impulse(), \"key.\"), time.game, 0.0)\nglobal.string.set(stop_hiding, if(\\\n  {caller.state} || ({caller.toggles}) || ({caller.qol}), \\\n  concat(\"Stop Hiding\", \"</size>\"), \\\n  \"Cods TowerTesting is Hiding\"\\\n))\n\ngotoif(\\\n  if(\\\n    isTowerTesting() && {contains.key()}, \\\n    if(\\\n      {contains.key({restart})}, \\\n      restart, \\\n      if({contains.key({exit})}, exit, stats)\\\n    ),\\\n    99\\\n  ), \\\n  contains({impulse.qol}, impulse())\\\n)\n\nupdate_state:\n{state.set({state.get} != {contains.key({state_switch})})}\n{region_cycling.set({region_cycling.get} != {contains.key({cycling})})}\n{curent_mode.set(if(\\\n  {contains.key({mode_switch})},\\\n  if({contains.mode(mode2)}, mode1, mode2),\\\n  if({contains.mode(mode2)}, mode2, mode1)\\\n))}\n; Set the job status to itself so interracting\n; with the script doesn't hide the job.\nglobal.string.set(job_status, global.string.get(job_status))\n\n; exit the script if we're called\n; for cycling, mode or if we're shut down\ngotoif(99, contains({impulse.toggles}, impulse()) || not({state.get}))\n\n; make a copy of yourself for movement_manager\nexecute(\"{script_name}\")\n\n#job_err <color=#FAA00F>\n#job_inf <color=#0AFF00>\nglobal.string.set(job_status, if(\\\n  {opened_building},\\\n  \"</size>{job_err}\" . \\\n  \"Waiting for the user to close the building</color></size>\",\\\n  \"</size>{job_err}Waiting for user to close the menu</color></size>\"\\\n))\n; Sets the\n\nloop:\nwaitwhile(isTowerTesting() && {state.get})\nwaituntil(isTowerTesting() || not({state.get}))\n\nglobal.string.set(\\\n  job_status, \\\n  \"</size>{job_inf}Waiting to exit tower testing</color></size>\"\\\n)\nin_towertesting:\nwaitframe() ; wait a frame\n\n; Update our timers\ntime.game += time.delta()\ntime.real += time.unscaled()\n\nadditional_cond_pos:\nadditional_cond = {additional_cond}\n\n; exit if the script is active, our conditional cond isn't met\n; our tower is alive and if we haven't killed all enemies\n; (if used in normal mode instead of endless)\ngotoif(\\\n  in_towertesting, \\\n  health(false) > 0.0 && {state.get} && not(additional_cond)\\\n)\n\nglobal.string.set(job_status, if(\\\n  additional_cond,\\\n  \"</size>{job_inf}Exit caused by additional_cond</color></size>\",\\\n  \"</size>{job_inf}Exit caused by tower death</color></size>\"\\\n))\n\nexit:\nexit()\nwait(0.26)\n\ngoto(if(isTowerTesting(), exit, if(\\\n  {contains.key({exit})} || not({state.get}), \\\n  99, \\\n  loop\\\n)))\n\n; mode1 means we cycle through our difficulties\n; and change region only after 6 counts\n; {contains.mode(mode1)} && counting < 6\n:const int base.mode1 6\n#switch.mode1 {contains.mode(mode1)} && counting == 0\n\n; mode2 means we always advance through the region\n; and change difficulty only after 15 repetitions\n; {contains.mode(mode2)} && counting < 14\n:const int base.mode2 15\n#switch.mode2 {contains.mode(mode2)} && counting < 14\n\nchange_region:\nwaitframe()\n\n; click on the arrow to change region\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\nchange_difficulty:\ncan_switch = true\n\ndifficulty_list_pos:\n; determine the difficulty we should switch to\ndifficulty = s2d(\\\n  sub({difficulty_list}, difficulty_index * coord_size, coord_size), \\\n  290.0\\\n)\n\n; increment the difficulty index if we should switch difficulty\n; this is always done if we're mode1, and if we're mode2 only when\n; we're on the last region before we refresh\ndifficulty_index = if(\\\n  {switch.mode2}, \\\n  difficulty_index, \\\n  (difficulty_index + 1) % difficulty_count\\\n)\n\nlaunch_round:\n; click on the difficulty\n{click.relative(395.0/800.0, difficulty/450.0, 0.0, 1.0)}\n\n; launch a round of towertesting\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\n; try to launch the round if we're not in towertesting and\n; not shut down. If we're shut down, terminate the program.\ngotoif(\\\n  if({state.get}, launch_round, 99), \\\n  not({state.get} && isTowerTesting())\\\n)\n\n; increment counting based on our mode\ncounting = if(\\\n  {contains.mode(mode1)}, \\\n  (counting + 1) % base.mode1, \\\n  (counting + 1) % base.mode2\\\n)\n\nmovement_manager:\nwaitwhile({state.get} && (isTowerTesting() || anyopen()))\nshow(\"towertesting\", true)\n\ngotoif(\\\n  if(\\\n    can_switch && {region_cycling.get} &&\\\n    ({contains.mode(mode2)} || {switch.mode1}),\\\n    change_region,\\\n    change_difficulty\\\n  ),\\\n  {state.get}\\\n)\n; exit script if we're shut down\n; Change region if we can do so, otherwise, change difficulty\n\n; The user requested a restart\nrestart:\nrestart()\n\n; The user requested the stats be shown\n; This clicks in the general area of the button where\n; resource/sec, xp/sec and frags obtained are seen\nstats:\nwaitframe()\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; Script identifier value\n\n; impulse key macros for easy customization\n#state_switch x\n#mode_switch q\n#cycling w\n#restart r\n#exit e\n#stats t\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.impulse = {};\\\n  TowerTest.diff = {};\\\n  TowerTest.max_digits = 0;\\\n  \\\n  --[[/*\\\n      * Go through all impulse keys and prevent compilation \\\n      * If there's duplicate keys\\\n     */]]\\\n  local imp = {};\\\n  local keys = \"{state_switch}|{mode_switch}|{cycling}|{restart}|{exit}|{stats}\";\\\n  for key in keys:gmatch(\"[^|]+\") do\\\n    if imp[key] then error(\"Key impulses cannot have duplicate keys\", 0) end\\\n    imp[key] = 1;\\\n  end\\\n)}\n\n; variable macros for improved visibility in the source code\n; a display var hides the identifier to prevent screen clutter\n; \n#display_var(name, impulse) {lua(\\\n  local impulse = string.gsub([[{impulse}]], \" \", \"\");\\\n  --[[Isolate the impulse key and check if it's already been used]]\\\n  if TowerTest.impulse[impulse] then\\\n    error(\"2 variables cannot be controlled by the same impulse\" .. impulse, 0);\\\n  end\\\n  TowerTest.impulse[impulse] = impulse ~= \"\";\\\n  --[[If we get an empty impulse, don't add it to the \"used impulses\"]]\\\n  \\\n  local var = table.pack(\\\n    \"<size=0>\", [[{script_name}]], \"</size>\",\\\n    \"{name}\"\\\n  );\\\n  if impulse ~= \"\" then var[5] = string.format(\"(%s)\", impulse:upper()); end\\\n  return string.format([[\"%s\"]], table.concat(var));\\\n)}\n\n; block hider\n; used to control when the global variables are shown or hidden \n#hider concat(\"<size=0>\", \"Variable hider\") . \"{script_name}\"\n:const string stop_hiding {display_var(Stop hiding variables,)}\n\n; the state of the script\n:const string state_var {display_var(state, {state_switch})}\n#state.get global.bool.get(state_var)\n#state.set(value) global.bool.set(state_var, {value})\n\n; if region cycling is enabled or not\n:const string cycle_var {display_var(Region Cycling, {cycling})}\n#region_cycling.get global.bool.get(cycle_var)\n#region_cycling.set(value) global.bool.set(cycle_var, {value})\n\n; which mode is selected\n:const string mode_var {display_var(Curent Mode, {mode_switch})}\n#curent_mode.get global.string.get(mode_var)\n#curent_mode.set(mode) global.string.set(mode_var, {mode})\n\n; mode values, so it's easy to edit\n:const string mode1 \"Difficulty>Region\"\n:const string mode2 \"Region>Difficulty\"\n\n; Variable used to tell the user what the AI is doing\n:const string job_status {display_var(<size=0>Job Status,)}\n\n; Detects if there's a building open\n#opened_building {lua(\\\n  local acc = {};\\\n  local isOpen = [[isopen(\"%s\")]];\\\n  local buildings = \"towertesting|tradingpost|powerplant|factory|laboratory|shipyard|workshop|arcade|museum|headquarters|constructionfirm|statueofcubos|mine|\";\\\n  for building in buildings:gmatch(\"[^|]+\") do\\\n    acc[1 + #acc] = isOpen:format(building);\\\n  end\\\n  return table.concat(acc, \" || \");\\\n)}\n\n; simple lua macro for recording coordinates\n#set_difficulty(coord_y) {lua(\\\n  TowerTest.diff[1 + #TowerTest.diff] = {coord_y};\\\n  if TowerTest.max_digits < #[[{coord_y}]] then\\\n    TowerTest.max_digits = #[[{coord_y}]];\\\n  end\\\n)}\n\n{set_difficulty(290.0)}\n{set_difficulty(256.0)}\n{set_difficulty(217.0)}\n{set_difficulty(182.0)}\n{set_difficulty(145.0)}\n{set_difficulty(112.0)}\n\n; const variables to make the difficulty logic easier to follow\n:const int coord_size {lua(return TowerTest.max_digits)}\n:const int difficulty_count {lua(return #TowerTest.diff)}\n\n; Simple lua macro that outputs the difficulty list based on\n; the inputed number. Negative number = reversed list and\n; Positive number = normal list\n#diff_list(mode) {lua(\\\n  local reversed = {mode} < 0;\\\n  local diff = TowerTest.diff;\\\n  local fmt = string.format(\"%%0%ds\", TowerTest.max_digits);\\\n  local diff_list = {};\\\n  for i = 1, #diff do\\\n    diff_list[i] = reversed and diff[#diff + 1 - i] or diff[i];\\\n    diff_list[i] = fmt:format(diff_list[i]);\\\n  end\\\n  return string.format([[\"%s\"]], table.concat(diff_list));\\\n)}\n\n; \n; guide for size for when I make changes to the script\n; this is simply a marker that represents the size of my laptop screen\n; I keep lines under this limit so it's easy to edit when on laptop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n"]]}}
```

# Changelog

### version 2.0.7

- Normal mode is no longer supported out of the box. It must be added as an additional_cond by the user.
- Current_mode is no longer in charge of ending the block hider.
- Added new global variable `job_status` that is now in charge of ending the block hider.

### version 2.0.6

- `time.game` and `time.real` are now global values.
- `time.real` now also gets reset by `game.newround()`
- macro `{hider}` is agan the variable that starts the block hider 
- added variable `stop_hider` that's in charge of stopping the block hider

### version 2.0.5

- Added `time.game` so users can end the round after 10 ingame seconds.
- Added `time.real` so users can end the round after 10 real time seconds.
- Added support for use in normal mode. It can now exit once you have killed all enemies and it doesn't get confused when resetting the run.
- Refactored comments in the main script, too many unneeded comments.
- Refactored a coupple goto(if())'s to gotoif's.
- Changed the hider to no longer start the hiding blocker, that's the role of the global timer now.

### version 2.0.1

- Updated internal macro display_var to be a lua macro that adds both the identifier and the triggered impulse to the var, instead of there needing to be 2 macros.
- Variable names are now :const strings instead of macros.
- Global variables in lua now start with a capitalized letter. All global lua variables are now in the table `TowerTest`.
- Decided that this package should include a version history too.
