# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)

Source code of Codrineye's TowerTesting<br>
You can import it if you want to customise the impulses, change your additional_cond or switch the difficulty cycling direction.<br>
The impulse definition is found close to the top of [Codrineye's TowerTesting_lib](Codrineye's%20TowerTesting_lib.tpt2), if you're changing the impulse for "stats" make sure it's the same as the keybind that opens the stats menu ingame.

The source also has comments explaining what you're looking at.

```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap max\n\n; store the coord_y value\n:local double difficulty\n\n; const string that define in which direction the script can\n; cycle through difficulties\n; Positive number = Easy to Impossible\n; Negative number = Impossible to Easy\n\n:const string forwards_diff_list {diff_list(1)}\n:const string reversed_diff_list {diff_list(-1)}\n\n; QOL macro to determine the direction\n#difficulty_list forwards_diff_list\n\n; detect at which difficulty we're at\n:local int difficulty_index\n\n; keep count until we complete a cycle\n:local int counting\n\n; signal to know if we can switch our difficulty or not\n:local bool can_switch\n\n; variable that lets you add aditional conditions\n:local bool additional_cond\n; \n; QOL macro that lets you add the additional cond from the source\n#additional_cond false\n\nkey.{state_switch}()\nkey.{mode_switch}()\nkey.{cycling}()\nkey.{restart}()\nkey.{exit}()\nkey.{stats}()\n\n; conditions for user convenience\n; \n; you get to chose the direction the difficulties are cycled in\n; start with easy and move on to impossible, or\n; start with impossible and move on to easy\n\nconcat(\"Easy -> Impossible\", forwards_diff_list) != \\\nconcat(\"Impossible -> Easy\", reversed_diff_list)\n\n; helper macros containing the components of our second condition\n; telling the user at what line they input the difficulty direction string\n; or at which line they input their additional cond\n\n#instruct.change_direction \"To change the difficulty direction you must\"\n#goto_line.change_direction \"go to line \" . difficulty_list_pos\n\n#instruct.additional_cond \"To use additional_cond you must\"\n#goto_line.additional_cond \"go to line \" . additional_cond_pos\n\nconcat({instruct.change_direction}, {goto_line.change_direction}) != \\\nconcat({instruct.additional_cond}, {goto_line.additional_cond})\n\n; helper macros to shorten contains operations\n; \n; .key makes it easier to see what I'm checking for\n; .mode(mode) makes it easier to see what mode I'm looking for\n\n#contains.key(impulse) contains(impulse(), \"key.{impulse}\")\n#contains.mode(mode) contains({curent_mode.get}, {mode})\n\n; impulse macros to shorten contains() checks\n; \n; .qol is the string representing all qol impulses\n; .toggle is the string representing all toggle impulses\n; .state is the string that represents all update_state impulses\n\n#impulse.qol \"key.{restart}key.{exit}key.{stats}\"\n#impulse.toggles \"key.{mode_switch}key.{cycling}\"\n#impulse.state \"key.{state_switch}\" . {impulse.toggles}\n\n; Start of code\n\n; I could use this for a jump table if I wanted to\n; local.int.set(\"restart_lable\", restart)\n; local.int.set(\"exit_lable\", exit)\n; local.int.set(\"stats_lable\", stats)\n\ngotoif(\\\n  if({state.get}, movement_manager, 99), \\\n  contains(impulse(), \"{script_name}\")\\\n)\n\n; caller macros that determine what the hide blocker should do\n; \n; .toggles always stop the hide block, no matter the scripts state\n; .state stops the hider if we're waking up else frees the hider\n; .qol doesn't interfere with the blockers state\n\n#caller.toggles contains({impulse.toggles}, impulse())\n#caller.state not({state.get}) && {contains.key({state_switch})}\n#caller.qol {state.get} && contains({impulse.qol}, impulse())\n\nglobal.string.set({hider}, if(\\\n  {caller.state} || ({caller.toggles}) || ({caller.qol}), \\\n  concat(\"Stop Hiding\", \"</size>\"), \\\n  \"Cods TowerTesting is Hiding\"\\\n))\n\ngotoif(if(\\\n  isTowerTesting(), \\\n  if(\\\n    {contains.key({restart})}, \\\n    restart, \\\n    if({contains.key({exit})}, exit, stats)\\\n  ),\\\n  99\\\n), contains({impulse.qol}, impulse()))\n\nupdate_state:\n; state is toggled only if you want it to change\n{state.set({state.get} != {contains.key({state_switch})})}\n\n; region_cycling is toggled only if you want it to change\n{region_cycling.set({region_cycling.get} != {contains.key({cycling})})}\n\n; curent_mode cycles through its values only if you want it to change\n{curent_mode.set(if(\\\n  {contains.key({mode_switch})},\\\n  if({contains.mode(mode2)}, mode1, mode2),\\\n  if({contains.mode(mode2)}, mode2, mode1)\\\n))}\n\n; exit the script if we're called\n; for cycling, mode or if we're shut down\ngotoif(99, contains({impulse.toggles}, impulse()) || not({state.get}))\n\n; make a copy of yourself for movement_manager\nexecute(\"{script_name}\")\n\nloop:\n; a gate that ensures we only enter the in_towertesting loop\n; when in towertesting\n; \n; we wait as long as towertesting is active\nwaitwhile(isTowerTesting() && {state.get})\n\n; we wait as long as towertesting is inactive\nwaituntil(isTowerTesting() || not({state.get}))\n\n; loop performed while we're in towertesting\n; to determine when to exit\nin_towertesting:\n\n; waitframe() is here to prevent the script from\n; crashing Facility AI, as this loop only consists\n; of atomic actions\nwaitframe()\n\n; additional_cond must always be false until it's met\n; if you want to exit when you reach x amount of eras\n; `era() >= x` => This is good\n; `era() < x`  => This is bad\n\nadditional_cond_pos:\nadditional_cond = {additional_cond}\n\n; stay in the loop as long as the tower is alive, the script is alive\n; and the users additional_cond is not met, otherwise, we exit\ngotoif(\\\n  in_towertesting, \\\n  health(false) > 0.0 && {state.get} && not(additional_cond)\\\n)\n\n; exit towertesting\nexit:\nexit()\n\n; wait for the exit transition animation\nwait(0.222)\n\n; attempt to exit while we're still in towertesting\n; once out of towertesting we terminate the script if\n; we're told by the user to exit or the AI is shut down\n; otherwise, we return to loop\n\ngoto(if(isTowerTesting(), exit, if(\\\n  {contains.key({exit})} || not({state.get}), \\\n  99, \\\n  loop\\\n)))\n\n; mode1 means we cycle through our difficulties\n; and change region only after 6 counts\n; {contains.mode(mode1)} && counting < 6\n:const int base.mode1 6\n#switch.mode1 {contains.mode(mode1)} && counting == 0\n\n; mode2 means we always advance through the region\n; and change difficulty only after 15 repetitions\n; {contains.mode(mode2)} && counting < 14\n:const int base.mode2 15\n#switch.mode2 {contains.mode(mode2)} && counting < 14\n\nchange_region:\n\n; wait for the game to enter the towertesting window\nwaitframe()\n\n; click on the arrow to change region\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\n\nchange_difficulty:\n\n; signal to the script that we're able to switch regions\ncan_switch = true\n\ndifficulty_list_pos:\n; determine the difficulty we should switch to\ndifficulty = s2d(\\\n  sub({difficulty_list}, difficulty_index * coord_size, coord_size), \\\n  290.0\\\n)\n\n; increment the difficulty index if we should switch difficulty\n; this is always done if we're mode1, and if we're mode2 only when\n; we're on the last region before we refresh\ndifficulty_index = if(\\\n  {switch.mode2}, \\\n  difficulty_index, \\\n  (difficulty_index + 1) % difficulty_count\\\n)\n\nlaunch_round:\n; click on the difficulty\n{click.relative(395.0/800.0, difficulty/450.0, 0.0, 1.0)}\n\n; launch a round of towertesting\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\n; quit if the script is shut down, otherwise try to launch\n; a round of towertesting otherwise proceed since we are\n; in a round of TowerTesting\ngoto(if(\\\n  {state.get}, \\\n  if(isTowerTesting(), in_towerTesting, launch_round),\\\n  99\\\n))\n\nin_towerTesting:\n; increment counting based on our mode\ncounting = if(\\\n  {contains.mode(mode1)}, \\\n  (counting + 1) % base.mode1, \\\n  (counting + 1) % base.mode2\\\n)\n\nmovement_manager:\n\n; waitwhile we can't open towertesting and our script is active\n; wait for our transition_delay to expire\n\nwaitwhile({state.get} && (isTowerTesting() || anyopen()))\n\n; open towertesting\nshow(\"towertesting\", true)\n\n; exit script if we're shut down\n; enter region if region_cycling is on and we're in mode 2 or\n; counting == 0 and we can change region\n; otherwise, try to change difficulty\ngoto(if(\\\n  {state.get}, \\\n  if(\\\n    ({contains.mode(mode2)} || {switch.mode1}) && \\\n    {region_cycling.get} && can_switch, \\\n    change_region, \\\n    change_difficulty\\\n  ), \\\n  99\\\n))\n\n; The user requested a restart\nrestart:\nrestart()\n\n; The user requested the stats be shown\n; This clicks in the general area of the button where\n; resource/sec, xp/sec and frags obtained are seen\n\nstats:\nwaitframe()\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; Script identifier value\n#identifier \"{script_name}\"\n\n; impulse key macros for easy customization\n; there's a const declaration at the bottom of the script\n; to prevent the same impulse from being assigned\n; \n#state_switch x\n#mode_switch q\n#cycling w\n#restart r\n#exit e\n#stats t\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.impulse = {};\\\n  TowerTest.diff = {};\\\n  TowerTest.max_digits = 0;\\\n)}\n\n; variable macros for improved visibility in the source code\n; a display var hides the identifier to prevent screen clutter\n; \n#display_var(name, impulse) {lua(\\\n  local impulse = string.gsub([[{impulse}]], \" \", \"\");\\\n  --[[Isolate the impulse key and check if it's already been used]]\\\n  if TowerTest.impulse[impulse] then\\\n    error(\"2 variables cannot be controlled by the same impulse\");\\\n  end\\\n  TowerTest.impulse[impulse] = true;\\\n  \\\n  local var = table.pack(\\\n    \"<size=0>\", [[{script_name}]], \"</size>\",\\\n    \"{name}\", string.format(\"(%s)\", string.upper(impulse))\\\n  );\\\n  return string.format([[\"%s\"]], table.concat(var));\\\n)}\n\n; block hider\n; it prevents the variables from being hidden\n; but hides them when it should\n#hider concat(\"<size=0>\", \"Variable Hider\") . {identifier}\n\n; the state of the script\n:const string state_var {display_var(state, {state_switch})}\n#state.get global.bool.get(state_var)\n#state.set(value) global.bool.set(state_var, {value})\n\n; if region cycling is enabled or not\n:const string cycle_var {display_var(Region Cycling, {cycling})}\n#region_cycling.get global.bool.get(cycle_var)\n#region_cycling.set(value) global.bool.set(cycle_var, {value})\n\n; which mode is selected\n; curent_mode is the last global variable that gets initialised\n; thus, setting a value to it will ensure the hiding block is stopped\n:const string mode_var {display_var(Curent Mode, {mode_switch})}\n#curent_mode.get global.string.get(mode_var)\n#curent_mode.set(mode) global.string.set(mode_var, {mode})\n\n; mode values, so it's easy to edit\n:const string mode1 \"Difficulty>Region</size>\"\n:const string mode2 \"Region>Difficulty</size>\"\n\n; simple lua macro for recording coordinates\n\n#set_difficulty(coord_y) {lua(\\\n  TowerTest.diff[1 + #TowerTest.diff] = [[{coord_y}]];\\\n  TowerTest.max_digits = math.max(\\\n    TowerTest.max_digits,\\\n    #[[{coord_y}]]\\\n  )\\\n)}\n\n{set_difficulty(290.0)}\n{set_difficulty(256.0)}\n{set_difficulty(217.0)}\n{set_difficulty(182.0)}\n{set_difficulty(145.0)}\n{set_difficulty(112.0)}\n\n; const variables to make the difficulty logic easier to follow\n:const int coord_size {lua(return TowerTest.max_digits)}\n:const int difficulty_count {lua(return #TowerTest.diff)}\n\n; Simple lua macro that outputs the difficulty list based on\n; the inputed number. Negative number = reversed list and\n; Positive number = normal list\n\n#diff_list(mode) {lua(\\\n  local reversed = {mode} < 0;\\\n  local diff = TowerTest.diff;\\\n  local diff_list = {};\\\n  for i = 1, #diff do\\\n    diff_list[i] = reversed and diff[#diff + 1 - i] or diff[i];\\\n  end\\\n  return string.format([[\"%s\"]], table.concat(diff_list));\\\n)}\n\n; safety const declarations to prevent\n; the same impulse key from repeating\n:const double {state_switch} 1.0\n\n:const double {mode_switch} 1.0\n:const double {cycling} 1.0\n:const double {exit} 1.0\n:const double {stats} 1.0\n:const double {restart} 1.0\n\n; \n; guide for size for when I make changes to the script\n; this is simply a marker that represents the size of my laptop screen\n; I keep lines under this limit so it's easy to edit when on laptop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \n"]]}}
```

# Changelog

### version 2.0.1

- Updated internal macro display_var to be a lua macro that adds both the identifier and the triggered impulse to the var, instead of there needing to be 2 macros.
- Variable names are now :const strings instead of macros.
- Global variables in lua now start with a capitalized letter. All global lua variables are now in the table `TowerTest`.
- Decided that this package should include a version history too.
