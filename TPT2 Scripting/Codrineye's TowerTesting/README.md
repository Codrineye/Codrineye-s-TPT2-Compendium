# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)

Source code of Codrineye's TowerTesting<br>
You can import it if you want to customise the impulses<br>
The impulse definition is found close to the top of [Codrineye's TowerTesting_lib](Codrineye's%20TowerTesting_lib.tpt2)

The source also has comments explaining what you're looking at.

```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap max\n\n; transition delay is the amount of time\n; it takes for the screen transition animation\n; to happen. It's not hard coded since it can\n; change due to the users machine\n:local double transition_delay\n\n; store the coord_y value\n:local double difficulty\n\n; detect at which difficulty we're at\n:local int difficulty_index\n\n; keep count until we complete a cycle\n:local int counting\n\n; signal to know if we can switch our difficulty or not\n:local bool can_switch\n\n; variable that lets you add aditional conditions\n:local bool additional_cond\n\nkey.{state_switch}()\nkey.{mode_switch}()\nkey.{cycling}()\nkey.{restart}()\nkey.{exit}()\nkey.{stats}()\n\n; condition that's for user convenience\n; \n; you get to chose the direction the difficulties are cycled in\n; start with easy and move on to impossible, or\n; start with impossible and move on to easy\n\nconcat(\"Easy -> Impossible\", {difficulty_list}) != \\\nconcat(\"Impossible -> Easy\", {inversed_difficulty_list})\n\n; helper macros to shorten contains operation\n; \n; .key makes it easier to see what I'm checking for\n; .mode1 is easier to understand the mode I'm looking for\n; .mode2 is the same reason as for mode1\n\n#contains.key(impulse) contains(impulse(), \"key.{impulse}\")\n#contains.mode1 contains({curent_mode.get}, {mode1})\n#contains.mode2 contains({curent_mode.get}, {mode2})\n\n; impulse macros to shorten contains() checks\n; \n; .qol is the string representing all qol impulses\n; .toggle is the string representing all toggle impulses\n; .state is the string that represents all update_state impulses\n\n#impulse.qol \"key.{restart}key.{exit}key.{stats}\"\n#impulse.toggles \"key.{mode_switch}key.{cycling}\"\n#impulse.state \"key.{state_switch}\" . {impulse.toggles}\n\n; Start of code\n\ntransition_delay = 0.5\n\ngotoif(\\\n  if({state.get}, movement_manager, 99), \\\n  contains(impulse(), \"{script_name}\")\\\n)\n\n; caller macros that determine what the hide blocker should do\n; \n; .toggles always stop the hide block, no matter the scripts state\n; .state stops the hider if we're waking up else frees the hider\n; .qol doesn't interfere with the blockers state\n\n#caller.toggles contains({impulse.toggles}, impulse())\n#caller.state not({state.get}) && {contains.key({state_switch})}\n#caller.qol {state.get} && contains({impulse.qol}, impulse())\n\nglobal.string.set({hider}, if(\\\n  {caller.state} || {caller.toggles} || {caller.qol}, \\\n  concat(\"Stop Hiding\", \"</size>\"), \\\n  \"Cods TowerTesting is Hiding\"\\\n))\n\ngoto(if(\\\n  contains({impulse.state}, impulse()), \\\n  update_state, \\\n  if(\\\n    not(isTowerTesting()), \\\n    99, \\\n    if(\\\n      {contains.key({restart})}, \\\n      restart, \\\n      if({contains.key({exit})}, exit, stats)\\\n    )\\\n  )\\\n))\n\nupdate_state:\n; state is toggled only if you want it to change\n{state.set({state.get} != {contains.key({state_switch})})}\n\n; region_cycling is toggled only if you want it to change\n{region_cycling.set({region_cycling.get} != {contains.key({cycling})})}\n\n; curent_mode cycles through its values only if you want it to change\nglobal.string.set({curent_mode}, if({contains.key({mode_switch})}, \\\n  if({contains.mode2}, {mode1}, {mode2}), \\\n  if({contains.mode2}, {mode2}, {mode1})\\\n))\n\n; exit the script if we're called\n; for cycling, mode or if we're shut down\ngotoif(99, contains({impulse.toggles}, impulse()) || not({state.get}))\n\n; make a copy of yourself for movement_manager\nexecute(\"{script_name}\")\n\nloop:\n; a gate that ensures we only enter the in_towertesting loop\n; when in towertesting\n; \n; we wait as long as towertesting is active\nwaitwhile(isTowerTesting() && {state.get})\n\n; we wait as long as towertesting is inactive\nwaituntil(isTowerTesting() || not({state.get}))\n\n; loop performed while we're in towertesting\n; to determine when to exit\nin_towertesting:\n\n; waitframe() is here because we're using atomic functions\nwaitframe()\n\n; additional_cond must always be false until it's met\n; if you want to exit when you reach x amount of eras\n; `era() >= x` => This is good\n;  `era() < x` => This is bad\n\nadditional_cond = false\n\n; stay in the loop as long as the tower is alive, the script is alive\n; and the users additional_cond is not met, otherwise, we exit\ngoto(if(\\\n  health(false) > 0.0 && {state.get} && not(additional_cond), \\\n  in_towertesting, \\\n  exit\\\n))\n\n; exit towertesting\nexit:\nexit()\n\n; wait for the exit transition animation\nwait(transition_delay)\n\n; attempt to exit while we're still in towertesting\n; once out of towertesting we terminate the script if\n; we're told by the user to exit or the AI is shut down\n; otherwise, we return to loop\ngoto(if(\\\n  isTowerTesting(), \\\n  exit, \\\n  if(\\\n    {contains.key({exit})} || not({state.get}), \\\n    99, \\\n    loop\\\n  )\\\n))\n\n; mode1 means we cycle through our difficulties\n; and change region only after 6 counts\n; {contains.mode1} && counting < 6\n:const int base.mode1 6\n#switch.mode1 {contains.mode1} && counting == 0\n\n; mode2 means we always advance through the region\n; and change difficulty only after 15 repetitions\n; {contains.mode2} && counting < 14\n:const int base.mode2 15\n#switch.mode2 {contains.mode2} && counting < 14\n\nchange_region:\n\n; click on the arrow to change region\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\n; wait for the game to change regions\nwait(transition_delay)\n\nchange_difficulty:\n\n; signal to the script that we're able to switch regions\ncan_switch = true\n\n; determine the difficulty we should switch to\ndifficulty = s2d(\\\n  sub({difficulty_list}, difficulty_index * coord_size, coord_size), \\\n  290.0\\\n)\n\n; increment the difficulty index if we should switch difficulty\n; this is always done if we're mode1, and if we're mode2 only when\n; we're on the last region before we refresh\ndifficulty_index = if(\\\n  {switch.mode2}, \\\n  difficulty_index, \\\n  (difficulty_index + 1) % difficulty_count\\\n)\n\n; click on the difficulty\n{click.relative(395.0/800.0, difficulty/450.0, 0.0, 1.0)}\n\n; wait for our click to register\nwait(transition_delay)\n\n; launch a round of towertesting\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\n; wait for the game to place us in towertesting\n; or if the script is shut down\nwaituntil(not({state.get}) || isTowerTesting())\n\n; increment counting based on our mode\ncounting = if(\\\n  {contains.mode1}, \\\n  (counting + 1) % base.mode1, \\\n  (counting + 1) % base.mode2\\\n)\n\nmovement_manager:\n\n; waitwhile we can't open towertesting and our script is active\n; wait for our transition_delay to expire\n\nwaitwhile({state.get} && (isTowerTesting() || anyopen()))\nwait(transition_delay)\n\n; open towertesting\nshow(\"towertesting\", true)\n\n; wait for the game to put us in the towertesting window\nwait(transition_delay)\n\n; exit script if we're shut down\n; enter region if region_cycling is on and we're in mode 2 or\n; counting == 0 and we can change region\n; otherwise, try to change difficulty\ngoto(if(\\\n  not({state.get}), \\\n  99, \\\n  if(\\\n    ({contains.mode2} || {switch.mode1}) && \\\n    {region_cycling.get} && can_switch, \\\n    change_region, \\\n    change_difficulty\\\n  )\\\n))\n\n; The user requested a restart\nrestart:\nrestart()\n\n; The user requested the stats be shown\n; This clicks in the general area of the button where\n; resource/sec, xp/sec and frags obtained are seen\n\nstats:\nwait(transition_delay)\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; Script identifier value\n#identifier \"Condineye's TowerTesting\"\n\n; impulse key macros for easy customization\n; there's a const declaration at the bottom of the script\n; to prevent the same impulse from being assigned\n; \n#state_switch x\n; \n#mode_switch q\n#cycling w\n; \n#restart r\n#exit e\n#stats t\n\n; variable macros for improved visibility in the source code\n; a display var hides the identifier to prevent screen clutter\n; \n; a var impulse can be added to a display var if\n; it's modified by an impulse, this uses the lua function\n; instead of the ingame function so that the value is pre-computed\n#display_var(name) \"<size=0>\" . {identifier} . \"</size>\" . \"{name}\"\n#var_impulse(impulse) ({lua(return string.upper([[{impulse}]]))})\n\n; block hider\n; it prevents the variables from being hidden\n; but hides them when it should\n#hider concat(\"<size=0>\", \"Variable Hider\") . {identifier}\n\n; the state of the script\n#state {display_var(status)} . \"{var_impulse({state_switch})}\"\n#state.get global.bool.get({state})\n#state.set(value) global.bool.set({state}, {value})\n\n; if region cycling is enabled or not\n#region_cycling {display_var(Region Cycling)} . \"{var_impulse({cycling})}\"\n#region_cycling.get global.bool.get({region_cycling})\n#region_cycling.set(value) global.bool.set({region_cycling}, {value})\n\n; which mode is selected\n; curent_mode is the last global variable that gets initialised\n; thus, setting a value to it will ensure the hiding block is stopped\n#curent_mode {display_var(Curent Mode)} . \"{var_impulse({mode_switch})}\"\n#curent_mode.get global.string.get({curent_mode})\n\n; mode values, so it's easy to edit\n#mode1 \"Difficulty>Region\" . \"</size>\"\n#mode2 \"Region>Difficulty\" . \"</size>\"\n\n; simple lua macro for recording coordinates\n\n{lua(\\\n  difficulty = {};\\\n  max_difficulty_digits = 0;\\\n)}\n#set_difficulty(coord_y) {lua(\\\n  difficulty[1 + #difficulty] = [[{coord_y}]];\\\n  max_difficulty_digits = math.max(\\\n    max_difficulty_digits, \\\n    #[[{coord_y}]]\\\n  );\\\n)}\n\n{set_difficulty(290.0)}\n{set_difficulty(256.0)}\n{set_difficulty(217.0)}\n{set_difficulty(182.0)}\n{set_difficulty(145.0)}\n{set_difficulty(112.0)}\n\n\n; const variables to make the difficulty logic easier to follow\n:const int coord_size {lua(return max_difficulty_digits)}\n:const int difficulty_count {lua(return #difficulty)}\n\n#difficulty_list {lua(\\\n  local diff_list = {};\\\n  diff_list[1 + #diff_list] = [[\"]];\\\n  for i = 1, #difficulty do\\\n    diff_list[1 + #diff_list] = difficulty[i];\\\n  end\\\n  diff_list[1 + #diff_list] = [[\"]];\\\n  return table.concat(diff_list);\\\n)}\n#inversed_difficulty_list {lua(\\\n  local diff_list = {};\\\n  diff_list[1 + #diff_list] = [[\"]];\\\n  for i = #difficulty, 1, -1 do\\\n    diff_list[1 + #diff_list] = difficulty[i];\\\n  end\\\n  diff_list[1 + #diff_list] = [[\"]];\\\n  return table.concat(diff_list)\\\n)}\n\n; safety const declarations to prevent\n; the same impulse key from repeating\n:const double {state_switch} 1.0\n:const double {mode_switch} 1.0\n:const double {cycling} 1.0\n:const double {exit} 1.0\n:const double {stats} 1.0\n:const double {restart} 1.0\n\n\n; \n; guide for size for when I make changes to the script\n; this is simply a marker that represents the size of my laptop screen\n; I keep lines under this line so it's easy to edit when on laptop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; "]]}}
```

