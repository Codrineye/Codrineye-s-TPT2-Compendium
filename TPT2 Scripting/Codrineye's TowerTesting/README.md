# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)


```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap max\n\n; transition delay is the amount of time\n; it takes for the screen transition animation\n; to happen. It's not hard coded since it can\n; change due to the users machine\n:local double transition_delay\n\n; store the coord_y value\n:local double difficulty\n\n; detect at which difficulty we're at\n:local int difficulty_index\n\n; keep count until we complete a cycle\n:local int counting\n\n; signal to know if we can switch our difficulty or not\n:local bool switch_difficulty\n\n; variable that lets you add aditional conditions\n:local bool additional_cond\n\nkey.{state_switch}()\nkey.{mode_switch}()\nkey.{cycling}()\nkey.{stats}()\nkey.{exit}()\nkey.{restart}()\n\n; condition that's for user convenience\n; \n; you get to chose the direction the difficulties are cycled in\n; start with easy and move on to impossible, or\n; start with impossible and move on to easy\n\nconcat(\"Easy -> Impossible\", {difficulty_list}) != \\\nconcat(\"Impossible -> Easy\", {inversed_difficulty_list})\n\n; helper macros to shorten contains operation\n; \n; c.key makes it easier to see what I'm checking for\n; c.mode1 is easier to understand the mode I'm looking for\n; c.mode2 is the same reason as for mode1\n\n#contains.key(impulse) contains(impulse(), \"key.{impulse}\")\n#contains.mode1 contains({curent_mode.get}, {mode1})\n#contains.mode2 contains({curent_mode.get}, {mode2})\n\n; Start of code\n\ntransition_delay = 0.5\n\ngotoif(\\\n  if({state.get}, movement_manager, 99), \\\n  contains(impulse(), \"{script_name}\")\\\n)\n\nglobal.string.set({hider}, if(\\\n  {state.get} == contains(\\\n    \"key.{state_switch}key.{cycling}key.{mode_switch}\", \\\n    impulse()\\\n  ), \\\n  \"Cods TowerTesting is Hiding\", \\\n  concat(\"Stop Hiding\", \"</size>\")\\\n))\n\ngoto(if(\\\n  contains(\\\n    \"key.{mode_switch}|key.{cycling}|key.{state_switch}\", \\\n    impulse()\\\n  ), \\\n  update.state, \\\n  if(\\\n    {contains.key({restart})}, \\\n    restart, \\\n    if({contains.key({exit})}, exit, stats)\\\n  )\\\n))\n\nupdate.state:\n\n; state is toggled only if you want it to change\nglobal.bool.set({state}, {state.get} != {contains.key({state_switch})})\n\n; region_cycling is toggled only if you want it to change\nglobal.bool.set(\\\n  {region_cycling}, \\\n  {region_cycling.get} != {contains.key({cycling})}\\\n)\n\n; curent_mode cycles through its values only if you want it to change\nglobal.string.set({curent_mode}, if(\\\n  {contains.mode2}, \\\n  if({contains.key({mode_switch})}, {mode1}, {mode2}), \\\n  {mode1}\\\n))\n\n; exit the script if we're called for cycling or mode\n; or if we're shut down\ngotoif(\\\n  99, \\\n  contains(\\\n    \"key.{cycling}|key.{mode_switch}\", \\\n    impulse()\\\n  ) || not({state.get})\\\n)\n\n; make a copy of yourself for movement_manager\nexecute(\"{script_name}\")\n\nloop.init:\n\n; a gate that makes sure we only proceed when out of towertesting\nwaitwhile(isTowerTesting() && {state.get})\nwaituntil(isTowerTesting() || not({state.get}))\n\n; waitframe() is here to make the loop have\n; a reasonable amount of repetitions and not crash the game\nloop.additional_cond:\nwaitframe()\n\n; additional cond must always be false until it's met\n; if you want to exit when you reach x amount of eras\n; you'd do `era() >= x`,\n; !! not !! `era() < x`\n\nadditional_cond = false\ngotoif(\\\n  loop.additional_cond, \\\n  health(false) > 0.0 && {state.get} &&\\\n  not(additional_cond)\\\n)\n\nexit:\nexit()\n\n; wait for the transition because the exit function\n; happens instantly due to our budget\n; loop exits while we're in towertesting\n; exit script if we're called by the user or if our state is false\nwait(transition_delay)\ngoto(if(\\\n  contains(impulse(), \"key.{exit}\") || not({state.get}), \\\n  99, \\\n  if(isTowerTesting(), exit, loop.init)\\\n))\n\n; movement manager manages our movement\nmovement_manager:\n\n; mode1 means we cycle through our difficulties\n; and change region only after 6 \n; {contains.mode1} && counting < 6\n\n; mode2 means we always advance through the region\n; and change difficulty only after 15 repetitions\n; {contains.mode2} && counting == 15\n; \n; we're looking at mode2 and\n; if we've gone through all regions\n\nswitch_difficulty = {contains.mode2} && counting < 15\ncounting = 0\n\nenter_region:\n\n; waitwhile we can't open towertesting and\n; for our transition_delay to expire to open towertesting\n\nwaitwhile({state.get} && (isTowerTesting() || anyopen()))\nwait(transition_delay)\n\nshow(\"towertesting\", true)\n\n; skip changing region if we shouldn't\ngotoif(\\\n  diff_change, \\\n  {contains.mode1} && counting < 6 ||\\\n  not({region_cycling.get})\\\n)\n\nwait(transition_delay)\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\ndiff_change:\ndifficulty = s2d(\\\n  sub({difficulty_list}, difficulty_index * coord_size, coord_size), \\\n  290.0\\\n)\n\ndifficulty_index = if(\\\n  switch_difficulty, \\\n  (difficulty_index + 1) % difficulty_count, \\\n  difficulty_index\\\n)\n\nwait(transition_delay)\n{click.relative(395.0/800.0, difficulty/450.0, 0.0, 1.0)}\n\n; launch towertesting\nwait(transition_delay)\n{click.relative(162.0/800.0, 97.0/450.0, 0.0, 1.0)}\n\ncounting = counting + 1\nswitch_difficulty = {contains.mode1}\n\nwaituntil(isTowerTesting() || anyopen())\n\n; remember that `&&` operations happen before `||`\n; goto logic is reversed from the enter_region gotoif\n\ngoto(if(\\\n  {state.get}, \\\n  if(\\\n    {contains.mode2} && counting < 14 ||\\\n    {contains.mode1} && counting == 6, \\\n    enter_region, \\\n    movement_manager\\\n  ), \\\n  99\\\n))\n\n; restart now clicks close to the middle of the screen\n; should not cause any issues, hopefully\nrestart:\nrestart()\n\nstats:\nwait(transition_delay)\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; Script identifier value\n#identifier \"Condineye's TowerTesting\"\n\n; impulse key macros for easy customization\n; there's a const declaration at the bottom of the script\n; to prevent the same impulse from being assigned\n; \n#state_switch x\n; \n#mode_switch q\n#cycling w\n; \n#stats t\n#exit e\n#restart r\n\n; variable macros for improved visibility\n; a display var hides the identifier to prevent screen clutter\n; \n; a var impulse can be added to a display var if\n; it's modified by an impulse, this uses the lua function\n; instead of the ingame function so that the value is pre-computed\n#display_var(name) \"<size=0>\" . {identifier} . \"</size>\" . \"{name}\"\n#var_impulse(impulse) ({lua(return string.upper([[{impulse}]]))})\n\n; \n; block hider manager\n; it prevents the variables from being hidden\n; but hides them when it should\n#hider concat(\"<size=0>\", \"Variable Hider\") . {identifier}\n\n; the state of the script\n#state {display_var(stat)} . \"{var_impulse({state_switch})}\"\n#state.get global.bool.get({state})\n\n; if region cycling is enabled or not\n#region_cycling {display_var(Region Cycling)} . \"{var_impulse({cycling})}\"\n#region_cycling.get global.bool.get({region_cycling})\n\n; which mode is selected\n; curent_mode is the last global variable that gets initialised\n; thus, setting a value to it will ensure the hiding block is stopped\n#curent_mode {display_var(Curent Mode)} . \"{var_impulse({mode_switch})}\"\n#curent_mode.get global.string.get({curent_mode})\n\n; mode values, so it's easy to edit\n#mode1 \"Difficulty>Region\" . \"</size>\"\n#mode2 \"Region>Difficulty\" . \"</size>\"\n\n; simple lua macro for recording coordinates\n; it's made in lua so it's easy to get const values\n\n{lua(\\\n  difficulty = {};\\\n  max_difficulty_digits = 0;\\\n)}\n#set_difficulty(coord_y) {lua(\\\n  difficulty[1 + #difficulty] = [[{coord_y}]];\\\n  max_difficulty_digits = math.max(\\\n    max_difficulty_digits, \\\n    #[[{coord_y}]]\\\n  );\\\n  return [[:const string difficulty]] .. #difficulty .. [[ '{coord_y}']];\\\n)}\n\n{set_difficulty(290.0)}\n{set_difficulty(256.0)}\n{set_difficulty(217.0)}\n{set_difficulty(182.0)}\n{set_difficulty(145.0)}\n{set_difficulty(112.0)}\n\n\n; const variables to make the difficulty logic easier to follow\n:const int coord_size {lua(return max_difficulty_digits)}\n:const int difficulty_count {lua(return #difficulty)}\n\n; the two lists used for the comment in `Stats Exit Diff_Change`\n#difficulty_list {lua(\\\n  local diff_list = {};\\\n  for i = 1, #difficulty do\\\n    diff_list[1 + #diff_list] = [[difficulty]] .. i;\\\n    diff_list[1 + #diff_list] = [[ . ]];\\\n  end\\\n  diff_list[#diff_list] = '';\\\n  return table.concat(diff_list);\\\n)}\n#inversed_difficulty_list {lua(\\\n  local diff_list = {};\\\n  for i = #difficulty, 1, -1 do\\\n    diff_list[1 + #diff_list] = [[difficulty]] .. i;\\\n    diff_list[1 + #diff_list] = [[ . ]];\\\n  end\\\n  diff_list[#diff_list] = '';\\\n  return table.concat(diff_list)\\\n)}\n\n\n:const int {state_switch} 1\n:const int {mode_switch} 1\n:const int {cycling} 1\n:const int {exit} 1\n:const int {stats} 1\n:const int {restart} 1\n\n"]]}}
```

