# Codrineye's TowerTesting

My first public project which got me to create this entire repo

It returns, but this time, it's with better logic<br>
There are 2 archives in this repo, [Cods TowerTesting](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cods%20TowerTesting/README.md) and [Cod TT](/TPT2%20Scripting/Codrineye's%20TowerTesting/Cod%20TT/README.md)

Source code of Codrineye's TowerTesting<br>
You can import it if you want to customise the impulses, change your additional_cond or switch the difficulty cycling direction.<br>
The impulse definition is found close to the top of [Codrineye's TowerTesting_lib](Codrineye's%20TowerTesting_lib.tpt2), if you're changing the impulse for "stats" make sure it's the same as the keybind that opens the stats menu ingame.

The source also has comments explaining what you're looking at.

```
{"workspaces":{"Codrineye's TowerTesting":[["Codrineye's TowerTesting",":import Codrineye's TowerTesting_lib\n:name {script_name}\n:budget_cap 600\n\n; Variable definitions\n;\n; Const string to define the direction in which difficulties are cycles through\n; false = Easy to Impossible\n; true = Impossible to Easy\n:const string order1 {diff_list(true)}\n:const string order2 {diff_list(false)}\n\n; Helper variable for region cycling\n:local bool started\n:local bool additional_cond\n; add an additional condition that can lead to exiting\n;\n; Timer variables\n:local double end_time\n:local double seconds\n:local double minutes\n:local double hours\n;\n:local int instance\n;\n:local string difficulty_list\n;\n; Macros for configuration in source\n#additional_cond false\n\nkey.{start}()\nkey.{cycling}()\nkey.{mode}()\nkey.{difficulty}()\n;\nkey.{exit}()\nkey.{stats}()\nkey.{restart}()\n\nclose.headquarters()\nclose.towertesting()\n; Attempt to hide the UI when leaving HQ or towertesting menu\n\n; Detect when a new round increments to update the progress character inside of the `diff` monolith\ngame.newround()\n;\n; Detects if any of the invalid buildings are open\n#opened_building {lua(\\\n  local acc = {};\\\n  local isOpen = [[isopen(\"%s\")]];\\\n  local buildings = table.pack(\\\n    \"tradingpost\", \"powerplant\",\\\n    \"factory\", \"laboratory\", \"shipyard\",\\\n    \"workshop\", \"arcade\", \"museum\",\\\n    \"constructionfirm\", \"statueofcubos\", \"mine\"\\\n  );\\\n  for i = 1, #buildings do\\\n    acc[1 + #acc] = isOpen:format(buildings[i]);\\\n  end\\\n  return table.concat(acc, \" || \");\\\n)}\n\n; If the impulse is exit, stats or restart, it must be done in towertesting\ncontains(\\\n  \"key.{start}|key.{mode}|key.{cycling}|key.{difficulty}|close.headquarters|close.towertesting\",\\\n  impulse()\\\n) || isTowerTesting()\n;\n; Prevent multiple exit() instances being created\n; Only 1 should be made\nimpulse() != \"key.{exit}\" ||\\\n{job.get} != \"</size><color=#0AFF00>Exit caused by pressing key.{exit}</color>\"\n\n;\n; We can only interact with the script if we're in a game of TowerTesting\n; inside of the HQ, in TowerTesting or in of town. Unfortunately, there's no way to ensure\n; we're activated outside of the game Perfect Space.\nisTowerTesting() || not(isBossFight() || {opened_building})\n\n\n; Condition that specifies the line number of the action the user might want to modify\n#condition_comment.info {lua(\\\n  local msg = table.pack(\\\n    \"</size><br>\",\\\n      \"additional_cond adds an additional condition \",\\\n      \"that could be met to exit tower testing<br>\",\\\n      \"<br>seconds, minutes and hours reprezent how much time \",\\\n      \"you want to pass in real world seconds before exiting tower testing\",\\\n      \"<br>Leave all at 0 if you don't want this\",\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg)\\\n)}\n\ncontains(\\\n  concat(\"click here for line info!<size=0>\", \"{condition_comment.info}\"),\\\n  \"\"\\\n)\n#condition_comment.line {lua(\\\n  local msg = table.pack(\\\n    \"</size><br>\",\\\n      \"<br>additional_cond is found on line \",\\\n      [[\" . additional_cond_pos . \"]],\\\n    \"<size=0>\"\\\n  );\\\n  return table.concat(msg);\\\n)}\n\ncontains(\\\n  concat(\"click here for line numbers!<size=0>\", \"{condition_comment.line}\"),\\\n  \"\"\\\n)\n\n; Start of code\n\n; Set the seconds, minutes and hours\n; After this time has elapsed, you'll exit towertesting\nseconds = 0.0\nminutes = arithmetic.double(0.0, \"*\", 60.0)\nhours = arithmetic.double(0.0, \"*\", 60.0 * 60.0)\n\n; Don't change the difficulty list if diff_mode is set and user didn't request a difficulty change\n; If the user did request a change, only change it if we're in config mode or if we're active\ndifficulty_list = if(\\\n  {diff_mode.get} != \"\" && (\\\n    impulse() != \"key.{difficulty}\" ||\\\n    not(\\\n      isopen(\"headquarters\") || isopen(\"towertesting\")\\\n      || ({status.get} != (impulse() == \"key.{start}\"))\\\n    )\\\n  ),\\\n  {diff_mode.get},\\\n  if({diff_mode.get} != order1, order1, order2)\\\n)\n\n; Increment the instance\ninstance = s2i(sub({diff.get}, 0, 1), 0) + 1\n\n; This starts the block hider\n; The difficulty variable holds a counter and the current coordinate\n; The counter is used to decide what we're doing based on the mode.\n; It uses index(\"ABCDEFGHIJKLMN\", sub(diff, 0, 1), 0) + 1 to count up\n; A = 0, B = 1 and O = 15. Thus, I can determine what to do by simply using a contains()\n;\n; How changing difficulty is determined:\n; If we're in mode1, we're always moving to the next difficulty. If we're in mode2, we only move\n; to the next difficulty after we've counted up to 15\n;\n; How changing region is determined:\n; If mode1, we only change the region when our counter is at A. If mode2, we always move to the\n; next region\n;\n:const string counting_string \"ABCDEFGHIJKLMNO\"\n;\n; We shut off the hider with a </size> block if the script is running\n; or if start/cycling/mode were pressed while inside the headquarters/towertesting menu\n{diff.set(\\\n  i2s(instance) . if(\\\n    {diff.get} != \"\" && {status.get} != (impulse() == \"key.{start}\")\\\n    && not(contains(\"key.{difficulty}|key.{mode}|game.newround\", impulse())),\\\n    sub({diff.get}, 1, 8),\\\n    sub(\\\n      counting_string,\\\n      arithmetic.int(\\\n        index(counting_string, sub({diff.get}, 1, 1), 0) +\\\n        if(impulse() == \"game.newround\", 1, 0),\\\n        if({status.get}, \"mod\", \"\"),\\\n        if(\\\n          {curent_mode.get} == mode1 ||\\\n          (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2), 6, 15)\\\n      ),\\\n      1\\\n    ) . sub(\\\n      {lua(--Determine if we change the difficulty or not)}\\\n      if(\\\n        impulse() == \"key.{difficulty}\" || {diff.get} == \"\" ||\\\n        {curent_mode.get} == mode1 || \\\n        (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2) ||\\\n        contains({diff.get}, \"O\"),\\\n        difficulty_list,\\\n        {diff.get}\\\n      ),\\\n      {lua(--/*\\\n        * Determine the offset.\\\n        * If we're not reading from difficulty_list, we have an offset of 1\\\n        * Otherwise, if we're changing difficulty, we move to the difficulty corresponding\\\n        * to our current position in the list.\\\n        * If we're at E->I on difficulty Hard and the user changes to I->E, we are now\\\n        * considered to be at difficulty Insane.\\\n        * Otherwise, if we're here for a game.newround, get the starting 2 bits for the position\\\n      */)}\\\n      if(\\\n        impulse() == \"key.{difficulty}\" || {diff.get} == \"\" ||\\\n        {curent_mode.get} == mode1 || \\\n        (impulse() == \"key.{mode}\" && {curent_mode.get} == mode2) ||\\\n        contains({diff.get}, \"O\"),\\\n        if(\\\n          impulse() == \"game.newround\",\\\n          s2i(sub({diff.get}, 2, 2), 1),\\\n          index(difficulty_list, sub({diff.get}, 2, 2), 0)\\\n        ),\\\n        2\\\n      ),\\\n      7\\\n    )\\\n  ) . if(\\\n    isopen(\"headquarters\") || isopen(\"towertesting\")\\\n    || ({status.get} != (impulse() == \"key.{start}\")),\\\n    \"</size>\",\\\n    \"{if_debugging(<line-height=0>)}\"\\\n  )\\\n)}\n\n;\n{status.set({status.get} != (impulse() == \"key.{start}\"))}\n;\n; Only toggle the region_cycling switch if we're running or we're in the HQ\n{region_cycling.set({region_cycling.get} != (\\\n  ({status.get} || isopen(\"headquarters\") || isopen(\"towertesting\")) &&\\\n  (impulse() == \"key.{cycling}\")\\\n))}\n\n; Keep the mode unchanged if we're initialized and the user\n{curent_mode.set(if(\\\n  {curent_mode.get} != \"\" && (\\\n    impulse() != \"key.{mode}\" ||\\\n    not(isopen(\"headquarters\") || isopen(\"towertesting\") || {status.get})\\\n  ),\\\n  {curent_mode.get},\\\n  if({curent_mode.get} == mode1, mode2, mode1)\\\n))}\n\n{diff_mode.set(difficulty_list)}\n\n; Set the job status\n; If we're shut down, stop the hiding block\n; If we're running and the user requested an exit, set the `Exit caused` message\n; otherwise, don't change the value\n{job.set(if(\\\n  {status.get},\\\n  if(\\\n    impulse() != \"key.{exit}\",\\\n    {job.get},\\\n    \"</size><color=#0AFF00>Exit caused by pressing key.{exit}</color>\"\\\n  ),\\\n  \"</size>{if_debugging(</line-height>)}</size>\"\\\n))}\n\n; Determine where we're going\n; If we're the first instance and we've just started up, we enter the loop\n; Otherwise, we're called for a qol or an irelevant impulse\n; If this is a qol impulse, we must be in towertesting to perform it\ngoto(if(\\\n  {status.get} && impulse() == \"key.{start}\" && instance == 1,\\\n  if(isTowerTesting(), loop, movement_manager),\\\n  if(\\\n    contains(\"key.{exit}|key.{stats}|key.{restart}\", impulse()) && isTowerTesting(),\\\n    if(\\\n      impulse() == \"key.{exit}\",\\\n      exit,\\\n      if(impulse() == \"key.{stats}\", stats, restart)\\\n    ),\\\n    end\\\n  )\\\n))\n\nloop:\nstarted = true ; signal that we can start cycling\nend_time = seconds + minutes + hours\n; Set our end time. If this is just 0, it'll get ignored\n;\n; Update our job\n{job.set(if(\\\n  {status.get},\\\n  \"</size><color=#0AFF00>Waiting to exit Tower Testing</color>\",\\\n  \"</size>{if_debugging(</line-height>)}</size>\"\\\n))}\n\nin_towertesting:\nwaitframe()\n\nadditional_cond_pos:\nadditional_cond = {additional_cond}\n\n; Rather complicated gotoif\n; We stay in towertesting for as long as we're running, not dead and\n; we haven't meat our additional condition\n; If the end_time is 0.0 (default), then our end_time will be ignored\n; Otherwise, we'll exit once the time of seconds, minutes and hours summed together is elapsed\ngotoif(\\\n  in_towertesting,\\\n  {status.get} && health(false) > 0.0 && not(additional_cond) && (\\\n    end_time == 0.0 ||\\\n    game.realtime() <= end_time\\\n  )\\\n)\n\n; Don't modify the job if we exited because of key.exit\n; Otherwise, mention the reason we ended the run\n{job.set(if(\\\n  contains({job.get}, \"Exit caused by\") || not({status.get}),\\\n  {job.get},\\\n  \"</size><color=#0AFF00>Exit caused by \" . if(\\\n    additional_cond,\\\n    \"additional_cond\",\\\n    if(isTowerTesting(), \"tower death\", \"an external cause\")\\\n  ) . \"</color>\"\\\n))}\n\nexit:\nwait(time.unscaled() * 1.5)\n; We try to exit.\n; This isn't a fixed value because it depends on the device\n; I've found that this operation results in the best amount of time\n;\n; A waitframe() is too quick and it causes lag\nexit()\n\n; Keep trying to exit if we're in towertesting.\n; Then, we continue over to the movement manager if we're still running\ngoto(if(\\\n  isTowerTesting(),\\\n  exit,\\\n  if({status.get} && impulse() == \"key.{start}\", movement_manager, end)\\\n))\n\nmovement_manager:\n{job.set(if(\\\n  {status.get},\\\n  \"</size><color=#FAA00F>User must \" . if(\\\n    isopen(\"headquarters\"),\\\n    \"exit the headquarters\",\\\n    \"close the window opened in town\"\\\n  ) . \"</color>\",\\\n  {job.get}\\\n))}\n;\n; We can only be activated if in the HQ, town or TT menu\n; The only places where show(\"towertesting\", true) won't work are\n; if we're inside hq, town/infinity perks menus\n; Thus, we must give a warning if we're in HQ or assume that town has an opened window\n\nwaitwhile(not(isopen(\"towertesting\")) && anyopen() && {status.get})\n; This will make us wait for as long as we're running and we're not in towertesting and\n; a window is open. \n\nshow(\"towertesting\", true)\n; Enter the TT menu\n;\n; Determine if we're able to change regions\n; Don't change the region if we've just now started\n; Otherwise, if we're in mode2, we'll always cycle no matter the counter value\ngoto(if(\\\n  {status.get},\\\n  if(\\\n    {region_cycling.get} && (\\\n      ({curent_mode.get} == mode1 && contains({diff.get}, \"A\")) ||\\\n      ({curent_mode.get} == mode2)\\\n    ) && started,\\\n    change_region,\\\n    enter_towertesting\\\n  ),\\\n  end\\\n))\n\nchange_region:\nwaitframe()\n\n; click on the arrow to change region\n{click.relative(290.0/800.0, 201.0/450.0, 0.0, 1.0)}\n\nenter_towertesting:\n; Click on the difficulty\n; diff.get has a 1-character instance counter, 1-character progress counter,\n; a length-2 position and the difficulty string of 5 characters\n{click.relative(395.0 / 800.0, s2d(sub({diff.get}, 4, 5), 0.0) / 450.0, 0.0, 1.0)}\n\n; Launch a round of towertesting\n{click.relative(162.0 / 800.0, 97.0/450.0, 0.0, 1.0)}\n\ngotoif(if({status.get}, loop, end), isTowerTesting() || not({status.get}))\n\nwaitframe()\ngoto(enter_towertesting)\n\n; The user requested a restart\nrestart:\nrestart()\ngoto(end)\n\n; The user requested the stats be shown\n; This clicks in the general area of the button where\n; resource/sec, xp/sec and frags obtained are seen\nstats:\nwaitframe()\n{click.relative(260.0/800.0, 275.0/450.0, 0.5, 0.5)}\n\nend:\n; Subtract 1 from the number of instances, as we've just removed an instance\n; If, for whatever reason someone modifies the variable and the instance int\n; stops becoming a valid number, fallback to 1 so that we don't have negative numbers.\n{diff.set(i2s(s2i(sub({diff.get}, 0, 1), 1) - 1) . sub({diff.get}, 1, 99))}"],["Codrineye's TowerTesting_lib","#script_name Codrineye's TowerTesting\n; Easy naming scheme to follow\n\n; impulse key macros for easy customization\n#start x\n#mode q\n#cycling w\n;\n#difficulty d\n;\n; qol impulses\n#restart r\n#exit e\n#stats t\n\n{lua(\\\n  TowerTest = {};\\\n  TowerTest.debug = false;\\\n  --[[Set to true for debugging, set to anything else besides TowerTest for not debugging]]\\\n  TowerTest.impulse = {};\\\n  \\\n  --[[/*\\\n    * Go through all impulse keys and\\\n    * prevent compilation if there's duplicate keys\\\n  */]]\\\n  local impulse = {};\\\n  local keys = table.pack(\\\n    \"{start}\", \"{mode}\", \"{cycling}\", \"{difficulty}\",\\\n    \"{restart}\", \"{exit}\", \"{stats}\"\\\n  );\\\n  for i = 1, #keys do\\\n    if impulse[keys[i]] ~= nil then\\\n      error(\"every key impulse must mean a different key\", 0);\\\n    end\\\n    impulse[keys[i]] = true;\\\n  end\\\n)}\n\n; variable macros for improved visibility in the source code\n; a display var hides the script identifier to make it less likely\n; that the var gets changed by another script\n;\n{lua(\\\n  local security_prefix = \"<size=0>C^t@t</size>\";\\\n  \\\n  --[[/*\\\n    * Used to add an impulse to the display_var\\\n    * value in `impulse` has no whitespace and is never empty\\\n    * Throws an error if the same impulse controls multiple vars\\\n    * \\\n    * Returns the impulse as an uppercase string encased in\\\n    * parenthesies ()\\\n    * add_impulse(a) returns `(A)`\\\n  */]]\\\n  local function add_impulse(impulse)\\\n    if TowerTest.impulse[impulse] == true then\\\n      local err_msg = table.pack(\\\n        \"Variables cannot be controlled by the same impulse\\n\",\\\n        \"Impulse '\", impulse, \"' has been used before!\"\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    TowerTest.impulse[impulse] = true;\\\n    return string.format(\"(%s)\", string.upper(impulse));\\\n  end\\\n  \\\n  --[[/*\\\n    * Used to create the name of a global variable\\\n    * meant to be visible in the global variables overlay.\\\n    * \\\n    * security_toggle is a bool that determinse if\\\n    * this variable gets the security prefix or not.\\\n    * \\\n    * var_name is the string that represents this variable\\\n    * \\\n    * impulse is the triggered impulse for this variable\\\n    * if it doesn't have one, nothing will be added\\\n  */]]\\\n  function TowerTest.display_var(var_name, security_toggle, impulse)\\\n    local var = {};\\\n    var[1] = security_toggle and security_prefix or \"\";\\\n    var[2] = var_name;\\\n    local impulse_val = impulse:gsub(\" \", \"\");\\\n    if impulse_val ~= \"\" then\\\n      var[3] = add_impulse(impulse_val);\\\n    end\\\n    return string.format([[\"%s\"]], table.concat(var));\\\n  end\\\n)}\n\n#display_var(name, secured, impulse) {lua(\\\n  return TowerTest.display_var([[{name}]], {secured}, [[{impulse}]]);\\\n)}\n\n; Returns empty or blank or case false\n#if_debugging(case_false) {lua(\\\n  return TowerTest.debug and \"\" or [[{case_false}]];\\\n)}\n\n; block hider\n; used to control when the global variables are shown or hidden \n#hider concat(\"{if_debugging(<size=0>)}C^t@t\", \"Variable hider\")\n#diff.get global.string.get({hider})\n#diff.set(diff) global.string.set({hider}, {diff})\n\n; the state of the script\n:const string status_var {display_var(Active, true, {start})}\n#status.get global.bool.get(status_var)\n#status.set(value) global.bool.set(status_var, {value})\n\n; if region cycling is enabled or not\n:const string cycle_var {display_var(Region Cycling, true, {cycling})}\n#region_cycling.get global.bool.get(cycle_var)\n#region_cycling.set(value) global.bool.set(cycle_var, {value})\n\n; which mode is selected\n:const string mode_var {display_var(Curent Mode, true, {mode})}\n#curent_mode.get global.string.get(mode_var)\n#curent_mode.set(mode) global.string.set(mode_var, {mode})\n\n; mode values, so it's easy to edit\n:const string mode1 \"Difficulty>Region\"\n:const string mode2 \"Region>Difficulty\"\n\n; Which direction do I select difficulties in?\n:const string diff_mode \"<size=0>C^t@tD$m\"\n#diff_mode.get global.string.get(diff_mode)\n#diff_mode.set(mode) global.string.set(diff_mode, {mode})\n\n; Variable used to tell the user what the AI is doing\n:const string job_status \"<size=0>C^t@tJ$S\"\n#job.get global.string.get(job_status)\n#job.set(job) global.string.set(job_status, {job})\n; job_status starts a hiding block, which is ended by the first </size>\n; and then, it ends the hiding block started by {hider} with the final\n; </size>\n\n; lua macro used to process coordinates and output a difficulty list\n{lua(\\\n  --[[y coordinate of all 6 difficulties]]\\\n  local difficulties = table.pack(\\\n    \"290.0\", \"256.0\", \"217.0\",\\\n    \"182.0\", \"145.0\", \"112.0\"\\\n  );\\\n  \\\n  function TowerTest.diff_list(switch)\\\n    if switch == nil or type(switch) ~= \"boolean\" then\\\n      local err_msg = table.pack(\\\n        \"\\n\",\\\n        \"\\nSwitch in macro diff_list must be true or false\",\\\n        \"\\nValue recieved was \", switch or \"nil\"\\\n      );\\\n      error(table.concat(err_msg), 0);\\\n    end\\\n    \\\n    local diff = {};\\\n    --[[true = keep order, false = reverse order]]\\\n    if switch then\\\n      diff = difficulties;\\\n    else\\\n      for i = #difficulties, 1, -1 do\\\n        diff[#diff + 1] = difficulties[i];\\\n      end\\\n    end\\\n    local acc = {};\\\n    local pos = 0;\\\n    for i = 1, #diff do\\\n      local offset = i * 2;\\\n      if i == #diff then\\\n        pos = 0;\\\n      else\\\n        pos = pos + 2 + #diff[i]\\\n      end\\\n      --[[/*\\\n        * Encode our coordinates\\\n        * We have a length-2 position and the difficulty coord\\\n        * the position = where in the list we are\\\n        * coord = what y value do we want\\\n      */]]\\\n      acc[offset - 1] = string.format(\"%02d\", pos);\\\n      acc[offset] = diff[i];\\\n    end\\\n    acc[#acc + 1] = \"</size>Diff Order(\" .. string.upper(\"{difficulty}\") .. \")=\"\\\n    if switch then\\\n      acc[#acc + 1] = \"Easy -> Impossible\";\\\n    else\\\n      acc[#acc + 1] = \"Impossible -> Easy\";\\\n    end\\\n    return table.concat(acc);\\\n  end\\\n)}\n\n#diff_list(switch) \"{lua(return TowerTest.diff_list({switch}))}\""]]}}
```

# Changelog

### version 2.2.6

Fixed a long standing bug that I never even saw where the counting_string was 1 short for some reason. Updated the `mod` boundaries for diff.set<br>
Fixed the default order not being set to order1 but rather to order2. Should've been way faster.<br>
Fixed a bug introduced in [2.2.5](#version-225). The logic for cycling regions relied on end_time being non-zero, which was accomplished by using `now() + 1e7 * (seconds + minutes + hours)`.

Removed what's either a bug or a feature, but that seems like a bug to me where being in mode2 wouldn't change the region after completing a cycle which would lead to the script getting offset by 1. This means that, if you started in Forest easy, you'd then end up in Chaos Easy, and instead of going to Forest Normal you'd enter Chaos Normal.

### version 2.2.5

Removed variables `game_time` and `time.real` in place for the games new functions `game.time()` and `game.realtime()`.<br>
Hider and `diff` have now been merged such that `diff` now holds the name and purpose of hider. Diff now holds the instance integer + everything else it already did.<br>
Added new impulse `close.towertesting()`<br>
Fixed the string in the condition. It was checking a malformed version of job_status without the ending `</color>` block. This had no importance on the UI, but internally this now actually prevents the script from creating multiple key.e copies (not like those mean much anyways, but still).<br>
Added an explanation of what job_status actually is to the root README.md, I for some reason didn't include it.

Removed the hdr/src version ideas since, after thinking about it more, that version would suck.

### version 2.2.4

Fixed a bug where the difficulty held in `diff` would get eaten away. (I was treating the string as if it was indexed by 1 not by 0).<br>
Fixed still being able to edit some variables outside of their context.<br>
Fixed a leaking color block in job status.

Correct version number in changelog.<br>
Remove debugging script from both source export and workspace export.<br>
Reset additional_cond to default setting of `false`.

### version 2.2.3

Full system has been rebuilt.<br>

Added new impulse `key.difficulty(D)` that lets people switch the difficulty list direction.<br>
New UI variable `mode_switch` that holds the direction string followed by `Diff Order(D)=`, look at the bottom of [library](./Codrineye's%20TowerTesting_lib.tpt2).

Hider has been repurposed to now hold the number of instances and the timer for `game_time`.<br>
`time.real` has been renamed to `end_time` and is always active. This adds the local variables `seconds`, `minutes` and `hours` which are used to define how long a run should last in real time. If the sum of these times is 0.0, end_time is ignored.

New hidden variable `diff` holds a counter and the y coordinate for the target difficulty. This gets reset to default when the script is shut off.<br>
Changed the script identifier to be a lot shorter.

The script now only has 1 instance of itself running, the instances counter ensures that only 1 script is in the loop.<br>
Additionally, it makes use of script conditions to prevent activation outside of its context (expanded uppon later) and to make sure only 1 instances made by `key.exit` is running to prevent lag.<br>
Improved the comment that outlines what line to modify by using lua macros and `<size=0></size>` blocks.

Added context-based activation.<br>
The script can only be interacted with when inside of a game of towertesting, the towertesting menu, in town or in headquarters.<br>
If the user is in HeadQuarters and interacts with the script, the UI will be shown. If they exit the HQ while the script is shut down, it will hide the UI.

### version 2.1.1

- Fixed the scripts overlay getting hidden when game.newround() activated even if the script is running

### version 2.1.0

- Fixed a trailing hiding block that was caused by pressing key.{restart} key.{stats} or key.{exit} before starting up the script.
- Improved the second condition by using contains() instead of string comparison.
- Removed unnecesary macros defined early on.

### version 2.0.9

- Added job macros `job.get`, `job.set` and `job_message` to work with the job_status variable
- `job_status` now tells you 4 different reasons that tower testing exited:
- 1. key.{exit} was pressed results in "Exit caused by pressing key.{exit}"
- 2. additional_cond is true results in "Exit caused by additional_cond"
- 3. we're still in towertesting means "Exit caused by tower death"
- 4. we aren't in towertesting means "Exit caused by an external source"

### version 2.0.8

- Changed all `contains.key` style checks with a simple `impulse() == "key."` check
- Made `display_var` macro more competent
- Script is now more resistant to key smashing. It's now a lot harder to create multiple copies of itself.

### version 2.0.7

- Normal mode is no longer supported out of the box. It must be added as an additional_cond by the user.
- Current_mode is no longer in charge of ending the block hider.
- Added new global variable `job_status` that is now in charge of ending the block hider.

### version 2.0.6

- `time.game` and `time.real` are now global values.
- `time.real` now also gets reset by `game.newround()`
- macro `{hider}` is agan the variable that starts the block hider 
- added variable `stop_hider` that's in charge of stopping the block hider

### version 2.0.5

- Added `time.game` so users can end the round after 10 ingame seconds.
- Added `time.real` so users can end the round after 10 real time seconds.
- Added support for use in normal mode. It can now exit once you have killed all enemies and it doesn't get confused when resetting the run.
- Refactored comments in the main script, too many unneeded comments.
- Refactored a coupple goto(if())'s to gotoif's.
- Changed the hider to no longer start the hiding blocker, that's the role of the global timer now.

### version 2.0.1

- Updated internal macro display_var to be a lua macro that adds both the identifier and the triggered impulse to the var, instead of there needing to be 2 macros.
- Variable names are now :const strings instead of macros.
- Global variables in lua now start with a capitalized letter. All global lua variables are now in the table `TowerTest`.
- Decided that this package should include a version history too.
