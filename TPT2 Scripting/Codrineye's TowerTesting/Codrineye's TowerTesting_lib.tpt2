#script_name Codrineye's TowerTesting
; Easy naming scheme to follow

; impulse key macros for easy customization
#start x
#mode q
#cycling w
;
#difficulty d
;
; qol impulses
#restart r
#exit e
#stats t

{lua(
  TowerTest = {
    debug = false,
    -- Set to true for debugging, set to anything else besides TowerTesting for not debugging
    impulse = {}
  };
  
  -- Go through all impulse keys and prevent compilation if there's duplicate keys
  local impulse = {};
  local keys = table.pack(
    "{start}", "{mode}", "{cycling}", "{difficulty}",
    "{restart}", "{exit}", "{stats}"
  );
  for i = 1, #keys do
    local key = keys[i];
    if impulse[key] ~= nil then
      error("every key impulse must mean a different key", 0);
    end
    impulse[key] = true;
  end
)}


; variable macros for improved visibility in the source code
; a display var hides the script identifier to make it less likely
; that the var gets changed by another script
;
{lua(
  local security_prefix = "<size=0>C^t@t</size>";
  
  --[[/*
    * Add an impulse to the display_var.
    * Value in `impulse` has no whitespace and is never empty.
    * Throws an error if the same impulse controls multiple vars
    *
    * Returns the impulse as an uppercase string encased in parenthesies ()
    * add_impulse(a) returns `(A)`
  */]]
  local function add_impulse(impulse)
    if TowerTest.impulse[impulse] == true then
      local err_msg = table.pack(
        "\n",
        "\nVariables cannot be controlled by the same impulse!",
        "\nImpulse '", impulse, "' has been used before!"
      );
      error(table.concat(err_msg))
    end
    TowerTest.impulse[impulse] = true;
    return string.format("(%s)", string.upper(impulse));
  end
  
  --[[/*
    * Create the name of a global variable meant to be visible in the global variables overlay/
    *
    * security_toggle is a bool that determines if this variable gets the security prefix or not.
    * var_name is the string that represents this varialbe
    * impulse is the triggered impulse for this variable
    * if it doesn't have one, nothing will be added
  */]]
  TowerTest.display_var = function(var_name, security_toggle, impulse)
    local var = {
      security_toggle and security_prefix or "",
      var_name
    };
    local impulse_val = impulse:gsub(" ", "");
    if impulse_val ~= "" then
      var[3] = add_impulse(impulse_val);
    end
    return string.format([["%s"]], table.concat(var));
  end
)}

#display_var(name, secured, impulse)={{lua(
  return TowerTest.display_var([[{name}]], {secured}, [[{impulse}]]);
)}}

; Returns empty or blank or case false
#if_debugging(case_false)={{lua(
  return TowerTest.debug and "" or [[{case_false}]];
)}}

; block hider
; used to control when the global variables are shown or hidden 
#hider concat("{if_debugging(<size=0>)}C^t@t", "Variable hider")
#diff.get global.string.get({hider})
#diff.set(diff) global.string.set({hider}, {diff})

; the state of the script
:const string status_var {display_var(Active, true, {start})}
#status.get global.bool.get(status_var)
#status.set(value) global.bool.set(status_var, {value})

; if region cycling is enabled or not
:const string cycle_var {display_var(Region Cycling, true, {cycling})}
#region_cycling.get global.bool.get(cycle_var)
#region_cycling.set(value) global.bool.set(cycle_var, {value})

; which mode is selected
:const string mode_var {display_var(Curent Mode, true, {mode})}
#curent_mode.get global.string.get(mode_var)
#curent_mode.set(mode) global.string.set(mode_var, {mode})

; mode values, so it's easy to edit
:const string mode1 "Difficulty>Region"
:const string mode2 "Region>Difficulty"

; Which direction do I select difficulties in?
:const string diff_mode "<size=0>C^t@tD$m"
#diff_mode.get global.string.get(diff_mode)
#diff_mode.set(mode) global.string.set(diff_mode, {mode})

; Variable used to tell the user what the AI is doing
:const string job_status "<size=0>C^t@tJ$S"
#job.get global.string.get(job_status)
#job.set(job) global.string.set(job_status, {job})
; job_status starts a hiding block, which is ended by the first </size>
; and then, it ends the hiding block started by {hider} with the final
; </size>

; lua macro used to process coordinates and output a difficulty list
{lua(
  -- y coordinate of all 6 difficulties
  local difficulties = table.pack(
    "290.0", "256.0", "217.0",
    "182.0", "145.0", "112.0"
  );
  
  TowerTest.diff_list = function(switch)
    if switch == nil or type(switch) ~= "boolean" then
      local err_msg = table.pack(
        "\n",
        "\nSwitch in macro diff_list must be true or false",
        "\nValue recieved was ", switch or "nil"
      );
      error(table.concat(err_msg), 0);
    end
    
    local diff = {};
    if switch then
      -- keep order
      diff = difficulties
    else
      -- referse order
      for i = #difficulties, 1, -1 do
        diff[#diff + 1] = difficulties[i];
      end
    end
    
    local acc = {};
    local pos = 0;
    for i = 1, #diff do
      local offset = i * 2;
      pos = (i == #diff and 0 or (pos + 2 + #diff[i]));
      --[[/*
        * Encode our coordinates
        * We have a length-2 position and the difficulty coord
        * position = where in the list we are
        * coord = what y value we want
      */]]
      acc[offset - i] = string.format("%02d", pos);
      acc[offset] = diff[i];
    end
    acc[#acc + 1] = "</size>Diff Order(" .. string.upper("{difficulty}") .. ")=";
    if switch then
      acc[#acc + 1] = "Easy -> Impossible";
    else
      acc[#acc + 1] = "Impossible -> Easy";
    end
    return table.concat(acc);
  end
)}

#diff_list(switch) "{lua(return TowerTest.diff_list({switch}))}"